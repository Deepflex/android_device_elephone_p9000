commit 27f637e732c1bd85a09b3165761153fa8350dd87
Author: Deepflex <hqdevnews@gmail.com>
Date:   Sat Aug 6 03:12:59 2016 +0700

    mtk opt net ims
    
    Change-Id: I58b23688707bf2380b60a278f86f2224bcf16a6a

diff --git a/Android.mk b/Android.mk
index ee92ea6..c71bc5b 100644
--- a/Android.mk
+++ b/Android.mk
@@ -20,9 +20,62 @@ LOCAL_AIDL_INCLUDES := $(LOCAL_PATH)/src/java
 LOCAL_SRC_FILES := \
     $(call all-java-files-under, src/java)
 
+
+# MTK
+LOCAL_SRC_FILES += \
+    src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl\
+    src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl\
+    src/java/org/gsma/joyn/capability/ICapabilityService.aidl\
+    src/java/org/gsma/joyn/chat/IChat.aidl\
+    src/java/org/gsma/joyn/chat/IChatListener.aidl\
+    src/java/org/gsma/joyn/chat/IChatService.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChatListener.aidl\
+    src/java/org/gsma/joyn/chat/INewChatListener.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChat.aidl\
+    src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl\
+    src/java/org/gsma/joyn/chat/ISpamReportListener.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl\
+    src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl\
+    src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCall.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl\
+    src/java/org/gsma/joyn/ipcall/IIPCallService.aidl\
+    src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharing.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharingListener.aidl\
+    src/java/org/gsma/joyn/ish/IImageSharingService.aidl\
+    src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharing.aidl\
+    src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSession.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl\
+    src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransfer.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransferService.aidl\
+    src/java/org/gsma/joyn/ft/IFileTransferListener.aidl\
+    src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl\
+    src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl\
+    src/java/org/gsma/joyn/contacts/IContactsService.aidl\
+    src/java/org/gsma/joyn/ICoreServiceWrapper.aidl \
+
+
 #LOCAL_JAVA_LIBRARIES := telephony-common
 
 LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE := ims-common
 
 include $(BUILD_JAVA_LIBRARY)
+
+# build MTK ImsService
+include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/packages/Android.mk b/packages/Android.mk
new file mode 100644
index 0000000..5053e7d
--- /dev/null
+++ b/packages/Android.mk
@@ -0,0 +1 @@
+include $(call all-subdir-makefiles)
diff --git a/packages/Ims/Android.mk b/packages/Ims/Android.mk
new file mode 100644
index 0000000..5525a9e
--- /dev/null
+++ b/packages/Ims/Android.mk
@@ -0,0 +1,23 @@
+LOCAL_PATH:= $(call my-dir)
+
+# Build the Ims OEM implementation including imsservice, imsadapter, imsriladapter.
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_JAVA_LIBRARIES += telephony-common
+#LOCAL_JAVA_LIBRARIES += mediatek-framework
+LOCAL_JAVA_LIBRARIES += ims-common
+LOCAL_STATIC_JAVA_LIBRARIES += wfo-common
+
+# Use SimServs.jar for VoLTE MMTelSS Package
+LOCAL_STATIC_JAVA_LIBRARIES += Simservs
+
+LOCAL_PACKAGE_NAME := ImsService
+LOCAL_CERTIFICATE := platform
+LOCAL_PRIVILEGED_MODULE := true
+
+LOCAL_PROGUARD_ENABLED := disabled
+LOCAL_PROGUARD_FLAGS := $(proguard.flags)
+
+include $(BUILD_PACKAGE)
diff --git a/packages/Ims/AndroidManifest.xml b/packages/Ims/AndroidManifest.xml
new file mode 100644
index 0000000..cc65fdc
--- /dev/null
+++ b/packages/Ims/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:androidprv="http://schemas.android.com/apk/prv/res/android"
+        package="com.mediatek.ims"
+        coreApp="true"
+        android:sharedUserId="android.uid.phone"
+>
+
+	<uses-permission android:name="android.permission.READ_PRECISE_PHONE_STATE"/>
+    <uses-permission android:name="android.Manifest.permission.READ_PRIVILEGED_PHONE_STATE"/>
+
+    <application android:name="ImsApp"
+                 android:persistent="true">
+    </application>
+</manifest>
diff --git a/packages/Ims/NOTICE b/packages/Ims/NOTICE
new file mode 100644
index 0000000..83c9081
--- /dev/null
+++ b/packages/Ims/NOTICE
@@ -0,0 +1,13 @@
+Copyright (C) 2011-2014 MediaTek Inc.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
\ No newline at end of file
diff --git a/packages/Ims/README b/packages/Ims/README
new file mode 100644
index 0000000..be12b65
--- /dev/null
+++ b/packages/Ims/README
@@ -0,0 +1,19 @@
+ImsService.apk is a service to provide IMS functionalities like volte, vilte, SS over LTE,
+SMS over LTE.
+
+WHAT IT DOES?
+=============
+ImsService.apk contains
+ - ImsService handle IMS power on/off or registration event.
+ - IMS OEM implementation files handle volte, vilte, ss over LTE or SMS over LTE functionalities.
+ - IMSA make the connection with volte processes to dispatch messages to related modules.
+
+HOW IT WAS BUILT?
+==================
+ImsService.apk is built from MTK internal build process if IMS feature is enable.
+
+HOW TO USE IT?
+==============
+It's a persist APK. It will launch by AMS and create ImsService why application oncreat function
+is called. When ImsService is avaiable it will enable/disable IMS from volte setting to
+register/de-register to server and provide the IMS features.
\ No newline at end of file
diff --git a/packages/Ims/proguard.flags b/packages/Ims/proguard.flags
new file mode 100644
index 0000000..e69de29
diff --git a/packages/Ims/src/com/mediatek/ims/ImsAdapter.java b/packages/Ims/src/com/mediatek/ims/ImsAdapter.java
new file mode 100644
index 0000000..57f020b
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsAdapter.java
@@ -0,0 +1,651 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Message;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+import com.mediatek.internal.telephony.ITelephonyEx;
+//import com.android.internal.telephony.gsm.GSMPhone;
+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.InterruptedIOException;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import static com.mediatek.ims.VaConstants.*;
+
+public class ImsAdapter extends BroadcastReceiver {
+
+    public static class VaEvent {
+        public static final int DEFAULT_MAX_DATA_LENGTH = 40960;
+
+        private int mPhoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+        private int request_id;
+        private int data_len;
+        private int read_offset;
+        private byte data[];
+        private int event_max_data_len = DEFAULT_MAX_DATA_LENGTH;
+
+        /**
+         * The VaEvent constructor with specified phone Id.
+         *
+         * @param phoneId the phone Id of the event
+         * @param rid the request Id of the event
+         */
+        public VaEvent(int phoneId, int rid) {
+            this(phoneId, rid, DEFAULT_MAX_DATA_LENGTH);
+        }
+
+        /**
+         * The VaEvent constructor with specified phone Id.
+         *
+         * @param phoneId the phone Id of the event
+         * @param rid the request Id of the event
+         * @param length the max data length of the event
+         */
+        public VaEvent(int phoneId, int rid, int length) {
+            mPhoneId = phoneId;
+            request_id = rid;
+            event_max_data_len = length;
+            data = new byte[event_max_data_len];
+            data_len = 0;
+            read_offset = 0;
+        }
+
+        public int putInt(int value) {
+            if (data_len > event_max_data_len - 4) {
+                return -1;
+            }
+
+            synchronized (this) {
+                for (int i = 0 ; i < 4 ; ++i) {
+                    data[data_len] = (byte) ((value >> (8 * i)) & 0xFF);
+                    data_len++;
+                }
+            }
+            return 0;
+        }
+
+        public int putShort(int value) {
+            if (data_len > event_max_data_len - 2) {
+                return -1;
+            }
+
+            synchronized (this) {
+                for (int i = 0 ; i < 2 ; ++i) {
+                    data[data_len] = (byte) ((value >> (8 * i)) & 0xFF);
+                    data_len++;
+                }
+            }
+
+            return 0;
+        }
+
+        public int putByte(int value) {
+            if (data_len > event_max_data_len - 1) {
+                return -1;
+            }
+
+            synchronized (this) {
+                data[data_len] = (byte) (value & 0xFF);
+                data_len++;
+            }
+
+            return 0;
+        }
+
+        public int putString(String str, int len) {
+            if (data_len > event_max_data_len - len) {
+                return -1;
+            }
+
+            synchronized (this) {
+                byte s[] = str.getBytes();
+                if (len < str.length()) {
+                    System.arraycopy(s, 0, data, data_len, len);
+                    data_len += len;
+                } else {
+                    int remain = len - str.length();
+                    System.arraycopy(s, 0, data, data_len, str.length());
+                    data_len += str.length();
+                    for (int i = 0 ; i < remain ; i++) {
+                        data[data_len] = 0;
+                        data_len++;
+                    }
+                }
+            }
+
+            return 0;
+        }
+
+        public int putBytes(byte [] value) {
+            int len = value.length;
+
+            if (len > event_max_data_len) {
+                return -1;
+            }
+
+            synchronized (this) {
+                System.arraycopy(value, 0, data, data_len, len);
+                data_len += len;
+            }
+
+            return 0;
+        }
+
+        public byte [] getData() {
+            return data;
+        }
+
+        public int getDataLen() {
+            return data_len;
+        }
+
+        public int getRequestID() {
+            return request_id;
+        }
+
+        public int getPhoneId() {
+            return mPhoneId;
+        }
+
+        public int getInt() {
+            int ret = 0;
+            synchronized (this) {
+                ret = ((data[read_offset + 3] & 0xff) << 24 | (data[read_offset + 2] & 0xff) << 16 | (data[read_offset + 1] & 0xff) << 8 | (data[read_offset] & 0xff));
+                read_offset += 4;
+            }
+            return ret;
+        }
+
+        public int getShort() {
+            int ret = 0;
+            synchronized (this) {
+                ret =  ((data[read_offset + 1] & 0xff) << 8 | (data[read_offset] & 0xff));
+                read_offset += 2;
+            }
+            return ret;
+        }
+
+        // Notice: getByte is to get int8 type from VA, not get one byte.
+        public int getByte() {
+            int ret = 0;
+            synchronized (this) {
+                ret = (data[read_offset] & 0xff);
+                read_offset += 1;
+            }
+            return ret;
+        }
+
+        public byte[] getBytes(int length) {
+            if (length > data_len - read_offset) {
+                return null;
+            }
+
+            byte[] ret = new byte[length];
+
+            synchronized (this) {
+                for (int i = 0 ; i < length ; i++) {
+                    ret[i] = data[read_offset];
+                    read_offset++;
+                }
+                return ret;
+            }
+        }
+
+        public String getString(int len) {
+            byte buf [] = new byte[len];
+
+            synchronized (this) {
+                System.arraycopy(data, read_offset, buf, 0, len);
+                read_offset += len;
+            }
+
+            return (new String(buf)).trim();
+        }
+    }
+
+    public class VaSocketIO extends Thread {
+        private byte buf[];
+
+        private int mTyp = -1;
+        private int mId  = -1;
+        private String mSocketName = null;
+        private LocalSocket mSocket = null;
+        private OutputStream mOut = null;
+        private DataInputStream mDin = null;
+
+        private int mPhoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+
+        Object VaSocketIOThreadLock = new Object();
+
+        public VaSocketIO(String socket_name) {
+            mSocketName = socket_name;
+            // TODO: buffer size confirm
+            buf = new byte[8];
+            Log.d("@M_" + TAG, "VaSocketIO(): Enter");
+        }
+
+        public void run() {
+            Log.d("@M_" + TAG, "VaSocketIO(): Run");
+            while (true) {
+                if (misImsAdapterEnabled) {
+                    boolean doTrm = false;
+                    try {
+                        if (mDin != null) {
+                            // read the Event from mIO
+                            VaEvent event = readEvent();
+
+                            // TODO: need to confirm if event is null or not
+                            if (event != null) {
+                                Message msg = new Message();
+                                msg.obj = event;
+                                mImsEventDispatcher.sendMessage(msg);
+                            }
+                        }
+                    } catch (InterruptedIOException e) {
+                        disconnectSocket();
+                        if (misImsAdapterEnabled && (IS_USER_BUILD || IS_USERDEBUG_BUILD)) {
+                            doTrm = true;
+                        }
+                        e.printStackTrace();
+                        Log.d("@M_" + TAG, "VaSocketIO(): InterruptedIOException (" + (doTrm == true ? "1" : "0") + ")");
+                    } catch (Exception e) {
+                        disconnectSocket();
+                        e.printStackTrace();
+                        if (misImsAdapterEnabled && (IS_USER_BUILD || IS_USERDEBUG_BUILD)) {
+                            doTrm = true;
+                        }
+                        Log.d("@M_" + TAG, "VaSocketIO(): Exception (" + (doTrm == true ? "1" : "0") + ")");
+                    }
+
+                    if (doTrm == true) {
+                        invokeTrm();
+                    }
+                } else {
+                    synchronized (VaSocketIOThreadLock) {
+                        try {
+                            Log.d("@M_" + TAG, "VaSocketIO(): thread \""
+                                    + Thread.currentThread().getId()
+                                    + "\" enter wait state");
+
+                            VaSocketIOThreadLock.wait();
+
+                            Log.d("@M_" + TAG, "VaSocketIO(): thread \""
+                                    + Thread.currentThread().getId()
+                                    + "\" leave wait state");
+
+                        } catch (InterruptedException ie) {
+                            Log.d("@M_" + TAG, "VaSocketIO(): waiting thread \""
+                                    + Thread.currentThread().getId()
+                                    + "\" interrupted ("
+                                    + ie.getMessage()+")");
+                        }
+                    }
+                }
+            }
+        }
+
+        public boolean connectSocket() {
+            Log.d("@M_" + TAG, "connectSocket() Enter");
+
+            if (mSocket != null)  {
+                Log.d("@M_" + TAG, "connectSocket() Reuse current Socket");
+
+                mPhoneId = Util.getDefaultVoltePhoneId();
+
+                // Reuse current Socket
+                return true;
+            }
+
+            try {
+                mSocket = new LocalSocket();
+                LocalSocketAddress addr = new LocalSocketAddress(
+                        mSocketName,
+                        LocalSocketAddress.Namespace.RESERVED);
+
+                mSocket.connect(addr);
+
+                mOut = new BufferedOutputStream(mSocket.getOutputStream(), 4096);
+                mDin = new DataInputStream(mSocket.getInputStream());
+
+                int sendBufferSize = 0;
+                sendBufferSize = mSocket.getSendBufferSize();
+                mSocket.setSendBufferSize(512);
+                sendBufferSize = mSocket.getSendBufferSize();
+
+                mPhoneId = Util.getDefaultVoltePhoneId();
+                Log.d("@M_" + TAG, "connectSocket() update socket phone Id: " + mPhoneId);
+
+            } catch (IOException e) {
+                e.printStackTrace();
+                disconnectSocket();
+                return false;
+            }
+            return true;
+        }
+
+        public void disconnectSocket() {
+            Log.d("@M_" + TAG, "disconnectSocket() Enter, mOut=" + mOut + ",mDin=" + mDin);
+            try {
+                if (mOut != null) {
+                    mOut.close();
+                }
+                if (mDin != null) {
+                    mDin.close();
+                }
+                if (mSocket != null) {
+                    mSocket.close();
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            } finally {
+                mSocket = null;
+                mOut = null;
+                mDin = null;
+                mPhoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+                Log.d("@M_" + TAG, "disconnectSocket() reset socket phone Id");
+            }
+        }
+
+        private void writeBytes(byte [] value, int len) throws IOException {
+            mOut.write(value, 0, len);
+        }
+
+        private void writeInt(int value) throws IOException {
+            for (int i = 0 ; i < 4 ; ++i) {
+                mOut.write((value >> (8 * i)) & 0xff);
+            }
+        }
+
+        public int writeEvent(VaEvent event) {
+            Log.d("@M_" + TAG, "writeEvent Enter");
+            int ret = -1;
+            try {
+                synchronized (this) {
+                    if (mOut != null) {
+                        if (event.getPhoneId() == SubscriptionManager.INVALID_PHONE_INDEX
+                                || event.getPhoneId() != mPhoneId) {
+                            Log.d("@M_" + TAG,
+                                    "writeEvent event phoneId mismatch, event skipped. (event requestId="
+                                            + event.getRequestID()
+                                            + ", phoneId=" + event.getPhoneId()
+                                            + ", socket phoneId=" + mPhoneId
+                                            + ")");
+                        } else {
+                            dumpEvent(event);
+
+                            writeInt(event.getRequestID());
+                            writeInt(event.getDataLen());
+                            writeBytes(event.getData(), event.getDataLen());
+                            mOut.flush();
+                            ret = 0;
+                        }
+                    } else {
+                        Log.d("@M_" + TAG, "mOut is null, socket is not setup");
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+                return -1;
+            }
+
+            return ret;
+        }
+
+        private int readInt() throws IOException {
+            mDin.readFully(buf, 0, 4);
+            return ((buf[3]) << 24 | (buf[2] & 0xff) << 16 | (buf[1] & 0xff) << 8 | (buf[0] & 0xff));
+        }
+
+        private void readFully(byte b[], int off, int len) throws IOException {
+            mDin.readFully(b, off, len);
+        }
+
+        private VaEvent readEvent() throws IOException {
+            Log.d("@M_" + TAG, "readEvent Enter");
+            int request_id;
+            int data_len;
+            byte buf [];
+            VaEvent event;
+
+            request_id = readInt();
+            data_len = readInt();
+            buf = new byte[data_len];
+            readFully(buf, 0, data_len);
+
+            int phoneId = Util.getDefaultVoltePhoneId();
+            event = new VaEvent(phoneId, request_id);
+            event.putBytes(buf);
+
+            dumpEvent(event);
+            return event;
+        }
+
+        private void dumpEvent(VaEvent event) {
+            Log.d("@M_" + TAG, "dumpEvent: phone_id:" + event.getPhoneId()
+                    + ",request_id:" + event.getRequestID()
+                    + ",data_len:" + event.getDataLen()
+                    + ",event:" + event.getData());
+        }
+    }
+
+    /* ImsAdapter class */
+    private static final String SOCKET_NAME1 = "volte_imsm";
+//    private static final String SOCKET_NAME2 = "volte_imsa2";
+
+    private static final String TAG = "[ImsAdapter]";
+    private Context mContext;
+    //private GSMPhone mPhone;
+    private VaSocketIO mIO;
+    private static ImsEventDispatcher mImsEventDispatcher;
+
+    private static ImsAdapter mInstance;
+    private static boolean misImsAdapterEnabled = false;
+    private static boolean mImsServiceUp = false;
+
+    private boolean IS_USER_BUILD = "user".equals(Build.TYPE);
+    private boolean IS_USERDEBUG_BUILD = "userdebug".equals(Build.TYPE);
+    private boolean IS_ENG_BUILD = "eng".equals(Build.TYPE);
+
+    public ImsAdapter(Context context) {
+
+        mContext = context;
+
+        if (mInstance == null) {
+            mInstance = this;
+        }
+
+        Log.d("@M_" + TAG, "ImsAdapter(): ImsAdapter Enter");
+        // new the mIO object to communicate with the va
+        mIO = new VaSocketIO(SOCKET_NAME1);
+        mImsEventDispatcher = new ImsEventDispatcher(mContext, mIO);
+
+        mIO.start();
+    }
+
+    public static ImsAdapter getInstance() {
+        return mInstance;
+    }
+
+    public void enableImsAdapter() {
+        Log.d("@M_" + TAG, "enableImsAdapter: misImsAdapterEnabled="
+                + misImsAdapterEnabled);
+
+        if (!misImsAdapterEnabled) {
+            if (mIO.connectSocket() == true) {
+                Log.d("@M_" + TAG, "enalbeImsAdapter(): connectSocket success");
+
+                // start domain event dispatcher to recieve broadcast
+                mImsEventDispatcher.enableRequest();
+
+                misImsAdapterEnabled = true;
+                synchronized (mIO.VaSocketIOThreadLock) {
+                    mIO.VaSocketIOThreadLock.notify();
+                }
+
+                enableImsStack();
+            } else {
+                Log.d("@M_" + TAG, "enableImsAdapter(): connectSocket error");
+
+                // restart MAL
+                if (misImsAdapterEnabled && (IS_USER_BUILD || IS_USERDEBUG_BUILD)) {
+                    invokeTrm();
+                }
+            }
+        }
+    }
+
+    public boolean getImsAdapterEnable() {
+        return misImsAdapterEnabled;
+    }
+
+    public void disableImsAdapter(boolean isNormalDisable) {
+
+        Log.d("@M_" + TAG, "disableImsAdapter(): misImsAdapterEnabled="
+                + misImsAdapterEnabled + ", isNormalDisable="
+                + isNormalDisable);
+
+        if(misImsAdapterEnabled) {
+            disableImsStack();
+
+            mImsEventDispatcher.disableRequest();
+            misImsAdapterEnabled = false;
+        }
+    }
+
+    // for AP side UT, set event and call ImsAdapter.sendTestEvent(event)
+    public void sendTestEvent(VaEvent event) {
+        // Sample Code:
+        // new the event object for Test Event
+        // VaEvent event = new VaEvent(MSG_ID_IMSA_IMCB_TEST_A);
+        // event.putInt(2);
+        // event.putInt(3);
+        mImsEventDispatcher.dispatchCallback(event);
+    }
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        final String action = intent.getAction();
+        Log.d("@M_" + TAG, "onReceive, intent action is " + action);
+    }
+
+    public void ImsServiceUp() {
+        mImsServiceUp = true;
+        Log.d("@M_" + TAG, "ImsServiceUp, start to ACTION_IMS_SERVICE_UP intent");
+/*
+        Intent intent = new Intent(ImsManager.ACTION_IMS_SERVICE_UP);
+        mContext.sendBroadcast(intent);
+*/
+    }
+
+    public boolean getImsServiceUp() {
+        return mImsServiceUp;
+    }
+
+    /**
+     * This is a utility class for ImsAdapter related work.
+     */
+    public static class Util {
+
+        /**
+         * To get current the default Volte Phone Id.
+         * Only for single 4G DSDS project, and it should always align to the 4G phone Id.
+         *
+         * @return current default Volte Phone Id. (align to 4G phone Id)
+         */
+        public static int getDefaultVoltePhoneId() {
+            int phoneId = SystemProperties.getInt(PhoneConstants.PROPERTY_CAPABILITY_SWITCH, 1) - 1;
+            if (phoneId < 0 || phoneId >= TelephonyManager.getDefault().getPhoneCount()) {
+                phoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+            }
+            return phoneId;
+        }
+    }
+
+    private ITelephonyEx getITelephonyEx() {
+        return ITelephonyEx.Stub.asInterface(
+                ServiceManager.getService(Context.TELEPHONY_SERVICE_EX));
+    }
+
+    private void enableImsStack() {
+
+        // Send IMS Enable to IMSM
+        VaEvent event = new VaEvent(Util.getDefaultVoltePhoneId(), MSG_ID_IMS_ENABLE_IND);
+        mIO.writeEvent(event);
+
+        return;
+    }
+
+    private void disableImsStack() {
+
+        // Send IMS Disable to IMSM
+        VaEvent event = new VaEvent(Util.getDefaultVoltePhoneId(), MSG_ID_IMS_DISABLE_IND);
+        mIO.writeEvent(event);
+
+        return;
+    }
+
+    private void invokeTrm() {
+        int trmPhoneId = Util.getDefaultVoltePhoneId();
+        Log.d("@M_" + TAG, "VaSocketIO(): recover Phone (trmPhoneId=" + trmPhoneId + ")");
+
+        try {
+            getITelephonyEx().setTrmForPhone(trmPhoneId, 2);
+        } catch (RemoteException re) {
+            Log.d("@M_" + TAG, "VaSocketIO: phone trm exception (re: "+re.getMessage()+")");
+        } catch (NullPointerException npex) {
+        // This could happen before phone restarts due to crashing
+            Log.d("@M_" + TAG, "VaSocketIO: phone trm exception (npex: "+npex.getMessage()+")");
+        }
+    }
+}
+
diff --git a/packages/Ims/src/com/mediatek/ims/ImsApp.java b/packages/Ims/src/com/mediatek/ims/ImsApp.java
new file mode 100644
index 0000000..e8db682
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsApp.java
@@ -0,0 +1,68 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.app.Application;
+import android.content.res.Configuration;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.android.ims.ImsManager;
+
+/**
+ * Top-level Application class for the Phone app.
+ */
+public class ImsApp extends Application {
+    private static final String TAG = "ImsApp";
+
+    public ImsApp() {
+    }
+
+    @Override
+    public void onCreate() {
+        if (UserHandle.myUserId() == 0) {
+            Log.d(TAG, "ImsApp onCreate begin");
+            // We are running as the primary user, so should bring up the
+            // global phone state.
+
+            ImsService imsService = new ImsService(this);
+            ServiceManager.addService(ImsManager.IMS_SERVICE, imsService.asBinder(), true);
+
+            Log.d(TAG, "ImsApp onCreate end");
+        }
+    }
+}
\ No newline at end of file
diff --git a/packages/Ims/src/com/mediatek/ims/ImsBaseCommands.java b/packages/Ims/src/com/mediatek/ims/ImsBaseCommands.java
new file mode 100644
index 0000000..e28c20c
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsBaseCommands.java
@@ -0,0 +1,474 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.RegistrantList;
+import android.os.Registrant;
+import android.os.Handler;
+
+/**
+ * {@hide}
+ */
+public abstract class ImsBaseCommands implements ImsCommandsInterface {
+    //***** Instance Variables
+    protected Context mContext;
+    protected RadioState mState = RadioState.RADIO_UNAVAILABLE;
+    protected Object mStateMonitor = new Object();
+
+    protected RegistrantList mRadioStateChangedRegistrants = new RegistrantList();
+    protected RegistrantList mOnRegistrants = new RegistrantList();
+    protected RegistrantList mAvailRegistrants = new RegistrantList();
+    protected RegistrantList mOffOrNotAvailRegistrants = new RegistrantList();
+    protected RegistrantList mNotAvailRegistrants = new RegistrantList();
+    protected RegistrantList mCallStateRegistrants = new RegistrantList();
+    protected Registrant mRingRegistrant;
+    protected RegistrantList mRingbackToneRegistrants = new RegistrantList();
+
+    /* M: CC part start */
+    protected RegistrantList mCallForwardingInfoRegistrants = new RegistrantList();
+    protected Registrant mCallRelatedSuppSvcRegistrant;
+    protected Registrant mIncomingCallIndicationRegistrant;
+    protected Registrant mCnapNotifyRegistrant;
+    protected RegistrantList mCipherIndicationRegistrant = new RegistrantList();
+    protected Registrant mSpeechCodecInfoRegistrant;
+    /* M: CC part end */
+
+    // IMS VoLTE
+    protected RegistrantList mEpsNetworkFeatureSupportRegistrants = new RegistrantList();
+    protected RegistrantList mEpsNetworkFeatureInfoRegistrants = new RegistrantList();
+    protected RegistrantList mSrvccHandoverInfoIndicationRegistrants = new RegistrantList();
+
+    //VoLTE
+    protected RegistrantList mImsEnableStartRegistrants = new RegistrantList();
+    protected RegistrantList mImsDisableStartRegistrants = new RegistrantList();
+    protected RegistrantList mImsEnableDoneRegistrants = new RegistrantList();
+    protected RegistrantList mImsDisableDoneRegistrants = new RegistrantList();
+    protected RegistrantList mImsRegistrationInfoRegistrants = new RegistrantList();
+    protected RegistrantList mDedicateBearerActivatedRegistrant = new RegistrantList();
+    protected RegistrantList mDedicateBearerModifiedRegistrant = new RegistrantList();
+    protected RegistrantList mDedicateBearerDeactivatedRegistrant = new RegistrantList();
+
+    /// M: IMS feature. @{
+    /* Register for updating call ids for conference call after SRVCC is done. */
+    protected RegistrantList mEconfSrvccRegistrants = new RegistrantList();
+    /* Register for updating conference call merged/added result. */
+    protected RegistrantList mEconfResultRegistrants = new RegistrantList();
+    /* Register for updating call mode and pau. */
+    protected RegistrantList mCallInfoRegistrants = new RegistrantList();
+    /// @}
+
+    protected Registrant mSsnRegistrant;
+    protected RegistrantList mSrvccStateRegistrants = new RegistrantList();
+    protected RegistrantList mCallProgressIndicatorRegistrants = new RegistrantList();
+    /// M: ViLTE feature, call mode changed event. @{
+    protected RegistrantList mCallModeChangeIndicatorRegistrants = new RegistrantList();
+    protected RegistrantList mVideoCapabilityIndicatorRegistrants = new RegistrantList();
+    /// @}
+
+    public ImsBaseCommands(Context context) {
+        mContext = context;
+    }
+
+    public void registerForNotAvailable(Handler h, int what, Object obj) {
+        Registrant r = new Registrant (h, what, obj);
+
+        synchronized (mStateMonitor) {
+            mNotAvailRegistrants.add(r);
+
+            if (!mState.isAvailable()) {
+                r.notifyRegistrant(new AsyncResult(null, null, null));
+            }
+        }
+    }
+
+    public void unregisterForNotAvailable(Handler h) {
+        synchronized (mStateMonitor) {
+            mNotAvailRegistrants.remove(h);
+        }
+    }
+
+    public void registerForCallStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallStateRegistrants.add(r);
+    }
+
+    public void unregisterForCallStateChanged(Handler h) {
+        mCallStateRegistrants.remove(h);
+    }
+
+    public void setOnCallRing(Handler h, int what, Object obj) {
+        mRingRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnCallRing(Handler h) {
+        if (mRingRegistrant != null && mRingRegistrant.getHandler() == h) {
+            mRingRegistrant.clear();
+            mRingRegistrant = null;
+        }
+    }
+
+    public void registerForRingbackTone(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mRingbackToneRegistrants.add(r);
+    }
+
+    public void unregisterForRingbackTone(Handler h) {
+        mRingbackToneRegistrants.remove(h);
+    }
+
+    public void registerForCallForwardingInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallForwardingInfoRegistrants.add(r);
+    }
+
+    public void unregisterForCallForwardingInfo(Handler h) {
+        mCallForwardingInfoRegistrants.remove(h);
+    }
+
+    public void setOnCallRelatedSuppSvc(Handler h, int what, Object obj) {
+        mCallRelatedSuppSvcRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnCallRelatedSuppSvc(Handler h) {
+        mCallRelatedSuppSvcRegistrant.clear();
+    }
+
+    public void setOnIncomingCallIndication(Handler h, int what, Object obj) {
+        mIncomingCallIndicationRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unsetOnIncomingCallIndication(Handler h) {
+        mIncomingCallIndicationRegistrant.clear();
+    }
+
+    public void setCnapNotify(Handler h, int what, Object obj) {
+        mCnapNotifyRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetCnapNotify(Handler h) {
+        mCnapNotifyRegistrant.clear();
+    }
+
+    public void registerForCipherIndication(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCipherIndicationRegistrant.add(r);
+    }
+
+    public void unregisterForCipherIndication(Handler h) {
+        mCipherIndicationRegistrant.remove(h);
+    }
+
+    public void setOnSpeechCodecInfo(Handler h, int what, Object obj) {
+        mSpeechCodecInfoRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnSpeechCodecInfo(Handler h) {
+        if (mSpeechCodecInfoRegistrant != null && mSpeechCodecInfoRegistrant.getHandler() == h) {
+            mSpeechCodecInfoRegistrant.clear();
+            mSpeechCodecInfoRegistrant = null;
+        }
+    }
+
+    public void registerForEpsNetworkFeatureSupport(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEpsNetworkFeatureSupportRegistrants.add(r);
+    }
+
+    public void unregisterForEpsNetworkFeatureSupport(Handler h) {
+        mEpsNetworkFeatureSupportRegistrants.remove(h);
+    }
+
+    public void registerForEpsNetworkFeatureInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEpsNetworkFeatureInfoRegistrants.add(r);
+    }
+
+    public void unregisterForEpsNetworkFeatureInfo(Handler h) {
+        mEpsNetworkFeatureInfoRegistrants.remove(h);
+    }
+
+    public void registerForSrvccHandoverInfoIndication(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mSrvccHandoverInfoIndicationRegistrants.add(r);
+    }
+    public void unregisterForSrvccHandoverInfoIndication(Handler h) {
+        mSrvccHandoverInfoIndicationRegistrants.remove(h);
+    }
+
+    public void registerForEconfSrvcc(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEconfSrvccRegistrants.add(r);
+    }
+
+    public void unregisterForEconfSrvcc(Handler h) {
+        mEconfSrvccRegistrants.remove(h);
+    }
+
+    public void registerForEconfResult(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mEconfResultRegistrants.add(r);
+    }
+
+    public void unregisterForEconfResult(Handler h) {
+        mEconfResultRegistrants.remove(h);
+    }
+
+    public void registerForCallInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mCallInfoRegistrants.add(r);
+    }
+
+    public void unregisterForCallInfo(Handler h) {
+        mCallInfoRegistrants.remove(h);
+    }
+
+    // IMS
+    public void registerForImsEnableStart(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsEnableStartRegistrants.add(r);
+    }
+
+    public void unregisterForImsEnableStart(Handler h) {
+        mImsEnableStartRegistrants.remove(h);
+    }
+
+    public void registerForImsDisableStart(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsDisableStartRegistrants.add(r);
+    }
+
+    public void unregisterForImsDisableStart(Handler h) {
+        mImsDisableStartRegistrants.remove(h);
+    }
+
+    public void registerForImsEnableComplete(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsEnableDoneRegistrants.add(r);
+    }
+
+    public void unregisterForImsEnableComplete(Handler h) {
+        mImsEnableDoneRegistrants.remove(h);
+    }
+
+    public void registerForImsDisableComplete(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsDisableDoneRegistrants.add(r);
+    }
+
+    public void unregisterForImsDisableComplete(Handler h) {
+        mImsDisableDoneRegistrants.remove(h);
+    }
+
+    public void registerForImsRegistrationInfo(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mImsRegistrationInfoRegistrants.add(r);
+    }
+
+    public void unregisterForImsRegistrationInfo(Handler h) {
+        mImsRegistrationInfoRegistrants.remove(h);
+    }
+
+    public void registerForDedicateBearerActivated(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDedicateBearerActivatedRegistrant.add(r);
+    }
+
+    public void unregisterForDedicateBearerActivated(Handler h) {
+        mDedicateBearerActivatedRegistrant.remove(h);
+    }
+
+    public void registerForDedicateBearerModified(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDedicateBearerModifiedRegistrant.add(r);
+    }
+
+    public void unregisterForDedicateBearerModified(Handler h) {
+        mDedicateBearerModifiedRegistrant.remove(h);
+    }
+
+    public void registerForDedicateBearerDeactivated(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+        mDedicateBearerDeactivatedRegistrant.add(r);
+    }
+
+    public void unregisterForDedicateBearerDeactivated(Handler h) {
+        mDedicateBearerDeactivatedRegistrant.remove(h);
+    }
+
+    public void setOnSuppServiceNotification(Handler h, int what, Object obj) {
+        mSsnRegistrant = new Registrant(h, what, obj);
+    }
+
+    public void unSetOnSuppServiceNotification(Handler h) {
+        if (mSsnRegistrant != null && mSsnRegistrant.getHandler() == h) {
+            mSsnRegistrant.clear();
+            mSsnRegistrant = null;
+        }
+    }
+
+    public void registerForSrvccStateChanged(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mSrvccStateRegistrants.add(r);
+    }
+
+    public void unregisterForSrvccStateChanged(Handler h) {
+        mSrvccStateRegistrants.remove(h);
+    }
+
+    public void registerForCallProgressIndicator(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mCallProgressIndicatorRegistrants.add(r);
+    }
+
+    public void unregisterForCallProgressIndicator(Handler h) {
+        mCallProgressIndicatorRegistrants.remove(h);
+    }
+
+    /// M: For ViLTE feature, register for call mode, video capability change. @{
+    /**
+     * Register for call mode change event. (RIL_UNSOL_CALLMOD_CHANGE_INDICATOR)
+     *
+     * @param h handler
+     * @param what message
+     * @param obj object
+     * @hide
+     */
+    public void registerForCallModeChangeIndicator(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mCallModeChangeIndicatorRegistrants.add(r);
+    }
+
+    /**
+     * Un-register for call mode change event.
+     *
+     * @param h handler
+     * @hide
+     */
+    public void unregisterForCallModeChangeIndicator(Handler h) {
+        mCallModeChangeIndicatorRegistrants.remove(h);
+    }
+
+    /**
+     * Register for video capability change event. (RIL_UNSOL_CALLMOD_CHANGE_INDICATOR)
+     *
+     * @param h handler
+     * @param what message
+     * @param obj object
+     * @hide
+     */
+    public void registerForVideoCapabilityIndicator(Handler h, int what, Object obj) {
+        Registrant r = new Registrant(h, what, obj);
+
+        mVideoCapabilityIndicatorRegistrants.add(r);
+    }
+
+    /**
+     * Un-register for video capability change event.
+     *
+     * @param h handler
+     * @hide
+     */
+    public void unregisterForVideoCapabilityIndicator(Handler h) {
+        mVideoCapabilityIndicatorRegistrants.remove(h);
+    }
+    /// @}
+
+    //***** Protected Methods
+    /**
+     * Store new RadioState and send notification based on the changes
+     *
+     * This function is called only by RIL.java when receiving unsolicited
+     * RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED
+     *
+     * RadioState has 3 values : RADIO_OFF, RADIO_UNAVAILABLE, RADIO_ON.
+     *
+     * @param newState new RadioState decoded from RIL_UNSOL_RADIO_STATE_CHANGED
+     */
+    protected void setRadioState(RadioState newState) {
+        RadioState oldState;
+
+        synchronized (mStateMonitor) {
+            oldState = mState;
+            mState = newState;
+
+            if (oldState == mState) {
+                // no state transition
+                return;
+            }
+
+            mRadioStateChangedRegistrants.notifyRegistrants();
+
+            if (mState.isAvailable() && !oldState.isAvailable()) {
+                mAvailRegistrants.notifyRegistrants();
+                onRadioAvailable();
+            }
+
+            if (!mState.isAvailable() && oldState.isAvailable()) {
+                mNotAvailRegistrants.notifyRegistrants();
+            }
+
+            if (mState.isOn() && !oldState.isOn()) {
+                mOnRegistrants.notifyRegistrants();
+            }
+
+            if ((!mState.isOn() || !mState.isAvailable())
+                && !((!oldState.isOn() || !oldState.isAvailable()))
+            ) {
+                mOffOrNotAvailRegistrants.notifyRegistrants();
+            }
+        }
+    }
+
+    protected void onRadioAvailable() {
+    }
+
+    /// M: IMS ViLTE feature. @{
+    /**
+     * accept video call.
+     * @param videoMode accept video as video, voice, video_rx or video_tx.
+     * @param callId  indication to accept which call.
+     * @param result the command result.
+     * @Override
+     */
+    public void acceptVideoCall(int videoMode, int callId) {}
+    /// @}
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsCallSessionProxy.java b/packages/Ims/src/com/mediatek/ims/ImsCallSessionProxy.java
new file mode 100644
index 0000000..f2ee27c
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsCallSessionProxy.java
@@ -0,0 +1,1905 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.ConnectivityManager;
+import android.net.Uri;
+import android.os.AsyncResult;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+
+import android.telecom.VideoProfile;
+
+import android.telephony.PhoneNumberUtils;
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+
+import android.text.TextUtils;
+
+import com.android.ims.ImsCallProfile;
+import com.android.ims.ImsConferenceState;
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsManager;
+import com.android.ims.ImsReasonInfo;
+import com.android.ims.ImsStreamMediaProfile;
+import com.android.ims.internal.IImsCallSessionListener;
+import com.android.ims.internal.IImsCallSession;
+import com.android.ims.internal.IImsVideoCallProvider;
+import com.android.ims.internal.ImsCallSession;
+
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandException.Error;
+import com.android.internal.telephony.LastCallFailCause;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.gsm.CallFailCause;
+import com.mediatek.ims.WfcReasonInfo;
+import com.mediatek.internal.telephony.ConferenceCallMessageHandler;
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+
+import com.mediatek.ims.internal.CallControlDispatcher;
+// For ViLTE feature.
+import com.mediatek.ims.internal.ImsVTProvider;
+
+// ALPS02136981. Prints fomatted debug logs.
+// import com.mediatek.telecom.FormattedLog;
+
+import com.mediatek.wfo.DisconnectCause;
+import com.mediatek.wfo.IWifiOffloadService;
+import com.mediatek.wfo.WifiOffloadManager;
+
+import java.io.FileOutputStream;
+import java.io.OutputStreamWriter;
+import javax.xml.parsers.SAXParser;
+import javax.xml.parsers.SAXParserFactory;
+import java.io.InputStream;
+import java.io.FileInputStream;
+import java.io.BufferedInputStream;
+
+import java.lang.Math;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class ImsCallSessionProxy extends IImsCallSession.Stub {
+    private static final String LOG_TAG = "ImsCallSessionProxy";
+    private static final boolean DBG = true;
+    private static final boolean VDBG = false; // STOPSHIP if true
+
+    private String mCallId;
+    private int mState = ImsCallSession.State.IDLE;
+    private Context mContext;
+    private ImsService mImsService;
+    private ImsRILAdapter mImsRILAdapter;
+    private ImsCallProfile mCallProfile;
+    private IImsCallSessionListener mListener;
+    private final Handler mHandler;
+    private final Handler mServiceHandler;
+    private boolean mHasPendingMo = false;
+    private boolean mIsMerging = false;
+    private boolean mIsOnTerminated = false;
+    private boolean mIsAddRemoveParticipantsCommandOK = false;
+    private String[] mPendingParticipantInfo ;
+    private int mPendingParticipantInfoIndex = 0;
+    private int mPendingParticipantStatistics = 0;
+    private boolean mIsHideHoldEventDuringMerging = false;
+    private String mMergeCallId = "";
+    private ImsCallInfo.State mMergeCallStatus = ImsCallInfo.State.INVALID;
+    private String mMergedCallId = "";
+    private ImsCallInfo.State mMergedCallStatus = ImsCallInfo.State.INVALID;
+    // normal call merge normal call
+    private boolean mNormalCallsMerge = false;
+    // at least one call is merged successfully
+    private boolean mThreeWayMergeSucceeded = false;
+    // count for +ECONF number in normal call merge normal call case
+    private int mEconfCount = 0;
+    private IImsCallSession mConfSession;
+
+    private String mCallNumber;
+
+    // WFC
+    private IWifiOffloadService mWfoService;
+    private int mRatType = WifiOffloadManager.RAN_TYPE_MOBILE_3GPP;
+    private static final int WFC_GET_CAUSE_FAILED = -1;
+
+    // For ViLTE.
+    private ImsVTProvider mVTProvider;
+    private ImsCallProfile mLocalCallProfile;
+    private ImsCallProfile mRemoteCallProfile;
+
+    private enum CallErrorState {
+        IDLE, DIAL, DISCONNECT;
+    };
+
+    private CallErrorState mCallErrorState = CallErrorState.IDLE;
+
+    private Message mDtmfMsg = null;
+    private Messenger mDtmfTarget = null;
+
+    private static final int INVALID_CALL_MODE = 0xFF;
+    private static final int IMS_VOICE_CALL = 20;
+    private static final int IMS_VIDEO_CALL = 21;
+    private static final int IMS_VOICE_CONF = 22;
+    private static final int IMS_VIDEO_CONF = 23;
+    private static final int IMS_VOICE_CONF_PARTS = 24;
+    private static final int IMS_VIDEO_CONF_PARTS = 25;
+
+    //***** Events URC
+    private static final int EVENT_POLL_CALLS_RESULT             = 101;
+    private static final int EVENT_CALL_INFO_INDICATION          = 102;
+    private static final int EVENT_RINGBACK_TONE                 = 103;
+    private static final int EVENT_ECONF_RESULT_INDICATION       = 104;
+    private static final int EVENT_GET_LAST_CALL_FAIL_CAUSE      = 105;
+    private static final int EVENT_CALL_MODE_CHANGE_INDICATION   = 106;
+    private static final int EVENT_VIDEO_CAPABILITY_INDICATION   = 107;
+
+    //***** Events Operation result
+    private static final int EVENT_DIAL_RESULT                   = 201;
+    private static final int EVENT_ACCEPT_RESULT                 = 202;
+    private static final int EVENT_HOLD_RESULT                   = 203;
+    private static final int EVENT_RESUME_RESULT                 = 204;
+    private static final int EVENT_MERGE_RESULT                  = 205;
+    private static final int EVENT_ADD_CONFERENCE_RESULT         = 206;
+    private static final int EVENT_REMOVE_CONFERENCE_RESULT      = 207;
+    private static final int EVENT_SIP_CODE_INDICATION           = 208;
+    private static final int EVENT_DIAL_CONFERENCE_RESULT        = 209;
+    private static final int EVENT_RETRIEVE_MERGE_FAIL_RESULT    = 211;
+    private static final int EVENT_DTMF_DONE    = 212;
+
+    //Constructor for MT call
+    ImsCallSessionProxy(Context context, ImsCallProfile profile, IImsCallSessionListener listener, ImsService imsService, 
+            Handler handler, ImsRILAdapter imsRILAdapter, String callId) {
+        if (DBG) {
+            Rlog.d(LOG_TAG, "ImsSessionProxy RILAdapter:" + imsRILAdapter + "imsService:" + imsService + " callID:" + callId);
+        }
+        mServiceHandler = handler;
+        mHandler = new MyHandler(handler.getLooper());
+        mContext = context;
+        mCallProfile = profile;
+        mLocalCallProfile = profile;
+        mRemoteCallProfile = profile;
+        mListener = listener;
+        mImsService = imsService;
+        mImsRILAdapter = imsRILAdapter;
+        mCallId = callId;
+        mImsRILAdapter.registerForCallInfo(mHandler, EVENT_CALL_INFO_INDICATION, null);
+        mImsRILAdapter.registerForRingbackTone(mHandler, EVENT_RINGBACK_TONE, null);
+        /// M: Register for updating conference call merged/added result.
+        mImsRILAdapter.registerForEconfResult(mHandler, EVENT_ECONF_RESULT_INDICATION, null);
+        mImsRILAdapter.registerForCallProgressIndicator(mHandler, EVENT_SIP_CODE_INDICATION, null);
+        mImsRILAdapter.registerForCallModeChangeIndicator(mHandler,
+                EVENT_CALL_MODE_CHANGE_INDICATION, null);
+        mImsRILAdapter.registerForVideoCapabilityIndicator(mHandler,
+                EVENT_VIDEO_CAPABILITY_INDICATION, null);
+
+        if (SystemProperties.get("ro.mtk_vilte_support").equals("1")) {
+            if (mCallId != null) {
+                //MT:new VT service
+                mVTProvider = new ImsVTProvider(Integer.parseInt(mCallId));
+            } else {
+                //MO:new VT service
+                mVTProvider = new ImsVTProvider();
+            }
+        }
+
+        /* Register for receiving conference call xml message */
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction(CallControlDispatcher.ACTION_IMS_CONFERENCE_CALL_INDICATION);
+        // WFC: Registers the listener to WifiOffloadService for handover event and get rat type
+        // from WifiOffloadService.
+        IBinder b = ServiceManager.getService(WifiOffloadManager.WFO_SERVICE);
+        mWfoService = IWifiOffloadService.Stub.asInterface(b);
+        if (mWfoService != null) {
+            try {
+                mWfoService.registerForHandoverEvent(new IWifiOffloadListenerProxy());
+                mRatType = mWfoService.getRatType();
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG, "RemoteException ImsCallSessionProxy()");
+            }
+        }
+        Rlog.d(LOG_TAG, "[WFC]mRatType is " + mRatType);
+
+        context.registerReceiver(mBroadcastReceiver, filter);
+        mConfSession = null;
+    }
+
+    //Constructor for MO call
+    ImsCallSessionProxy(Context context, ImsCallProfile profile, IImsCallSessionListener listener, ImsService imsService,
+            Handler handler, ImsRILAdapter imsRILAdapter) {
+        this(context, profile, listener, imsService, handler, imsRILAdapter, null);
+        if (DBG) {
+            Rlog.d(LOG_TAG, "ImsCallSessionProxy RILAdapter:" + imsRILAdapter);
+        }
+    }
+
+    @Override
+    public void close() {
+        if (DBG) {
+            Rlog.d(LOG_TAG, "ImsCallSessionProxy is closed!!! ");
+        }
+        mState = ImsCallSession.State.INVALID;
+        mImsRILAdapter.unregisterForCallInfo(mHandler);
+        mImsRILAdapter.unregisterForRingbackTone(mHandler);
+        mImsRILAdapter.unregisterForEconfResult(mHandler);
+        mImsRILAdapter.unregisterForCallProgressIndicator(mHandler);
+        mImsRILAdapter.unregisterForCallModeChangeIndicator(mHandler);
+        mImsRILAdapter.unregisterForVideoCapabilityIndicator(mHandler);
+
+        if (mContext != null) {
+            mContext.unregisterReceiver(mBroadcastReceiver);
+        }
+    }
+
+    @Override
+    public String getCallId() {
+        return mCallId;
+    }
+
+    @Override
+    public ImsCallProfile getCallProfile() {
+        return mCallProfile;
+    }
+
+    @Override
+    public ImsCallProfile getLocalCallProfile() {
+        return mLocalCallProfile;
+    }
+
+    @Override
+    public ImsCallProfile getRemoteCallProfile() {
+        return mRemoteCallProfile;
+    }
+
+    @Override
+    public String getProperty(String name) {
+        return mCallProfile.getCallExtra(name);
+    }
+
+    @Override
+    public int getState() {
+        return mState;
+    }
+
+    @Override
+    public boolean isInCall() {
+        return false;
+    }
+
+    @Override
+    public void setListener(IImsCallSessionListener listener) {
+        mListener = listener;
+    }
+
+    @Override
+    public void setMute(boolean muted) {
+        mImsRILAdapter.setMute(muted, null);
+    }
+
+    @Override
+    public void start(String callee, ImsCallProfile profile) {
+        int clirMode = profile.getCallExtraInt(ImsCallProfile.EXTRA_OIR, 0);
+        boolean isVideoCall = false;
+        boolean isEmergencyNumber = false;
+        Message result = mHandler.obtainMessage(EVENT_DIAL_RESULT);
+
+        if (profile.mServiceType == ImsCallProfile.SERVICE_TYPE_EMERGENCY) {
+            isEmergencyNumber = true;
+        }
+
+        if (profile.getVideoStateFromImsCallProfile(profile) !=
+                VideoProfile.STATE_AUDIO_ONLY) {
+            isVideoCall = true;
+        }
+        mImsRILAdapter.start(callee, clirMode, isEmergencyNumber, isVideoCall, result);
+        mHasPendingMo = true;
+        mCallNumber = callee;
+    }
+
+    @Override
+    public void startConference(String[] participants, ImsCallProfile profile) {
+        int clirMode = profile.getCallExtraInt(ImsCallProfile.EXTRA_OIR, 0);
+        boolean isVideoCall = false;
+        Message result = mHandler.obtainMessage(EVENT_DIAL_CONFERENCE_RESULT);
+
+        if (profile.getVideoStateFromImsCallProfile(profile) !=
+                VideoProfile.STATE_AUDIO_ONLY) {
+            isVideoCall = true;
+        }
+        mImsRILAdapter.startConference(participants, clirMode, isVideoCall, result);
+        mHasPendingMo = true;
+    }
+
+    @Override
+    public void accept(int callType, ImsStreamMediaProfile profile) {
+        Rlog.d(LOG_TAG, "accept - original call Type:" + mCallProfile.mCallType
+                + "accept as:" + callType);
+        if (mCallProfile.mCallType == ImsCallProfile.CALL_TYPE_VOICE) {
+            mImsRILAdapter.accept();
+        } else {
+            int videoMode;
+            /* We set the videoMode base on AT+EVTA mode value.
+             * AT+EVTA=<mode>,<call id>
+             * Mode  =1 , accept as audio
+             * Mode  =2 , accept as one way only video (Rx)
+             * Mode  =3 , accept as one way only video (Tx)
+             * For videoMode = 0, we will use ATA command to accept this video call.
+             */
+            switch (callType) {
+                case ImsCallProfile.CALL_TYPE_VT:
+                    videoMode = 0;
+                    break;
+                case ImsCallProfile.CALL_TYPE_VOICE:
+                    videoMode = 1;
+                    break;
+                case ImsCallProfile.CALL_TYPE_VT_RX:
+                    videoMode = 2;
+                    break;
+                case ImsCallProfile.CALL_TYPE_VT_TX:
+                    videoMode = 3;
+                    break;
+                default:
+                    videoMode = 0;
+                    break;
+            }
+            mImsRILAdapter.acceptVideoCall(videoMode, Integer.parseInt(mCallId));
+        }
+    }
+
+    @Override
+    public void reject(int reason) {
+        if (mCallId != null) {
+            mImsRILAdapter.reject(Integer.parseInt(mCallId));
+        } else {
+            Rlog.e(LOG_TAG, "Reject Call fail since there is no call ID. Abnormal Case");
+        }
+    }
+
+    @Override
+    public void terminate(int reason) {
+        if (mCallId != null) {
+            mImsRILAdapter.terminate(Integer.parseInt(mCallId));
+        } else {
+            Rlog.e(LOG_TAG, "Terminate Call fail since there is no call ID. Abnormal Case");
+        }
+    }
+
+    @Override
+    public void hold(ImsStreamMediaProfile profile) {
+        Message result = mHandler.obtainMessage(EVENT_HOLD_RESULT);
+        mImsRILAdapter.hold(Integer.parseInt(mCallId), result);
+    }
+
+    @Override
+    public void resume(ImsStreamMediaProfile profile) {
+        Message result = mHandler.obtainMessage(EVENT_RESUME_RESULT);
+        mImsRILAdapter.resume(Integer.parseInt(mCallId), result);
+    }
+
+    @Override
+    public void merge() {
+        Message result;
+        Rlog.e(LOG_TAG, "Merge callId:" + mCallId);
+        ImsCallInfo myCallInfo = mImsRILAdapter.getCallInfo(mCallId);
+        ImsCallInfo beMergedCallInfo = null;
+
+        if (myCallInfo == null) {
+            Rlog.e(LOG_TAG, "can't find this call callInfo");
+            mergeFailed();
+            return;
+        }
+
+        if (myCallInfo.mState == ImsCallInfo.State.ACTIVE) {
+            beMergedCallInfo = mImsRILAdapter.getCallInfo(ImsCallInfo.State.HOLDING);
+        } else if (myCallInfo.mState == ImsCallInfo.State.HOLDING) {
+            beMergedCallInfo = mImsRILAdapter.getCallInfo(ImsCallInfo.State.ACTIVE);
+        }
+
+        if (beMergedCallInfo == null) {
+            Rlog.e(LOG_TAG, "can't find another call's callInfo");
+            mergeFailed();
+            return;
+        }
+
+        Rlog.d(LOG_TAG, "merge command- my call: conference type=" + myCallInfo.mIsConference +
+                " call status=" + myCallInfo.mState + "beMergedCall: conference type=" +
+                beMergedCallInfo.mIsConference + " call status=" + beMergedCallInfo.mState);
+
+        mMergeCallId = myCallInfo.mCallId;
+        mMergeCallStatus = myCallInfo.mState;
+        mMergedCallId = beMergedCallInfo.mCallId;
+        mMergedCallStatus = beMergedCallInfo.mState;
+
+        if (myCallInfo.mIsConference == false && beMergedCallInfo.mIsConference == false) {
+            //Case 1: Normal call merge normal call
+            result = mHandler.obtainMessage(EVENT_MERGE_RESULT);
+            mImsRILAdapter.merge(result);
+            mIsHideHoldEventDuringMerging = true;
+            mNormalCallsMerge = true;
+        } else if (myCallInfo.mIsConference == true && beMergedCallInfo.mIsConference == true) {
+            // Case 2: conference call merge conference call
+            Rlog.d(LOG_TAG, "conference call merge conference call");
+            result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+            mImsRILAdapter.inviteParticipants(Integer.parseInt(mCallId),
+                    beMergedCallInfo.mCallNum, result);
+            return;
+        } else {
+            if (myCallInfo.mIsConference) {
+                Rlog.d(LOG_TAG, "active conference call merge background normal call");
+                result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+                mImsRILAdapter.inviteParticipants(Integer.parseInt(mCallId),
+                        beMergedCallInfo.mCallNum, result);
+            } else {
+                Rlog.d(LOG_TAG, "active normal call merge background conference call");
+                result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+                mImsRILAdapter.inviteParticipants(Integer.parseInt(beMergedCallInfo.mCallId),
+                        myCallInfo.mCallNum, result);
+            }
+        }
+        mIsMerging = true;
+    }
+
+    @Override
+    public void update(int callType, ImsStreamMediaProfile profile) {
+        // currently MD not support for video downgrade or audio upgrade.
+    }
+
+    @Override
+    public void extendToConference(String[] participants) {
+        // currently MD not support to join multiple participants to join conference call.
+    }
+
+    @Override
+    public void inviteParticipants(String[] participants) {
+        Message result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+        mPendingParticipantInfoIndex = 0;
+        mPendingParticipantInfo = participants;
+        mPendingParticipantStatistics = participants.length;
+        if (mCallId != null || mPendingParticipantStatistics == 0) {
+            mImsRILAdapter.inviteParticipants(Integer.parseInt(mCallId),
+                    mPendingParticipantInfo[mPendingParticipantInfoIndex], result);
+        } else {
+            Rlog.e(LOG_TAG, "inviteParticipants fail since no call ID or participants is null" +
+                    " CallID=" + mCallId + " Participant number=" + mPendingParticipantStatistics);
+            if (mListener != null) {
+                try {
+                    mListener.callSessionInviteParticipantsRequestFailed(
+                            ImsCallSessionProxy.this, new ImsReasonInfo());
+                } catch (RemoteException e) {
+                    Rlog.e(LOG_TAG, "RemoteException occurs when InviteParticipantsRequestFailed");
+                }
+            }
+        }
+    }
+
+    @Override
+    public void removeParticipants(String[] participants) {
+        Message result = mHandler.obtainMessage(EVENT_REMOVE_CONFERENCE_RESULT);
+        mPendingParticipantInfoIndex = 0;
+        mPendingParticipantInfo = participants;
+        mPendingParticipantStatistics = participants.length;
+        if (mCallId != null || mPendingParticipantStatistics == 0) {
+            mImsRILAdapter.removeParticipants(Integer.parseInt(mCallId),
+                    mPendingParticipantInfo[mPendingParticipantInfoIndex], result);
+        } else {
+            Rlog.e(LOG_TAG, "removeParticipants fail since no call ID or participants is null" +
+                    " CallID=" + mCallId + " Participant number=" + mPendingParticipantStatistics);
+            if (mListener != null) {
+                try {
+                    mListener.callSessionRemoveParticipantsRequestFailed(
+                            ImsCallSessionProxy.this, new ImsReasonInfo());
+                } catch (RemoteException e) {
+                    Rlog.e(LOG_TAG, "RemoteException occurs when RemoveParticipantsRequestFailed");
+                }
+            }
+        }
+    }
+
+    @Override
+    public void sendDtmf(char c, Message result) {
+        mImsRILAdapter.sendDtmf(c, result);
+    }
+
+    @Override
+    public void startDtmf(char c) {
+        mImsRILAdapter.startDtmf(c, null);
+    }
+
+    @Override
+    public void stopDtmf() {
+        mImsRILAdapter.stopDtmf(null);
+    }
+
+    // Google issue. Original sendDtmf could not pass Message.target to another process,
+    // because Message.writeToParcel didn't write target. Workaround this issue by adding
+    // a new API which passes target by Messenger.
+    @Override
+    public void sendDtmfbyTarget(char c, Message result, Messenger target) {
+        mDtmfMsg = result;
+        mDtmfTarget = target;
+        // Use ImsCallSessionProxy handler to send result back to original Message target.
+        Message local_result = mHandler.obtainMessage(EVENT_DTMF_DONE);
+        mImsRILAdapter.sendDtmf(c, local_result);
+    }
+
+    @Override
+    public void sendUssd(String ussdMessage) {
+    }
+
+    @Override
+    public IImsVideoCallProvider getVideoCallProvider() {
+        Rlog.d(LOG_TAG, "getVideoCallProvider: mVTProvider= " + mVTProvider);
+        if (mVTProvider != null) {
+            return mVTProvider.getInterface();
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean isMultiparty() {
+        return mCallProfile.getCallExtraInt(ImsCallProfile.EXTRA_MPTY, 0) == 1;
+    }
+
+    @Override
+    public boolean isIncomingCallMultiparty() {
+        return mCallProfile.getCallExtraInt(ImsCallProfile.EXTRA_INCOMING_MPTY, 0) == 1;
+    }
+
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+
+        /**
+        * To handle IMS conference call message
+        *
+        * @param len    The length of data
+        * @param data   Conference call message
+        */
+
+        private void handleImsConfCallMessage(int len, int callId, String data) {
+            try {
+                if ((data == null) || (data.equals(""))) {
+                    Rlog.e(LOG_TAG, "Failed to handleImsConfCallMessage due to data is empty");
+                    return;
+                }
+
+                Rlog.d(LOG_TAG, "handleVoLteConfCallMessage, data length = " + data.length() +
+                        "callId = " + callId);
+
+                //ALPS02136981. Prints debug messages for ImsPhone.
+                logDebugMessagesWithNotifyFormat("CC", "ConfXMLNotify", "conferenceCall", data);
+
+                // Write conference call data to file
+                String file = "/sdcard/conferenceCall.xml";
+                //For VoLTE testing purpose, mark it temporarily.
+                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(file), "UTF-8");
+                out.write(data, 0, data.length());
+                out.close();
+
+                //Read conference call file and parse it
+                InputStream inStream = new BufferedInputStream(new FileInputStream(file));
+                SAXParserFactory factory = SAXParserFactory.newInstance();
+                SAXParser saxParse = factory.newSAXParser();
+                ConferenceCallMessageHandler xmlData = new ConferenceCallMessageHandler();
+                if (xmlData == null) {
+                    Rlog.e(LOG_TAG, "can't create xmlData object");
+                    return;
+                }
+                saxParse.parse(inStream, xmlData);
+
+                //get user data from xml and fill them into ImsConferenceState data structure.
+                List<ConferenceCallMessageHandler.User> users = xmlData.getUsers();
+                int i = 0;
+                ImsConferenceState imsConferenceState = new ImsConferenceState();
+
+
+                for (ConferenceCallMessageHandler.User u : users) {
+                    i++;
+                    Bundle confInfo = new Bundle();
+                    confInfo.putString(ImsConferenceState.USER,
+                            getUserNameFromSipTelUriString(u.getEntity()));
+                    confInfo.putString(ImsConferenceState.DISPLAY_TEXT, u.getDisplayText());
+                    confInfo.putString(ImsConferenceState.ENDPOINT, u.getEndPoint());
+                    String state = u.getStatus();
+                    if (state.equals(ConferenceCallMessageHandler.STATUS_PENDING)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_PENDING);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_DIALING_OUT)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_DIALING_OUT);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_DIALING_IN)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_DIALING_IN);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_ALERTING)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_ALERTING);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_ON_HOLD)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_ON_HOLD);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_CONNECTED)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_CONNECTED);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_DISCONNECTING)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_DISCONNECTING);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_DISCONNECTED)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_DISCONNECTED);
+                    } else if (state.equals(ConferenceCallMessageHandler.STATUS_MUTED_VIA_FOCUS)) {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_MUTED_VIA_FOCUS);
+                    } else {
+                        confInfo.putString(ImsConferenceState.STATUS,
+                                ImsConferenceState.STATUS_CONNECT_FAIL);
+                    }
+                    imsConferenceState.mParticipants.put(Integer.toString(i), confInfo);
+                }
+
+                if (mListener != null) {
+                    try {
+                        mListener.callSessionConferenceStateUpdated(ImsCallSessionProxy.this,
+                                imsConferenceState);
+                    } catch (RemoteException e) {
+                        Rlog.e(LOG_TAG, "RemoteException occurs when callSessionConferenceStateUpdated()");
+                    }
+                }
+
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "Failed to handle volte conference call message !!!" + e);
+            }
+        }
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            final String action = intent.getAction();
+            if (DBG) {
+                Rlog.d(LOG_TAG, "received broadcast " + action);
+            }
+            /* Handle IMS conference call xml message */
+            if (mCallId != null) {
+                if (CallControlDispatcher.ACTION_IMS_CONFERENCE_CALL_INDICATION.equals(action)) {
+                    int callId = intent.getIntExtra(CallControlDispatcher.EXTRA_CALL_ID, 3);
+
+                    if (callId == Integer.parseInt(mCallId)) {
+                        String data = intent.getStringExtra(
+                                CallControlDispatcher.EXTRA_MESSAGE_CONTENT);
+                        if ((data != null) && (!data.equals(""))) {
+                            handleImsConfCallMessage(data.length(), callId, data);
+                        }
+                    }
+                }
+            } else {
+                Rlog.e(LOG_TAG, "can't handle conference message since no call ID. Abnormal Case");
+            }
+        }
+    };
+
+    private class MyHandler extends Handler {
+
+        private static final String PAU_NUMBER_FIELD = "<tel:";
+        private static final String PAU_NAME_FIELD = "<name:";
+        private static final String PAU_SIP_NUMBER_FIELD = "<sip:";
+        private static final String PAU_END_FLAG_FIELD = ">";
+
+        public MyHandler(Looper looper) {
+            super(looper, null, true);
+        }
+
+        private String getFieldValueFromPau(String pau, String field) {
+            String value = "";
+            if (TextUtils.isEmpty(pau) || TextUtils.isEmpty(field)) {
+                Rlog.d(LOG_TAG, "getFieldValueFromPau()... pau or field is null !");
+                return value;
+            }
+
+            if (!pau.contains(field)) {
+                Rlog.d(LOG_TAG, "getFieldValueFromPau()... There is no such field in pau !"
+                        + " field / pau :" + field + " / " + pau);
+                return value;
+            }
+
+            int startIndex = pau.indexOf(field);
+            startIndex += field.length();
+            int endIndex = pau.indexOf(PAU_END_FLAG_FIELD, startIndex);
+            value = pau.substring(startIndex, endIndex);
+            return value;
+        }
+
+        private int sipCauseFromCode(int causeCode) {
+            Rlog.d(LOG_TAG, "sipCauseFromCode: causeCode = " + causeCode);
+
+            switch (causeCode) {
+                case CallFailCause.USER_BUSY:
+                    return ImsReasonInfo.CODE_SIP_BUSY;
+
+                case CallFailCause.TEMPORARY_FAILURE:
+                case CallFailCause.CHANNEL_NOT_AVAIL:
+                    return ImsReasonInfo.CODE_SIP_TEMPRARILY_UNAVAILABLE;
+
+                case CallFailCause.QOS_NOT_AVAIL:
+                    return ImsReasonInfo.CODE_SIP_NOT_ACCEPTABLE;
+
+                case CallFailCause.NO_CIRCUIT_AVAIL:
+                case CallFailCause.FACILITY_NOT_IMPLEMENT:
+                case CallFailCause.PROTOCOL_ERROR_UNSPECIFIED:
+                    return ImsReasonInfo.CODE_SIP_SERVER_INTERNAL_ERROR;
+
+                case CallFailCause.ACM_LIMIT_EXCEEDED:
+                    return ImsReasonInfo.CODE_LOCAL_CALL_EXCEEDED;
+
+                case CallFailCause.CALL_BARRED:
+                case CallFailCause.FDN_BLOCKED:
+                    return ImsReasonInfo.CODE_LOCAL_ILLEGAL_STATE;
+
+                case CallFailCause.BEARER_NOT_AVAIL:
+                case CallFailCause.INTERWORKING_UNSPECIFIED:
+                /* sip 510 not implemented */
+                case CallFailCause.FACILITY_REJECTED:
+                /* sip 502 bad gateway */
+                case CallFailCause.ACCESS_INFORMATION_DISCARDED:
+                    return ImsReasonInfo.CODE_SIP_SERVER_ERROR;
+
+                case CallFailCause.NO_USER_RESPONDING:
+                    return ImsReasonInfo.CODE_TIMEOUT_NO_ANSWER;
+
+                case CallFailCause.USER_ALERTING_NO_ANSWER:
+                    return ImsReasonInfo.CODE_USER_NOANSWER;
+
+                case CallFailCause.CALL_REJECTED:
+                    return ImsReasonInfo.CODE_SIP_USER_REJECTED;
+
+                case CallFailCause.NORMAL_UNSPECIFIED:
+                    return ImsReasonInfo.CODE_USER_TERMINATED_BY_REMOTE;
+
+                case CallFailCause.UNOBTAINABLE_NUMBER:
+                case CallFailCause.INVALID_NUMBER_FORMAT:
+                    return ImsReasonInfo.CODE_SIP_BAD_ADDRESS;
+
+                case CallFailCause.RESOURCE_UNAVAILABLE:
+                case CallFailCause.SWITCHING_CONGESTION:
+                case CallFailCause.SERVICE_NOT_AVAILABLE:
+                case CallFailCause.NETWORK_OUT_OF_ORDER:
+                case CallFailCause.INCOMPATIBLE_DESTINATION:
+                    return ImsReasonInfo.CODE_SIP_SERVICE_UNAVAILABLE;
+
+                case CallFailCause.BEARER_NOT_AUTHORIZED:
+                case CallFailCause.INCOMING_CALL_BARRED_WITHIN_CUG:
+                    return ImsReasonInfo.CODE_SIP_FORBIDDEN;
+
+                case CallFailCause.CHANNEL_UNACCEPTABLE:
+                case CallFailCause.BEARER_NOT_IMPLEMENT:
+                    return ImsReasonInfo.CODE_SIP_NOT_ACCEPTABLE;
+
+                case CallFailCause.NO_ROUTE_TO_DESTINATION:
+                    return ImsReasonInfo.CODE_SIP_NOT_FOUND;
+
+                case CallFailCause.OPERATOR_DETERMINED_BARRING:
+                    return ImsReasonInfo.CODE_SIP_REQUEST_CANCELLED;
+
+                case CallFailCause.RECOVERY_ON_TIMER_EXPIRY:
+                    return ImsReasonInfo.CODE_SIP_REQUEST_TIMEOUT;
+
+                /* SIP 481: call/transaction doesn't exist */
+                case CallFailCause.INVALID_TRANSACTION_ID_VALUE:
+                    return ImsReasonInfo.CODE_SIP_CLIENT_ERROR;
+
+                /* [VoLTE]Normal call failed, need to dial as ECC */
+                case CallFailCause.IMS_EMERGENCY_REREG:
+                    return ImsReasonInfo.CODE_SIP_REDIRECTED_EMERGENCY;
+
+                case CallFailCause.ERROR_UNSPECIFIED:
+                case CallFailCause.NORMAL_CLEARING:
+                default:
+                    // WFC: Because +CEER doesn't carry fail cause for WifiCalling, we need to get
+                    // fail cause from WifiOffloadService
+                    int wfcReason = getWfcDisconnectCause(causeCode);
+                    if (wfcReason != WFC_GET_CAUSE_FAILED) {
+                        return wfcReason;
+                    }
+
+                    int serviceState = mImsService.getImsServiceState();
+
+                    Rlog.d(LOG_TAG, "serviceState = " + serviceState);
+
+                    if (serviceState == ServiceState.STATE_POWER_OFF) {
+                        return ImsReasonInfo.CODE_LOCAL_POWER_OFF;
+                    } else if (serviceState == ServiceState.STATE_OUT_OF_SERVICE) {
+                        return ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN;
+                    } else if (causeCode == CallFailCause.NORMAL_CLEARING) {
+                        return ImsReasonInfo.CODE_USER_TERMINATED_BY_REMOTE;
+                    } else {
+                        // If nothing else matches, report unknown call drop reason
+                        // to app, not NORMAL call end.
+                        return ImsReasonInfo.CODE_UNSPECIFIED;
+                    }
+                }
+        }
+
+        private boolean isCallModeUpdated(int callMode, int videoState) {
+            Rlog.d(LOG_TAG, "updateCallMode- callMode:" + callMode + "videoState:" + videoState);
+            boolean isChanged = false;
+            int oldCallMode = mCallProfile.mCallType;
+
+            if (callMode == IMS_VIDEO_CALL || callMode == IMS_VIDEO_CONF ||
+                    callMode == IMS_VIDEO_CONF_PARTS) {
+                switch(videoState) {
+                    case 0:  //pause
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT_NODIR;
+                        break;
+                    case 1:  //send only
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT_TX;
+                        break;
+                    case 2:  // recv only
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT_RX;
+                        break;
+                    case 3:  // send and recv
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                        break;
+                    default:
+                        mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                        break;
+                }
+
+                if (mCallProfile.mCallType != oldCallMode) {
+                    isChanged = true;
+                }
+            } else if (callMode == IMS_VOICE_CALL || callMode == IMS_VOICE_CONF ||
+                    callMode == IMS_VOICE_CONF_PARTS) {
+                mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VOICE;
+                if (mCallProfile.mCallType != oldCallMode) {
+                    isChanged = true;
+                }
+            }
+
+            return isChanged;
+        }
+
+        private void retrieveMergeFail() {
+
+            ImsCallInfo mergeCallInfo = null;
+            ImsCallInfo mergedCallInfo = null;
+            boolean     isNotifyMergeFail = false;
+
+            Rlog.d(LOG_TAG, "retrieveMergeFail");
+            if (mMergeCallId != null && !mMergeCallId.equals("")) {
+                mergeCallInfo = mImsRILAdapter.getCallInfo(mMergeCallId);
+            }
+
+            if (mMergedCallId != null && !mMergedCallId.equals("")) {
+                mergedCallInfo = mImsRILAdapter.getCallInfo(mMergedCallId);
+            }
+
+            if (mergeCallInfo != null && mergedCallInfo != null) {
+                Rlog.d(LOG_TAG, "retrieveMergeFail- MergeCallInfo: callId=" + mergeCallInfo.mCallId
+                        + " call status=" + mergeCallInfo.mState + " MergedCallInfo: callId=" +
+                        mergedCallInfo.mCallId + " call status=" + mergedCallInfo.mState);
+                if (mergeCallInfo.mState == ImsCallInfo.State.ACTIVE &&
+                        mergedCallInfo.mState == ImsCallInfo.State.HOLDING) {
+                    //Nothing Change
+                    isNotifyMergeFail = true;
+                } else if (mergeCallInfo.mState == ImsCallInfo.State.ACTIVE &&
+                        mergedCallInfo.mState == ImsCallInfo.State.ACTIVE) {
+                    // 2 active call and hold the merged call
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- two active call and hold merged call");
+                    Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                    mImsRILAdapter.hold(Integer.parseInt(mMergedCallId), result);
+                } else if (mergeCallInfo.mState == ImsCallInfo.State.HOLDING &&
+                        mergedCallInfo.mState == ImsCallInfo.State.HOLDING) {
+                    // 2 hold call and resume merge call
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- two hold call and resume merge call");
+                    Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                    mImsRILAdapter.resume(Integer.parseInt(mMergeCallId), result);
+                } else {
+                    /*
+                     *Sincemerge call is become hold and merged call is become active,
+                     *we need to swap two calls
+                     */
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- swap two calls");
+                    Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                    mImsRILAdapter.swap(result);
+                }
+            } else if (mergeCallInfo == null || mergedCallInfo == null) {
+                //Only one call is exist and maintain the call state to original state
+                if (mergeCallInfo != null) {
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- only merge call is left");
+                    if (mergeCallInfo.mState != ImsCallInfo.State.ACTIVE) {
+                        Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                        mImsRILAdapter.resume(Integer.parseInt(mMergeCallId), result);
+                    } else {
+                        isNotifyMergeFail = true;
+                    }
+                } else if (mergedCallInfo != null) {
+                    Rlog.d(LOG_TAG, "retrieveMergeFail- only merged call is left");
+                    if (mergedCallInfo.mState != ImsCallInfo.State.HOLDING) {
+                        Message result = mHandler.obtainMessage(EVENT_RETRIEVE_MERGE_FAIL_RESULT);
+                        mImsRILAdapter.hold(Integer.parseInt(mMergedCallId), result);
+                    } else {
+                        isNotifyMergeFail = true;
+                    }
+                }
+            }
+
+            if (isNotifyMergeFail) {
+                mergeFailed();
+            }
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            AsyncResult ar;
+            int callMode = INVALID_CALL_MODE;
+            if (DBG) {
+                Rlog.d(LOG_TAG, "receive message by ImsCallSessionProxy - CallId:" + mCallId);
+            }
+
+            switch (msg.what) {
+                case EVENT_CALL_INFO_INDICATION:
+                    /* +ECPI:<call_id>, <msg_type>, <is_ibt>, <is_tch>, <dir>, <call_mode>[, <number>, <toa>], "",<cause>
+                     *
+                     * if msg_type = DISCONNECT_MSG or ALL_CALLS_DISC_MSG,
+                     * +ECPI:<call_id>, <msg_type>, <is_ibt>, <is_tch>,,,"",,"",<cause>
+                     *
+                     * if others,
+                     * +ECPI:<call_id>, <msg_type>, <is_ibt>, <is_tch>, <dir>, <call_mode>[, <number>, <toa>], ""
+                     *
+                     *      0  O  CSMCC_SETUP_MSG
+                     *      1  X  CSMCC_DISCONNECT_MSG
+                     *      2  O  CSMCC_ALERT_MSG
+                     *      3  X  CSMCC_CALL_PROCESS_MSG
+                     *      4  X  CSMCC_SYNC_MSG
+                     *      5  X  CSMCC_PROGRESS_MSG
+                     *      6  O  CSMCC_CALL_CONNECTED_MSG
+                     *   129  X  CSMCC_ALL_CALLS_DISC_MSG
+                     *   130  O  CSMCC_MO_CALL_ID_ASSIGN_MSG
+                     *   131  O  CSMCC_STATE_CHANGE_HELD
+                     *   132  O  CSMCC_STATE_CHANGE_ACTIVE
+                     *   133  O  CSMCC_STATE_CHANGE_DISCONNECTED
+                     *   134  X  CSMCC_STATE_CHANGE_MO_DISCONNECTING
+                     */
+                    ar = (AsyncResult) msg.obj;
+                    String[] callInfo = (String[]) ar.result;
+                    int msgType = 0;
+                    boolean isCallProfileUpdated = false;
+
+                    if (DBG) Rlog.d(LOG_TAG, "receive EVENT_CALL_INFO_INDICATION");
+                    if ((callInfo[1] != null) && (!callInfo[1].equals(""))) {
+                        msgType = Integer.parseInt(callInfo[1]);
+                    }
+
+                    if ((callInfo[5] != null) && (!callInfo[5].equals(""))) {
+                        callMode = Integer.parseInt(callInfo[5]);
+                    }
+
+                    if (mIsMerging && (!callInfo[0].equals(mCallId))) {
+                        switch (msgType) {
+                            case 130:
+                                Rlog.d(LOG_TAG, "IMS: +ECPI : conference assign call id");
+                                ImsCallProfile imsCallProfile = new ImsCallProfile();
+                                if ((callInfo[6] != null) && (!callInfo[6].equals(""))) {
+                                    imsCallProfile.setCallExtra(ImsCallProfile.EXTRA_OI,
+                                            callInfo[6]);
+                                    /*
+                                    *we assume the remote uri information is same as telephone
+                                    * number and update the remote ui information after getting pau.
+                                    */
+                                    imsCallProfile.setCallExtra(ImsCallProfile.EXTRA_REMOTE_URI,
+                                            callInfo[6]);
+                                    imsCallProfile.setCallExtraInt(ImsCallProfile.EXTRA_OIR,
+                                            ImsCallProfile.OIR_PRESENTATION_NOT_RESTRICTED);
+                                } else {
+                                    imsCallProfile.setCallExtraInt(ImsCallProfile.EXTRA_OIR,
+                                            ImsCallProfile.OIR_PRESENTATION_NOT_RESTRICTED);
+                                }
+
+                                mConfSession = new ImsCallSessionProxy(mContext,imsCallProfile,
+                                        null, mImsService, mServiceHandler, mImsRILAdapter, callInfo[0]);
+                                try {
+                                    mListener.callSessionMergeStarted(ImsCallSessionProxy.this,
+                                            mConfSession, mCallProfile);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException when session merged started");
+                                }
+                                break;
+                            default:
+                                break;
+                        }
+                    } else if (mCallId != null && mCallId.equals(callInfo[0])) {
+                        switch (msgType) {
+                            case 0:
+                                mState = ImsCallSession.State.ESTABLISHING;
+                                Rlog.d(LOG_TAG, "IMS: +ECPI : incoming call");
+                                if ((callInfo[5] != null) && (!callInfo[5].equals(""))) {
+                                    callMode = Integer.parseInt(callInfo[5]);
+                                }
+
+                                if (callMode == IMS_VIDEO_CALL || callMode == IMS_VIDEO_CONF ||
+                                        callMode == IMS_VIDEO_CONF_PARTS) {
+                                    mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                                } else {
+                                    mCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VOICE;
+                                }
+
+                                if (callMode == IMS_VOICE_CONF ||
+                                        callMode == IMS_VIDEO_CONF ||
+                                        callMode == IMS_VOICE_CONF_PARTS ||
+                                        callMode == IMS_VIDEO_CONF_PARTS) {
+                                    mCallProfile.setCallExtraInt(
+                                            ImsCallProfile.EXTRA_INCOMING_MPTY, 1);
+
+                                    // ALPS02136981. Prints debug messages for ImsPhone.
+                                    mCallNumber = "conferenceCall";
+                                } else {
+                                    mCallProfile.setCallExtraInt(
+                                            ImsCallProfile.EXTRA_INCOMING_MPTY, 0);
+
+                                    // ALPS02136981. Prints debug messages for ImsPhone.
+                                    mCallNumber = callInfo[6];
+                                }
+
+                                if ((callInfo[6] != null) && (!callInfo[6].equals(""))) {
+                                    mCallProfile.setCallExtra(ImsCallProfile.EXTRA_OI, callInfo[6]);
+                                    /*
+                                    * we assume the remote uri information is same as telephone
+                                    * number and update the remote ui information after getting pau.
+                                    */
+                                    mCallProfile.setCallExtra(ImsCallProfile.EXTRA_REMOTE_URI,
+                                            callInfo[6]);
+                                }
+                                mCallProfile.setCallExtraInt(ImsCallProfile.EXTRA_OIR,
+                                            ImsCallProfile.OIR_PRESENTATION_NOT_RESTRICTED);
+                                /* ServiceID may need to refine in the future */
+                                int serviceId = 1;
+
+                                Rlog.d(LOG_TAG, "IMS: sendIncomingCallIntent() call_id = "
+                                        + mCallId + " dialString = " +  callInfo[6]);
+
+                                //ALPS02136981. Prints debug messages for ImsPhone.
+                                logDebugMessagesWithNotifyFormat("CC", "MT", mCallNumber, "");
+
+                                Intent intent = new Intent(ImsManager.ACTION_IMS_INCOMING_CALL);
+                                intent.putExtra(ImsManager.EXTRA_CALL_ID, mCallId);
+                                intent.putExtra(ImsManager.EXTRA_DIAL_STRING, callInfo[6]);
+                                intent.putExtra(ImsManager.EXTRA_SERVICE_ID, serviceId);
+                                mContext.sendBroadcast(intent);
+                                break;
+                            case 2: // CSMCC_ALERT_MSG
+                                int isIbt = 1;
+
+                                if (callInfo[2] != null) {
+                                    isIbt = Integer.parseInt(callInfo[2]);
+                                }
+
+                                // ALPS02136981. Prints debug messages for ImsPhone.
+                                if (callMode == IMS_VOICE_CONF ||
+                                        callMode == IMS_VIDEO_CONF ||
+                                        callMode == IMS_VOICE_CONF_PARTS ||
+                                        callMode == IMS_VIDEO_CONF_PARTS) {
+                                    mCallNumber = "conferenceCall";
+                                }
+                                logDebugMessagesWithNotifyFormat(
+                                        "CC", "Alerting", mCallNumber, " isIbt=" + isIbt);
+
+                                if (isIbt == 0) {
+                                    mCallProfile.mMediaProfile.mAudioDirection =
+                                            ImsStreamMediaProfile.DIRECTION_INACTIVE;
+                                }
+
+                                updatePau(callInfo[8]);
+
+                                if (mListener != null) {
+                                    try {
+                                        mListener.callSessionProgressing(ImsCallSessionProxy.this,
+                                                mCallProfile.mMediaProfile);
+                                    } catch (RemoteException e) {
+                                        Rlog.e(LOG_TAG, "RemoteException callSessionProgressing");
+                                    }
+                                }
+                                mHasPendingMo = false;
+                                break;
+                            case 6: //CSMCC_CALL_CONNECTED_MSG
+                                mState = ImsCallSession.State.ESTABLISHED;
+                                mCallProfile.mMediaProfile.mAudioDirection =
+                                        ImsStreamMediaProfile.DIRECTION_SEND_RECEIVE;
+
+                                updateMultipartyState(callMode);
+
+                                // ALPS02136981. Prints debug messages for ImsPhone.
+                                logDebugMessagesWithNotifyFormat("CC", "Active", mCallNumber, "");
+
+                                updatePau(callInfo[8]);
+
+                                if (mListener != null) {
+                                    try {
+                                        /* There may not has alerting message while dial
+                                         * conference call. We need to reset mHasPendingMO.
+                                         */
+                                        if (mHasPendingMo) {
+                                            mListener.callSessionProgressing(
+                                                    ImsCallSessionProxy.this,
+                                                    mCallProfile.mMediaProfile);
+                                        }
+                                        mListener.callSessionStarted(ImsCallSessionProxy.this,
+                                                mCallProfile);
+                                    } catch (RemoteException e) {
+                                        Rlog.e(LOG_TAG, "RemoteException callSessionStarted()");
+                                    }
+                                }
+                                mHasPendingMo = false;
+                                break;
+                            case 131: //CSMCC_STATE_CHANGE_HELD
+                                // ALPS02136981. Prints debug messages for ImsPhone.
+                                logDebugMessagesWithNotifyFormat("CC", "Onhold", mCallNumber, "");
+
+                                updatePau(callInfo[8]);
+
+                                if (mListener != null) {
+                                    if (mIsHideHoldEventDuringMerging == false) {
+                                        try {
+                                            mListener.callSessionHeld(ImsCallSessionProxy.this,
+                                                    mCallProfile);
+                                        } catch (RemoteException e) {
+                                            Rlog.e(LOG_TAG, "RemoteException callSessionHeld");
+                                        }
+                                    } else {
+                                        try {
+                                            mListener.callSessionPauInfoChanged(
+                                                    ImsCallSessionProxy.this, mCallProfile);
+                                        } catch (RemoteException e) {
+                                            Rlog.e(LOG_TAG,
+                                                "RemoteException callSessionPauInfoChanged");
+                                        }
+                                    }
+                                }
+                                break;
+                            case 132: //CSMCC_STATE_CHANGE_ACTIVE
+                                updatePau(callInfo[8]);
+
+                                if (mListener != null) {
+                                    if (mState == ImsCallSession.State.ESTABLISHED) {
+                                        try {
+                                            // ALPS02136981. Prints debug messages for ImsPhone.
+                                            logDebugMessagesWithNotifyFormat("CC", "Active", mCallNumber, "");
+
+                                            mListener.callSessionResumed(
+                                                    ImsCallSessionProxy.this, mCallProfile);
+                                        } catch (RemoteException e) {
+                                            Rlog.e(LOG_TAG, "RemoteException SessionResumed");
+                                        }
+                                    } else {
+                                        try {
+                                            mListener.callSessionPauInfoChanged(
+                                                    ImsCallSessionProxy.this, mCallProfile);
+                                        } catch (RemoteException e) {
+                                            Rlog.e(LOG_TAG,
+                                                "RemoteException callSessionPauInfoChanged");
+                                        }
+                                    }
+                                }
+                                break;
+                            case 133: //CSMCC_STATE_CHANGE_DISCONNECTED
+                                // ALPS02136981. Prints debug messages for ImsPhone.
+                                logDebugMessagesWithNotifyFormat("CC", "Disconnected", mCallNumber, "");
+
+                                mIsOnTerminated = true;
+                                mState = ImsCallSession.State.TERMINATED;
+                                if (mHasPendingMo) {
+                                    mHasPendingMo = false;
+                                    mCallErrorState = CallErrorState.DIAL;
+                                } else {
+                                    mCallErrorState = CallErrorState.DISCONNECT;
+                                }
+                                Message result = mHandler.obtainMessage(
+                                        EVENT_GET_LAST_CALL_FAIL_CAUSE);
+                                mImsRILAdapter.getLastCallFailCause(result);
+                                break;
+                            default:
+                                break;
+                        }
+                    } else if (mCallId == null && msgType == 130) {
+                        Rlog.d(LOG_TAG, "IMS: receive 130 URC, call_id = " + callInfo[0]);
+                        mState = ImsCallSession.State.ESTABLISHING;
+                        mCallId = callInfo[0];
+                        if (mVTProvider != null) {
+                            mVTProvider.setId(Integer.parseInt(mCallId));
+                        }
+                    }
+                    break;
+                case EVENT_RINGBACK_TONE:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_RINGBACK_TONE");
+                    }
+                    break;
+                case EVENT_ECONF_RESULT_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    handleEconfIndication((String[]) ar.result);
+                    break;
+                case EVENT_DIAL_RESULT:
+                case EVENT_DIAL_CONFERENCE_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive DIAL_RESULT or DIAL_CONFERENCE_RESULT");
+                    }
+                    if (ar.exception != null) {
+                        if (DBG) {
+                            Rlog.d(LOG_TAG, "dial call failed!!");
+                        }
+                        if (mListener != null) {
+
+                            Message result = mHandler.obtainMessage(
+                                    EVENT_GET_LAST_CALL_FAIL_CAUSE);
+                            mCallErrorState = CallErrorState.DIAL;
+                            mImsRILAdapter.getLastCallFailCause(result);
+                            mHasPendingMo = false;
+                        }
+                    }
+                    break;
+                case EVENT_HOLD_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_HOLD_RESULT");
+                    }
+                    if (mListener != null) {
+                        if (ar.exception != null) {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "hold call failed!!");
+                            }
+                            try {
+                                ImsReasonInfo imsReasonInfo = null;
+                                if ((ar.exception instanceof CommandException)
+                                        && (((CommandException) (ar.exception)).getCommandError()
+                                            == Error.CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED)) {
+                                    imsReasonInfo = new ImsReasonInfo(
+                                            ImsReasonInfo.CODE_LOCAL_CALL_TERMINATED, 0);
+                                } else {
+                                    imsReasonInfo = new ImsReasonInfo();
+                                }
+                                mListener.callSessionHoldFailed(ImsCallSessionProxy.this,
+                                        imsReasonInfo);
+                            } catch (RemoteException e) {
+                                Rlog.e(LOG_TAG, "RemoteException callSessionHoldFailed()");
+                            }
+                        } else {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "hold call successed!!");
+                            }
+                        }
+                    }
+                    break;
+                case EVENT_RESUME_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_RESUME_RESULT");
+                    }
+                    if (mListener != null) {
+                        if (ar.exception != null) {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "resume call failed!!");
+                            }
+                            try {
+                                mListener.callSessionResumeFailed(ImsCallSessionProxy.this,
+                                        new ImsReasonInfo());
+                            } catch (RemoteException e) {
+                                Rlog.e(LOG_TAG, "RemoteException callSessionResumeFailed()");
+                            }
+                        } else {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "resume call successed");
+                            }
+                        }
+                    }
+                    break;
+                case EVENT_MERGE_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_MERGE_RESULT");
+                    }
+                    if (mListener != null) {
+                        if (ar.exception != null) {
+                            if (DBG) {
+                                Rlog.d(LOG_TAG, "merge call failed!!");
+                            }
+                            // ALPS02136981. Prints debug messages for ImsPhone.
+                            logDebugMessagesWithNotifyFormat(
+                                    "CC", "ConfCreated", "conferenceCall", " failed");
+
+                            retrieveMergeFail();
+                        }
+                    }
+                    break;
+                case EVENT_RETRIEVE_MERGE_FAIL_RESULT:
+
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_RETRIEVE_MERGE_FAIL_RESULT");
+                    }
+                    // Don't care the retrieve result and just notify merge fail to ImsPhone.
+                    mergeFailed();
+                    break;
+                case EVENT_ADD_CONFERENCE_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_ADD_CONFERENCE_RESULT");
+                    }
+
+                    if (mIsMerging) {
+                        if (ar.exception != null) {
+                            retrieveMergeFail();
+                        } else {
+                            /*
+                             * We only know the merge command is accepted by server for now.
+                             * The merge result will be notified by receiving +ECONF URC.
+                             */
+                        }
+                    } else {
+                        if (mIsOnTerminated == true) {
+                            break;
+                        }
+
+                        if (ar.exception == null) {
+                            mIsAddRemoveParticipantsCommandOK = true;
+                        }
+                        mPendingParticipantInfoIndex ++;
+
+                        if (mPendingParticipantInfoIndex < mPendingParticipantStatistics) {
+                            Message result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+
+                            mImsRILAdapter.inviteParticipants(Integer.parseInt(mCallId),
+                                    mPendingParticipantInfo[mPendingParticipantInfoIndex], result);
+
+                        } else {
+                            if (mListener != null) {
+                                if (mIsAddRemoveParticipantsCommandOK == false) {
+                                    try {
+                                        mListener.callSessionInviteParticipantsRequestFailed(
+                                                ImsCallSessionProxy.this, new ImsReasonInfo());
+                                    } catch (RemoteException e) {
+                                        Rlog.e(LOG_TAG, "RemoteException InviteFailed()");
+                                    }
+                                } else {
+                                    try {
+                                        mListener.callSessionInviteParticipantsRequestDelivered(
+                                                ImsCallSessionProxy.this);
+                                    } catch (RemoteException e) {
+                                        Rlog.e(LOG_TAG, "RemoteException InviteDelivered()");
+                                    }
+                                }
+                            }
+                            mIsAddRemoveParticipantsCommandOK = false;
+                        }
+                    }
+                    break;
+                case EVENT_REMOVE_CONFERENCE_RESULT:
+                    ar = (AsyncResult) msg.obj;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_REMOVE_CONFERENCE_RESULT");
+                    }
+
+                    if (mIsOnTerminated == true) {
+                        break;
+                    }
+
+                    if (ar.exception == null) {
+                        mIsAddRemoveParticipantsCommandOK = true;
+                    }
+
+                    mPendingParticipantInfoIndex ++;
+                    if (mPendingParticipantInfoIndex < mPendingParticipantStatistics) {
+                        Message result = mHandler.obtainMessage(EVENT_ADD_CONFERENCE_RESULT);
+
+                        mImsRILAdapter.removeParticipants(Integer.parseInt(mCallId),
+                                mPendingParticipantInfo[mPendingParticipantInfoIndex], result);
+                    } else {
+                        if (mListener != null) {
+                            if (mIsAddRemoveParticipantsCommandOK == false) {
+                                try {
+                                    mListener.callSessionRemoveParticipantsRequestFailed(
+                                            ImsCallSessionProxy.this, new ImsReasonInfo());
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException RemoveFailed()");
+                                }
+                            } else {
+                                try {
+                                    mListener.callSessionRemoveParticipantsRequestDelivered(
+                                            ImsCallSessionProxy.this);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException RemoveDelivered()");
+                                }
+                            }
+                        }
+                        mIsAddRemoveParticipantsCommandOK = false;
+                    }
+                    break;
+                case EVENT_GET_LAST_CALL_FAIL_CAUSE:
+                    ar = (AsyncResult) msg.obj;
+                    ImsReasonInfo imsReasonInfo;
+                    int sipCauseCode = ImsReasonInfo.CODE_UNSPECIFIED;
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_GET_LAST_CALL_FAIL_CAUSE");
+                    }
+
+                    if (ar.exception != null) {
+                        imsReasonInfo = new ImsReasonInfo();
+                    } else {
+                        LastCallFailCause failCause = (LastCallFailCause) ar.result;
+                        sipCauseCode = sipCauseFromCode(failCause.causeCode);
+                        imsReasonInfo = new ImsReasonInfo(sipCauseCode, 0);
+                    }
+
+                    switch (mCallErrorState) {
+                        case DIAL :
+                            if (mListener != null) {
+                                try {
+                                    mListener.callSessionStartFailed(ImsCallSessionProxy.this,
+                                            imsReasonInfo);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException callSessionStartFailed()");
+                                }
+                            }
+                            break;
+                        case DISCONNECT :
+                            if (mListener != null) {
+                                try {
+                                    mListener.callSessionTerminated(ImsCallSessionProxy.this,
+                                            imsReasonInfo);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException callSessionTerminated()");
+                                }
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                case EVENT_SIP_CODE_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    int[] sipMessage = (int[]) ar.result;
+                    if (DBG) {
+                        /* ESIPCPI: <call_id>,<dir>,<SIP_msg_type>,<method>,<response_code> */
+                        if (mCallId != null) {
+                            if (sipMessage != null && sipMessage[0] == Integer.parseInt(mCallId)) {
+                                Rlog.d(LOG_TAG, "receive sip cause =" + sipMessage[4]);
+                            }
+                        }
+                    }
+                    break;
+                case EVENT_CALL_MODE_CHANGE_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    String[] callModeInfo = (String[]) ar.result;
+
+                    /* +EIMSCMODE: <call id>,<call mode>,<video state>,<audio direction>,<PAU> */
+                    if (callModeInfo != null && callModeInfo[0].equals(mCallId)) {
+                        int videoState = 2; // assum video state: send_recv is default value
+                        if ((callModeInfo[1] != null) && (!callModeInfo[1].equals(""))) {
+                            callMode = Integer.parseInt(callModeInfo[1]);
+                        }
+                        if ((callModeInfo[2] != null) && (!callModeInfo[2].equals(""))) {
+                            videoState = Integer.parseInt(callModeInfo[2]);
+                        }
+
+                        if (DBG) {
+                            Rlog.d(LOG_TAG, "receive EVENT_CALL_MODE_CHANGE_INDICATION mode=" +
+                                    callMode + "video state:" + videoState);
+                        }
+                        if (isCallModeUpdated(callMode, videoState)) {
+                            if (mListener != null) {
+                                try {
+                                    mListener.callSessionUpdated(ImsCallSessionProxy.this,
+                                            mCallProfile);
+                                } catch (RemoteException e) {
+                                    Rlog.e(LOG_TAG, "RemoteException callSessionUpdated()");
+                                }
+                            }
+                        }
+                        notifyMultipartyStateChanged(callMode);
+                        if (callModeInfo.length >= 5) {
+                            notifyPauInfoChanged(callModeInfo[4]);
+                        }
+                    }
+                    break;
+                case EVENT_VIDEO_CAPABILITY_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    String[] videoCapabilityInfo = (String[]) ar.result;
+                    if (DBG) {
+                        //+EIMSVCAP: <call ID>, <local video capability>, <remote video capability>
+                        boolean  lVideoCapability = false;
+                        boolean  rVideoCapability = false;
+                        if (videoCapabilityInfo != null &&
+                                videoCapabilityInfo[0].equals(mCallId)) {
+                            if ((videoCapabilityInfo[1] != null) &&
+                                    (!videoCapabilityInfo[1].equals(""))) {
+                                lVideoCapability = Boolean.parseBoolean(videoCapabilityInfo[1]);
+                                if (lVideoCapability) {
+                                    mLocalCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                                } else {
+                                    mLocalCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VOICE;
+                                }
+                            }
+                            if ((videoCapabilityInfo[2] != null) &&
+                                    (!videoCapabilityInfo[2].equals(""))) {
+                                rVideoCapability = Boolean.parseBoolean(videoCapabilityInfo[2]);
+                                if (rVideoCapability) {
+                                    mRemoteCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VT;
+                                } else {
+                                    mRemoteCallProfile.mCallType = ImsCallProfile.CALL_TYPE_VOICE;
+                                }
+                            }
+
+                            Rlog.d(LOG_TAG, "receive EVENT_VIDEO_CAPABILITY_INDICATION local " +
+                                    "video capability:" + lVideoCapability +
+                                    " remote video capability:" + rVideoCapability);
+                        }
+                    }
+                    break;
+                case EVENT_DTMF_DONE:
+                    // Send message to original target handler.
+                    if (mDtmfTarget != null && mDtmfMsg != null) {
+                        try {
+                            mDtmfTarget.send(mDtmfMsg);
+                        } catch (RemoteException e) {
+                            Rlog.e(LOG_TAG, "RemoteException handleMessge() for DTMF");
+                        }
+                    }
+                    mDtmfTarget = null;
+                    mDtmfMsg = null;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        private void handleEconfIndication(String[] result) {
+            // +ECONF:<conf_call_id>,<op>,<num>,<result>,<cause>[,<joined_call_id>]
+            if (DBG) {
+                Rlog.d(LOG_TAG, "receive EVENT_ECONF_RESULT_INDICATION mCallId:" + mCallId
+                        + ", conf_call_id:" + result[0] + "joined_call_id:" + result[5]);
+            }
+
+            // Prevent timing issue in ImsCall.processMergeComplete(), it will check if the
+            // session is still alive, by marking this session "terminating"
+            // TODO: check which parameter means original call id
+            if (mCallId != null && mCallId.equals(result[5]) && result[3].equals("0")) {
+                mState = ImsCallSession.State.TERMINATING;
+            }
+
+            if (mIsMerging != true) {
+                return;
+            }
+
+            if (mNormalCallsMerge) {
+                // normal call merge normal call
+                mEconfCount++;
+                if (result[3].equals("0")) {
+                    mThreeWayMergeSucceeded = true;
+                }
+                if (mEconfCount == 2 && mThreeWayMergeSucceeded) {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "3 way conference merge succeeded");
+                    }
+                    // ALPS02136981. Prints debug messages for ImsPhone.
+                    logDebugMessagesWithNotifyFormat(
+                            "CC", "ConfCreated", "conferenceCall", " successed");
+
+                    mergeCompleted();
+                    mNormalCallsMerge = false;
+                } else if (mEconfCount == 2 && mThreeWayMergeSucceeded != true) {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "3 way conference merge failed!!");
+                    }
+                    // ALPS02136981. Prints debug messages for ImsPhone.
+                    logDebugMessagesWithNotifyFormat(
+                            "CC", "ConfCreated", "conferenceCall", " failed");
+
+                    retrieveMergeFail();
+                    /// ALPS02383993: Terminate the conference if merge failed @{
+                    int confCallId = Integer.parseInt(result[0]);
+                    mImsRILAdapter.terminate(confCallId);
+                    /// @}
+                    mNormalCallsMerge = false;
+                }
+            } else {
+                // conference call merge normal call
+                if (result[3].equals("0")) {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "conference call merge normal call successed");
+                    }
+                    // ALPS02136981. Prints debug messages for ImsPhone.
+                    logDebugMessagesWithNotifyFormat(
+                            "CC", "ConfCreated", "conferenceCall", " successed");
+
+                    mergeCompleted();
+                } else {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "conference call merge normal call failed!!");
+                    }
+                    // ALPS02136981. Prints debug messages for ImsPhone.
+                    logDebugMessagesWithNotifyFormat(
+                            "CC", "ConfCreated", "conferenceCall", " failed");
+
+                    retrieveMergeFail();
+                }
+            }
+        }
+
+        private boolean updateMultipartyState(int callMode) {
+            boolean isMultipartyMode = (callMode == IMS_VOICE_CONF || callMode == IMS_VIDEO_CONF
+                    || callMode == IMS_VOICE_CONF_PARTS || callMode == IMS_VIDEO_CONF_PARTS);
+            if (isMultiparty() == isMultipartyMode) {
+                return false;
+            } else if (isMultipartyMode == true) {
+                mCallProfile.setCallExtraInt(ImsCallProfile.EXTRA_MPTY, 1);
+                mCallNumber = "conferenceCall";
+            } else {
+                mCallProfile.setCallExtraInt(
+                        ImsCallProfile.EXTRA_MPTY, 0);
+            }
+            return true;
+        }
+
+        private void notifyMultipartyStateChanged(int callMode) {
+            boolean stateChanged = updateMultipartyState(callMode);
+            if (stateChanged == false) {
+                return;
+            }
+            if (DBG) {
+                Rlog.d(LOG_TAG, "notifyMultipartyStateChanged isMultiparty(): " + isMultiparty());
+            }
+            if (mListener != null) {
+                try {
+                    mListener.callSessionMultipartyStateChanged(ImsCallSessionProxy.this,
+                            isMultiparty());
+                } catch (RemoteException e) {
+                    Rlog.e(LOG_TAG, "RemoteException callSessionMultipartyStateChanged()");
+                }
+            }
+        }
+
+        private boolean updatePau(String pau) {
+            if (pau == null || pau.equals("")) {
+                return false;
+            }
+            String sipNumber = getFieldValueFromPau(pau, PAU_SIP_NUMBER_FIELD);
+            Rlog.d(LOG_TAG, "updatePau()... sipNumber: " + sipNumber);
+            if (!sipNumber.equals(mCallProfile.getCallExtra(ImsCallProfile.EXTRA_REMOTE_URI))) {
+                mCallProfile.setCallExtra(ImsCallProfile.EXTRA_REMOTE_URI, sipNumber);
+            }
+            if (pau.equals(mCallProfile.getCallExtra(ImsCallProfile.EXTRA_PAU))) {
+                return false;
+            }
+            mCallProfile.setCallExtra(ImsCallProfile.EXTRA_PAU, pau);
+            return true;
+        }
+
+        private void notifyPauInfoChanged(String pau) {
+            if (updatePau(pau) == false) {
+                return;
+            }
+
+            if (mListener == null) {
+                return;
+            }
+            try {
+                mListener.callSessionPauInfoChanged(ImsCallSessionProxy.this, mCallProfile);
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG,
+                        "RemoteException callSessionPauInfoChanged");
+            }
+        }
+
+        private int getWfcDisconnectCause(int causeCode) {
+            Rlog.d(LOG_TAG, "[WFC] getWfcDisconnectCause mRatType = " + mRatType);
+            if (mWfoService == null || mRatType != WifiOffloadManager.RAN_TYPE_WIFI
+                    || causeCode == CallFailCause.NORMAL_CLEARING) {
+                return WFC_GET_CAUSE_FAILED;
+            }
+
+            DisconnectCause disconnectCause = null;
+            try {
+                disconnectCause = mWfoService.getDisconnectCause();
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG, "RemoteException in getWfcDisconnectCause()");
+            }
+            if (disconnectCause == null) {
+                return WFC_GET_CAUSE_FAILED;
+            }
+            int wfcErrorCause = disconnectCause.getErrorCause();
+            Rlog.d(LOG_TAG, "[WFC] wfcErrorCause = " + wfcErrorCause);
+            if (wfcErrorCause == WfcReasonInfo.CODE_WFC_WIFI_SIGNAL_LOST) {
+                return ImsReasonInfo.CODE_SIP_WIFI_SIGNAL_LOST;
+            } else if ((wfcErrorCause == WfcReasonInfo.CODE_WFC_UNABLE_TO_COMPLETE_CALL)
+                    || (wfcErrorCause == WfcReasonInfo.CODE_WFC_UNABLE_TO_COMPLETE_CALL_CD)) {
+                return ImsReasonInfo.CODE_SIP_HANDOVER_WIFI_FAIL;
+            } else if (wfcErrorCause ==
+                    WfcReasonInfo.CODE_WFC_NO_AVAILABLE_QUALIFIED_MOBILE_NETWORK) {
+                return ImsReasonInfo.CODE_SIP_HANDOVER_LTE_FAIL;
+            } else {
+                return WFC_GET_CAUSE_FAILED;
+            }
+        }
+    }
+
+    private void mergeCompleted() {
+        if (mListener != null) {
+            try {
+                mListener.callSessionMergeComplete(mConfSession);
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG, "RemoteException callSessionMerged()");
+            }
+        }
+        mIsMerging = false;
+        mIsHideHoldEventDuringMerging = false;
+    }
+
+    private void mergeFailed() {
+        if (mListener != null) {
+            try {
+                mListener.callSessionMergeFailed(ImsCallSessionProxy.this,
+                        new ImsReasonInfo());
+            } catch (RemoteException e) {
+                Rlog.e(LOG_TAG, "RemoteException callSessionMergeFailed()");
+            }
+        }
+       mMergeCallId = "";
+       mMergeCallStatus = ImsCallInfo.State.INVALID;
+       mMergedCallId = "";
+       mMergedCallStatus = ImsCallInfo.State.INVALID;
+
+       mIsMerging = false;
+       mIsHideHoldEventDuringMerging = false;
+       if (mConfSession instanceof ImsCallSessionProxy) {
+           ((ImsCallSessionProxy) mConfSession).close();
+       }
+    }
+
+    /**
+     * Logs unified debug log messages, for "Notify".
+     * Format: [category][Module][Notify][Action][call-number][local-call-ID] Msg. String.
+     * P.S. uses the RIL call ID as the local call ID.
+     *
+     * @param category currently we only have 'CC' category.
+     * @param action the action name. (e.q. Active, MT, Onhold, etc.)
+     * @param isConf is conference
+     * @param msg the optional messages
+     * @hide
+     */
+    void logDebugMessagesWithNotifyFormat(
+            String category, String action, String callNumber, String msg) {
+        if (category == null || action == null) {
+            // return if no mandatory tags.
+            return;
+        }
+
+        /*
+        FormattedLog formattedLog = new FormattedLog.Builder()
+                .setCategory(category)
+                .setServiceName("ImsPhone")
+                .setOpType(FormattedLog.OpType.NOTIFY)
+                .setActionName(action)
+                .setCallNumber(callNumber)
+                .setCallId(getCallId())
+                .setExtraMessage(msg)
+                .buildDebugMsg();
+        */
+        String s = "[" + category + "][ImsPhone][Notify][" + action + "]["
+                + callNumber + "][" + getCallId() + "] " + msg;
+
+        /*
+        if (formattedLog != null) {
+            Rlog.d(LOG_TAG, formattedLog.toString());
+        }
+        */
+        Rlog.d(LOG_TAG, s);
+    }
+
+    /**
+     * A listener type for receiving notification on WFC handover events.
+     */
+    private class IWifiOffloadListenerProxy extends WifiOffloadManager.Listener {
+        @Override
+        public void onHandover(int stage, int ratType) {
+            if (ratType == mRatType || stage == WifiOffloadManager.HANDOVER_START) {
+                return;
+            }
+            if (mListener != null) {
+                try {
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "onHandover");
+                    }
+                    mListener.callSessionHandover(ImsCallSessionProxy.this, mRatType, ratType,
+                            new ImsReasonInfo());
+                } catch (RemoteException e) {
+                    Rlog.e(LOG_TAG, "RemoteException onHandover()");
+                }
+            }
+            mRatType = ratType;
+        }
+    }
+
+    /**
+     * Get the user name (i.e. phone number or Sip account) from a Sip/Tel Uri string.
+     * Reference RFC 3966.
+     *
+     * @param uriString the string of the Sip/Tel URI.
+     * @return the string of user name.
+     * @hide
+     * @internal
+     */
+    private String getUserNameFromSipTelUriString(String uriString) {
+        if (uriString == null) {
+            return null;
+        }
+
+        Uri uri = Uri.parse(uriString);
+
+        // Gets the address part, i.e. everything between 'sip:' and the fragment separator '#'.
+        // ex: '+8618407404132@10.185.184.137:5087;transport=UDP'
+        // or '1234;phone-context=munich.example.com;isub=@1134'
+        String address = uri.getSchemeSpecificPart();
+        if (address == null) {
+            return null;
+        }
+
+        // Gets user name, i.e. everything before '@'.
+        // ex: '+8618407404132' or '1234;phone-context=munich.example.com;isub='
+        String userName = PhoneNumberUtils.getUsernameFromUriNumber(address);
+        if (userName == null) {
+            return null;
+        }
+
+        // Gets pure user name part, i.e. everything before ';' or ','.
+        // ex: '+8618407404132' or '1234'
+        int pIndex = userName.indexOf(';');    //WAIT
+        int wIndex = userName.indexOf(',');    //PAUSE
+
+        if (pIndex >= 0 && wIndex >= 0) {
+            return userName.substring(0, Math.min(pIndex, wIndex) + 1);
+        } else if (pIndex >= 0) {
+            return userName.substring(0, pIndex + 1);
+        } else if (wIndex >= 0) {
+            return userName.substring(0, wIndex + 1);
+        } else {
+            return userName;
+        }
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsCommandsInterface.java b/packages/Ims/src/com/mediatek/ims/ImsCommandsInterface.java
new file mode 100644
index 0000000..2f18cce
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsCommandsInterface.java
@@ -0,0 +1,56 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+
+/**
+ * {@hide}
+ */
+public interface ImsCommandsInterface {
+    enum RadioState {
+        RADIO_OFF,         /* Radio explicitly powered off (eg CFUN=0) */
+        RADIO_UNAVAILABLE, /* Radio unavailable (eg, resetting or not booted) */
+        RADIO_ON;          /* Radio is on */
+
+        public boolean isOn() /* and available...*/ {
+            return this == RADIO_ON;
+        }
+
+        public boolean isAvailable() {
+            return this != RADIO_UNAVAILABLE;
+        }
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsConfigStub.java b/packages/Ims/src/com/mediatek/ims/ImsConfigStub.java
new file mode 100644
index 0000000..2dff992
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsConfigStub.java
@@ -0,0 +1,261 @@
+package com.mediatek.ims;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsConfigListener;
+import com.android.ims.internal.IImsConfig;
+
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * IMSConfig class for handle the IMS MO configruation.
+ *
+ * The implementation is based on 3GPP 24.167  3GPP IMS Management Object (MO); Stage 3
+ *
+ *  @hide
+ */
+public class ImsConfigStub extends IImsConfig.Stub {
+    private static final String TAG = "ImsConfigService";
+
+    private static final int  MAX_BYTE_COUNT               = 256;
+
+    private Context mContext;
+    private String  mAtCmdResult = "";
+    private static TelephonyManager sTelephonyManager = null;
+    private String  mPcscf;
+    private static final String PROPERTY_VOLTE_ENALBE = "ro.mtk.volte.enable";
+
+    /**
+     *
+     * Construction function for ImsConfigStub.
+     *
+     * @param context the application context
+     *
+     */
+    public ImsConfigStub(Context context) {
+        mContext = context;
+        mPcscf = "";
+    }
+
+    /**
+     * Gets the value for ims service/capabilities parameters from the master
+     * value storage. Synchronous blocking call.
+     *
+     * @param item as defined in com.android.ims.ImsConfig#ConfigConstants.
+     * @return value in Integer format.
+     */
+    @Override
+    public int getProvisionedValue(int item) {
+        return handleGetMasterValue(item);
+    }
+
+
+    /**
+     * Gets the value for ims service/capabilities parameters from the master
+     * value storage. Synchronous blocking call.
+     *
+     * @param item as defined in com.android.ims.ImsConfig#ConfigConstants.
+     * @return value in String format.
+     */
+    @Override
+    public String getProvisionedStringValue(int item) {
+        if (sTelephonyManager == null) {
+            sTelephonyManager = (TelephonyManager) mContext.getSystemService(
+                                    Context.TELEPHONY_SERVICE);
+        }
+
+        return "";
+    }
+
+    /**
+     * Sets the value for IMS service/capabilities parameters by the operator device
+     * management entity. It sets the config item value in the provisioned storage
+     * from which the master value is derived. Synchronous blocking call.
+     *
+     * @param item as defined in com.android.ims.ImsConfig#ConfigConstants.
+     * @param value in Integer format.
+     */
+    @Override
+    public int setProvisionedValue(int item, int value) {
+        return handleProvisionedValue(item, value);
+    }
+
+    /**
+     * Sets the value for IMS service/capabilities parameters by the operator device
+     * management entity. It sets the config item value in the provisioned storage
+     * from which the master value is derived.  Synchronous blocking call.
+     *
+     * @param item as defined in com.android.ims.ImsConfig#ConfigConstants.
+     * @param value in String format.
+     */
+    @Override
+    public int setProvisionedStringValue(int item, String value) {
+
+        return 0;
+
+    }
+
+    /**
+     * Gets the value of the specified IMS feature item for specified network type.
+     * This operation gets the feature config value from the master storage (i.e. final
+     * value) asynchronous non-blocking call.
+     *
+     * @param feature as defined in com.android.ims.ImsConfig#FeatureConstants.
+     * @param network as defined in android.telephony.TelephonyManager#NETWORK_TYPE_XXX.
+     * @param listener feature value returned asynchronously through listener.
+     */
+    @Override
+    public void getFeatureValue(int feature, int network, ImsConfigListener listener) {
+    switch (feature) {
+        case ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE:
+        case ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE:
+            int value = android.provider.Settings.Global.getInt(
+                    mContext.getContentResolver(),
+                    android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED,
+                    ImsConfig.FeatureValueConstants.OFF);
+            if (listener != null) {
+                try {
+                    listener.onGetFeatureResponse(feature, network, value,
+                            ImsConfig.OperationStatusConstants.SUCCESS);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "RemoteException occurs when onGetFeatureResponse.");
+                }
+            }
+            break;
+        default:
+            break;
+    }
+
+    }
+
+    /**
+     * Sets the value for IMS feature item for specified network type.
+     * This operation stores the user setting in setting db from which master db
+     * is dervied.
+     *
+     * @param feature as defined in com.android.ims.ImsConfig#FeatureConstants.
+     * @param network as defined in android.telephony.TelephonyManager#NETWORK_TYPE_XXX.
+     * @param value as defined in com.android.ims.ImsConfig#FeatureValueConstants.
+     * @param listener provided if caller needs to be notified for set result.
+     */
+    @Override
+    public void setFeatureValue(int feature, int network, int value, ImsConfigListener listener) {
+
+        switch (feature) {
+            case ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE:
+            case ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE:
+                int oldValue = SystemProperties.getInt(PROPERTY_VOLTE_ENALBE, 0);
+                if( value != oldValue) {
+                    if (value ==1) {
+                        SystemProperties.set(PROPERTY_VOLTE_ENALBE,"1");
+                    } else {
+                        SystemProperties.set(PROPERTY_VOLTE_ENALBE,"0");
+                    }
+                }
+                break;
+            default:
+                break;
+        }
+    }
+
+    /**
+     * Gets the value for IMS volte provisioned.
+     * This should be the same as the operator provisioned value if applies.
+     *
+     * @return boolean
+     */
+    @Override
+    public boolean getVolteProvisioned() {
+        return true;
+    }
+
+    /**
+     * Gets the value for IMS feature item for video call quality.
+     *
+     * @param listener, provided if caller needs to be notified for set result.
+     * @return void
+     */
+    public void getVideoQuality(ImsConfigListener listener) {
+
+    }
+
+    /**
+     * Sets the value for IMS feature item video quality.
+     *
+     * @param quality, defines the value of video quality.
+     * @param listener, provided if caller needs to be notified for set result.
+     * @return void
+     */
+     public void setVideoQuality(int quality, ImsConfigListener listener) {
+
+     }
+
+    private String getAtCmdLine(int item) {
+        String atCmdString = "";
+        Log.i(TAG, "getAtCmdLine:" + item);
+        return atCmdString;
+    }
+
+    private String getAtCmdSetLine(int item, int value) {
+        String atCmdString = "";
+        Log.i(TAG, "getAtCmdLine:" + item);
+        return atCmdString;
+    }
+
+    private synchronized int handleGetMasterValue(int item) {
+        Log.i(TAG, "handleGetMasterValue:" + item);
+
+        String retValue = executeCommandResponse(getAtCmdLine(item));
+
+        if (retValue.length() >  0) {
+            try {
+                return Integer.parseInt(retValue);
+            } catch (NumberFormatException ne) {
+                ne.printStackTrace();
+            }
+        }
+
+        return 0;
+    }
+
+    private synchronized int handleProvisionedValue(int item, int value) {
+        Log.i(TAG, "handleProvisionedValue:" + item + ":" + value);
+        // Not support from now, ignore it
+        // executeCommandResponse(getAtCmdSetLine(item, value));
+        return 24;
+    }
+
+    private synchronized String executeCommandResponse(String atCmdLine) {
+        String atCmdResult = "";
+
+        if (sTelephonyManager == null) {
+            sTelephonyManager = (TelephonyManager)
+                                mContext.getSystemService(Context.TELEPHONY_SERVICE);
+        }
+
+        byte[] rawData = atCmdLine.getBytes();
+        byte[] cmdByte = new byte[rawData.length + 1];
+        byte[] respByte = new byte[MAX_BYTE_COUNT + 1];
+        System.arraycopy(rawData, 0, cmdByte, 0, rawData.length);
+        cmdByte[cmdByte.length - 1] = 0;
+
+        if (sTelephonyManager.invokeOemRilRequestRaw(cmdByte, respByte) > 0) {
+            atCmdResult = new String(respByte);
+        }
+
+        //Handle CME ERROR
+        if (atCmdResult.indexOf("+CME ERROR") != -1) {
+            atCmdResult = "";
+        }
+        return atCmdResult;
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsEcbmProxy.java b/packages/Ims/src/com/mediatek/ims/ImsEcbmProxy.java
new file mode 100644
index 0000000..af44369
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsEcbmProxy.java
@@ -0,0 +1,61 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import com.android.ims.internal.IImsEcbm;
+import com.android.ims.internal.IImsEcbmListener;
+
+public class ImsEcbmProxy extends IImsEcbm.Stub {
+    private static final String LOG_TAG = "ImsEcbmProxy";
+    private IImsEcbmListener mListener;
+
+    ImsEcbmProxy() {
+    }
+    /**
+      * Sets the listener.
+      */
+     public void setListener(IImsEcbmListener listener) {
+         mListener = listener;
+     }
+
+     /**
+      * Requests Modem to come out of ECBM mode
+      */
+     public void exitEmergencyCallbackMode() {
+
+     }
+
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsEventDispatcher.java b/packages/Ims/src/com/mediatek/ims/ImsEventDispatcher.java
new file mode 100644
index 0000000..eac446c
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsEventDispatcher.java
@@ -0,0 +1,143 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.Message;
+
+//import com.mediatek.ims.ImsAdapter;
+import com.mediatek.ims.ImsAdapter.VaEvent;
+import com.mediatek.ims.ImsAdapter.VaSocketIO;
+
+import com.mediatek.ims.internal.ImsSimservsDispatcher;
+import com.mediatek.ims.internal.TimerDispatcher;
+import com.mediatek.ims.internal.CallControlDispatcher;
+import com.mediatek.ims.internal.DataDispatcher;
+
+import static com.mediatek.ims.VaConstants.*;
+
+import java.util.ArrayList;
+
+
+
+
+public class ImsEventDispatcher extends Handler {
+
+    private Context mContext;
+    private VaSocketIO mSocket;
+    private ArrayList<VaEventDispatcher> mVaEventDispatcher = new ArrayList<VaEventDispatcher>();
+    private static final String TAG = "ImsEventDispatcher";
+
+    public ImsEventDispatcher(Context context, VaSocketIO IO) {
+        mContext = context;
+        mSocket = IO;
+
+        createDispatcher();
+    }
+
+    public interface VaEventDispatcher {
+        void vaEventCallback(VaEvent event);
+        void enableRequest();
+        void disableRequest();
+    }
+
+    void enableRequest() {
+        for (VaEventDispatcher dispatcher : mVaEventDispatcher) {
+            dispatcher.enableRequest();
+        }
+    }
+
+    void disableRequest() {
+        for (VaEventDispatcher dispatcher : mVaEventDispatcher) {
+            dispatcher.disableRequest();
+        }
+    }
+
+    /* modify the following for domain owners */
+
+    /* Event Dispatcher */
+    private CallControlDispatcher mCallControlDispatcher;
+    private DataDispatcher mDataDispatcher;
+    private TimerDispatcher mTimerDispatcher;
+    private ImsSimservsDispatcher mSimservsDispatcher;
+
+    private void createDispatcher() {
+
+        mCallControlDispatcher = new CallControlDispatcher(mContext, mSocket);
+        mVaEventDispatcher.add(mCallControlDispatcher);
+
+        mDataDispatcher = new DataDispatcher(mContext, mSocket);
+        mVaEventDispatcher.add(mDataDispatcher);
+
+        mTimerDispatcher = new TimerDispatcher(mContext, mSocket);
+        mVaEventDispatcher.add(mTimerDispatcher);
+
+        mSimservsDispatcher = new ImsSimservsDispatcher(mContext, mSocket);
+        mVaEventDispatcher.add(mSimservsDispatcher);
+    }
+
+    @Override
+    public void handleMessage(Message msg) {
+        dispatchCallback((VaEvent) msg.obj);
+    }
+
+    /* dispatch Callback */
+    void dispatchCallback(VaEvent event) {
+
+        switch (event.getRequestID()) {
+            case MSG_ID_NOTIFY_XUI_IND:
+                mSimservsDispatcher.vaEventCallback(event);
+                break;
+
+            case MSG_ID_NOTIFY_SS_PROGRESS_INDICATION :
+                mCallControlDispatcher.vaEventCallback(event);
+                break;
+
+            case MSG_ID_REQUEST_PCSCF_DISCOVERY:
+            case MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ:
+            case MSG_ID_WRAP_IMSM_IMSPA_INFORMATION_REQ:
+            case MSG_ID_WRAP_IMSM_IMSPA_PDN_DEACT_REQ:
+                mDataDispatcher.vaEventCallback(event);
+                break;
+
+            case MSG_ID_REQUEST_TIMER_CREATE:
+            case MSG_ID_REQUEST_TIMER_CANCEL:
+                mTimerDispatcher.vaEventCallback(event);
+                break;
+        }
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsNotificationController.java b/packages/Ims/src/com/mediatek/ims/ImsNotificationController.java
new file mode 100644
index 0000000..406c07b
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsNotificationController.java
@@ -0,0 +1,550 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.app.KeyguardManager;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.Uri;
+import android.net.wifi.WifiManager;
+import android.os.Handler;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.TelephonyIntents;
+
+// import com.mediatek.common.MPlugin;
+// import com.mediatek.common.wfc.IImsNotificationControllerExt;
+
+/** Class to show WFC related notifications like registration & WFC call.
+ */
+public class ImsNotificationController {
+
+    BroadcastReceiver mBr = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            // TODO Auto-generated method stub
+            if (DBG) Log.d(TAG, "Intent action:" + intent.getAction());
+
+            /* Restore screen lock state, even if intent received may not provide its effect */
+            if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                mIsScreenLock = true;
+                handleScreenOff();
+            } else {
+                mIsScreenLock = mKeyguardManager.isKeyguardLocked();
+            }
+            if (DBG) Log.d(TAG, "on receive:screen lock:" + mIsScreenLock);
+
+            if (intent.getAction().equals(TelephonyIntents.ACTION_SIM_STATE_CHANGED)) {
+                String simState = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
+                Log.d(TAG, "simState:" + simState);
+                // Check Sim absent case
+                if (simState.equals(IccCardConstants.INTENT_VALUE_ICC_ABSENT)) {
+                    mIsSimPresent = false;
+                    if (DBG) Log.d(TAG, "SIM not present");
+                } else if (simState.equals(IccCardConstants.INTENT_VALUE_ICC_NOT_READY)) {
+                    mIsSimPresent = true;
+                    if (mImsState == WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR) {
+                        if (DBG) Log.d(TAG, "Reset to default,if incorrect sim error was present");
+                        mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+                        mWfcCapabilityPresent = false;
+                        removeWfcNotification();
+                    }
+                }
+            }
+            if (DBG) Log.d(TAG, "SIM present:" + mIsSimPresent);
+            if (isWifiEnabled() && ImsManager.isWfcEnabledByUser(context)
+                        && !mIsSimPresent) {
+                mImsState = WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR;
+                mWfcCapabilityPresent = false;
+                displayWfcErrorNotification(false);
+                return;
+            }
+
+            /* ALPS02260621: Need to save phone_type as there is no provision of getting it
+                     * without having phone object.
+                     */
+       /* if (intent.getAction().equals(PhoneConstants.ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED)) {
+                String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+                int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY,
+                        RILConstants.NO_PHONE);
+                if (phoneType == RILConstants.IMS_PHONE) {
+                    if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                            || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                        mPhoneType = RILConstants.IMS_PHONE;
+                    } else {
+                        mPhoneType = RILConstants.NO_PHONE;
+                    }
+                }
+            }
+            if (DBG) {
+                Log.d(TAG, "mPhoneType:" + mPhoneType);
+            }*/
+
+             if (Settings.Global.getInt(context.getContentResolver(),
+                    Settings.Global.WFC_IMS_ENABLED,
+                    ImsConfig.FeatureValueConstants.OFF)
+                    == ImsConfig.FeatureValueConstants.OFF
+                    || !isWifiEnabled() || !isWifiConnected()) {
+                if (DBG) Log.d(TAG, "WFC off or Wifi off or not connected");
+                if (mImsState > WfcReasonInfo.CODE_WFC_DEFAULT) {
+                    if (DBG) Log.d(TAG, "remove error noti, return");
+                    removeWfcNotification();
+                    return;
+                }
+            }
+             
+            if (intent.getAction().equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+                handleImsStateChange(intent);
+            } else if (intent.getAction().equals(PhoneConstants
+                    .ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED)) {
+                /* ALPS02260621: Need to save phone_type as there is no provision of getting it
+                  * without having phone object.
+                  */
+                String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+                int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY,
+                        RILConstants.NO_PHONE);
+                if (phoneType == RILConstants.IMS_PHONE) {
+                    if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                            || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                        mPhoneType = RILConstants.IMS_PHONE;
+                    } else {
+                        mPhoneType = RILConstants.NO_PHONE;
+                    }
+                }
+                handleCallIntent(state, phoneType);
+            } else if (intent.getAction().equals(ImsManager.ACTION_IMS_SERVICE_DOWN)) {
+                removeWfcNotification();
+            } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                handleScreenOn();
+            } else if (intent.getAction().equals(Intent.ACTION_USER_PRESENT)) {
+                handleScreenUnlock();
+            }
+            Log.d(TAG, "mPhoneType:" + mPhoneType);
+        }
+    };
+
+    private static final boolean DBG = true;
+    private static final String TAG = "ImsNotificationController";
+    private static final String ACTION_LAUNCH_WFC_SETTINGS
+            = "android.settings.WIFI_CALLING_SETTINGS";
+    private static final String ACTION_LAUNCH_WFC_INVALID_SIM_ALERT
+            = "mediatek.settings.WFC_INVALID_SIM_DIALOG_LAUNCH";
+
+    /**
+    * Wfc registration notification ID. This is
+     * the ID of the Notification given to the NotificationManager.
+     * Note: Id should be unique within APP.
+     */
+    private static final int WFC_NOTIFICATION = 0x10;
+
+    // MTK TODO
+    private static final int WFC_REGISTERED_ICON =
+            0;  // com.mediatek.internal.R.drawable.wfc_notify_registration_success;
+    private static final int WFC_CALL_ICON =
+            0;  // com.mediatek.internal.R.drawable.wfc_notify_ongoing_call;
+    private static final int WFC_ERROR_ICON =
+            0;  // com.mediatek.internal.R.drawable.wfc_notify_registration_error;
+
+    private static final int WFC_REGISTERED_TITLE =
+            0;  // com.mediatek.internal.R.string.success_notification_title;
+    private static final int WFC_CALL_TITLE =
+            0;  // com.mediatek.internal.R.string.ongoing_call_notification_title;
+    private static final int WFC_ERROR_TITLE =
+            0;  // com.mediatek.internal.R.string.network_error_notification_title;
+
+    private static final int WFC_REGISTERED_SUMMARY =
+            0;  // com.mediatek.internal.R.string.success_notification_summary;
+
+    // Current WFC state.
+    // Can be: 1) Success: WFC registered (2) DEFAULT: WFC on but not registered
+    // (3) Various error codes: defined in WfcReasonInfo
+    private int mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+
+    private boolean mWfcCapabilityPresent = false;
+    private boolean mWfcCallOngoing = false;
+    private boolean mIsScreenLock = false;
+    private boolean mIsSimPresent = true;
+
+    /*  Vars required for ImsNotificationController initialization */
+    private Context mContext;
+    private long mSubId;
+    private int mPhoneType = RILConstants.NO_PHONE;
+
+    private NotificationManager mNotificationManager;
+    private WifiManager mWifiManager;
+    private ConnectivityManager mConnectivityManager;
+    private KeyguardManager mKeyguardManager;
+    private ContentObserver mWfcSwitchContentObserver;
+
+    /* IMSN Plugin */
+    // IImsNotificationControllerExt mImsnExt;
+
+    /** Constructor.
+     * @param context context
+     * @param subId subId
+     */
+    public ImsNotificationController(Context context, long subId) {
+        if (DBG) {
+            Log.d(TAG, "in constructor: subId:" + subId);
+        }
+        mContext = context;
+        mSubId = subId;
+        mNotificationManager =
+                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        mConnectivityManager =
+                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        mKeyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
+        mIsScreenLock =  mKeyguardManager.isKeyguardLocked();
+        registerReceiver();
+        registerForWfcSwitchChange();
+
+         /* IMSN plugin part */
+        // mImsnExt = getIMSNPlugin(context);
+    }
+
+    /** Stop the Imsnotification controller.
+     */
+    public void stop() {
+        if (DBG) Log.d(TAG, "in destroy Instance");
+        unRegisterReceiver();
+        unRegisterForWfcSwitchChange();
+        /* Cancel visible notifications, if any */
+        mNotificationManager.cancelAll();
+    }
+
+    private void registerReceiver() {
+        IntentFilter filter = new IntentFilter(ImsManager.ACTION_IMS_STATE_CHANGED);
+        filter.addAction(PhoneConstants.ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED);
+        filter.addAction(TelephonyIntents.ACTION_SIM_STATE_CHANGED);
+        filter.addAction(ImsManager.ACTION_IMS_SERVICE_DOWN);
+        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_USER_PRESENT);
+        mContext.registerReceiver(mBr, filter);
+    }
+
+    private void unRegisterReceiver() {
+        mContext.unregisterReceiver(mBr);
+    }
+
+    private void handleCallIntent(String state, int phoneType) {
+        //String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+        //int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY, RILConstants.NO_PHONE);
+        if (DBG) Log.d(TAG, "in handleCallIntent, phone state:" + state);
+        if (DBG) Log.d(TAG, "in handleCallIntent, phone type:" + phoneType);
+        if (phoneType == RILConstants.IMS_PHONE) {
+            if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                    || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                mWfcCallOngoing = true;
+                displayWfcCallNotification();
+            } else {
+                mWfcCallOngoing = false;
+                displayWfcRegistrationNotification(false);
+            }
+        } else if (phoneType == RILConstants.GSM_PHONE && mWfcCallOngoing) {
+            mWfcCallOngoing = false;
+            displayWfcRegistrationNotification(false);
+        }
+    }
+
+    private void handleImsStateChange(Intent intent) {
+        if (intent.getAction().equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+            mImsState = intent.getIntExtra(ImsManager.EXTRA_IMS_REG_STATE_KEY,
+                    ServiceState.STATE_OUT_OF_SERVICE);
+            if (DBG) Log.d(TAG, "in handleImsStateChange, serviceState:" + mImsState);
+            if (mImsState != ServiceState.STATE_IN_SERVICE) {
+                removeWfcNotification();
+            } else {
+                handleInStateService(intent);
+            }
+        }
+        if (DBG) Log.d(TAG, "exit handleImsStateChange, imsState:" + mImsState);
+    }
+
+    private void handleInStateService(Intent intent) {
+        if (DBG) Log.d(TAG, "in handleInStateService");
+        /*handle for registration icon*/
+        boolean[] enabledFeatures = intent
+                .getBooleanArrayExtra(ImsManager.EXTRA_IMS_ENABLE_CAP_KEY);
+        if (DBG) Log.d(TAG, "wifi capability:" + enabledFeatures[ImsConfig.FeatureConstants
+                .FEATURE_TYPE_VOICE_OVER_WIFI]);
+        if (enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI] == true) {
+            mWfcCapabilityPresent = true;
+            /* Capabilities have been change to WIFI, so set wfc status as Success.
+             * It is done to cover handover cases in which IMS_STATE_CHANGE is not
+             * received before capability_change intent
+            */
+            mImsState = WfcReasonInfo.CODE_WFC_SUCCESS;
+            /* ALPS02187200: Query phone state to check whether UE is in Call
+             * when capability change to Wifi.This case can happen during handover from
+             * LTE to Wifi when call is ongoing.
+             */
+            TelephonyManager tm = (TelephonyManager) mContext
+                    .getSystemService(Context.TELEPHONY_SERVICE);
+            // TODO: for multiSim
+            /* ALPS02260621: check phone_type before showing call icon*/
+            if ((tm.getCallState() == TelephonyManager.CALL_STATE_OFFHOOK
+                            || tm.getCallState() == TelephonyManager.CALL_STATE_RINGING)
+                        && mPhoneType == RILConstants.IMS_PHONE) {
+                mWfcCallOngoing = true;
+                displayWfcCallNotification();
+            } else {
+                displayWfcRegistrationNotification(true);
+            }
+        } else {
+            mWfcCapabilityPresent = false;
+            /* Capabilities have been change to other than WIFI, so set wfc status as OFF */
+            mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+            removeWfcNotification();
+        }
+    }
+
+
+
+    /* Listening screen off intent because no intent for screen lock present in SDK now
+     * So, treating screen Off as screen lock
+     * Remove notification, if screen off
+     */
+    private void handleScreenOff() {
+        mNotificationManager.cancel(WFC_NOTIFICATION);
+    }
+
+    /* Screen on but check if screen is locked or not. If unlocked, show notification. */
+    private void handleScreenOn() {
+        if (!mIsScreenLock) {
+            if (DBG) Log.d(TAG, "screen not locked & screen on, show notification");
+            showNotification();
+        }
+    }
+
+    /* Intent received when user unlocks. Show notification. */
+    private void handleScreenUnlock() {
+        showNotification();
+    }
+
+    private void showNotification() {
+        if (mWfcCallOngoing) {
+            displayWfcCallNotification();
+        } else if (mWfcCapabilityPresent) {
+            displayWfcRegistrationNotification(false);
+        }
+    }
+
+    private void displayWfcCallNotification() {
+        if (DBG) Log.d(TAG, "in call handling, screen lock:" + mIsScreenLock);
+        if (!mIsScreenLock && mImsState == WfcReasonInfo.CODE_WFC_SUCCESS
+                    && mWfcCapabilityPresent) {
+            // TODO: to handle fake SRVCC case(wfc registered but during call setup it goes on CS).
+            //Need RAT type of call setup
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(mContext.getResources().getString(WFC_CALL_TITLE))
+                    .setSmallIcon(WFC_CALL_ICON)
+                    .setOngoing(true)
+                    .setVisibility(Notification.VISIBILITY_SECRET)
+                    .build();
+            mNotificationManager.notify(WFC_NOTIFICATION, noti);
+            if (DBG) Log.d(TAG, "showing wfc call notification");
+        }
+    }
+
+    private void displayWfcRegistrationNotification(boolean showTicker) {
+        if (DBG) Log.d(TAG, "in registration handling, screen lock:" + mIsScreenLock);
+        if (!mIsScreenLock && mImsState == WfcReasonInfo.CODE_WFC_SUCCESS && mWfcCapabilityPresent
+            && mWfcCallOngoing == false) {
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(mContext.getResources().getString(WFC_REGISTERED_TITLE))
+                    .setContentText(mContext.getResources().getString(WFC_REGISTERED_SUMMARY))
+                    .setSmallIcon(WFC_REGISTERED_ICON)
+                    .setOngoing(true)
+                    .setVisibility(Notification.VISIBILITY_SECRET)
+                    .build();
+            if (showTicker) {
+                noti.tickerText = mContext.getResources().getString(WFC_REGISTERED_TITLE);
+            }
+            Intent intent = new Intent(ACTION_LAUNCH_WFC_SETTINGS);
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+            /*
+            if (mImsnExt != null) {
+                intent = mImsnExt.getIntent(IImsNotificationControllerExt.REGISTRATION, intent);
+            }
+            */
+            noti.contentIntent = PendingIntent.getActivity(mContext, 0, intent, 0);
+            noti.flags |= Notification.FLAG_NO_CLEAR;
+            mNotificationManager.notify(WFC_NOTIFICATION, noti);
+            if (DBG) Log.d(TAG, "showing wfc registration notification");
+        }
+    }
+
+
+    private void displayWfcErrorNotification(boolean showTicker) {
+            if (DBG) Log.d(TAG, "in error handling, screen lock:" + mIsScreenLock);
+            if (!mIsScreenLock && mImsState > WfcReasonInfo.CODE_WFC_DEFAULT) {
+            if (DBG) Log.d(TAG, "WFC error:" + mImsState);
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(mContext.getResources().getString(WFC_ERROR_TITLE))
+                    .setContentText(mContext.getResources().getString(WfcReasonInfo
+                            .getImsStatusCodeString(mImsState)))
+                    .setSmallIcon(WFC_ERROR_ICON)
+                    .setOngoing(true)
+                    .setVisibility(Notification.VISIBILITY_SECRET)
+                    .build();
+            if (showTicker) {
+                noti.tickerText = mContext.getResources().getString(WFC_ERROR_TITLE);
+            }
+            Intent intent;
+            //if (mImsState == WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR) {
+                intent = new Intent(ACTION_LAUNCH_WFC_INVALID_SIM_ALERT);
+                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            //}
+            /*
+            if (mImsnExt != null) {
+                intent = mImsnExt.getIntent(IImsNotificationControllerExt.ERROR, intent);
+            }
+            */
+            noti.contentIntent = PendingIntent.getActivity(mContext, 0, intent, 0);
+            noti.flags |= Notification.FLAG_NO_CLEAR;
+            mNotificationManager.notify(WFC_NOTIFICATION, noti);
+            if (DBG) Log.d(TAG, "showing wfc error notification");
+            mWfcCallOngoing = false;
+        }
+    }
+
+    private void removeWfcNotification() {
+        if (DBG) Log.d(TAG, "removing wfc notification, if any");
+        mNotificationManager.cancel(WFC_NOTIFICATION);
+        mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+        mWfcCapabilityPresent = false;
+        mWfcCallOngoing = false;
+    }
+
+    public int getRegistrationStatus() {
+        return mImsState;
+    }
+
+    private boolean isWifiEnabled() {
+        int wifiState = mWifiManager.getWifiState();
+        if (DBG) Log.d(TAG, "wifi state:" + wifiState);
+        return (wifiState != WifiManager.WIFI_STATE_DISABLED);
+    }
+
+    private boolean isWifiConnected() {
+        NetworkInfo networkInfo = mConnectivityManager
+                .getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+        if (networkInfo != null) {
+            if (DBG) Log.d(TAG, "networkInfo:" + networkInfo.isConnected());
+            if (DBG) Log.d(TAG, "networkInfo:" + networkInfo.getDetailedState());
+        }
+        return (networkInfo != null && (networkInfo.isConnected()
+                    || networkInfo.getDetailedState() == DetailedState.CAPTIVE_PORTAL_CHECK));
+    }
+
+    /* Observes WFC settings changes. Needed for cases when WFC is switch OFF but
+     * state_changes intent is received. Ex: WFC error & user switches WCF OFF.
+     */
+    private void registerForWfcSwitchChange() {
+        mWfcSwitchContentObserver = new ContentObserver(new Handler()) {
+
+            @Override
+            public void onChange(boolean selfChange) {
+                this.onChange(selfChange, Settings.Global.getUriFor(Settings
+                        .Global.WFC_IMS_ENABLED));
+            }
+
+            @Override
+            public void onChange(boolean selfChange, Uri uri) {
+                if (Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.WFC_IMS_ENABLED,
+                    ImsConfig.FeatureValueConstants.OFF)
+                    == ImsConfig.FeatureValueConstants.OFF) {
+                    if (DBG) Log.d(TAG, "contentObserver:WFC OFF");
+                    if (mImsState > WfcReasonInfo.CODE_WFC_DEFAULT) {
+                        if (DBG) Log.d(TAG, "remove error notification");
+                        removeWfcNotification();
+                    }
+                } else {
+                    if (DBG) Log.d(TAG, "contentObserver:WFC ON");
+                    if (isWifiEnabled() && !mIsSimPresent) {
+                        if (DBG) Log.d(TAG, "show error notification");
+                        mImsState = WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR;
+                        mWfcCapabilityPresent = false;
+                        displayWfcErrorNotification(false);
+                    }
+                }
+            }
+        };
+        mContext.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.WFC_IMS_ENABLED),
+                false, mWfcSwitchContentObserver);
+    }
+
+    private void unRegisterForWfcSwitchChange() {
+        mContext.getContentResolver().unregisterContentObserver(mWfcSwitchContentObserver);
+        mWfcSwitchContentObserver = null;
+    }
+
+    /*
+    private IImsNotificationControllerExt getIMSNPlugin(Context context) {
+        IImsNotificationControllerExt ext;
+        ext = (IImsNotificationControllerExt) MPlugin.createInstance(
+                IImsNotificationControllerExt.class.getName(), context);
+        return ext;
+    }
+    */
+}
+
diff --git a/packages/Ims/src/com/mediatek/ims/ImsRILAdapter.java b/packages/Ims/src/com/mediatek/ims/ImsRILAdapter.java
new file mode 100644
index 0000000..6aaf611
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsRILAdapter.java
@@ -0,0 +1,2768 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+
+package com.mediatek.ims;
+
+import static com.android.internal.telephony.RILConstants.*;
+
+import android.content.Context;
+import android.net.LocalSocket;
+import android.net.LocalSocketAddress;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.PowerManager.WakeLock;
+import android.os.SystemProperties;
+import android.telephony.PhoneNumberUtils;
+import android.telephony.Rlog;
+import android.telephony.TelephonyManager;
+import android.util.SparseArray;
+
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.gsm.SuppServiceNotification;
+import com.android.internal.telephony.imsphone.ImsPhone;
+import com.android.internal.telephony.LastCallFailCause;
+import com.android.internal.telephony.UUSInfo;
+
+/// M: CC053: MoMS [Mobile Managerment] @{
+// import android.os.IBinder;
+// import android.os.Binder;
+// import android.content.pm.PackageManager;
+// import android.os.ServiceManager;
+// import com.mediatek.common.mom.IMobileManagerService;
+// import com.mediatek.common.mom.MobileManagerUtils;
+// import com.mediatek.common.mom.SubPermissions;
+/// @}
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.List;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+/// M: CC012: DTMF request special handling @{
+import java.util.Vector;
+/// @}
+
+/**
+ * {@hide}
+ */
+class RILRequest {
+    static final String LOG_TAG = "IMSRILRequest";
+
+    //***** Class Variables
+    static Random sRandom = new Random();
+    static AtomicInteger sNextSerial = new AtomicInteger(0);
+    private static Object sPoolSync = new Object();
+    private static RILRequest sPool = null;
+    private static int sPoolSize = 0;
+    private static final int MAX_POOL_SIZE = 4;
+    private Context mContext;
+
+    //***** Instance Variables
+    int mSerial;
+    int mRequest;
+    Message mResult;
+    Parcel mParcel;
+    RILRequest mNext;
+
+    /**
+     * Retrieves a new RILRequest instance from the pool.
+     *
+     * @param request RIL_REQUEST_*
+     * @param result sent when operation completes
+     * @return a RILRequest instance from the pool.
+     */
+    static RILRequest obtain(int request, Message result) {
+        RILRequest rr = null;
+
+        synchronized(sPoolSync) {
+            if (sPool != null) {
+                rr = sPool;
+                sPool = rr.mNext;
+                rr.mNext = null;
+                sPoolSize--;
+            }
+        }
+
+        if (rr == null) {
+            rr = new RILRequest();
+        }
+
+        rr.mSerial = sNextSerial.getAndIncrement();
+
+        rr.mRequest = request;
+        rr.mResult = result;
+        rr.mParcel = Parcel.obtain();
+
+        if (result != null && result.getTarget() == null) {
+            throw new NullPointerException("Message target must not be null");
+        }
+
+        // first elements in any RIL Parcel
+        rr.mParcel.writeInt(request);
+        rr.mParcel.writeInt(rr.mSerial);
+
+        return rr;
+    }
+
+    /**
+     * Returns a RILRequest instance to the pool.
+     *
+     * Note: This should only be called once per use.
+     */
+    void release() {
+        synchronized (sPoolSync) {
+            if (sPoolSize < MAX_POOL_SIZE) {
+                mNext = sPool;
+                sPool = this;
+                sPoolSize++;
+                mResult = null;
+            }
+        }
+    }
+
+    private RILRequest() {
+    }
+
+    static void
+    resetSerial() {
+        // use a random so that on recovery we probably don't mix old requests
+        // with new.
+        sNextSerial.set(sRandom.nextInt());
+    }
+
+    String
+    serialString() {
+        //Cheesy way to do %04d
+        StringBuilder sb = new StringBuilder(8);
+        String sn;
+
+        long adjustedSerial = (((long)mSerial) - Integer.MIN_VALUE)%10000;
+
+        sn = Long.toString(adjustedSerial);
+
+        //sb.append("J[");
+        sb.append('[');
+        for (int i = 0, s = sn.length() ; i < 4 - s; i++) {
+            sb.append('0');
+        }
+
+        sb.append(sn);
+        sb.append(']');
+        return sb.toString();
+    }
+
+    void
+    onError(int error, Object ret) {
+        CommandException ex;
+
+        ex = CommandException.fromRilErrno(error);
+
+        if (ImsRILAdapter.IMS_RILA_LOGD) Rlog.d(LOG_TAG, serialString() + "< "
+            + ImsRILAdapter.requestToString(mRequest)
+            + " error: " + ex + " ret=" + ImsRILAdapter.retToString(mRequest, ret));
+
+        if (mResult != null) {
+            AsyncResult.forMessage(mResult, ret, ex);
+            mResult.sendToTarget();
+        }
+
+        if (mParcel != null) {
+            mParcel.recycle();
+            mParcel = null;
+        }
+    }
+}
+
+/**
+ * IMS RIL dial normal MO call information.
+ *
+ * {@hide}
+ */
+class MoCallInfo {
+    String mCallee;
+    int mClirMode;
+    boolean mIsEmergency;
+    boolean mIsVideoCall;
+    Message mResult;
+
+    //***** Constructors
+    public MoCallInfo(String callee, int clirMode, boolean isEmergency,
+            boolean isVideoCall, Message result) {
+        mCallee = callee;
+        mClirMode = clirMode;
+        mIsEmergency = isEmergency;
+        mIsVideoCall = isVideoCall;
+        mResult = result;
+    }
+}
+
+/**
+ * IMS RIL dial conference call information.
+ *
+ * {@hide}
+ */
+class ConferenceCallDialInfo {
+    String[] mParticipants;
+    int mClirMode;
+    boolean mIsVideoCall;
+    Message mResult;
+
+    //***** Constructors
+    public ConferenceCallDialInfo(String[] participants, int clirMode,
+            boolean isVideoCall, Message result) {
+        mParticipants = participants;
+        mClirMode = clirMode;
+        mIsVideoCall = isVideoCall;
+        mResult = result;
+    }
+}
+
+/**
+ * IMS RIL call information.
+ *
+ * {@hide}
+ */
+class ImsCallInfo {
+    /* State is indicated for call status */
+    enum State {
+        ACTIVE,
+        HOLDING,
+        ALERTING,   // MO call only
+        INCOMING,   // MT call only
+        INVALID;
+    }
+
+    String mCallNum;
+    String mCallId;
+    boolean mIsConference;
+    State mState;
+
+    //***** Constructors
+    public ImsCallInfo(String callId, String callNum, boolean isConference, State state) {
+        mCallId = callId;
+        mCallNum = callNum;
+        mIsConference = isConference;
+        mState = state;
+    }
+}
+
+/**
+ * IMS RIL Adapter implementation.
+ *
+ * {@hide}
+ */
+public class ImsRILAdapter extends ImsBaseCommands implements ImsCommandsInterface {
+    static final String IMS_RILA_LOG_TAG = "IMS_RILA";
+
+    //***** Instance Variables
+    Context mContext;
+    LocalSocket mSocket;
+    HandlerThread mSenderThread;
+    ImsRILSender mSender;
+    Thread mReceiverThread;
+    ImsRILReceiver mReceiver;
+    WakeLock mWakeLock;
+    final int mWakeLockTimeout;
+    // The number of wakelock requests currently active.  Don't release the lock
+    // until dec'd to 0
+    int mWakeLockCount;
+
+    SparseArray<RILRequest> mRequestList = new SparseArray<RILRequest>();
+
+    /**
+     * Property to override DEFAULT_WAKE_LOCK_TIMEOUT
+     */
+    static final String PROPERTY_WAKE_LOCK_TIMEOUT = "ro.ril.wake_lock_timeout";
+    /**
+     * Wake lock timeout should be longer than the longest timeout in
+     * the vendor ril.
+     */
+    private static final int DEFAULT_WAKE_LOCK_TIMEOUT = 60000;
+
+    //***** Events
+    static final int EVENT_SEND                 = 1;
+    static final int EVENT_WAKE_LOCK_TIMEOUT    = 2;
+
+    // match with constant in ril_ims.c
+    static final int RIL_MAX_COMMAND_BYTES = (8 * 1024);
+    static final int RESPONSE_SOLICITED = 0;
+    static final int RESPONSE_UNSOLICITED = 1;
+    static final int SOCKET_OPEN_RETRY_MILLIS = 4 * 1000;
+    static final boolean IMS_RILA_LOGD = true;
+    static final int MAX_CONNECTIONS = 7;
+
+    private static final int INVALID_CALL_MODE = 0xFF;
+    private static final int IMS_VOICE_CALL = 20;
+    private static final int IMS_VIDEO_CALL = 21;
+    private static final int IMS_VOICE_CONF = 22;
+    private static final int IMS_VIDEO_CONF = 23;
+    private static final int IMS_VOICE_CONF_PARTS = 24;
+    private static final int IMS_VIDEO_CONF_PARTS = 25;
+
+    private static final int  MAX_BYTE_COUNT = 256;
+
+    private MoCallInfo mMoCall = null;
+    private ConferenceCallDialInfo mConferenceCallDialInfo = null;
+
+    // Adapter Defined Event
+    private static final int EVENT_AT_CMD_DONE = 100;
+
+    private HashMap<String, ImsCallInfo> mCallConnections = new HashMap<String, ImsCallInfo>();
+
+    private Handler mHandler = new Handler() {
+        public void handleMessage(Message msg) {
+            AsyncResult ar;
+            switch (msg.what) {
+                case EVENT_AT_CMD_DONE:
+                    Rlog.i(IMS_RILA_LOG_TAG, "IMS: Adapter receive EVENT_AT_CMD_DONE");
+                    ar = (AsyncResult) msg.obj;
+                    handleAtCmdResponseAndDial(ar);
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+
+    /// M: CC009: DTMF request special handling @{
+    /* DTMF request will be ignored when duplicated sending */
+    private class dtmfQueueHandler {
+
+        public dtmfQueueHandler() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public void start() {
+            mDtmfStatus = DTMF_STATUS_START;
+        }
+
+        public void stop() {
+            mDtmfStatus = DTMF_STATUS_STOP;
+        }
+
+        public boolean isStart() {
+            return (mDtmfStatus == DTMF_STATUS_START);
+        }
+
+        public void add(RILRequest o) {
+            mDtmfQueue.addElement(o);
+        }
+
+        public void remove(RILRequest o) {
+            mDtmfQueue.remove(o);
+        }
+
+        public void remove(int idx) {
+            mDtmfQueue.removeElementAt(idx);
+        }
+
+        public RILRequest get() {
+            return (RILRequest) mDtmfQueue.get(0);
+        }
+
+        public int size() {
+            return mDtmfQueue.size();
+        }
+
+        public void setPendingRequest(RILRequest r) {
+            mPendingCHLDRequest = r;
+        }
+
+        public RILRequest getPendingRequest() {
+            return mPendingCHLDRequest;
+        }
+
+        public void setSendChldRequest() {
+            mIsSendChldRequest = true;
+        }
+
+        public void resetSendChldRequest() {
+            mIsSendChldRequest = false;
+        }
+
+        public boolean hasSendChldRequest() {
+            riljLog("mIsSendChldRequest = " + mIsSendChldRequest);
+            return mIsSendChldRequest;
+        }
+
+        public final int MAXIMUM_DTMF_REQUEST = 32;
+        private final boolean DTMF_STATUS_START = true;
+        private final boolean DTMF_STATUS_STOP = false;
+
+        private boolean mDtmfStatus = DTMF_STATUS_STOP;
+        private Vector mDtmfQueue = new Vector(MAXIMUM_DTMF_REQUEST);
+
+        private RILRequest mPendingCHLDRequest = null;
+        private boolean mIsSendChldRequest = false;
+    }
+
+    private dtmfQueueHandler mDtmfReqQueue = new dtmfQueueHandler();
+    /// @}
+
+    //***** Constructors
+    public ImsRILAdapter(Context context) {
+        super(context);
+        mContext = context;
+        Rlog.i(IMS_RILA_LOG_TAG, "IMS:ImsRILAdapter constructor");
+
+        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, IMS_RILA_LOG_TAG);
+        mWakeLock.setReferenceCounted(false);
+        mWakeLockTimeout = SystemProperties.getInt(PROPERTY_WAKE_LOCK_TIMEOUT,
+                DEFAULT_WAKE_LOCK_TIMEOUT);
+        mWakeLockCount = 0;
+
+        // initialize IMS RIL sender
+        mSenderThread = new HandlerThread("ImsRILSender");
+        mSenderThread.start();
+        Looper looper = mSenderThread.getLooper();
+        mSender = new ImsRILSender(looper);
+
+        // initialize IMS RIL receiver
+        mReceiver = new ImsRILReceiver();
+        mReceiverThread = new Thread(mReceiver, "ImsRILReceiver");
+        mReceiverThread.start();
+
+    }
+
+    public void setMute(boolean enableMute, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_MUTE, response);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                            + " " + enableMute);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(enableMute ? 1 : 0);
+
+        send(rr);
+    }
+
+    /**
+    * dial volte or vilte call.
+    *
+    * @param callee dialing number string
+    * @param clirMode to present the dialing number or not
+    * @param isEmergency indicate is emergency call or not
+    * @param isVideoCall indicate is belong to vilte call or volte call
+    * @param result command result
+    *
+    */
+    public void start(String callee, int clirMode, boolean isEmergency,
+            boolean isVideoCall, Message result) {
+        String atCmdString = "DIALSOURCE_IMS";
+
+        if (mMoCall != null) Rlog.e(IMS_RILA_LOG_TAG, "IMS: mMoCall is not null when dial !!");
+
+        // New Mo Call Wrapper, used when OEM Hook Raw response return
+        mMoCall = new MoCallInfo(callee, clirMode, isEmergency, isVideoCall, result);
+        executeCommandResponse(atCmdString);
+    }
+
+    /**
+    * dial volte or vilte conference call.
+    *
+    * @param participants participants dialing number string
+    * @param clirMode to present the dialing number or not
+    * @param isVideoCall indicate is belong to vilte call or volte call
+    * @param result command result
+    *
+    */
+    public void startConference(String[] participants, int clirMode,
+            boolean isVideoCall, Message result) {
+        String atCmdString = "DIALSOURCE_IMS";
+
+        if (mConferenceCallDialInfo != null) {
+            Rlog.e(IMS_RILA_LOG_TAG, "IMS: ConferenceCallDialInfo is not null when dial !!");
+        }
+
+        // New Mo Call Wrapper, used when OEM Hook Raw response return
+        mConferenceCallDialInfo = new ConferenceCallDialInfo(participants, clirMode,
+                isVideoCall, result);
+        executeCommandResponse(atCmdString);
+    }
+
+    public void accept() {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_ANSWER, null);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+
+    }
+
+    /**
+     * accept video call.
+     *
+     * @param videoMode indicate to the accept video call as video, audio, video_rx, or video_tx.
+     * @param callId indicate which call we want to accept.
+     *
+     */
+    public void acceptVideoCall(int videoMode, int callId) {
+        if (IMS_RILA_LOGD) {
+            riljLog("acceptVideoCall : callId = " + callId + ", videoMode = " + videoMode);
+        }
+
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_VIDEO_CALL_ACCEPT, null);
+
+        rr.mParcel.writeInt(2);
+        rr.mParcel.writeInt(videoMode);
+        rr.mParcel.writeInt(callId);
+
+        if (IMS_RILA_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                    + " " + videoMode + ", " + callId);
+        }
+        send(rr);
+    }
+
+    public void reject(int callId) {
+        if (IMS_RILA_LOGD) riljLog("IMS reject : callId = " + callId);
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP, null);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " +
+                callId);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        send(rr);
+    }
+
+    public void terminate(int callId) {
+        if (IMS_RILA_LOGD) riljLog("IMS terminate : callId = " + callId);
+
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP, null);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest) + " " +
+                callId);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        send(rr);
+    }
+
+    /**
+     * To hold the call.
+     * @param callId toIndicate which call session to hold.
+     * @param result command result.
+     */
+    public void hold(int callId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HOLD_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        if (IMS_RILA_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    /**
+     * To resume the call.
+     * @param callId toIndicate which call session to resume.
+     * @param result command result.
+     */
+    public void resume(int callId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_RESUME_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        if (IMS_RILA_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+        send(rr);
+    }
+
+    public void merge(Message result) {
+        /// M: CC053: MoMS [Mobile Managerment] @{
+        // 3. Permission Control for Conference call
+        /*
+        if (MobileManagerUtils.isSupported()) {
+            if (!checkMoMSSubPermission(SubPermissions.MAKE_CONFERENCE_CALL)) {
+                return;
+            }
+        }
+        */
+        /// @}
+
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_CONFERENCE, result);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        ///@}
+    }
+
+    public void sendDtmf(char c, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_DTMF, result);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeString(Character.toString(c));
+
+        send(rr);
+
+    }
+
+    /**
+     * Start to paly a DTMF tone on the active call. Ignored if there is no active call
+     * or there is a playing DTMF tone.
+     * @param c should be one of 0-9, '*' or '#'. Other values will be
+     * @param result is present the command is OK or fail
+     */
+    public void startDtmf(char c, Message result) {
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            riljLog("startDtmf: queue size: " + mDtmfReqQueue.size());
+
+            if (!mDtmfReqQueue.hasSendChldRequest() &&
+                mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (!mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_START, result);
+
+                    rr.mParcel.writeString(Character.toString(c));
+                    mDtmfReqQueue.start();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send start dtmf");
+                        if (IMS_RILA_LOGD) {
+                            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+                        }
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " +
+                        mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /// @}
+    }
+
+    /**
+     * Stop the playing DTMF tone. Ignored if there is no playing DTMF
+     * tone or no active call.
+     * @param result is present the command is OK or fail
+     */
+    public void stopDtmf(Message result) {
+        /// M: CC012: DTMF request special handling @{
+        /* DTMF request will be ignored when the count of requests reaches 32 */
+        synchronized (mDtmfReqQueue) {
+            riljLog("stopDtmf: queue size: " + mDtmfReqQueue.size());
+
+            if (!mDtmfReqQueue.hasSendChldRequest() &&
+                mDtmfReqQueue.size() < mDtmfReqQueue.MAXIMUM_DTMF_REQUEST) {
+                if (mDtmfReqQueue.isStart()) {
+                    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, result);
+
+                    mDtmfReqQueue.stop();
+                    mDtmfReqQueue.add(rr);
+                    if (mDtmfReqQueue.size() == 1) {
+                        riljLog("send stop dtmf");
+                        if (IMS_RILA_LOGD) riljLog(rr.serialString() +
+                            "> " + requestToString(rr.mRequest));
+                        send(rr);
+                    }
+                } else {
+                    riljLog("DTMF status conflict, want to start DTMF when status is " +
+                        mDtmfReqQueue.isStart());
+                }
+            }
+        }
+        /// @}
+    }
+    public void setCallIndication(int mode, int callId, int seqNum) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_SET_CALL_INDICATION, null);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeInt(mode);
+        rr.mParcel.writeInt(callId);
+        rr.mParcel.writeInt(seqNum);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+                + " " + mode + ", " + callId + ", " + seqNum);
+
+        send(rr);
+
+    }
+
+    public void turnOnIms(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_IMS_ENABLE, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(1);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void turnOffIms(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_IMS_ENABLE, response);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(0);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+
+    }
+
+    /// M: IMS feature(Can't work in 3G domain). @{
+    public void addConferenceMember(int confCallId, String address, int callIdToAdd,
+        Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(confCallId));
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeString(Integer.toString(callIdToAdd));
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+
+    public void removeConferenceMember(int confCallId, String address, int callIdToRemove,
+        Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER, response);
+
+        rr.mParcel.writeInt(3);
+        rr.mParcel.writeString(Integer.toString(confCallId));
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeString(Integer.toString(callIdToRemove));
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        send(rr);
+    }
+    /// @}
+
+    /**
+    * Add a new member to VoLTE conference call according to the parameter - address.
+    *
+    * @param confCallId IMS(VoLTE) conference call id
+    * @param participant The address(phone number or SIP URI)
+    * @param response Command response.
+    *
+    */
+    public void inviteParticipants(int confCallId, String participant, Message response) {
+        int participantCallId = -1;
+        ImsCallInfo callInfo;
+        for (Map.Entry<String, ImsCallInfo> entry : mCallConnections.entrySet()) {
+            callInfo = entry.getValue();
+            if (participant.equals(callInfo.mCallNum)) {
+                participantCallId = Integer.parseInt(callInfo.mCallId);
+                break;
+            }
+        }
+
+        addConferenceMember(confCallId, participant, participantCallId, response);
+    }
+
+    /**
+    * remove a member from VoLTE conference call according to the parameter - address.
+    *
+    * @param confCallId IMS(VoLTE) conference call id.
+    * @param participant The address(phone number or SIP URI).
+    * @param response Command response.
+    *
+    */
+    public void removeParticipants(int confCallId, String participant, Message response) {
+        int participantCallId = -1;
+        ImsCallInfo callInfo;
+        for (Map.Entry<String, ImsCallInfo> entry : mCallConnections.entrySet()) {
+            callInfo = entry.getValue();
+            if (participant.equals(callInfo.mCallNum)) {
+                participantCallId = Integer.parseInt(callInfo.mCallId);
+                break;
+            }
+        }
+
+        removeConferenceMember(confCallId, participant, participantCallId, response);
+    }
+
+    /**
+    * To get last call fail cause.
+    *
+    * @param response Command response.
+    *
+    */
+    public void getLastCallFailCause(Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_LAST_CALL_FAIL_CAUSE, response);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+    * To release all calls.
+    * @param response Command response.
+    */
+    public void hangupAllCall(Message response) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_HANGUP_ALL, response);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /**
+    * To get callinfo by call Id.
+    * @param callId callId.
+    * @return reture the specified callinfo
+    */
+    public ImsCallInfo getCallInfo(String callId) {
+        return mCallConnections.get(callId);
+    }
+
+    /**
+    * To get callinfo by state.
+    * @param state call state.
+    * @return reture the specified callinfo
+    */
+    public ImsCallInfo getCallInfo(ImsCallInfo.State state) {
+        ImsCallInfo callInfo;
+        for (Map.Entry<String, ImsCallInfo> entry : mCallConnections.entrySet()) {
+            callInfo = entry.getValue();
+            Rlog.d(IMS_RILA_LOG_TAG, "getCallInfo- callID:" + callInfo.mCallId + "call num:" +
+                    callInfo.mCallNum + "call State:" + callInfo.mState);
+            if (callInfo.mState == state) {
+                return callInfo;
+            }
+        }
+        return null;
+    }
+
+    /**
+    * To swap calls.
+    * @param result Command response.
+    */
+    public void swap(Message result) {
+        RILRequest rr
+                = RILRequest.obtain(
+                        RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE,
+                                        result);
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        /// M: CC012: DTMF request special handling @{
+        handleChldRelatedRequest(rr);
+        /// @}
+
+    }
+
+    /**
+    * To send WFC profile information to modem
+    * @param wfcPreference WFC preference selected by User
+    */
+    public void sendWfcProfileInfo(int wfcPreference) {
+        String s[] = new String[2];
+        s[0] = "AT+EWFCP=" + wfcPreference;
+        s[1] = "";
+        Rlog.d(IMS_RILA_LOG_TAG, "At cmnd:" + s[0]);
+        invokeOemRilRequestStrings(s, null);
+    }
+
+    public void invokeOemRilRequestStrings(String[] strings, Message response) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_OEM_HOOK_STRINGS, response);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        rr.mParcel.writeStringArray(strings);
+
+        send(rr);
+    }
+    private static int readRilMessage(InputStream is, byte[] buffer)
+            throws IOException {
+        int countRead;
+        int offset;
+        int remaining;
+        int messageLength;
+
+        // First, read in the length of the message
+        offset = 0;
+        remaining = 4;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0) {
+                Rlog.e(IMS_RILA_LOG_TAG, "Hit EOS reading message length");
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        messageLength = ((buffer[0] & 0xff) << 24)
+                | ((buffer[1] & 0xff) << 16)
+                | ((buffer[2] & 0xff) << 8)
+                | (buffer[3] & 0xff);
+
+        // Then, re-use the buffer and read in the message itself
+        offset = 0;
+        remaining = messageLength;
+        do {
+            countRead = is.read(buffer, offset, remaining);
+
+            if (countRead < 0) {
+                Rlog.e(IMS_RILA_LOG_TAG, "Hit EOS reading message.  messageLength=" + messageLength
+                        + " remaining=" + remaining);
+                return -1;
+            }
+
+            offset += countRead;
+            remaining -= countRead;
+        } while (remaining > 0);
+
+        return messageLength;
+    }
+
+    class ImsRILSender extends Handler implements Runnable {
+        public ImsRILSender(Looper looper) {
+            super(looper);
+        }
+
+        // Only allocated once
+        byte[] dataLength = new byte[4];
+
+        //***** Runnable implementation
+        @Override
+        public void
+        run() {
+            //setup if needed
+        }
+
+
+        //***** Handler implementation
+        @Override public void
+        handleMessage(Message msg) {
+            RILRequest rr = (RILRequest)(msg.obj);
+            RILRequest req = null;
+
+            switch (msg.what) {
+                case EVENT_SEND:
+                    try {
+                        LocalSocket s;
+
+                        s = mSocket;
+
+                        if (s == null) {
+                            rr.onError(RADIO_NOT_AVAILABLE, null);
+                            rr.release();
+                            decrementWakeLock();
+                            return;
+                        }
+
+                        byte[] data;
+                        data = rr.mParcel.marshall();
+                        synchronized (mRequestList) {
+                            mRequestList.append(rr.mSerial, rr);
+                            rr.mParcel.recycle();
+                            rr.mParcel = null;
+                        }
+
+                        if (data.length > RIL_MAX_COMMAND_BYTES) {
+                            throw new RuntimeException(
+                                    "Parcel larger than max bytes allowed! "
+                                                          + data.length);
+                        }
+
+                        // parcel length in big endian
+                        dataLength[0] = dataLength[1] = 0;
+                        dataLength[2] = (byte)((data.length >> 8) & 0xff);
+                        dataLength[3] = (byte)((data.length) & 0xff);
+
+                        //Rlog.v(IMS_RILA_LOG_TAG, "writing packet: " + data.length + " bytes");
+
+                        s.getOutputStream().write(dataLength);
+                        s.getOutputStream().write(data);
+                    } catch (IOException ex) {
+                        Rlog.e(IMS_RILA_LOG_TAG, "IOException", ex);
+                        req = findAndRemoveRequestFromList(rr.mSerial);
+                        // make sure this request has not already been handled,
+                        // eg, if RILReceiver cleared the list.
+                        if (req != null) {
+                            rr.onError(RADIO_NOT_AVAILABLE, null);
+                            rr.release();
+                            decrementWakeLock();
+                        }
+                    } catch (RuntimeException exc) {
+                        Rlog.e(IMS_RILA_LOG_TAG, "Uncaught exception ", exc);
+                        req = findAndRemoveRequestFromList(rr.mSerial);
+                        // make sure this request has not already been handled,
+                        // eg, if RILReceiver cleared the list.
+                        if (req != null) {
+                            rr.onError(GENERIC_FAILURE, null);
+                            rr.release();
+                            decrementWakeLock();
+                        }
+                    }
+                    break;
+
+                case EVENT_WAKE_LOCK_TIMEOUT:
+                    // Haven't heard back from the last request.  Assume we're
+                    // not getting a response and  release the wake lock.
+
+                    // The timer of WAKE_LOCK_TIMEOUT is reset with each
+                    // new send request. So when WAKE_LOCK_TIMEOUT occurs
+                    // all requests in mRequestList already waited at
+                    // least DEFAULT_WAKE_LOCK_TIMEOUT but no response.
+                    //
+                    // Note: Keep mRequestList so that delayed response
+                    // can still be handled when response finally comes.
+
+                    synchronized (mRequestList) {
+                        if (clearWakeLock()) {
+                            if (IMS_RILA_LOGD) {
+                                int count = mRequestList.size();
+                                Rlog.d(IMS_RILA_LOG_TAG, "WAKE_LOCK_TIMEOUT " +
+                                        " mRequestList=" + count);
+                                for (int i = 0; i < count; i++) {
+                                    rr = mRequestList.valueAt(i);
+                                    Rlog.d(IMS_RILA_LOG_TAG, i + ": [" + rr.mSerial + "] "
+                                            + requestToString(rr.mRequest));
+                                }
+                            }
+                        }
+                    }
+                    break;
+            }
+        }
+    }
+
+    class ImsRILReceiver implements Runnable {
+        byte[] buffer;
+
+        ImsRILReceiver() {
+            buffer = new byte[RIL_MAX_COMMAND_BYTES];
+        }
+
+        @Override
+        public void
+        run() {
+            int retryCount = 0;
+            String imsRilSocket = "rild-ims";
+
+            try { for (;; ) {
+                LocalSocket s = null;
+                LocalSocketAddress l;
+
+                try {
+                    s = new LocalSocket();
+                    l = new LocalSocketAddress(imsRilSocket,
+                            LocalSocketAddress.Namespace.RESERVED);
+                    s.connect(l);
+                } catch (IOException ex) {
+                    try {
+                        if (s != null) {
+                            s.close();
+                        }
+                    } catch (IOException ex2) {
+                        //ignore failure to close after failure to connect
+                        Rlog.e(IMS_RILA_LOG_TAG, "Failed to close the socket");
+                    }
+
+                    // don't print an error message after the the first time
+                    // or after the 8th time
+
+                    if (retryCount == 8) {
+                        Rlog.e(IMS_RILA_LOG_TAG,
+                            "Couldn't find '" + imsRilSocket
+                            + "' socket after " + retryCount
+                            + " times, continuing to retry silently");
+                    } else if (retryCount > 0 && retryCount < 8) {
+                        Rlog.i(IMS_RILA_LOG_TAG,
+                            "Couldn't find '" + imsRilSocket
+                            + "' socket; retrying after timeout");
+                    }
+
+                    try {
+                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
+                    } catch (InterruptedException er) {
+                    }
+
+                    retryCount++;
+                    continue;
+                }
+
+                retryCount = 0;
+
+                mSocket = s;
+                Rlog.i(IMS_RILA_LOG_TAG, "Connected to '" + imsRilSocket + "' socket");
+
+                int length = 0;
+                try {
+                    InputStream is = mSocket.getInputStream();
+
+                    for (;; ) {
+                        Parcel p;
+
+                        length = readRilMessage(is, buffer);
+
+                        if (length < 0) {
+                            // End-of-stream reached
+                            break;
+                        }
+
+                        p = Parcel.obtain();
+                        p.unmarshall(buffer, 0, length);
+                        p.setDataPosition(0);
+
+                        //Rlog.v(IMS_RILA_LOG_TAG, "Read packet: " + length + " bytes");
+
+                        processResponse(p);
+                        p.recycle();
+                    }
+                } catch (java.io.IOException ex) {
+                    Rlog.i(IMS_RILA_LOG_TAG, "'" + imsRilSocket + "' socket closed",
+                          ex);
+                } catch (Throwable tr) {
+                    Rlog.e(IMS_RILA_LOG_TAG, "Uncaught exception read length=" + length +
+                        "Exception:" + tr.toString());
+                }
+
+                Rlog.i(IMS_RILA_LOG_TAG, "Disconnected from '" + imsRilSocket
+                      + "' socket");
+
+                setRadioState (RadioState.RADIO_UNAVAILABLE);
+
+                try {
+                    mSocket.close();
+                } catch (IOException ex) {
+                }
+
+                mSocket = null;
+                //RILRequest.resetSerial();
+
+                // Clear request list on close
+                //clearRequestList(RADIO_NOT_AVAILABLE, false);
+            } } catch (Throwable tr) {
+                Rlog.e(IMS_RILA_LOG_TAG, "Uncaught exception", tr);
+            }
+
+            /* We're disconnected so we don't know the ril version */
+            //notifyRegistrantsRilConnectionChanged(-1);
+        }
+    }
+
+    /**
+     * Holds a PARTIAL_WAKE_LOCK whenever
+     * a) There is outstanding RIL request sent to RIL deamon and no replied
+     * b) There is a request pending to be sent out.
+     *
+     * There is a WAKE_LOCK_TIMEOUT to release the lock, though it shouldn't
+     * happen often.
+     */
+
+    private void acquireWakeLock() {
+        synchronized (mWakeLock) {
+            mWakeLock.acquire();
+            mWakeLockCount++;
+
+            mSender.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+            Message msg = mSender.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
+            mSender.sendMessageDelayed(msg, mWakeLockTimeout);
+        }
+    }
+
+    private void decrementWakeLock() {
+        synchronized (mWakeLock) {
+            if (mWakeLockCount > 1) {
+                mWakeLockCount--;
+            } else {
+                mWakeLockCount = 0;
+                mWakeLock.release();
+                mSender.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+            }
+        }
+    }
+
+    // true if we had the wakelock
+    private boolean clearWakeLock() {
+        synchronized (mWakeLock) {
+            if (mWakeLockCount == 0 && mWakeLock.isHeld() == false) return false;
+            Rlog.d(IMS_RILA_LOG_TAG, "NOTE: mWakeLockCount is " + mWakeLockCount +
+                "at time of clearing");
+            mWakeLockCount = 0;
+            mWakeLock.release();
+            mSender.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+            return true;
+        }
+    }
+
+    private void send(RILRequest rr) {
+        Message msg;
+
+        if (mSocket == null) {
+            rr.onError(RADIO_NOT_AVAILABLE, null);
+            rr.release();
+            return;
+        }
+
+        msg = mSender.obtainMessage(EVENT_SEND, rr);
+
+        acquireWakeLock();
+
+        msg.sendToTarget();
+    }
+
+    private void processResponse(Parcel p) {
+        int type;
+        Rlog.i(IMS_RILA_LOG_TAG, " IMS processResponse()");
+
+        type = p.readInt();
+        if (type == RESPONSE_UNSOLICITED) {
+            processUnsolicited(p);
+        } else if (type == RESPONSE_SOLICITED) {
+            Rlog.i(IMS_RILA_LOG_TAG, "IMS: receive the RESPONSE_SOLICITED !!");
+            RILRequest rr = processSolicited (p);
+            if (rr != null) {
+                rr.release();
+                decrementWakeLock();
+            }
+        }
+    }
+
+   private RILRequest
+   processSolicited (Parcel p) {
+       int serial, error;
+       boolean found = false;
+
+       serial = p.readInt();
+       error = p.readInt();
+
+       RILRequest rr;
+
+       rr = findAndRemoveRequestFromList(serial);
+
+       if (rr == null) {
+           Rlog.w(IMS_RILA_LOG_TAG, "Unexpected solicited response! sn: "
+                           + serial + " error: " + error);
+           return null;
+       }
+
+       /// M: CC012: DTMF request special handling @{
+       /* DTMF request will be ignored when the count of requests reaches 32 */
+       if ((rr.mRequest == RIL_REQUEST_DTMF_START) ||
+           (rr.mRequest == RIL_REQUEST_DTMF_STOP)) {
+           synchronized (mDtmfReqQueue) {
+               mDtmfReqQueue.remove(rr);
+               riljLog("remove first item in dtmf queue done, size = " + mDtmfReqQueue.size());
+               if (mDtmfReqQueue.size() > 0) {
+                   RILRequest rr2 = mDtmfReqQueue.get();
+                   if (IMS_RILA_LOGD) riljLog(rr2.serialString() + "> " + requestToString(rr2.mRequest));
+                   send(rr2);
+               } else {
+                   if (mDtmfReqQueue.getPendingRequest() != null) {
+                       riljLog("send pending switch request");
+                       send(mDtmfReqQueue.getPendingRequest());
+                       mDtmfReqQueue.setSendChldRequest();
+                       mDtmfReqQueue.setPendingRequest(null);
+                   }
+               }
+           }
+       }
+       /// @}
+       Object ret = null;
+
+       /// M: CC012: DTMF request special handling @{
+       if (rr.mRequest == RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE ||
+           rr.mRequest == RIL_REQUEST_CONFERENCE ||
+           rr.mRequest == RIL_REQUEST_SEPARATE_CONNECTION ||
+           rr.mRequest == RIL_REQUEST_EXPLICIT_CALL_TRANSFER) {
+           riljLog("clear mIsSendChldRequest");
+           mDtmfReqQueue.resetSendChldRequest();
+       }
+       /// @}
+
+       if (error == 0 || p.dataAvail() > 0) {
+           // either command succeeds or command fails but with data payload
+           try {switch (rr.mRequest) {
+
+           case RIL_REQUEST_DIAL: ret =  responseVoid(p); break;
+           case RIL_REQUEST_GET_IMSI: ret =  responseString(p); break;
+           case RIL_REQUEST_HANGUP: ret =  responseVoid(p); break;
+           case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_CONFERENCE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_UDUB: ret =  responseVoid(p); break;
+           case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: ret =  responseFailCause(p); break;
+           case RIL_REQUEST_VOICE_REGISTRATION_STATE: ret =  responseStrings(p); break;
+           case RIL_REQUEST_DATA_REGISTRATION_STATE: ret =  responseStrings(p); break;
+           case RIL_REQUEST_OPERATOR: ret =  responseStrings(p); break;
+           case RIL_REQUEST_RADIO_POWER: ret =  responseVoid(p); break;
+           case RIL_REQUEST_DTMF: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SEND_USSD: ret =  responseVoid(p); break;
+           case RIL_REQUEST_CANCEL_USSD: ret =  responseVoid(p); break;
+           case RIL_REQUEST_GET_CLIR: ret =  responseInts(p); break;
+           case RIL_REQUEST_SET_CLIR: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_CALL_FORWARD: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_CALL_WAITING: ret =  responseInts(p); break;
+           case RIL_REQUEST_SET_CALL_WAITING: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SMS_ACKNOWLEDGE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_GET_IMEI: ret =  responseString(p); break;
+           case RIL_REQUEST_GET_IMEISV: ret =  responseString(p); break;
+           case RIL_REQUEST_ANSWER: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_FACILITY_LOCK: ret =  responseInts(p); break;
+           case RIL_REQUEST_SET_FACILITY_LOCK: ret =  responseInts(p); break;
+           case RIL_REQUEST_CHANGE_BARRING_PASSWORD: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: ret =  responseInts(p); break;
+           case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: ret =  responseVoid(p); break;
+           case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS: ret =  responseVoid(p); break;
+           case RIL_REQUEST_DTMF_START: ret =  responseVoid(p); break;
+           case RIL_REQUEST_DTMF_STOP: ret =  responseVoid(p); break;
+           case RIL_REQUEST_BASEBAND_VERSION: ret =  responseString(p); break;
+           case RIL_REQUEST_SEPARATE_CONNECTION: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_MUTE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_GET_MUTE: ret =  responseInts(p); break;
+           case RIL_REQUEST_QUERY_CLIP: ret =  responseInts(p); break;
+           case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: ret =  responseInts(p); break;
+           case RIL_REQUEST_RESET_RADIO: ret =  responseVoid(p); break;
+           case RIL_REQUEST_OEM_HOOK_RAW: ret =  responseRaw(p); break;
+           case RIL_REQUEST_OEM_HOOK_STRINGS: ret =  responseStrings(p); break;
+           case RIL_REQUEST_SCREEN_STATE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: ret =  responseVoid(p); break;
+           case RIL_REQUEST_WRITE_SMS_TO_SIM: ret =  responseInts(p); break;
+           case RIL_REQUEST_DELETE_SMS_ON_SIM: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: ret =  responseInts(p); break;
+           case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_LOCATION_UPDATES: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_TTY_MODE: ret =  responseVoid(p); break;
+           case RIL_REQUEST_QUERY_TTY_MODE: ret =  responseInts(p); break;
+           case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: ret = responseVoid(p); break;
+           case RIL_REQUEST_VOICE_RADIO_TECH: ret = responseInts(p); break;
+           case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_INITIAL_ATTACH_APN: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_DATA_PROFILE: ret = responseVoid(p); break;
+           case RIL_REQUEST_IMS_REGISTRATION_STATE: ret = responseInts(p); break;
+           /// M: CC010: Add RIL interface @{
+           case RIL_REQUEST_HANGUP_ALL: ret =  responseVoid(p); break;
+           case RIL_REQUEST_FORCE_RELEASE_CALL: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_CALL_INDICATION: ret = responseVoid(p); break;
+           case RIL_REQUEST_EMERGENCY_DIAL: ret =  responseVoid(p); break;
+           case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_ECC_LIST: ret = responseVoid(p); break;
+           /// @}
+           /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+           case RIL_REQUEST_SET_SPEECH_CODEC_INFO: ret = responseVoid(p); break;
+           /// @}
+           /// M: For 3G VT only @{
+           case RIL_REQUEST_VT_DIAL: ret = responseVoid(p); break;
+           case RIL_REQUEST_VOICE_ACCEPT: ret = responseVoid(p); break;
+           case RIL_REQUEST_REPLACE_VT_CALL: ret = responseVoid(p); break;
+           /// @}
+           /// M: IMS feature. @{
+           case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+           case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER: responseString(p); break;
+           case RIL_REQUEST_DIAL_WITH_SIP_URI: ret = responseVoid(p); break;
+           case RIL_REQUEST_RESUME_CALL: ret = responseVoid(p); break;
+           case RIL_REQUEST_HOLD_CALL: ret = responseVoid(p); break;
+           /// @}
+
+           //MTK-START SS
+           case RIL_REQUEST_GET_COLP: ret = responseInts(p); break;
+           case RIL_REQUEST_SET_COLP: ret = responseVoid(p); break;
+           case RIL_REQUEST_GET_COLR: ret = responseInts(p); break;
+           //MTK-END SS
+
+           // IMS
+           case RIL_REQUEST_SET_IMS_ENABLE: ret = responseVoid(p); break;
+           case RIL_REQUEST_SIM_GET_ATR: ret = responseString(p); break;
+           // M: Fast Dormancy
+           case RIL_REQUEST_SET_SCRI: ret = responseVoid(p); break;
+           case RIL_REQUEST_SET_FD_MODE: ret = responseInts(p); break;
+
+           /// M: SVLTE Remove access feature
+           case RIL_REQUEST_CONFIG_MODEM_STATUS: ret = responseVoid(p); break;
+
+           /// M: IMS VoLTE conference dial feature. @{
+           case RIL_REQUEST_CONFERENCE_DIAL: ret =  responseVoid(p); break;
+           /// @}
+           case RIL_REQUEST_RELOAD_MODEM_TYPE: ret =  responseVoid(p); break;
+           /// M: CC010: Add RIL interface @{
+           case RIL_REQUEST_SET_IMS_CALL_STATUS: ret = responseVoid(p); break;
+           /// @}
+
+           /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+           case RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER: ret = responseVoid(p); break;
+           case RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS: ret = responseVoid(p); break;
+           /// @}
+           /// M: IMS ViLTE feature. @{
+           case RIL_REQUEST_VIDEO_CALL_ACCEPT: ret = responseVoid(p); break;
+           /// @}
+           default:
+               throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
+           //break;
+           }} catch (Throwable tr) {
+               // Exceptions here usually mean invalid RIL responses
+
+               Rlog.w(IMS_RILA_LOG_TAG, rr.serialString() + "< "
+                       + requestToString(rr.mRequest)
+                       + " exception, possible invalid RIL response", tr);
+
+               if (rr.mResult != null) {
+                   AsyncResult.forMessage(rr.mResult, null, tr);
+                   rr.mResult.sendToTarget();
+               }
+               return rr;
+           }
+       }
+
+       if (rr.mRequest == RIL_REQUEST_SHUTDOWN) {
+           // Set RADIO_STATE to RADIO_UNAVAILABLE to continue shutdown process
+           // regardless of error code to continue shutdown procedure.
+           riljLog("Response to RIL_REQUEST_SHUTDOWN received. Error is " +
+                   error + " Setting Radio State to Unavailable regardless of error.");
+           setRadioState(RadioState.RADIO_UNAVAILABLE);
+       }
+
+       if (error != 0) {
+           rr.onError(error, ret);
+       } else {
+
+           if (IMS_RILA_LOGD) riljLog(rr.serialString() + "< " + requestToString(rr.mRequest)
+                   + " " + retToString(rr.mRequest, ret));
+
+           if (rr.mResult != null) {
+               AsyncResult.forMessage(rr.mResult, ret, null);
+               rr.mResult.sendToTarget();
+           }
+       }
+       return rr;
+   }
+
+    private RILRequest findAndRemoveRequestFromList(int serial) {
+        RILRequest rr = null;
+        synchronized (mRequestList) {
+            rr = mRequestList.get(serial);
+            if (rr != null) {
+                mRequestList.remove(serial);
+            }
+        }
+
+        return rr;
+    }
+
+    private Object responseVoid(Parcel p) {
+        return null;
+    }
+
+    private Object responseString(Parcel p) {
+        String response;
+
+        response = p.readString();
+
+        return response;
+    }
+
+    private Object responseStrings(Parcel p) {
+        int num;
+        String response[];
+
+        response = p.readStringArray();
+
+        return response;
+    }
+
+    private Object
+    responseRaw(Parcel p) {
+        int num;
+        byte response[];
+
+        response = p.createByteArray();
+
+        return response;
+    }
+
+    private Object responseInts(Parcel p) {
+        int numInts;
+        int response[];
+
+        numInts = p.readInt();
+
+        response = new int[numInts];
+
+        for (int i = 0 ; i < numInts ; i++) {
+            response[i] = p.readInt();
+        }
+
+        return response;
+    }
+
+    private Object
+    responseCallRing(Parcel p){
+        char response[] = new char[4];
+
+        response[0] = (char) p.readInt();    // isPresent
+        response[1] = (char) p.readInt();    // signalType
+        response[2] = (char) p.readInt();    // alertPitch
+        response[3] = (char) p.readInt();    // signal
+
+        return response;
+    }
+
+    private Object
+    responseSuppServiceNotification(Parcel p) {
+        SuppServiceNotification notification = new SuppServiceNotification();
+
+        notification.notificationType = p.readInt();
+        notification.code = p.readInt();
+        notification.index = p.readInt();
+        notification.type = p.readInt();
+        notification.number = p.readString();
+
+        return notification;
+    }
+
+    private Object
+    responseFailCause(Parcel p) {
+        LastCallFailCause failCause = new LastCallFailCause();
+        failCause.causeCode = p.readInt();
+        if (p.dataAvail() > 0) {
+          failCause.vendorCause = p.readString();
+        }
+        return failCause;
+    }
+
+    static String responseToString(int request)
+    {
+        switch(request) {
+            case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_NEW_SMS: return "UNSOL_RESPONSE_NEW_SMS";
+            case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
+            case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
+            case RIL_UNSOL_ON_USSD: return "UNSOL_ON_USSD";
+            case RIL_UNSOL_ON_USSD_REQUEST: return "UNSOL_ON_USSD_REQUEST";
+            case RIL_UNSOL_NITZ_TIME_RECEIVED: return "UNSOL_NITZ_TIME_RECEIVED";
+            case RIL_UNSOL_SIGNAL_STRENGTH: return "UNSOL_SIGNAL_STRENGTH";
+            case RIL_UNSOL_DATA_CALL_LIST_CHANGED: return "UNSOL_DATA_CALL_LIST_CHANGED";
+            case RIL_UNSOL_SUPP_SVC_NOTIFICATION: return "UNSOL_SUPP_SVC_NOTIFICATION";
+            case RIL_UNSOL_STK_SESSION_END: return "UNSOL_STK_SESSION_END";
+            case RIL_UNSOL_STK_PROACTIVE_COMMAND: return "UNSOL_STK_PROACTIVE_COMMAND";
+            case RIL_UNSOL_STK_EVENT_NOTIFY: return "UNSOL_STK_EVENT_NOTIFY";
+            case RIL_UNSOL_STK_CALL_SETUP: return "UNSOL_STK_CALL_SETUP";
+            case RIL_UNSOL_SIM_SMS_STORAGE_FULL: return "UNSOL_SIM_SMS_STORAGE_FULL";
+            case RIL_UNSOL_SIM_REFRESH: return "UNSOL_SIM_REFRESH";
+            case RIL_UNSOL_CALL_RING: return "UNSOL_CALL_RING";
+            case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED: return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
+            case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS: return "UNSOL_RESPONSE_CDMA_NEW_SMS";
+            case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS: return "UNSOL_RESPONSE_NEW_BROADCAST_SMS";
+            case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL: return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
+            case RIL_UNSOL_RESTRICTED_STATE_CHANGED: return "UNSOL_RESTRICTED_STATE_CHANGED";
+            case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
+            case RIL_UNSOL_CDMA_CALL_WAITING: return "UNSOL_CDMA_CALL_WAITING";
+            case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: return "UNSOL_CDMA_OTA_PROVISION_STATUS";
+            case RIL_UNSOL_CDMA_INFO_REC: return "UNSOL_CDMA_INFO_REC";
+            case RIL_UNSOL_OEM_HOOK_RAW: return "UNSOL_OEM_HOOK_RAW";
+            case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONE";
+            case RIL_UNSOL_RESEND_INCALL_MUTE: return "UNSOL_RESEND_INCALL_MUTE";
+            case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: return "CDMA_SUBSCRIPTION_SOURCE_CHANGED";
+            case RIL_UNSOl_CDMA_PRL_CHANGED: return "UNSOL_CDMA_PRL_CHANGED";
+            case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
+            case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED: return "UNSOL_VOICE_RADIO_TECH_CHANGED";
+            case RIL_UNSOL_CELL_INFO_LIST: return "UNSOL_CELL_INFO_LIST";
+            case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED:
+                return "UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED:
+                    return "RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
+            case RIL_UNSOL_SRVCC_STATE_NOTIFY:
+                    return "UNSOL_SRVCC_STATE_NOTIFY";
+            case RIL_UNSOL_SIP_CALL_PROGRESS_INDICATOR:
+                    return "UNSOL_SIP_CALL_PROGRESS_INDICATOR";
+            case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: return "RIL_UNSOL_HARDWARE_CONFIG_CHANGED";
+            /* M: CC part start */
+            case RIL_UNSOL_CALL_FORWARDING: return "UNSOL_CALL_FORWARDING";
+            case RIL_UNSOL_CRSS_NOTIFICATION: return "UNSOL_CRSS_NOTIFICATION";
+            case RIL_UNSOL_INCOMING_CALL_INDICATION: return "UNSOL_INCOMING_CALL_INDICATION";
+            case RIL_UNSOL_CIPHER_INDICATION: return "RIL_UNSOL_CIPHER_INDICATION";
+            case RIL_UNSOL_CNAP: return "RIL_UNSOL_CNAP";
+            case RIL_UNSOL_SPEECH_CODEC_INFO: return "UNSOL_SPEECH_CODEC_INFO";
+            /* M: CC part end */
+            //MTK-START multiple application support
+            case RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED: return "RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED";
+            //MTK-END multiple application support
+            case RIL_UNSOL_SIM_MISSING: return "UNSOL_SIM_MISSING";
+            case RIL_UNSOL_VIRTUAL_SIM_ON: return "UNSOL_VIRTUAL_SIM_ON";
+            case RIL_UNSOL_VIRTUAL_SIM_OFF: return "UNSOL_VIRTUAL_SIM_ON_OFF";
+            case RIL_UNSOL_SIM_RECOVERY: return "UNSOL_SIM_RECOVERY";
+            case RIL_UNSOL_SIM_PLUG_OUT: return "UNSOL_SIM_PLUG_OUT";
+            case RIL_UNSOL_SIM_PLUG_IN: return "UNSOL_SIM_PLUG_IN";
+            case RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED: return "RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED";
+            case RIL_UNSOL_DATA_ALLOWED: return "RIL_UNSOL_DATA_ALLOWED";
+            case RIL_UNSOL_PHB_READY_NOTIFICATION: return "UNSOL_PHB_READY_NOTIFICATION";
+            case RIL_UNSOL_IMEI_LOCK: return "UNSOL_IMEI_LOCK";
+            case RIL_UNSOL_RESPONSE_ACMT: return "UNSOL_ACMT_INFO";
+            case RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED";
+            case RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED: return "UNSOL_RESPONSE_MMRR_STATUS_CHANGED";
+            case RIL_UNSOL_NEIGHBORING_CELL_INFO: return "UNSOL_NEIGHBORING_CELL_INFO";
+            case RIL_UNSOL_NETWORK_INFO: return "UNSOL_NETWORK_INFO";
+            case RIL_UNSOL_IMS_ENABLE_DONE: return "RIL_UNSOL_IMS_ENABLE_DONE";
+            case RIL_UNSOL_IMS_DISABLE_DONE: return "RIL_UNSOL_IMS_DISABLE_DONE";
+            case RIL_UNSOL_IMS_REGISTRATION_INFO: return "RIL_UNSOL_IMS_REGISTRATION_INFO";
+            case RIL_UNSOL_STK_SETUP_MENU_RESET: return "RIL_UNSOL_STK_SETUP_MENU_RESET";
+            case RIL_UNSOL_RESPONSE_PLMN_CHANGED: return "RIL_UNSOL_RESPONSE_PLMN_CHANGED";
+            case RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED: return "RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED";
+            //Remote SIM ME lock related APIs [Start]
+            case RIL_UNSOL_MELOCK_NOTIFICATION: return "RIL_UNSOL_MELOCK_NOTIFICATION";
+            //Remote SIM ME lock related APIs [End]
+            // M: Fast Dormancy
+            case RIL_UNSOL_SCRI_RESULT: return "RIL_UNSOL_SCRI_RESULT";
+            case RIL_UNSOL_STK_EVDL_CALL: return "RIL_UNSOL_STK_EVDL_CALL";
+            case RIL_UNSOL_STK_CALL_CTRL: return "RIL_UNSOL_STK_CALL_CTRL";
+
+            /// M: IMS feature. @{
+            case RIL_UNSOL_ECONF_SRVCC_INDICATION: return "RIL_UNSOL_ECONF_SRVCC_INDICATION";
+            //For updating conference call merged/added result.
+            case RIL_UNSOL_ECONF_RESULT_INDICATION: return "RIL_UNSOL_ECONF_RESULT_INDICATION";
+            //For updating call mode and pau information.
+            case RIL_UNSOL_CALL_INFO_INDICATION : return "RIL_UNSOL_CALL_INFO_INDICATION";
+            /// @}
+
+            case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: return "RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO";
+            case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION: return "RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION";
+            // M: CC33 LTE.
+            case RIL_UNSOL_RAC_UPDATE: return "RIL_UNSOL_RAC_UPDATE";
+            case RIL_UNSOL_REMOVE_RESTRICT_EUTRAN: return "RIL_UNSOL_REMOVE_RESTRICT_EUTRAN";
+
+            //MTK-START for MD state change
+            case RIL_UNSOL_MD_STATE_CHANGE: return "RIL_UNSOL_MD_STATE_CHANGE";
+            //MTK-END for MD state change
+            case RIL_UNSOL_STK_CC_ALPHA_NOTIFY: return "UNSOL_STK_CC_ALPHA_NOTIFY";
+            //IMS
+            case RIL_UNSOL_IMS_ENABLE_START: return "RIL_UNSOL_IMS_ENABLE_START";
+            case RIL_UNSOL_IMS_DISABLE_START: return "RIL_UNSOL_IMS_DISABLE_START";
+            //IMS feature for ViLTE related URC.
+            case RIL_UNSOL_CALLMOD_CHANGE_INDICATOR: return "RIL_UNSOL_CALLMOD_CHANGE_INDICATOR";
+            case RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR:
+                return "RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR";
+            default: return "<unknown response>";
+        }
+    }
+
+    static String requestToString(int request) {
+        switch(request) {
+            case RIL_REQUEST_GET_SIM_STATUS: return "GET_SIM_STATUS";
+            case RIL_REQUEST_ENTER_SIM_PIN: return "ENTER_SIM_PIN";
+            case RIL_REQUEST_ENTER_SIM_PUK: return "ENTER_SIM_PUK";
+            case RIL_REQUEST_ENTER_SIM_PIN2: return "ENTER_SIM_PIN2";
+            case RIL_REQUEST_ENTER_SIM_PUK2: return "ENTER_SIM_PUK2";
+            case RIL_REQUEST_CHANGE_SIM_PIN: return "CHANGE_SIM_PIN";
+            case RIL_REQUEST_CHANGE_SIM_PIN2: return "CHANGE_SIM_PIN2";
+            case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION:
+                return "ENTER_NETWORK_DEPERSONALIZATION";
+            case RIL_REQUEST_GET_CURRENT_CALLS: return "GET_CURRENT_CALLS";
+            case RIL_REQUEST_DIAL: return "DIAL";
+            case RIL_REQUEST_GET_IMSI: return "GET_IMSI";
+            case RIL_REQUEST_HANGUP: return "HANGUP";
+            case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: return "HANGUP_WAITING_OR_BACKGROUND";
+            case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND:
+                return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
+            case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE:
+                return "REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
+            case RIL_REQUEST_CONFERENCE: return "CONFERENCE";
+            case RIL_REQUEST_UDUB: return "UDUB";
+            case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: return "LAST_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_SIGNAL_STRENGTH: return "SIGNAL_STRENGTH";
+            case RIL_REQUEST_VOICE_REGISTRATION_STATE: return "VOICE_REGISTRATION_STATE";
+            case RIL_REQUEST_DATA_REGISTRATION_STATE: return "DATA_REGISTRATION_STATE";
+            case RIL_REQUEST_OPERATOR: return "OPERATOR";
+            case RIL_REQUEST_RADIO_POWER: return "RADIO_POWER";
+            case RIL_REQUEST_DTMF: return "DTMF";
+            case RIL_REQUEST_SEND_SMS: return "SEND_SMS";
+            case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
+            case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
+            case RIL_REQUEST_SIM_IO: return "SIM_IO";
+            case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
+            case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
+            case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
+            case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
+            case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: return "QUERY_CALL_FORWARD_STATUS";
+            case RIL_REQUEST_SET_CALL_FORWARD: return "SET_CALL_FORWARD";
+            case RIL_REQUEST_QUERY_CALL_WAITING: return "QUERY_CALL_WAITING";
+            case RIL_REQUEST_SET_CALL_WAITING: return "SET_CALL_WAITING";
+            case RIL_REQUEST_SMS_ACKNOWLEDGE: return "SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GET_IMEI: return "GET_IMEI";
+            case RIL_REQUEST_GET_IMEISV: return "GET_IMEISV";
+            case RIL_REQUEST_ANSWER: return "ANSWER";
+            case RIL_REQUEST_DEACTIVATE_DATA_CALL: return "DEACTIVATE_DATA_CALL";
+            case RIL_REQUEST_QUERY_FACILITY_LOCK: return "QUERY_FACILITY_LOCK";
+            case RIL_REQUEST_SET_FACILITY_LOCK: return "SET_FACILITY_LOCK";
+            case RIL_REQUEST_CHANGE_BARRING_PASSWORD: return "CHANGE_BARRING_PASSWORD";
+            case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: return "QUERY_NETWORK_SELECTION_MODE";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
+                return "SET_NETWORK_SELECTION_AUTOMATIC";
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
+            case RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS:
+                return "ABORT_QUERY_AVAILABLE_NETWORKS";
+            case RIL_REQUEST_DTMF_START: return "DTMF_START";
+            case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
+            case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
+            case RIL_REQUEST_SEPARATE_CONNECTION: return "SEPARATE_CONNECTION";
+            case RIL_REQUEST_SET_MUTE: return "SET_MUTE";
+            case RIL_REQUEST_GET_MUTE: return "GET_MUTE";
+            case RIL_REQUEST_QUERY_CLIP: return "QUERY_CLIP";
+            case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: return "LAST_DATA_CALL_FAIL_CAUSE";
+            case RIL_REQUEST_DATA_CALL_LIST: return "DATA_CALL_LIST";
+            case RIL_REQUEST_RESET_RADIO: return "RESET_RADIO";
+            case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
+            case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
+            case RIL_REQUEST_SCREEN_STATE: return "SCREEN_STATE";
+            case RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION: return "SET_SUPP_SVC_NOTIFICATION";
+            case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
+            case RIL_REQUEST_DELETE_SMS_ON_SIM: return "DELETE_SMS_ON_SIM";
+            case RIL_REQUEST_SET_BAND_MODE: return "SET_BAND_MODE";
+            case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: return "QUERY_AVAILABLE_BAND_MODE";
+            case RIL_REQUEST_STK_GET_PROFILE: return "REQUEST_STK_GET_PROFILE";
+            case RIL_REQUEST_STK_SET_PROFILE: return "REQUEST_STK_SET_PROFILE";
+            case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: return "REQUEST_STK_SEND_ENVELOPE_COMMAND";
+            case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE:
+                return "REQUEST_STK_SEND_TERMINAL_RESPONSE";
+            case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM:
+                return "REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
+            case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: return "REQUEST_EXPLICIT_CALL_TRANSFER";
+            case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
+                return "REQUEST_SET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
+                return "REQUEST_GET_PREFERRED_NETWORK_TYPE";
+            case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: return "REQUEST_GET_NEIGHBORING_CELL_IDS";
+            case RIL_REQUEST_SET_LOCATION_UPDATES: return "REQUEST_SET_LOCATION_UPDATES";
+            case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:
+                return "RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE";
+            case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
+                return "RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE";
+            case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
+                return "RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE";
+            case RIL_REQUEST_SET_TTY_MODE: return "RIL_REQUEST_SET_TTY_MODE";
+            case RIL_REQUEST_QUERY_TTY_MODE: return "RIL_REQUEST_QUERY_TTY_MODE";
+            case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:
+                return "RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:
+                return "RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
+            case RIL_REQUEST_CDMA_FLASH: return "RIL_REQUEST_CDMA_FLASH";
+            case RIL_REQUEST_CDMA_BURST_DTMF: return "RIL_REQUEST_CDMA_BURST_DTMF";
+            case RIL_REQUEST_CDMA_SEND_SMS: return "RIL_REQUEST_CDMA_SEND_SMS";
+            case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE: return "RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE";
+            case RIL_REQUEST_GSM_GET_BROADCAST_CONFIG:
+                return "RIL_REQUEST_GSM_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_SET_BROADCAST_CONFIG:
+                return "RIL_REQUEST_GSM_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG:
+                return "RIL_REQUEST_CDMA_GET_BROADCAST_CONFIG";
+            case RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG:
+                return "RIL_REQUEST_CDMA_SET_BROADCAST_CONFIG";
+            case RIL_REQUEST_GSM_BROADCAST_ACTIVATION:
+                return "RIL_REQUEST_GSM_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY:
+                return "RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY";
+            case RIL_REQUEST_CDMA_BROADCAST_ACTIVATION:
+                return "RIL_REQUEST_CDMA_BROADCAST_ACTIVATION";
+            case RIL_REQUEST_CDMA_SUBSCRIPTION: return "RIL_REQUEST_CDMA_SUBSCRIPTION";
+            case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: return "RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM";
+            case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: return "RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM";
+            case RIL_REQUEST_DEVICE_IDENTITY: return "RIL_REQUEST_DEVICE_IDENTITY";
+            case RIL_REQUEST_GET_SMSC_ADDRESS: return "RIL_REQUEST_GET_SMSC_ADDRESS";
+            case RIL_REQUEST_SET_SMSC_ADDRESS: return "RIL_REQUEST_SET_SMSC_ADDRESS";
+            case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
+                return "REQUEST_EXIT_EMERGENCY_CALLBACK_MODE";
+            case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS:
+                return "RIL_REQUEST_REPORT_SMS_MEMORY_STATUS";
+            case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING:
+                return "RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING";
+            case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:
+                return "RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE";
+            case RIL_REQUEST_ISIM_AUTHENTICATION: return "RIL_REQUEST_ISIM_AUTHENTICATION";
+            case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU:
+                return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
+            case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS:
+                return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
+            case RIL_REQUEST_VOICE_RADIO_TECH: return "RIL_REQUEST_VOICE_RADIO_TECH";
+            case RIL_REQUEST_GET_CELL_INFO_LIST: return "RIL_REQUEST_GET_CELL_INFO_LIST";
+            case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE:
+                return "RIL_REQUEST_SET_CELL_INFO_LIST_RATE";
+            case RIL_REQUEST_SET_INITIAL_ATTACH_APN: return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
+            case RIL_REQUEST_SET_DATA_PROFILE: return "RIL_REQUEST_SET_DATA_PROFILE";
+            case RIL_REQUEST_IMS_REGISTRATION_STATE: return "RIL_REQUEST_IMS_REGISTRATION_STATE";
+            case RIL_REQUEST_IMS_SEND_SMS: return "RIL_REQUEST_IMS_SEND_SMS";
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: return "RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL: return "RIL_REQUEST_SIM_OPEN_CHANNEL";
+            case RIL_REQUEST_SIM_CLOSE_CHANNEL: return "RIL_REQUEST_SIM_CLOSE_CHANNEL";
+            case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
+                return "RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL";
+            case RIL_REQUEST_NV_READ_ITEM: return "RIL_REQUEST_NV_READ_ITEM";
+            case RIL_REQUEST_NV_WRITE_ITEM: return "RIL_REQUEST_NV_WRITE_ITEM";
+            case RIL_REQUEST_NV_WRITE_CDMA_PRL: return "RIL_REQUEST_NV_WRITE_CDMA_PRL";
+            case RIL_REQUEST_NV_RESET_CONFIG: return "RIL_REQUEST_NV_RESET_CONFIG";
+            case RIL_REQUEST_SET_UICC_SUBSCRIPTION: return "RIL_REQUEST_SET_UICC_SUBSCRIPTION";
+            case RIL_REQUEST_ALLOW_DATA: return "RIL_REQUEST_ALLOW_DATA";
+            case RIL_REQUEST_GET_HARDWARE_CONFIG: return "GET_HARDWARE_CONFIG";
+            case RIL_REQUEST_SIM_AUTHENTICATION: return "RIL_REQUEST_SIM_AUTHENTICATION";
+            case RIL_REQUEST_SHUTDOWN: return "RIL_REQUEST_SHUTDOWN";
+            case RIL_REQUEST_SET_RADIO_CAPABILITY:
+                    return "RIL_REQUEST_SET_RADIO_CAPABILITY";
+            case RIL_REQUEST_GET_RADIO_CAPABILITY:
+                    return "RIL_REQUEST_GET_RADIO_CAPABILITY";
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_HANGUP_ALL: return "HANGUP_ALL";
+            case RIL_REQUEST_FORCE_RELEASE_CALL: return "FORCE_RELEASE_CALL";
+            case RIL_REQUEST_SET_CALL_INDICATION: return "SET_CALL_INDICATION";
+            case RIL_REQUEST_EMERGENCY_DIAL: return "EMERGENCY_DIAL";
+            case RIL_REQUEST_SET_ECC_SERVICE_CATEGORY: return "SET_ECC_SERVICE_CATEGORY";
+            case RIL_REQUEST_SET_ECC_LIST: return "SET_ECC_LIST";
+            /// @}
+            /// M: CC077: 2/3G CAPABILITY_HIGH_DEF_AUDIO @{
+            case RIL_REQUEST_SET_SPEECH_CODEC_INFO: return "SET_SPEECH_CODEC_INFO";
+            /// @}
+            /// M: For 3G VT only @{
+            case RIL_REQUEST_VT_DIAL: return "RIL_REQUEST_VT_DIAL";
+            case RIL_REQUEST_VOICE_ACCEPT: return "VOICE_ACCEPT";
+            case RIL_REQUEST_REPLACE_VT_CALL: return "RIL_REQUEST_REPLACE_VT_CALL";
+            /// @}
+
+            /// M: IMS feature. @{
+            case RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER:
+                return "RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER:
+                return "RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER";
+            case RIL_REQUEST_DIAL_WITH_SIP_URI: return "RIL_REQUEST_DIAL_WITH_SIP_URI";
+            case RIL_REQUEST_RESUME_CALL: return "RIL_REQUEST_RESUNME_CALL";
+            case RIL_REQUEST_HOLD_CALL: return "RIL_REQUEST_HOLD_CALL";
+            /// @}
+
+            //MTK-START SS
+            case RIL_REQUEST_GET_COLP: return "GET_COLP";
+            case RIL_REQUEST_SET_COLP: return "SET_COLP";
+            case RIL_REQUEST_GET_COLR: return "GET_COLR";
+            //MTK-END SS
+
+            //MTK-START SIM ME lock
+            case RIL_REQUEST_QUERY_SIM_NETWORK_LOCK: return "QUERY_SIM_NETWORK_LOCK";
+            case RIL_REQUEST_SET_SIM_NETWORK_LOCK: return "SET_SIM_NETWORK_LOCK";
+            //MTK-END SIM ME lock
+            //ISIM
+            case RIL_REQUEST_GENERAL_SIM_AUTH: return "RIL_REQUEST_GENERAL_SIM_AUTH";
+            case RIL_REQUEST_OPEN_ICC_APPLICATION: return "RIL_REQUEST_OPEN_ICC_APPLICATION";
+            case RIL_REQUEST_GET_ICC_APPLICATION_STATUS:
+                return "RIL_REQUEST_GET_ICC_APPLICATION_STATUS";
+            case RIL_REQUEST_SIM_IO_EX: return "SIM_IO_EX";
+
+            // PHB Start
+            case RIL_REQUEST_QUERY_PHB_STORAGE_INFO: return "RIL_REQUEST_QUERY_PHB_STORAGE_INFO";
+            case RIL_REQUEST_WRITE_PHB_ENTRY: return "RIL_REQUEST_WRITE_PHB_ENTRY";
+            case RIL_REQUEST_READ_PHB_ENTRY: return "RIL_REQUEST_READ_PHB_ENTRY";
+            case RIL_REQUEST_QUERY_UPB_CAPABILITY: return "RIL_REQUEST_QUERY_UPB_CAPABILITY";
+            case RIL_REQUEST_EDIT_UPB_ENTRY: return "RIL_REQUEST_EDIT_UPB_ENTRY";
+            case RIL_REQUEST_DELETE_UPB_ENTRY: return "RIL_REQUEST_DELETE_UPB_ENTRY";
+            case RIL_REQUEST_READ_UPB_GAS_LIST: return "RIL_REQUEST_READ_UPB_GAS_LIST";
+            case RIL_REQUEST_READ_UPB_GRP: return "RIL_REQUEST_READ_UPB_GRP";
+            case RIL_REQUEST_WRITE_UPB_GRP: return "RIL_REQUEST_WRITE_UPB_GRP";
+            case RIL_REQUEST_GET_PHB_STRING_LENGTH: return "RIL_REQUEST_GET_PHB_STRING_LENGTH";
+            case RIL_REQUEST_GET_PHB_MEM_STORAGE: return "RIL_REQUEST_GET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_SET_PHB_MEM_STORAGE: return "RIL_REQUEST_SET_PHB_MEM_STORAGE";
+            case RIL_REQUEST_READ_PHB_ENTRY_EXT: return "RIL_REQUEST_READ_PHB_ENTRY_EXT";
+            case RIL_REQUEST_WRITE_PHB_ENTRY_EXT: return "RIL_REQUEST_WRITE_PHB_ENTRY_EXT";
+            // PHB End
+
+            /* M: network part start */
+            case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT:
+                return "SET_NETWORK_SELECTION_MANUAL_WITH_ACT";
+            case RIL_REQUEST_GET_POL_CAPABILITY: return "RIL_REQUEST_GET_POL_CAPABILITY";
+            case RIL_REQUEST_GET_POL_LIST: return "RIL_REQUEST_GET_POL_LIST";
+            case RIL_REQUEST_SET_POL_ENTRY: return "RIL_REQUEST_SET_POL_ENTRY";
+            case RIL_REQUEST_SET_TRM: return "RIL_REQUEST_SET_TRM";
+            case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT:
+                return "QUERY_AVAILABLE_NETWORKS_WITH_ACT";
+            //Femtocell (CSG) feature START
+            case RIL_REQUEST_GET_FEMTOCELL_LIST: return "RIL_REQUEST_GET_FEMTOCELL_LIST";
+            case RIL_REQUEST_ABORT_FEMTOCELL_LIST: return "RIL_REQUEST_ABORT_FEMTOCELL_LIST";
+            case RIL_REQUEST_SELECT_FEMTOCELL: return "RIL_REQUEST_SELECT_FEMTOCELL";
+            //Femtocell (CSG) feature END
+            /* M: network part end */
+            case RIL_REQUEST_STK_EVDL_CALL_BY_AP: return "RIL_REQUEST_STK_EVDL_CALL_BY_AP";
+            case RIL_REQUEST_QUERY_MODEM_TYPE: return "RIL_REQUEST_QUERY_MODEM_TYPE";
+            case RIL_REQUEST_STORE_MODEM_TYPE: return "RIL_REQUEST_STORE_MODEM_TYPE";
+            case RIL_REQUEST_SIM_GET_ATR: return "SIM_GET_ATR";
+            case RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW: return "SIM_OPEN_CHANNEL_WITH_SW";
+
+            // IMS
+            case RIL_REQUEST_SET_IMS_ENABLE: return "RIL_REQUEST_SET_IMS_ENABLE";
+
+            // M: Fast Dormancy
+            case RIL_REQUEST_SET_SCRI: return "RIL_REQUEST_SET_SCRI";
+            case RIL_REQUEST_SET_FD_MODE: return "RIL_REQUEST_SET_FD_MODE";
+            // MTK-START, SMS part
+            case RIL_REQUEST_GET_SMS_PARAMS: return "RIL_REQUEST_GET_SMS_PARAMS";
+            case RIL_REQUEST_SET_SMS_PARAMS: return "RIL_REQUEST_SET_SMS_PARAMS";
+            case RIL_REQUEST_GET_SMS_SIM_MEM_STATUS: return "RIL_REQUEST_GET_SMS_SIM_MEM_STATUS";
+            case RIL_REQUEST_SET_ETWS: return "RIL_REQUEST_SET_ETWS";
+            case RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO";
+            case RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO:
+                return "RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO";
+            case RIL_REQUEST_GET_CB_CONFIG_INFO: return "RIL_REQUEST_GET_CB_CONFIG_INFO";
+            case RIL_REQUEST_REMOVE_CB_MESSAGE: return "RIL_REQUEST_REMOVE_CB_MESSAGE";
+            // MTK-END, SMS part
+            case RIL_REQUEST_SET_DATA_CENTRIC: return "RIL_REQUEST_SET_DATA_CENTRIC";
+
+            case RIL_REQUEST_MODEM_POWEROFF: return "MODEM_POWEROFF";
+            case RIL_REQUEST_MODEM_POWERON: return "MODEM_POWERON";
+            // M: CC33 LTE.
+            case RIL_REQUEST_SET_DATA_ON_TO_MD: return "RIL_REQUEST_SET_DATA_ON_TO_MD";
+            case RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE:
+                return "RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE";
+            case RIL_REQUEST_BTSIM_CONNECT: return "RIL_REQUEST_BTSIM_CONNECT";
+            case RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF:
+                return "RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF";
+            case RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM:
+                return "RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM";
+            case RIL_REQUEST_BTSIM_TRANSFERAPDU: return "RIL_REQUEST_SEND_BTSIM_TRANSFERAPDU";
+
+            /// M: IMS VoLTE conference dial feature. @{
+            case RIL_REQUEST_CONFERENCE_DIAL: return "RIL_REQUEST_CONFERENCE_DIAL";
+            /// @}
+            case RIL_REQUEST_RELOAD_MODEM_TYPE: return "RIL_REQUEST_RELOAD_MODEM_TYPE";
+            /// M: CC010: Add RIL interface @{
+            case RIL_REQUEST_SET_IMS_CALL_STATUS: return "RIL_REQUEST_SET_IMS_CALL_STATUS";
+            /// @}
+
+            /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+            case RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER:
+                return "RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER";
+            case RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS:
+                return "RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS";
+            /// @}
+
+            /// M: SVLTE remote SIM access feature
+            case RIL_REQUEST_CONFIG_MODEM_STATUS: return "RIL_REQUEST_CONFIG_MODEM_STATUS";
+            /* M: C2K part start */
+            case RIL_REQUEST_GET_NITZ_TIME: return "RIL_REQUEST_GET_NITZ_TIME";
+            case RIL_REQUEST_QUERY_UIM_INSERTED: return "RIL_REQUEST_QUERY_UIM_INSERTED";
+            case RIL_REQUEST_SWITCH_HPF: return "RIL_REQUEST_SWITCH_HPF";
+            case RIL_REQUEST_SET_AVOID_SYS: return "RIL_REQUEST_SET_AVOID_SYS";
+            case RIL_REQUEST_QUERY_AVOID_SYS: return "RIL_REQUEST_QUERY_AVOID_SYS";
+            case RIL_REQUEST_QUERY_CDMA_NETWORK_INFO: return "RIL_REQUEST_QUERY_CDMA_NETWORK_INFO";
+            case RIL_REQUEST_GET_LOCAL_INFO: return "RIL_REQUEST_GET_LOCAL_INFO";
+            case RIL_REQUEST_UTK_REFRESH: return "RIL_REQUEST_UTK_REFRESH";
+            case RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS:
+                return "RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS";
+            case RIL_REQUEST_QUERY_NETWORK_REGISTRATION:
+                return "RIL_REQUEST_QUERY_NETWORK_REGISTRATION";
+            case RIL_REQUEST_AGPS_TCP_CONNIND: return "RIL_REQUEST_AGPS_TCP_CONNIND";
+            case RIL_REQUEST_AGPS_SET_MPC_IPPORT: return "RIL_REQUEST_AGPS_SET_MPC_IPPORT";
+            case RIL_REQUEST_AGPS_GET_MPC_IPPORT: return "RIL_REQUEST_AGPS_GET_MPC_IPPORT";
+            case RIL_REQUEST_SET_MEID: return "RIL_REQUEST_SET_MEID";
+            case RIL_REQUEST_SET_ETS_DEV: return "RIL_REQUEST_SET_ETS_DEV";
+            case RIL_REQUEST_WRITE_MDN: return "RIL_REQUEST_WRITE_MDN";
+            case RIL_REQUEST_SET_VIA_TRM: return "RIL_REQUEST_SET_VIA_TRM";
+            case RIL_REQUEST_SET_ARSI_THRESHOLD: return "RIL_REQUEST_SET_ARSI_THRESHOLD";
+            case RIL_REQUEST_QUERY_UTK_MENU_FROM_MD: return "RIL_REQUEST_QUERY_UTK_MENU_FROM_MD";
+            case RIL_REQUEST_QUERY_STK_MENU_FROM_MD: return "RIL_REQUEST_QUERY_STK_MENU_FROM_MD";
+            /* M: C2K part end */
+            // M: [C2K][MD IRAT]RIL
+            case RIL_REQUEST_SET_ACTIVE_PS_SLOT: return "RIL_REQUEST_SET_ACTIVE_PS_SLOT";
+            case RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE:
+                return "RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE";
+            case RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN:
+                return "RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN";
+            /// @}
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+            case RIL_REQUEST_SET_SVLTE_RAT_MODE: return "RIL_REQUEST_SET_SVLTE_RAT_MODE";
+            /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+            /// M: [C2K][IR] Support SVLTE IR feature. @{
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED: return "RIL_REQUEST_SET_REG_SUSPEND_ENABLED";
+            case RIL_REQUEST_RESUME_REGISTRATION: return "RIL_REQUEST_RESUME_REGISTRATION";
+            case RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA:
+                return "RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA";
+            case RIL_REQUEST_RESUME_REGISTRATION_CDMA:
+                return "RIL_REQUEST_RESUME_REGISTRATION_CDMA";
+            case RIL_REQUEST_CONFIG_EVDO_MODE:
+                return "RIL_REQUEST_CONFIG_EVDO_MODE";
+            /// M: [C2K][IR] Support SVLTE IR feature. @}
+
+            case RIL_REQUEST_SET_STK_UTK_MODE:
+                return "RIL_REQUEST_SET_STK_UTK_MODE";
+
+            // M: Notify RILJ that call fade happened
+            case RIL_UNSOL_CDMA_SIGNAL_FADE:
+                return "RIL_UNSOL_CDMA_SIGNAL_FADE";
+            // M: Notify RILJ that the AT+EFNM was received
+            case RIL_UNSOL_CDMA_TONE_SIGNALS:
+                return "RIL_UNSOL_CDMA_TONE_SIGNALS";
+
+            case RIL_REQUEST_SWITCH_ANTENNA: return "RIL_REQUEST_SWITCH_ANTENNA";
+            /// M: IMS ViLTE feature. @{
+            case RIL_REQUEST_VIDEO_CALL_ACCEPT: return "RIL_REQUEST_VIDEO_CALL_ACCEPT";
+            /// @}
+            default: return "<unknown request>";
+        }
+
+    }
+
+    static String retToString(int req, Object ret) {
+        if (ret == null) return "";
+
+        StringBuilder sb;
+        String s;
+        int length;
+        if (ret instanceof int[]) {
+            int[] intArray = (int[]) ret;
+            length = intArray.length;
+            sb = new StringBuilder("{");
+            if (length > 0) {
+                int i = 0;
+                sb.append(intArray[i++]);
+                while (i < length) {
+                    sb.append(", ").append(intArray[i++]);
+                }
+            }
+            sb.append("}");
+            s = sb.toString();
+        } else if (ret instanceof String[]) {
+            String[] strings = (String[]) ret;
+            length = strings.length;
+            sb = new StringBuilder("{");
+            if (length > 0) {
+                int i = 0;
+                sb.append(strings[i++]);
+                while (i < length) {
+                    sb.append(", ").append(strings[i++]);
+                }
+            }
+            sb.append("}");
+            s = sb.toString();
+        } else {
+            s = ret.toString();
+        }
+        return s;
+    }
+
+    private void riljLog(String msg) {
+        Rlog.d(IMS_RILA_LOG_TAG, msg
+                + "");
+    }
+
+    private void riljLogv(String msg) {
+        Rlog.v(IMS_RILA_LOG_TAG, msg
+                + "");
+    }
+
+    private void unsljLog(int response) {
+        riljLog("[UNSL]< " + responseToString(response));
+    }
+
+    private void unsljLogMore(int response, String more) {
+        riljLog("[UNSL]< " + responseToString(response) + " " + more);
+    }
+
+    private void unsljLogRet(int response, Object ret) {
+        riljLog("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
+    }
+
+    private void unsljLogvRet(int response, Object ret) {
+        riljLogv("[UNSL]< " + responseToString(response) + " " + retToString(response, ret));
+    }
+
+    private void processUnsolicited(Parcel p) {
+        Rlog.i(IMS_RILA_LOG_TAG, " IMS processUnsolicited !!");
+                int response;
+                Object ret;
+                response = p.readInt();
+                try { switch(response) {
+                    case RIL_UNSOL_CALL_INFO_INDICATION : ret = responseStrings(p); break;
+                    case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: ret =  responseVoid(p); break;
+                    case RIL_UNSOL_IMS_REGISTRATION_INFO: ret = responseInts(p); break;
+                    case RIL_UNSOL_INCOMING_CALL_INDICATION: ret = responseStrings(p); break;
+                    case RIL_UNSOL_RINGBACK_TONE: ret = responseInts(p); break;
+                    case RIL_UNSOL_CIPHER_INDICATION: ret = responseStrings(p); break;
+                    case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT: ret = responseInts(p); break;
+                    case RIL_UNSOL_ECONF_SRVCC_INDICATION: ret = responseInts(p); break;
+                    case RIL_UNSOL_ECONF_RESULT_INDICATION: ret = responseStrings(p); break;
+                    case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO: ret = responseInts(p); break;
+                    case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:ret = responseInts(p); break;
+                    case RIL_UNSOL_SPEECH_CODEC_INFO: ret =  responseInts(p); break;
+                    case RIL_UNSOL_CALL_RING: ret =  responseCallRing(p); break;
+                    case RIL_UNSOL_SUPP_SVC_NOTIFICATION: ret = responseSuppServiceNotification(p); break;
+                    case RIL_UNSOL_SRVCC_STATE_NOTIFY: ret = responseInts(p); break;
+                    case RIL_UNSOL_SIP_CALL_PROGRESS_INDICATOR: ret = responseInts(p); break;
+                    // IMS
+                    case RIL_UNSOL_IMS_ENABLE_DONE: ret = responseVoid(p); break;
+                    case RIL_UNSOL_IMS_DISABLE_DONE: ret = responseVoid(p); break;
+                    case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: ret =  responseVoid(p); break;
+                    // IMS
+                    case RIL_UNSOL_IMS_ENABLE_START: ret = responseVoid(p); break;
+                    case RIL_UNSOL_IMS_DISABLE_START: ret = responseVoid(p); break;
+                    // For ViLTE related URC.
+                    case RIL_UNSOL_CALLMOD_CHANGE_INDICATOR: ret = responseStrings(p); break;
+                    case RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR: ret = responseStrings(p); break;
+                    default:
+                        throw new RuntimeException("Unrecognized unsol response: " + response);
+                    //break; (implied)
+                } } catch (Throwable tr) {
+                    Rlog.e(IMS_RILA_LOG_TAG, "Exception processing unsol response: " + response +
+                        "Exception:" + tr.toString());
+                    return;
+                }
+
+                switch(response) {
+                    case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
+                        /* has bonus radio state int */
+                        RadioState newState = getRadioStateFromInt(p.readInt());
+                        if (IMS_RILA_LOGD) unsljLogMore(response, newState.toString());
+
+                        switchToRadioState(newState);
+                    break;
+                    //For updating call mode and pau information.
+                    case RIL_UNSOL_CALL_INFO_INDICATION:
+                        if (ret == null) {
+                            break;
+                        }
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mCallInfoRegistrants != null) {
+                            mCallInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+
+                        String[] callInfo = (String[]) ret;
+
+                        if (callInfo[0] == null || callInfo[1] == null) {
+                            riljLog("RIL_UNSOL_CALL_INFO_INDICATION something wrong");
+                            break;
+                        }
+
+                        int msgType = Integer.parseInt(callInfo[1]);
+                        int callId = Integer.parseInt(callInfo[0]);
+                        int callMode = INVALID_CALL_MODE;
+                        boolean isConferenceCall = false;
+                        if ((callInfo[5] != null) && (!callInfo[5].equals(""))) {
+                            callMode = Integer.parseInt(callInfo[5]);
+                        }
+
+                        if (callMode == IMS_VOICE_CONF ||
+                                callMode == IMS_VIDEO_CONF ||
+                                callMode == IMS_VOICE_CONF_PARTS ||
+                                callMode == IMS_VIDEO_CONF_PARTS) {
+                            isConferenceCall = true;
+                        }
+
+                        ImsCallInfo imsCallInfo;
+                        switch(msgType) {
+                            case 0:   //record callstring to mCallConnections for MT case.
+                                {
+                                    ImsCallInfo.State state = ImsCallInfo.State.INCOMING;
+                                    mCallConnections.put(callInfo[0],
+                                            new ImsCallInfo(callInfo[0], callInfo[6],
+                                                    isConferenceCall, state));
+                                    break;
+                                }
+                            case 130:   //record callstring to mCallConnections for MO case.
+                                {
+                                    ImsCallInfo.State state = ImsCallInfo.State.ALERTING;
+                                    mCallConnections.put(callInfo[0],
+                                            new ImsCallInfo(callInfo[0], callInfo[6],
+                                                    isConferenceCall, state));
+                                    break;
+                                }
+                            case 2:   //record callstring to mCallConnections for MO case.
+                                {
+                                    imsCallInfo = mCallConnections.get(callInfo[0]);
+                                    imsCallInfo.mIsConference = isConferenceCall;
+                                    mCallConnections.put(callInfo[0], imsCallInfo);
+                                    break;
+                                }
+                            case 131:
+                                {
+                                    imsCallInfo = mCallConnections.get(callInfo[0]);
+                                    imsCallInfo.mState = ImsCallInfo.State.HOLDING;
+                                    imsCallInfo.mIsConference = isConferenceCall;
+                                    mCallConnections.put(callInfo[0], imsCallInfo);
+                                    break;
+                                }
+                            case 132:
+                                {
+                                    imsCallInfo = mCallConnections.get(callInfo[0]);
+                                    imsCallInfo.mState = ImsCallInfo.State.ACTIVE;
+                                    imsCallInfo.mIsConference = isConferenceCall;
+                                    mCallConnections.put(callInfo[0], imsCallInfo);
+                                    break;
+                                }
+                            case 133: //clear callstring  when call is disconnected.
+                                mCallConnections.remove(callInfo[0]);
+                                break;
+                            default:
+                                break;
+                        }
+                        break;
+                    case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mCallStateRegistrants != null) {
+                            mCallStateRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, null, null));
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_REGISTRATION_INFO:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mImsRegistrationInfoRegistrants != null) {
+                            mImsRegistrationInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_INCOMING_CALL_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+                        if (mIncomingCallIndicationRegistrant != null) {
+                            mIncomingCallIndicationRegistrant.notifyRegistrant(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_RINGBACK_TONE:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+                        if (mRingbackToneRegistrants != null) {
+                            boolean playtone = (((int[]) ret)[0] == 1);
+                            mRingbackToneRegistrants.notifyRegistrants(
+                                                new AsyncResult(null, playtone, null));
+                        }
+                        break;
+                    case RIL_UNSOL_CIPHER_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+
+                        int simCipherStatus = Integer.parseInt(((String[]) ret)[0]);
+                        int sessionStatus = Integer.parseInt(((String[]) ret)[1]);
+                        int csStatus = Integer.parseInt(((String[]) ret)[2]);
+                        int psStatus = Integer.parseInt(((String[]) ret)[3]);
+
+                        riljLog("RIL_UNSOL_CIPHER_INDICATION :" + simCipherStatus + " " + sessionStatus + " " + csStatus + " " + psStatus);
+
+                        int[] cipherResult = new int[3];
+
+                        cipherResult[0] = simCipherStatus;
+                        cipherResult[1] = csStatus;
+                        cipherResult[2] = psStatus;
+
+                        if (mCipherIndicationRegistrant != null) {
+                            mCipherIndicationRegistrant.notifyRegistrants(
+                                new AsyncResult(null, cipherResult, null));
+                        }
+                        break;
+                    case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+                        if (mEpsNetworkFeatureSupportRegistrants != null) {
+                            mEpsNetworkFeatureSupportRegistrants.notifyRegistrants(
+                                                new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    /// M: IMS feature. @{
+                    //For updating call ids for conference call after SRVCC is done.
+                    case RIL_UNSOL_ECONF_SRVCC_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mEconfSrvccRegistrants != null) {
+                            mEconfSrvccRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+
+                    //For updating conference call merged/added result.
+                    case RIL_UNSOL_ECONF_RESULT_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mEconfResultRegistrants != null) {
+                             riljLog("Notify ECONF result");
+                             String[] econfResult = (String[]) ret;
+                             riljLog("ECONF result = " + econfResult[3]);
+                             mEconfResultRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mEpsNetworkFeatureInfoRegistrants != null) {
+                           mEpsNetworkFeatureInfoRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+
+                    case RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mSrvccHandoverInfoIndicationRegistrants != null) {
+                            mSrvccHandoverInfoIndicationRegistrants.notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    /// @}
+                    case RIL_UNSOL_SPEECH_CODEC_INFO:
+                        if (IMS_RILA_LOGD) unsljLogvRet(response, ret);
+
+                        if (mSpeechCodecInfoRegistrant != null) {
+                            mSpeechCodecInfoRegistrant.notifyRegistrant(
+                                new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_CALL_RING:
+                        Rlog.d(IMS_RILA_LOG_TAG, "IMS: receive RIL_UNSOL_CALL_RING");
+                        if (IMS_RILA_LOGD) unsljLogRet(response, ret);
+
+                        if (mRingRegistrant != null) {
+                            mRingRegistrant.notifyRegistrant(
+                                    new AsyncResult (null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_SUPP_SVC_NOTIFICATION:
+                        if (IMS_RILA_LOGD) unsljLogRet(response, ret);
+                        if (mSsnRegistrant != null) {
+                            mSsnRegistrant.notifyRegistrant(
+                                                new AsyncResult (null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_SRVCC_STATE_NOTIFY:
+                        if (IMS_RILA_LOGD) unsljLogRet(response, ret);
+                        if (mSrvccStateRegistrants != null) {
+                            mSrvccStateRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_SIP_CALL_PROGRESS_INDICATOR:
+                        if (IMS_RILA_LOGD) unsljLogRet(response, ret);
+                        if (mCallProgressIndicatorRegistrants != null) {
+                            mCallProgressIndicatorRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_ENABLE_DONE:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mImsEnableDoneRegistrants != null) {
+                            mImsEnableDoneRegistrants.notifyRegistrants();
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_DISABLE_DONE:
+                        if (IMS_RILA_LOGD) unsljLog(response);
+                        if (mImsDisableDoneRegistrants != null) {
+                            mImsDisableDoneRegistrants.notifyRegistrants();
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_ENABLE_START:
+                        if (IMS_RILA_LOGD) {
+                            unsljLog(response);
+                        }
+                        if (mImsEnableStartRegistrants != null) {
+                            mImsEnableStartRegistrants.notifyRegistrants();
+                        }
+                        break;
+                    case RIL_UNSOL_IMS_DISABLE_START:
+                        if (IMS_RILA_LOGD) {
+                            unsljLog(response);
+                        }
+                        if (mImsDisableStartRegistrants != null) {
+                            mImsDisableStartRegistrants.notifyRegistrants();
+                        }
+                        break;
+                    case RIL_UNSOL_CALLMOD_CHANGE_INDICATOR:
+                        if (IMS_RILA_LOGD) {
+                            unsljLogRet(response, ret);
+                        }
+                        if (mCallModeChangeIndicatorRegistrants != null) {
+                            mCallModeChangeIndicatorRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    case RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR:
+                        if (IMS_RILA_LOGD) {
+                            unsljLogRet(response, ret);
+                        }
+                        if (mVideoCapabilityIndicatorRegistrants != null) {
+                            mVideoCapabilityIndicatorRegistrants
+                                    .notifyRegistrants(new AsyncResult(null, ret, null));
+                        }
+                        break;
+                    default:
+                        break;
+                }
+
+    }
+
+    private synchronized String executeCommandResponse(String atCmdLine) {
+        String atCmdResult = "";
+        String cmd[] = new String[2];
+        cmd[0] = atCmdLine;
+        cmd[1] = "";
+
+        Rlog.d(IMS_RILA_LOG_TAG, "IMS: invokeOemRilRequestRaw() ");
+
+        try {
+            invokeOemRilRequestStrings(cmd,
+                mHandler.obtainMessage(EVENT_AT_CMD_DONE));
+        } catch (NullPointerException ex) {
+            ex.printStackTrace();
+        }
+        return atCmdResult;
+    }
+
+    private void handleAtCmdResponseAndDial(AsyncResult ar) {
+        // Receive OEM Hook Raw response, then dial
+        if (mMoCall == null && mConferenceCallDialInfo == null) {
+            Rlog.e(IMS_RILA_LOG_TAG, "IMS: mMoCall is null when calling");
+            return;
+        }
+
+
+        if (mConferenceCallDialInfo != null) {
+            conferenceDial(mConferenceCallDialInfo.mParticipants,
+                    mConferenceCallDialInfo.mClirMode,
+                    mConferenceCallDialInfo.mIsVideoCall,
+                    mConferenceCallDialInfo.mResult);
+        } else {
+            if (mMoCall.mIsVideoCall) {
+                vtDial(mMoCall.mCallee, mMoCall.mClirMode, null, mMoCall.mResult);
+            } else {
+                if (mMoCall.mIsEmergency) {
+                    int serviceCategory =
+                        PhoneNumberUtils.getServiceCategoryFromEcc(mMoCall.mCallee);
+                    setEccServiceCategory(serviceCategory);
+                    emergencyDial(mMoCall.mCallee, mMoCall.mClirMode,
+                        null, mMoCall.mResult);
+                } else {
+                    dial(mMoCall.mCallee, mMoCall.mClirMode, mMoCall.mResult);
+                }
+            }
+        }
+
+        // Clear MOCall or ConferenceCall information
+        mMoCall = null;
+        mConferenceCallDialInfo = null;
+    }
+
+    /// M: CC053: MoMS [Mobile Managerment] @{
+    // 3. Permission Control for Conference call
+    /**
+    * To check sub-permission for MoMS before using API.
+    *
+    * @param subPermission  The permission to be checked.
+    *
+    * @return Return true if the permission is granted else return false.
+    */
+    private boolean checkMoMSSubPermission(String subPermission) {
+
+        Rlog.d(IMS_RILA_LOG_TAG, "checkMoMSSubPermission(\"" + subPermission + "\"): no-op!");
+        /*
+        try {
+            IMobileManagerService mMobileManager;
+            IBinder binder = ServiceManager.getService(Context.MOBILE_SERVICE);
+            mMobileManager = IMobileManagerService.Stub.asInterface(binder);
+            int result = mMobileManager.checkPermission(subPermission, Binder.getCallingUid());
+            if (result != PackageManager.PERMISSION_GRANTED) {
+                riljLog("[Error]Subpermission is not granted!!");
+                return false;
+            }
+        } catch (Exception e) {
+            riljLog("[Error]Failed to chcek permission: " +  subPermission);
+            return false;
+        }
+        */
+
+        return true;
+    }
+    /// @}
+
+    /// M: CC012: DTMF request special handling @{
+    /*
+     * to protect modem status we need to avoid two case :
+     * 1. DTMF start -> CHLD request -> DTMF stop
+     * 2. CHLD request -> DTMF request
+     */
+    private void handleChldRelatedRequest(RILRequest rr) {
+        synchronized (mDtmfReqQueue) {
+            int queueSize = mDtmfReqQueue.size();
+            int i, j;
+            if (queueSize > 0) {
+                RILRequest rr2 = mDtmfReqQueue.get();
+                if (rr2.mRequest == RIL_REQUEST_DTMF_START) {
+                    // need to send the STOP command
+                    if (IMS_RILA_LOGD) {
+                        riljLog("DTMF queue isn't 0, send stop dtmf and pending switch");
+                    }
+                    if (queueSize > 1) {
+                        j = 2;
+                    } else {
+                        // need to create a new STOP command
+                        j = 1;
+                    }
+                    if (IMS_RILA_LOGD) riljLog("queue size  " + mDtmfReqQueue.size());
+
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                    if (IMS_RILA_LOGD) {
+                        riljLog("queue size  after " + mDtmfReqQueue.size());
+                    }
+                    if (mDtmfReqQueue.size() == 1) {
+                        // only start command, we need to add stop command
+                        RILRequest rr3 = RILRequest.obtain(RIL_REQUEST_DTMF_STOP, null);
+                        if (IMS_RILA_LOGD) riljLog("add dummy stop dtmf request");
+                        mDtmfReqQueue.stop();
+                        mDtmfReqQueue.add(rr3);
+                    }
+                }
+                else {
+                    // first request is STOP, just remove it and send switch
+                    if (IMS_RILA_LOGD) {
+                        riljLog("DTMF queue isn't 0, first request is STOP, penging switch");
+                    }
+                    j = 1;
+                    for (i = queueSize - 1; i >= j; i--) {
+                        mDtmfReqQueue.remove(i);
+                    }
+                }
+                mDtmfReqQueue.setPendingRequest(rr);
+            } else {
+                if (IMS_RILA_LOGD) riljLog("DTMF queue is 0, send switch Immediately");
+                mDtmfReqQueue.setSendChldRequest();
+                send(rr);
+            }
+        }
+    }
+    /// @}
+
+    public void
+    dial (String address, int clirMode, Message result) {
+        dial(address, clirMode, null, result);
+    }
+
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        if (!PhoneNumberUtils.isUriNumber(address)) {
+           RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+
+           rr.mParcel.writeString(address);
+           rr.mParcel.writeInt(clirMode);
+
+           if (uusInfo == null) {
+              rr.mParcel.writeInt(0); // UUS information is absent
+           } else {
+              rr.mParcel.writeInt(1); // UUS information is present
+              rr.mParcel.writeInt(uusInfo.getType());
+              rr.mParcel.writeInt(uusInfo.getDcs());
+              rr.mParcel.writeByteArray(uusInfo.getUserData());
+           }
+
+           if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+           send(rr);
+        } else {
+           RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL_WITH_SIP_URI, result);
+
+           rr.mParcel.writeString(address);
+           if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+           send(rr);
+        }
+    }
+
+    public void
+    emergencyDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_EMERGENCY_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+        rr.mParcel.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    /* M: IMS VoLTE conference dial feature start*/
+    /**
+     * Dial conference call.
+     * @param participants participants' dailing number.
+     * @param clirMode indication to present the dialing number or not.
+     * @param isVideoCall indicate the call is belong to video call or voice call.
+     * @param result the command result.
+     */
+    public void
+    conferenceDial(String[] participants, int clirMode, boolean isVideoCall, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_CONFERENCE_DIAL, result);
+
+        int numberOfParticipants = participants.length;
+        /* numberOfStrings is including
+         * 1. isvideoCall
+         * 2. numberofparticipants
+         * 3. participants numbers
+         * 4. clirmod
+         */
+        int numberOfStrings = 1 + 1 + numberOfParticipants + 1 ;
+        List<String> participantList = Arrays.asList(participants);
+
+        if (IMS_RILA_LOGD) {
+            Rlog.d(IMS_RILA_LOG_TAG, "conferenceDial: numberOfParticipants "
+                    + numberOfParticipants + "numberOfStrings:" + numberOfStrings);
+        }
+
+        rr.mParcel.writeInt(numberOfStrings);
+
+        if (isVideoCall) {
+            rr.mParcel.writeString(Integer.toString(1));
+        } else {
+            rr.mParcel.writeString(Integer.toString(0));
+        }
+
+        rr.mParcel.writeString(Integer.toString(numberOfParticipants));
+
+        for (String dialNumber : participantList) {
+            rr.mParcel.writeString(dialNumber);
+            if (IMS_RILA_LOGD) {
+                Rlog.d(IMS_RILA_LOG_TAG, "conferenceDial: dialnumber " + dialNumber);
+            }
+        }
+        rr.mParcel.writeString(Integer.toString(clirMode));
+        if (IMS_RILA_LOGD) {
+            Rlog.d(IMS_RILA_LOG_TAG, "conferenceDial: clirMode " + clirMode);
+        }
+
+        if (IMS_RILA_LOGD) {
+            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+        }
+
+        send(rr);
+
+    }
+    /* IMS VoLTE conference dial feature end*/
+
+    public void setEccServiceCategory(int serviceCategory) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_SET_ECC_SERVICE_CATEGORY, null);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(serviceCategory);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest)
+            + " " + serviceCategory);
+
+        send(rr);
+    }
+
+    /// M: For 3G VT only @{
+    public void
+    vtDial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_VT_DIAL, result);
+
+        rr.mParcel.writeString(address);
+        rr.mParcel.writeInt(clirMode);
+
+        if (uusInfo == null) {
+            rr.mParcel.writeInt(0); // UUS information is absent
+        } else {
+            rr.mParcel.writeInt(1); // UUS information is present
+            rr.mParcel.writeInt(uusInfo.getType());
+            rr.mParcel.writeInt(uusInfo.getDcs());
+            rr.mParcel.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    acceptVtCallWithVoiceOnly(int callId, Message result) {
+        RILRequest rr = RILRequest.obtain(RIL_REQUEST_VOICE_ACCEPT, result);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " +
+                requestToString(rr.mRequest) + " " + callId);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(callId);
+
+        send(rr);
+    }
+
+    public void replaceVtCall(int index, Message result) {
+        RILRequest rr
+                = RILRequest.obtain(RIL_REQUEST_REPLACE_VT_CALL, result);
+
+        rr.mParcel.writeInt(1);
+        rr.mParcel.writeInt(index);
+
+        if (IMS_RILA_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+    /// @}
+
+    private void switchToRadioState(RadioState newState) {
+        setRadioState(newState);
+    }
+
+    private RadioState getRadioStateFromInt(int stateInt) {
+        RadioState state;
+
+        /* RIL_RadioState ril.h */
+        switch(stateInt) {
+            case 0: state = RadioState.RADIO_OFF; break;
+            case 1: state = RadioState.RADIO_UNAVAILABLE; break;
+            case 10: state = RadioState.RADIO_ON; break;
+
+            default:
+                throw new RuntimeException(
+                            "Unrecognized IMS_RIL_RadioState: " + stateInt);
+        }
+        return state;
+    }
+
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsService.java b/packages/Ims/src/com/mediatek/ims/ImsService.java
new file mode 100644
index 0000000..865c9ee
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsService.java
@@ -0,0 +1,902 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.Uri;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.provider.Settings;
+
+import android.telephony.Rlog;
+import android.telephony.ServiceState;
+
+import com.android.ims.ImsCallProfile;
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsManager;
+import com.android.ims.ImsReasonInfo;
+import com.android.ims.ImsServiceClass;
+import com.android.ims.internal.IImsRegistrationListener;
+import com.android.ims.internal.IImsCallSession;
+import com.android.ims.internal.IImsCallSessionListener;
+import com.android.ims.internal.IImsEcbm;
+import com.android.ims.internal.IImsUt;
+import com.android.ims.internal.IImsConfig;
+import com.android.ims.internal.IImsService;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.TelephonyIntents;
+
+import com.mediatek.ims.ImsAdapter;
+import com.mediatek.ims.ImsConfigStub;
+import com.mediatek.ims.WfcReasonInfo;
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+import com.mediatek.wfo.DisconnectCause;
+import com.mediatek.wfo.IWifiOffloadService;
+import com.mediatek.wfo.WifiOffloadManager;
+
+public class ImsService extends IImsService.Stub {
+    private static final String LOG_TAG = "ImsService";
+    private static final boolean DBG = true;
+    private static final boolean VDBG = false; // STOPSHIP if true
+
+    private ImsAdapter mImsAdapter = null;
+    private ImsRILAdapter  mImsRILAdapter = null;
+    private IImsCallSession mPendingMT = null;
+    private Context mContext;
+
+    private static IWifiOffloadService sWifiOffloadService = null;
+    private IWifiOffloadServiceDeathRecipient mDeathRecipient =
+            new IWifiOffloadServiceDeathRecipient();
+
+    private static ImsConfigStub sImsConfig = null;
+    private static ImsUtStub sImsUtStub = null;
+
+    private final Handler mHandler;
+    private IImsRegistrationListener mListener = null;
+    private int mImsRegInfo = ServiceState.STATE_POWER_OFF;
+    private int mImsExtInfo = 0;
+    private int mServiceId = 0;
+    private int mImsState = PhoneConstants.IMS_STATE_DISABLED;
+    private int mActivePhoneId = 0;
+    private int mRegErrorCode = ImsReasonInfo.CODE_UNSPECIFIED;
+    private int mRAN = WifiOffloadManager.RAN_TYPE_MOBILE_3GPP;
+
+    //***** Event Constants
+    private static final int EVENT_IMS_REGISTRATION_INFO = 1;
+    protected static final int EVENT_RADIO_NOT_AVAILABLE    = 2;
+    protected static final int EVENT_SET_IMS_ENABLED_DONE   = 3;
+    protected static final int EVENT_SET_IMS_DISABLE_DONE   = 4;
+    protected static final int EVENT_IMS_DISABLED_URC   = 5;
+    private static final int EVENT_VIRTUAL_SIM_ON = 6;
+    protected static final int EVENT_INCOMING_CALL_INDICATION = 7;
+    protected static final int EVENT_CALL_INFO_INDICATION = 8;
+    protected static final int EVENT_CALL_RING = 9;
+    protected static final int EVENT_IMS_ENABLING_URC   = 10;
+    protected static final int EVENT_IMS_ENABLED_URC   = 11;
+    protected static final int EVENT_IMS_DISABLING_URC   = 12;
+    ///M : WFC @{
+    protected static final int EVENT_SIP_CODE_INDICATION = 13;
+    /// @}
+
+    private static final int IMS_ALLOW_INCOMING_CALL_INDICATION = 0;
+    private static final int IMS_DISALLOW_INCOMING_CALL_INDICATION = 1;
+
+    //***** IMS Feature Support
+    private static final int IMS_VOICE_OVER_LTE = 1;
+    private static final int IMS_RCS_OVER_LTE = 2;
+    private static final int IMS_SMS_OVER_LTE = 4;
+    private static final int IMS_VIDEO_OVER_LTE = 8;
+    private static final int IMS_VOICE_OVER_WIFI = 16;
+
+    //Refer to ImsConfig FeatureConstants
+    private static final int IMS_MAX_FEATURE_SUPPORT_SIZE = 4;
+
+    ///M : WFC @{
+    private ImsNotificationController mNotificationController = null;
+    /// @}
+
+    /** events id definition */
+    /// M: Simulate IMS Registration @{
+    private boolean mImsRegistry = false;
+    private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            ///M : WFC @{
+            if ("ACTION_IMS_SIMULATE".equals(intent.getAction())){
+            /// @}
+                mImsRegistry = intent.getBooleanExtra("registry", false);
+                Rlog.w(LOG_TAG, "Simulate IMS Registration: " + mImsRegistry);
+                int[] result = new int[] {
+                    (mImsRegistry ? 1 : 0),
+                    15,
+                    mActivePhoneId};
+                AsyncResult ar = new AsyncResult(null, result, null);
+                mHandler.sendMessage(mHandler.obtainMessage(EVENT_IMS_REGISTRATION_INFO, ar));
+            } else if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
+                if (sWifiOffloadService == null){
+                    //first use wifioffloadservice and new the object.
+                    checkAndBindWifiOffloadService();
+                }
+                if (sWifiOffloadService != null) {
+                    try {
+                        sWifiOffloadService.registerForHandoverEvent(
+                                createWifiOffloadListenerProxy());
+                    } catch (RemoteException e) {
+                        Rlog.e(LOG_TAG, "can't register handover event");
+                    }
+                } else {
+                    Rlog.e(LOG_TAG, "can't get WifiOffloadService");
+                }
+            }
+        }
+    };
+    /// @}
+
+    public ImsService(Context context) {
+        mImsAdapter = new ImsAdapter(context);
+        mImsRILAdapter = new ImsRILAdapter(context);
+
+        Rlog.d(LOG_TAG, " mImsRILAdapter= " + mImsRILAdapter);
+
+        mContext = context;
+        mHandler = new MyHandler();
+
+        if (sImsConfig == null) {
+            sImsConfig = new ImsConfigStub(mContext);
+        }
+
+        mImsRILAdapter.registerForImsRegistrationInfo(mHandler, EVENT_IMS_REGISTRATION_INFO, null);
+        mImsRILAdapter.registerForImsEnableStart(mHandler, EVENT_IMS_ENABLING_URC, null);
+        mImsRILAdapter.registerForImsEnableComplete(mHandler, EVENT_IMS_ENABLED_URC, null);
+        mImsRILAdapter.registerForImsDisableStart(mHandler, EVENT_IMS_DISABLING_URC, null);
+        mImsRILAdapter.registerForImsDisableComplete(mHandler, EVENT_IMS_DISABLED_URC, null);
+        mImsRILAdapter.setOnIncomingCallIndication(mHandler, EVENT_INCOMING_CALL_INDICATION, null);
+        mImsRILAdapter.setOnCallRing(mHandler, EVENT_CALL_RING, null);
+        mImsRILAdapter.registerForCallProgressIndicator(mHandler, EVENT_SIP_CODE_INDICATION, null);
+        /// register for radio state changed
+        mImsRILAdapter.registerForNotAvailable(mHandler, EVENT_RADIO_NOT_AVAILABLE, null);
+        /// M: Simulate IMS Registration @{
+        final IntentFilter filter = new IntentFilter();
+        filter.addAction("ACTION_IMS_SIMULATE");
+        filter.addAction(Intent.ACTION_BOOT_COMPLETED);
+
+        if (SystemProperties.get("ro.mtk_wfc_support").equals("1")) {
+            /* Register for Content Observer */
+            // TODO: where to unregister it: in close()??
+            registerForWfcPreferenceChange(mHandler);
+            /* Send wfc preference info to Modem */
+            setWfcProfileInfo();
+            mNotificationController = new ImsNotificationController(context, 1);
+            Rlog.d(LOG_TAG, "noticontroller created" + mNotificationController);
+        }
+
+        context.registerReceiver(mBroadcastReceiver, filter);
+
+        if (SystemProperties.getInt("ro.mtk.volte.enable", 0)==1) {
+            turnOnIms(RadioCapabilitySwitchUtil.getMainCapabilityPhoneId());
+        }else {
+            turnOffIms(RadioCapabilitySwitchUtil.getMainCapabilityPhoneId());
+        }
+        /// @}
+    }
+
+    public void enableImsAdapter() {
+        mImsAdapter.enableImsAdapter();
+    }
+
+    public void disableImsAdapter(boolean isNormalDisable) {
+        mImsAdapter.disableImsAdapter(isNormalDisable);
+        mImsState = PhoneConstants.IMS_STATE_DISABLED;
+    }
+
+    @Override
+    public boolean isConnected(int serviceId, int serviceType, int callType) {
+        /* temp solution: always return ImsAdapter if enable */
+        return mImsAdapter.getImsAdapterEnable();
+    }
+
+    @Override
+    public int open(int phoneId, int serviceClass, PendingIntent incomingCallIntent,
+            IImsRegistrationListener listener) {
+        if (mListener != null) {
+            Rlog.e(LOG_TAG, "IMS: it did not close IMS servide before open() !!");
+        }
+        setRegistrationListener(1, listener);
+        return 1;
+    }
+
+    @Override
+    public void close(int serviceId) {
+        // remove registration listener
+        mListener = null;
+    }
+
+    @Override
+    public boolean isOpened(int serviceId) {
+        /* temp solution: always return ImsAdapter if enable */
+        return mImsAdapter.getImsAdapterEnable();
+    }
+
+    /**
+     * Used for turning on IMS when its in OFF state.
+     */
+
+    @Override
+    public void turnOnIms(int phoneId) {
+        Rlog.d(LOG_TAG, "turnOnIms, mActivePhoneId = " + mActivePhoneId +
+            " phoneId = " + phoneId);
+        phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        Rlog.d(LOG_TAG, "turnOnIms, MainCapabilityPhoneId = " + phoneId);
+
+        boolean isPhoneIdChanged = false;
+        if (mActivePhoneId != phoneId) {
+            mActivePhoneId = phoneId;
+            isPhoneIdChanged = true;
+        }
+        mImsRILAdapter.turnOnIms(mHandler.obtainMessage(EVENT_SET_IMS_ENABLED_DONE));
+        mImsState = PhoneConstants.IMS_STATE_ENABLING;
+    }
+
+    /**
+     * Used for turning off IMS when its in ON state.
+     * When IMS is OFF, device will behave as CSFB'ed.
+     */
+    @Override
+    public void turnOffIms(int phoneId) {
+        Rlog.d(LOG_TAG, "turnOffIms, mActivePhoneId = " + mActivePhoneId +
+            " phoneId = " + phoneId);
+        phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        Rlog.d(LOG_TAG, "turnOffIms, MainCapabilityPhoneId = " + phoneId);
+
+        boolean isPhoneIdChanged = false;
+        if (mActivePhoneId != phoneId) {
+            mActivePhoneId = phoneId;
+            isPhoneIdChanged = true;
+        }
+        mImsRILAdapter.turnOffIms(mHandler.obtainMessage(EVENT_SET_IMS_DISABLE_DONE));
+        mImsState = PhoneConstants.IMS_STATE_DISABLING;
+    }
+
+    @Override
+    public void setRegistrationListener(int serviceId, IImsRegistrationListener listener) {
+        mListener = listener;
+        if (mImsRegInfo != ServiceState.STATE_POWER_OFF) {
+            notifyRegistrationStateChange(mImsRegInfo);
+        }
+        if ((mImsRegInfo == ServiceState.STATE_IN_SERVICE)) {
+            notifyRegistrationCapabilityChange(mImsExtInfo);
+        }
+    }
+
+    @Override
+    public ImsCallProfile createCallProfile(int serviceId, int serviceType, int callType) {
+        return new ImsCallProfile(serviceType, callType);
+    }
+
+    @Override
+    public IImsCallSession createCallSession(int serviceId, ImsCallProfile profile, IImsCallSessionListener listener) {
+        // This API is for outgoing call to create IImsCallSession
+        return new ImsCallSessionProxy(mContext, profile, listener, this, mHandler, mImsRILAdapter);
+    }
+
+    @Override
+    public IImsCallSession getPendingCallSession(int serviceId, String callId) {
+        // This API is for incoming call to create IImsCallSession
+        if (mPendingMT == null) {
+            return null;
+        }
+
+        IImsCallSession pendingMT = mPendingMT;
+
+        try {
+            if (pendingMT.getCallId().equals(callId)) {
+                mPendingMT = null;
+                return pendingMT;
+            }
+        } catch (RemoteException e) {
+            // error handling. Currently no-op
+        }
+
+        return null;
+    }
+
+    /**
+     * Ut interface for the supplementary service configuration.
+     */
+    @Override
+    public IImsUt getUtInterface(int serviceId) {
+        if (sImsUtStub == null) {
+            sImsUtStub = new ImsUtStub(mContext);
+        }
+        return sImsUtStub;
+    }
+
+    /**
+     * Config interface to get/set IMS service/capability parameters.
+     */
+    @Override
+    public IImsConfig getConfigInterface(int phoneId) {
+        if (sImsConfig == null) {
+            sImsConfig = new ImsConfigStub(mContext);
+        }
+        return sImsConfig;
+    }
+
+    /**
+     * ECBM interface for Emergency Callback mode mechanism.
+     */
+    @Override
+    public IImsEcbm getEcbmInterface(int serviceId) {
+        /* leave blank */
+        return new ImsEcbmProxy();
+    }
+
+    /**
+      * Used to set current TTY Mode.
+      */
+    @Override
+    public void setUiTTYMode(int serviceId, int uiTtyMode, Message onComplete) {
+        return;
+    }
+
+    /**
+     *call interface for allowing/refusing the incoming call indication send to App.
+     *@hide
+     */
+    public void setCallIndication(String callId, int seqNum, boolean isAllow) {
+        /* leave blank */
+        if (isAllow) {
+            ImsCallProfile imsCallProfile = new ImsCallProfile();
+            if (mPendingMT != null) {
+                try {
+                    mPendingMT.close();
+                } catch (RemoteException e) {
+                    // error handling. Currently no-op
+                    Rlog.e(LOG_TAG, "setCallIndication: can't close pending MT");
+                }
+            }
+            mPendingMT = new ImsCallSessionProxy(mContext, imsCallProfile,
+                    null, ImsService.this, mHandler, mImsRILAdapter, callId);
+            mImsRILAdapter.setCallIndication(IMS_ALLOW_INCOMING_CALL_INDICATION,
+                    Integer.parseInt(callId), seqNum);
+        } else {
+            mImsRILAdapter.setCallIndication(IMS_DISALLOW_INCOMING_CALL_INDICATION,
+                    Integer.parseInt(callId), seqNum);
+        }
+    }
+
+    /**
+     * Use to query ims enable/disable status.
+     *@return ims status
+     *@hide
+     */
+    public int getImsState() {
+        return mImsState;
+    }
+
+    /**
+     * Use to query ims registration information.
+     *@return true if the ims is registered or false if the ims is unregistered.
+     *@hide
+     */
+    public boolean getImsRegInfo(int phoneId) {
+        if (phoneId != mActivePhoneId) {
+            Rlog.d(LOG_TAG, "IMS: getImsRegInfo() phoneId = " + phoneId +
+                " mActivePhoneId = " + mActivePhoneId);
+            return false;
+        }
+
+        if (mImsRegInfo == ServiceState.STATE_IN_SERVICE) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Use to query ims registration extension information.
+     *@return string ims extension information.
+     *@hide
+     */
+    public String getImsExtInfo() {
+        return Integer.toHexString(mImsExtInfo);
+    }
+
+    /**
+     * Use to query ims service state .
+     *@return mImsRegInfo for service state information.
+     *@hide
+     */
+    public int getImsServiceState() {
+        return mImsRegInfo;
+    }
+
+    /**
+     * Use to hang up all calls .
+     *@hide
+     */
+    public void hangupAllCall() {
+        mImsRILAdapter.hangupAllCall(null);
+    }
+
+    /**
+     *sned the incoming call intent  to ImsPhoneCallTracker.
+     *@hide
+     */
+    private void sendIncomingCallIndication(AsyncResult ar) {
+        // +EAIC:<call_id>,<number>,<type>,<call_mode>,<seq_no>
+        String callId = ((String[]) ar.result)[0];
+        String dialString = ((String[]) ar.result)[1];
+        String seqNum = ((String[]) ar.result)[4];
+        int serviceId = 1;
+
+        Rlog.d(LOG_TAG, "IMS: sendIncomingCallIndication() call_id = " + callId +
+                " dialString = " +  dialString + " seqNum = " + seqNum);
+
+        Intent intent = new Intent(ImsManager.ACTION_IMS_INCOMING_CALL_INDICATION);
+        intent.putExtra(ImsManager.EXTRA_CALL_ID, callId);
+        intent.putExtra(ImsManager.EXTRA_DIAL_STRING, dialString);
+        intent.putExtra(ImsManager.EXTRA_SEQ_NUM, Integer.parseInt(seqNum));
+        intent.putExtra(ImsManager.EXTRA_SERVICE_ID, serviceId);
+        mContext.sendBroadcast(intent);
+    }
+
+    /**
+     *create wifiOffloadListnerProxy.
+     *@return return wifiOffloadLisetnerProxy
+     *@hide
+     */
+    private IWifiOffloadListenerProxy createWifiOffloadListenerProxy() {
+        IWifiOffloadListenerProxy proxy =
+                new IWifiOffloadListenerProxy();
+        return proxy;
+    }
+
+    /**
+     *transfer AP wifi call mode to MD wifi call mode.
+     *@param wfcMode which is used in AP side.     
+     *@return return rilWfcMode which is used in MD side.
+     *@hide
+     */
+    private int mapToMDWfcProfile(int wfcMode) {
+
+        int rilWfcMode = ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED;
+
+        switch (wfcMode) {
+            case ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY:
+                rilWfcMode = 3;
+                break;
+            case ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED:
+                rilWfcMode = 2;
+                break;
+            case ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED:
+                rilWfcMode = 1;
+                break;
+            default:
+                break;
+        }
+        return rilWfcMode;
+    }
+
+    /**
+     *notify MD wifi profile is changed.
+     *@hide
+     */
+    private void setWfcProfileInfo() {
+        int wfcMode = android.provider.Settings.Global.getInt(mContext.getContentResolver(),
+                android.provider.Settings.Global.WFC_IMS_MODE,
+                ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED);
+        int rilWfcMode = mapToMDWfcProfile(wfcMode);
+        mImsRILAdapter.sendWfcProfileInfo(rilWfcMode);
+    }
+
+    /**
+     * Adapter class for {@link IWifiOffloadListener}.
+     */
+    private class IWifiOffloadListenerProxy extends WifiOffloadManager.Listener {
+
+        @Override
+        public void onHandover(int stage, int ratType) {
+            if (DBG) {
+                Rlog.d(LOG_TAG,"onHandover");
+            }
+
+            mRAN = ratType;
+
+            if ((stage == WifiOffloadManager.HANDOVER_END &&
+                    mImsRegInfo == ServiceState.STATE_IN_SERVICE)) {
+                notifyRegistrationCapabilityChange(mImsExtInfo);
+            }
+        }
+    }
+
+    public ImsRILAdapter getImsRILAdapter() {
+        if (mImsRILAdapter == null) {
+            Rlog.d(LOG_TAG, "IMS: getImsRILAdapter, mImsRILAdapter is null ");
+        }
+
+        return mImsRILAdapter;
+    }
+
+    /**
+     * Death recipient class for monitoring IMS service.
+     *
+     * @param phoneId  to indicate which phone.
+     */
+    private void checkAndBindWifiOffloadService() {
+        IBinder b = ServiceManager.getService(WifiOffloadManager.WFO_SERVICE);
+
+        if (b != null) {
+            try {
+                b.linkToDeath(mDeathRecipient, 0);
+            } catch (RemoteException e) {
+            }
+        }
+
+        sWifiOffloadService = IWifiOffloadService.Stub.asInterface(b);
+        Rlog.d(LOG_TAG, "checkAndBindWifiOffloadService: sWifiOffloadService = " +
+                sWifiOffloadService);
+    }
+
+    /**
+     * Death recipient class for monitoring WifiOffload service.
+     */
+    private class IWifiOffloadServiceDeathRecipient implements IBinder.DeathRecipient {
+        @Override
+        public void binderDied() {
+            sWifiOffloadService = null;
+        }
+    }
+
+
+    /**
+     *notify upper application ims registration information.
+     *@param imsRegInfo   the registration inforamtion.
+     *@hide
+     */
+    private void notifyRegistrationStateChange(int imsRegInfo) {
+        if (mListener == null) {
+            return;
+        }
+
+        if (DBG) {
+            Rlog.d(LOG_TAG, "IMS: notifyRegistrationStateChange imsRegInfo= " + imsRegInfo);
+        }
+
+        if (imsRegInfo == ServiceState.STATE_IN_SERVICE) {
+            try {
+                mListener.registrationConnected();
+                if (sWifiOffloadService != null) {
+                    mRAN = sWifiOffloadService.getRatType();
+                }
+                mRegErrorCode = ImsReasonInfo.CODE_UNSPECIFIED;
+            } catch (RemoteException e) {
+                // error handling. Currently no-op 
+                Rlog.e(LOG_TAG, "IMS: notifyStateChange fail on access WifiOffloadService");
+            }
+        } else {
+            try {
+                ImsReasonInfo imsReasonInfo = null;
+
+                if(sWifiOffloadService != null && 
+                        sWifiOffloadService.getRatType() == WifiOffloadManager.RAN_TYPE_WIFI) {
+                    // wfc disconnect
+                    DisconnectCause wifiDisconnectCause = sWifiOffloadService.getDisconnectCause();
+                    int wifiErrorCode = wifiDisconnectCause.getErrorCause();
+                    imsReasonInfo= new ImsReasonInfo(ImsReasonInfo.CODE_REGISTRATION_ERROR,
+                            wifiErrorCode,Integer.toString(wifiErrorCode));
+                } else {
+                    // volte disconnect
+                    imsReasonInfo= new ImsReasonInfo(ImsReasonInfo.CODE_REGISTRATION_ERROR,
+                            mRegErrorCode,Integer.toString(mRegErrorCode));
+                }
+
+                mListener.registrationDisconnected(imsReasonInfo);
+            } catch (RemoteException e) {
+                // error handling. Currently no-op
+            }
+        }
+    }
+
+    /**
+     *notify upper application ims feature capability information.
+     *@param imsExtInfo   the ims feature capability inforamtion.
+     *@hide
+     */
+    private void notifyRegistrationCapabilityChange(int imsExtInfo) {
+        if (mListener == null) {
+            return;
+        }
+
+        int[] enabledFeatures = new int[IMS_MAX_FEATURE_SUPPORT_SIZE];
+        int[] disabledFeatures = new int[IMS_MAX_FEATURE_SUPPORT_SIZE];
+
+        for (int i = 0; i < IMS_MAX_FEATURE_SUPPORT_SIZE; i++) {
+            enabledFeatures[i] = -1;
+            disabledFeatures[i] = -1;
+        }
+
+        if (mRAN != WifiOffloadManager.RAN_TYPE_WIFI &&
+                (imsExtInfo & IMS_VOICE_OVER_LTE) == IMS_VOICE_OVER_LTE) {
+            enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE;
+        } else {
+            disabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_LTE;
+        }
+
+        if ((imsExtInfo & IMS_VIDEO_OVER_LTE) == IMS_VIDEO_OVER_LTE) {
+            enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE;
+        } else {
+            disabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_LTE;
+        }
+        /// WFC @{
+        if (mRAN == WifiOffloadManager.RAN_TYPE_WIFI &&
+                (imsExtInfo & IMS_VOICE_OVER_LTE) == IMS_VOICE_OVER_LTE) {
+            enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI;
+            Rlog.d(LOG_TAG, "[WFC]IMS_VOICE_OVER_WIFI");
+        } else {
+            disabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI] =
+                    ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI;
+        }
+        ///@}
+
+        // currently modem not support video over wifi
+        disabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_WIFI] =
+                ImsConfig.FeatureConstants.FEATURE_TYPE_VIDEO_OVER_WIFI;
+
+        try {
+            mListener.registrationFeatureCapabilityChanged(ImsServiceClass.MMTEL,
+                    enabledFeatures, disabledFeatures);
+        } catch (RemoteException e) {
+            // error handling. Currently no-op
+        }
+    }
+
+    /*
+    * Observes WFC preference settings changes .
+    */
+    private void registerForWfcPreferenceChange(Handler handler) {
+        ContentObserver contentObserver = new ContentObserver(handler) {
+
+            @Override
+            public void onChange(boolean selfChange) {
+                this.onChange(selfChange, Settings.System.getUriFor(Settings.Global.WFC_IMS_MODE));
+            }
+
+            @Override
+            public void onChange(boolean selfChange, Uri uri) {
+                Uri i = android.provider.Settings.Global
+                        .getUriFor(android.provider.Settings.Global.WFC_IMS_MODE);
+                int wfc_preference = Settings.System.getInt(mContext.getContentResolver(),
+                        Settings.Global.WFC_IMS_MODE,
+                        ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED);
+                int ril_wfc_preference = mapToMDWfcProfile(wfc_preference);
+                if (DBG) Rlog.d(LOG_TAG, "uri:" + uri + ", db_uri:" + i);
+                if (DBG) Rlog.d(LOG_TAG, "wfc_preference:" + wfc_preference);
+                if (i != null && i.equals(uri)) {
+                    /* send change to modem */
+                    mImsRILAdapter.sendWfcProfileInfo(ril_wfc_preference);
+                }
+            }
+        };
+
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.Global.WFC_IMS_MODE),
+                false, contentObserver);
+    }
+
+    /**
+     *Ims service Message hanadler.
+     *@hide
+     */
+    private class MyHandler extends Handler {
+
+        @Override
+        public void handleMessage(Message msg) {
+            AsyncResult ar;
+            Intent intent;
+            switch (msg.what) {
+                case EVENT_IMS_REGISTRATION_INFO:
+                    if (DBG) Rlog.d(LOG_TAG, "receive EVENT_IMS_REGISTRATION_INFO");
+
+                    /**
+                     * According to 3GPP TS 27.007 +CIREGU format
+                     *
+                     * AsyncResult.result is an Object[]
+                     * ((Object[])AsyncResult.result)[0] is integer type to indicate the IMS regiration status.
+                     *                                    0: not registered
+                     *                                    1: registered
+                     * ((Object[])AsyncResult.result)[1] is numeric value in hexadecimal format to indicate the IMS capability.
+                     *                                    1: RTP-based transfer of voice according to MMTEL (see 3GPP TS 24.173 [87])
+                     *                                    2: RTP-based transfer of text according to MMTEL (see 3GPP TS 24.173 [87])
+                     *                                    4: SMS using IMS functionality (see 3GPP TS 24.341[101])
+                     *                                    8: RTP-based transfer of video according to MMTEL (see 3GPP TS 24.183 [87])
+                     *
+                     */
+                    ar = (AsyncResult) msg.obj;
+                    /// M: Fix DSDS bug
+                    /// Do not notify AP when socket_id from RILD is not equal the active phone id. @{
+                    int socketId = ((int[]) ar.result)[2];
+                    if (socketId != mActivePhoneId) {
+                        Rlog.d(LOG_TAG, "IMS: drop IMS reg info, socketId = " + socketId +
+                            " mActivePhoneId = " + mActivePhoneId);
+                        break;
+                    }
+                    /// @}
+
+                    int newImsRegInfo = ServiceState.STATE_POWER_OFF;
+                    if (((int[]) ar.result)[0] == 1) {
+                        newImsRegInfo = ServiceState.STATE_IN_SERVICE;
+                    } else {
+                        newImsRegInfo = ServiceState.STATE_OUT_OF_SERVICE;
+                    }
+                    /// M: Simulate IMS Registration @{
+                    if (SystemProperties.getInt("persist.ims.simulate", 0) == 1) {
+                        newImsRegInfo = (mImsRegistry ?
+                                ServiceState.STATE_IN_SERVICE : ServiceState.STATE_OUT_OF_SERVICE);
+                        Rlog.d(LOG_TAG, "Override EVENT_IMS_REGISTRATION_INFO: newImsRegInfo=" +
+                                newImsRegInfo);
+                    }
+                    /// @}
+                    int newImsExtInfo = ((int[]) ar.result)[1];
+
+                    /* notify upper application the IMS registration status is chagned */
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "newReg:" + newImsRegInfo + " oldReg:" + mImsRegInfo);
+                    }
+
+                    mImsRegInfo = newImsRegInfo;
+                    notifyRegistrationStateChange(mImsRegInfo);
+
+                    /* notify upper application the IMS capability is chagned when IMS is registered */
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "newRegExt:" + newImsExtInfo + "oldRegExt:" + mImsExtInfo);
+                    }
+
+                    if ((mImsRegInfo == ServiceState.STATE_IN_SERVICE)) {
+                        mImsExtInfo = newImsExtInfo;
+                    } else {
+                        mImsExtInfo = 0;
+                    }
+                    notifyRegistrationCapabilityChange(mImsExtInfo);
+                    break;
+                case EVENT_IMS_ENABLING_URC:
+                    //+EIMS: 1
+                    //Since MD doens't send IMS_ENABLED_URC to AP we should handle initial here.
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_IMS_ENABLING_URC, mActivePhoneId = "
+                                + mActivePhoneId);
+                    }
+                    // notify AP Ims Service is up
+                    intent = new Intent(ImsManager.ACTION_IMS_SERVICE_UP);
+                    intent.putExtra(ImsManager.EXTRA_PHONE_ID, mActivePhoneId);
+                    mContext.sendBroadcast(intent);
+                    // enable ImsAdapter
+                    enableImsAdapter();
+                    mImsState = PhoneConstants.IMS_STATE_ENABLE;
+                    if (SystemProperties.get("ro.mtk_wfc_support").equals("1")) {
+                        setWfcProfileInfo();
+                    }
+                    break;
+                case EVENT_IMS_ENABLED_URC:
+                    //+EIMCFLAG: 1
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_IMS_ENABLED_URC");
+                    }
+                    break;
+                case EVENT_IMS_DISABLING_URC:
+                    //+EIMS: 0
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_IMS_DISABLING_URC");
+                    }
+                    break;
+                case EVENT_IMS_DISABLED_URC:
+                    //+EIMCFLAG: 0
+                    if (DBG) Rlog.d(LOG_TAG, "receive EVENT_IMS_DISABLED_URC");
+                    int phoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+                    Rlog.d(LOG_TAG, "IMS: phoneId = " + phoneId);
+                    intent = new Intent(ImsManager.ACTION_IMS_SERVICE_DOWN);
+                    intent.putExtra(ImsManager.EXTRA_PHONE_ID, phoneId);
+                    mContext.sendBroadcast(intent);
+
+                    disableImsAdapter(true);
+                    mImsState = PhoneConstants.IMS_STATE_DISABLED;
+                    break;
+                case EVENT_SET_IMS_ENABLED_DONE:
+                    // Only log for tracking set ims enable command response
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_SET_IMS_ENABLED_DONE");
+                    }
+                    break;
+                case EVENT_SET_IMS_DISABLE_DONE:
+                    // Only log for tracking set ims disable command response
+                    if (DBG) {
+                        Rlog.d(LOG_TAG, "receive EVENT_SET_IMS_DISABLE_DONE");
+                    }
+                    break;
+                case EVENT_INCOMING_CALL_INDICATION:
+                    Rlog.d(LOG_TAG, "receive EVENT_INCOMING_CALL_INDICATION");
+                    ar = (AsyncResult) msg.obj;
+                    sendIncomingCallIndication(ar);
+                    break;
+                case EVENT_CALL_RING:
+                    Rlog.d(LOG_TAG, "receive EVENT_CALL_RING");
+                    break;
+                case EVENT_RADIO_NOT_AVAILABLE:
+                    Rlog.d(LOG_TAG, "receive EVENT_RADIO_NOT_AVAILABLE");
+                    mContext.sendBroadcast(new Intent(ImsManager.ACTION_IMS_SERVICE_DOWN));
+                    disableImsAdapter(false);
+                    break;
+                case EVENT_SIP_CODE_INDICATION:
+                    ar = (AsyncResult) msg.obj;
+                    int[] sipMessage = (int[]) ar.result;
+                    /* ESIPCPI: <call_id>,<dir>,<SIP_msg_type>,<method>,<response_code> */
+                    if (sipMessage != null) {
+                        Rlog.d(LOG_TAG, "Method =" + sipMessage[3] + "Reg cause =" + sipMessage[4]);
+                        if (sipMessage[3] == 0 ||
+                                sipMessage[3] == 9) {
+                            /* Save the WFC registration error for later use */
+                            mRegErrorCode = sipMessage[4];
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+
+    @Override
+    public int getRegistrationStatus() {
+        if (mNotificationController == null) return WfcReasonInfo.CODE_WFC_DEFAULT;
+        return mNotificationController.getRegistrationStatus();
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/ImsUtStub.java b/packages/Ims/src/com/mediatek/ims/ImsUtStub.java
new file mode 100644
index 0000000..10e182c
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/ImsUtStub.java
@@ -0,0 +1,1116 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.Context;
+import android.os.AsyncResult;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.util.Log;
+
+import com.android.ims.ImsCallForwardInfo;
+/// For OP01 UT
+import com.android.ims.ImsCallForwardInfoEx;
+import com.android.ims.ImsReasonInfo;
+import com.android.ims.ImsSsInfo;
+import com.android.ims.ImsUtInterface;
+import com.android.ims.internal.IImsUt;
+import com.android.ims.internal.IImsUtListener;
+import com.android.internal.telephony.CallForwardInfo;
+
+import java.net.UnknownHostException;
+
+/// For OP01 UT
+import com.android.internal.telephony.CallForwardInfoEx;
+import com.android.internal.telephony.CommandsInterface;
+import com.mediatek.simservs.xcap.XcapException;
+
+
+import static com.android.internal.telephony.imsphone.ImsPhoneMmiCode.UT_BUNDLE_KEY_CLIR;
+import static com.android.internal.telephony.imsphone.ImsPhoneMmiCode.UT_BUNDLE_KEY_SSINFO;
+
+/**
+ * ImsUT class for handle the IMS UT interface.
+ *
+ * The implementation is based on IR.92
+ *
+ *  @hide
+ */
+public class ImsUtStub extends IImsUt.Stub {
+    private static final String TAG = "ImsUtService";
+    private static final boolean DBG = true;
+
+    private Context mContext;
+
+    private static final Object mLock = new Object();
+    private static int sRequestId = 0;
+    private IImsUtListener mListener = null;
+    private MMTelSSTransport mMMTelSSTSL;
+    private ResultHandler mHandler;
+
+    static final int IMS_UT_EVENT_GET_CB = 1000;
+    static final int IMS_UT_EVENT_GET_CF = 1001;
+    static final int IMS_UT_EVENT_GET_CW = 1002;
+    static final int IMS_UT_EVENT_GET_CLIR = 1003;
+    static final int IMS_UT_EVENT_GET_CLIP = 1004;
+    static final int IMS_UT_EVENT_GET_COLR = 1005;
+    static final int IMS_UT_EVENT_GET_COLP = 1006;
+    static final int IMS_UT_EVENT_SET_CB = 1007;
+    static final int IMS_UT_EVENT_SET_CF = 1008;
+    static final int IMS_UT_EVENT_SET_CW = 1009;
+    static final int IMS_UT_EVENT_SET_CLIR = 1010;
+    static final int IMS_UT_EVENT_SET_CLIP = 1011;
+    static final int IMS_UT_EVENT_SET_COLR = 1012;
+    static final int IMS_UT_EVENT_SET_COLP = 1013;
+    /// For OP01 UT @{
+    static final int IMS_UT_EVENT_GET_CF_TIME_SLOT = 1014;
+    static final int IMS_UT_EVENT_SET_CF_TIME_SLOT = 1015;
+    /// @}
+
+    static final int HTTP_ERROR_CODE_403 = 403;
+
+    /**
+    *
+    * Construction function for ImsConfigStub.
+    *
+    * @param context the application context
+    *
+    */
+   public ImsUtStub(Context context) {
+       mContext = context;
+       mMMTelSSTSL = MMTelSSTransport.getInstance();
+       mMMTelSSTSL.registerUtService(mContext);
+
+       HandlerThread thread = new HandlerThread("ImsUtStubResult");
+       thread.start();
+       Looper looper = thread.getLooper();
+       mHandler = new ResultHandler(looper);
+   }
+
+   private class ResultHandler extends Handler {
+       public ResultHandler(Looper looper) {
+            super(looper);
+       }
+
+       @Override
+       public void handleMessage(Message msg) {
+           if (DBG) {
+               Log.d(TAG, "handleMessage(): event = " + msg.what + ", requestId = " + msg.arg1);
+           }
+           switch (msg.what) {
+               case IMS_UT_EVENT_GET_CB:
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           int[] result = (int []) ar.result;
+                           ImsSsInfo[] info = new ImsSsInfo[1];
+                           info[0] = new ImsSsInfo();
+                           info[0].mStatus = result[0];
+                           // TODO: add ServiceClass information
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CB: status = " + result[0]);
+                           }
+
+                           try {
+                               mListener.utConfigurationCallBarringQueried(ImsUtStub.this,
+                                       msg.arg1, info);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationCallBarringQueried");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof UnknownHostException) {
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CB: UnknownHostException.");
+                           }
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CB: "
+                                       + "UnknownHostException utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof XcapException) {
+                           XcapException xcapException = (XcapException) ar.exception;
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   xcapExceptionToImsReasonInfo(xcapException));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CB: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else {
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                               0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CB: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_GET_CF:
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           CallForwardInfo[] cfInfo = (CallForwardInfo[]) ar.result;
+                           ImsCallForwardInfo[] imsCfInfo = null;
+
+                           if (cfInfo != null && cfInfo.length != 0) {
+                               imsCfInfo = new ImsCallForwardInfo[cfInfo.length];
+                               for (int i = 0; i < cfInfo.length; i++) {
+                                   if (DBG) {
+                                       Log.d(TAG, "IMS_UT_EVENT_GET_CF: cfInfo[" + i + "] = "
+                                               + cfInfo[i]);
+                                   }
+                                   imsCfInfo[i] = getImsCallForwardInfo(cfInfo[i]);
+                               }
+                           }
+
+                           try {
+                               mListener.utConfigurationCallForwardQueried(ImsUtStub.this,
+                                       msg.arg1, imsCfInfo);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationCallForwardQueried");
+                               e.printStackTrace();
+                           }
+                       } else {
+                           if (ar.exception instanceof XcapException) {
+                               XcapException xcapException = (XcapException) ar.exception;
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       xcapExceptionToImsReasonInfo(xcapException));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF: "
+                                           + "utConfigurationQueryFailed");
+                                   e.printStackTrace();
+                               }
+                           } else if (ar.exception instanceof UnknownHostException) {
+                               if (DBG) {
+                                   Log.d(TAG, "IMS_UT_EVENT_GET_CF: UnknownHostException.");
+                               }
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF: "
+                                           + "UnknownHostException utConfigurationQueryFailed");
+                                   e.printStackTrace();
+                               }
+                           } else {
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                           new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                                   0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF: "
+                                           + "utConfigurationQueryFailed");
+                                   e.printStackTrace();
+                               }
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_GET_CW:
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           int[] result = (int []) ar.result;
+                           ImsSsInfo[] info = new ImsSsInfo[1];
+                           info[0] = new ImsSsInfo();
+                           info[0].mStatus = result[0];
+                           // TODO: add ServiceClass information
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CW: status = " + result[0]);
+                           }
+
+                           try {
+                               mListener.utConfigurationCallWaitingQueried(ImsUtStub.this,
+                                       msg.arg1, info);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationCallWaitingQueried");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof UnknownHostException) {
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CW: UnknownHostException.");
+                           }
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CW: "
+                                       + "UnknownHostException utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof XcapException) {
+                           XcapException xcapException = (XcapException) ar.exception;
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   xcapExceptionToImsReasonInfo(xcapException));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CW: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else {
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                               0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CW: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_GET_CLIR:
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           int[] result = (int []) ar.result;
+                           Bundle info = new Bundle();
+                           info.putIntArray(UT_BUNDLE_KEY_CLIR, result);
+
+                           try {
+                               mListener.utConfigurationQueried(ImsUtStub.this, msg.arg1, info);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CLIR: "
+                                       + "utConfigurationQueried");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof UnknownHostException) {
+                           if (DBG) {
+                               Log.d(TAG, "IMS_UT_EVENT_GET_CLIR: UnknownHostException.");
+                           }
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CLIR: "
+                                       + "UnknownHostException utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else if (ar.exception instanceof XcapException) {
+                           XcapException xcapException = (XcapException) ar.exception;
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                   msg.arg1,
+                                   xcapExceptionToImsReasonInfo(xcapException));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CLIR: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       } else {
+                           try {
+                               mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                               0));
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CLIR: "
+                                       + "utConfigurationQueryFailed");
+                               e.printStackTrace();
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_GET_CLIP:
+               case IMS_UT_EVENT_GET_COLR: // fall through
+               case IMS_UT_EVENT_GET_COLP: // fall through
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           int[] result = (int []) ar.result;
+                           ImsSsInfo ssInfo = new ImsSsInfo();
+                           ssInfo.mStatus = result[0];
+                           Bundle info = new Bundle();
+                           info.putParcelable(UT_BUNDLE_KEY_SSINFO, ssInfo);
+
+                           try {
+                               mListener.utConfigurationQueried(ImsUtStub.this, msg.arg1, info);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationQueried, event = "
+                                       + msg.what);
+                               e.printStackTrace();
+                           }
+                       } else {
+                           if (ar.exception instanceof XcapException) {
+                               XcapException xcapException = (XcapException) ar.exception;
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       xcapExceptionToImsReasonInfo(xcapException));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in utConfigurationQueryFailed, "
+                                           + "event = " + msg.what);
+                                   e.printStackTrace();
+                               }
+                           } else if (ar.exception instanceof UnknownHostException) {
+                               if (DBG) {
+                                   Log.d(TAG, "UnknownHostException. event = " + msg.what);
+                               }
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException UnknownHostException "
+                                           + "utConfigurationQueryFailed, event" + msg.what);
+                                   e.printStackTrace();
+                               }
+                           } else {
+                               try {
+                                   mListener.utConfigurationQueryFailed(ImsUtStub.this, msg.arg1,
+                                           new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                                   0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in utConfigurationQueryFailed, "
+                                           + "event = " + msg.what);
+                                   e.printStackTrace();
+                               }
+                           }
+                       }
+                   }
+                   break;
+               case IMS_UT_EVENT_SET_CB:
+               case IMS_UT_EVENT_SET_CF: // fall through
+               case IMS_UT_EVENT_SET_CW: // fall through
+               case IMS_UT_EVENT_SET_CLIR: // fall through
+               case IMS_UT_EVENT_SET_CLIP: // fall through
+               case IMS_UT_EVENT_SET_COLR: // fall through
+               case IMS_UT_EVENT_SET_COLP: // fall through
+               case IMS_UT_EVENT_SET_CF_TIME_SLOT: // For OP01 UT
+                   if (null != mListener) {
+                       AsyncResult ar = (AsyncResult) msg.obj;
+
+                       if (null == ar.exception) {
+                           if (DBG) {
+                               Log.d(TAG, "utConfigurationUpdated(): "
+                                       + "event = " + msg.what);
+                           }
+                           try {
+                               mListener.utConfigurationUpdated(ImsUtStub.this, msg.arg1);
+                           } catch (RemoteException e) {
+                               Log.e(TAG, "RemoteException in utConfigurationUpdated, event = "
+                                       + msg.what);
+                               e.printStackTrace();
+                           }
+                       } else {
+                           if (ar.exception instanceof XcapException) {
+                               XcapException xcapException = (XcapException) ar.exception;
+                               try {
+                                   mListener.utConfigurationUpdateFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       xcapExceptionToImsReasonInfo(xcapException));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in utConfigurationUpdateFailed, "
+                                           + "event = " + msg.what);
+                                   e.printStackTrace();
+                               }
+                           } else if (ar.exception instanceof UnknownHostException) {
+                               if (DBG) {
+                                   Log.d(TAG, "UnknownHostException. event = " + msg.what);
+                               }
+                               try {
+                                   mListener.utConfigurationUpdateFailed(ImsUtStub.this,
+                                       msg.arg1,
+                                       new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException UnknownHostException "
+                                           + "utConfigurationUpdateFailed, event" + msg.what);
+                                   e.printStackTrace();
+                               }
+                           } else {
+                               try {
+                                   mListener.utConfigurationUpdateFailed(ImsUtStub.this, msg.arg1,
+                                           new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR,
+                                                   0));
+                               } catch (RemoteException e) {
+                                   Log.e(TAG, "RemoteException in utConfigurationUpdateFailed, "
+                                           + "event = " + msg.what);
+                                   e.printStackTrace();
+                               }
+                           }
+                       }
+                   }
+                   break;
+                /// For OP01 UT @{
+                case IMS_UT_EVENT_GET_CF_TIME_SLOT:
+                    if (null != mListener) {
+                        AsyncResult ar = (AsyncResult) msg.obj;
+
+                        if (null == ar.exception) {
+                            CallForwardInfoEx[] cfInfo = (CallForwardInfoEx[]) ar.result;
+                            ImsCallForwardInfoEx[] imsCfInfo = null;
+
+                            if (cfInfo != null && cfInfo.length != 0) {
+                                imsCfInfo = new ImsCallForwardInfoEx[cfInfo.length];
+                                for (int i = 0; i < cfInfo.length; i++) {
+                                    ImsCallForwardInfoEx info = new ImsCallForwardInfoEx();
+                                    info.mCondition =
+                                            getConditionFromCFReason(cfInfo[i].reason);
+                                    info.mStatus = cfInfo[i].status;
+                                    info.mServiceClass = cfInfo[i].serviceClass;
+                                    info.mToA = cfInfo[i].toa;
+                                    info.mNumber = cfInfo[i].number;
+                                    info.mTimeSeconds = cfInfo[i].timeSeconds;
+                                    info.mTimeSlot = cfInfo[i].timeSlot;
+                                    imsCfInfo[i] = info;
+                                }
+                            }
+
+                            try {
+                                mListener.utConfigurationCallForwardInTimeSlotQueried(
+                                        ImsUtStub.this, msg.arg1, imsCfInfo);
+                            } catch (RemoteException e) {
+                                Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF_TIME_SLOT"
+                                        + " utConfigurationCallForwardInTimeSlotQueried");
+                                e.printStackTrace();
+                            }
+                        } else {
+                            if (ar.exception instanceof XcapException) {
+                                XcapException xcapException = (XcapException) ar.exception;
+                                try {
+                                    mListener.utConfigurationQueryFailed(
+                                            ImsUtStub.this, msg.arg1,
+                                            xcapExceptionToImsReasonInfo(xcapException));
+                                } catch (RemoteException e) {
+                                    Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF_TIME_SLOT"
+                                            + " utConfigurationQueryFailed");
+                                    e.printStackTrace();
+                                }
+                            } else if (ar.exception instanceof UnknownHostException) {
+                                if (DBG) {
+                                    Log.d(TAG, "IMS_UT_EVENT_GET_CF_TIME_SLOT: "
+                                            + "UnknownHostException.");
+                                }
+                                try {
+                                    mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                        msg.arg1,
+                                        new ImsReasonInfo(ImsReasonInfo.CODE_UT_UNKNOWN_HOST, 0));
+                                } catch (RemoteException e) {
+                                    Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF_TIME_SLOT: "
+                                            + "UnknownHostException utConfigurationQueryFailed");
+                                    e.printStackTrace();
+                                }
+                            } else {
+                                try {
+                                    mListener.utConfigurationQueryFailed(ImsUtStub.this,
+                                            msg.arg1,
+                                            new ImsReasonInfo(
+                                                    ImsReasonInfo.CODE_UT_NETWORK_ERROR, 0));
+                                } catch (RemoteException e) {
+                                    Log.e(TAG, "RemoteException in IMS_UT_EVENT_GET_CF_TIME_SLOT"
+                                            + " utConfigurationQueryFailed");
+                                    e.printStackTrace();
+                                }
+                            }
+                        }
+                    }
+                    break;
+                    /// @}
+               default:
+                   Log.d(TAG, "Unknown Event: " + msg.what);
+                   break;
+           }
+       }
+   };
+
+    /**
+     * Closes the object. This object is not usable after being closed.
+     */
+    public void close() {
+    }
+
+    private String getFacilityFromCBType(int cbType) {
+        switch (cbType) {
+            case ImsUtInterface.CB_BAIC:
+                return CommandsInterface.CB_FACILITY_BAIC;
+            case ImsUtInterface.CB_BAOC:
+                return CommandsInterface.CB_FACILITY_BAOC;
+            case ImsUtInterface.CB_BOIC:
+                return CommandsInterface.CB_FACILITY_BAOIC;
+            case ImsUtInterface.CB_BOIC_EXHC:
+                return CommandsInterface.CB_FACILITY_BAOICxH;
+            case ImsUtInterface.CB_BIC_WR:
+                return CommandsInterface.CB_FACILITY_BAICr;
+            // TODO: Barring of Anonymous Communication Rejection (ACR)
+            case ImsUtInterface.CB_BIC_ACR:
+                return "ACR";
+            case ImsUtInterface.CB_BA_ALL:
+                return CommandsInterface.CB_FACILITY_BA_ALL;
+            case ImsUtInterface.CB_BA_MO:
+                return CommandsInterface.CB_FACILITY_BA_MO;
+            case ImsUtInterface.CB_BA_MT:
+                return CommandsInterface.CB_FACILITY_BA_MT;
+            // TODO: Barring of Specific Incoming calls
+            case ImsUtInterface.CB_BS_MT:
+                return "BS_MT";
+            default:
+                return null;
+        }
+    }
+
+    private int getCFActionFromAction(int cfAction) {
+        switch(cfAction) {
+            case ImsUtInterface.ACTION_DEACTIVATION:
+                return CommandsInterface.CF_ACTION_DISABLE;
+            case ImsUtInterface.ACTION_ACTIVATION:
+                return CommandsInterface.CF_ACTION_ENABLE;
+            case ImsUtInterface.ACTION_ERASURE:
+                return CommandsInterface.CF_ACTION_ERASURE;
+            case ImsUtInterface.ACTION_REGISTRATION:
+                return CommandsInterface.CF_ACTION_REGISTRATION;
+            default:
+                break;
+        }
+
+        return CommandsInterface.CF_ACTION_DISABLE;
+    }
+
+    private int getCFReasonFromCondition(int condition) {
+        switch(condition) {
+            case ImsUtInterface.CDIV_CF_UNCONDITIONAL:
+                return CommandsInterface.CF_REASON_UNCONDITIONAL;
+            case ImsUtInterface.CDIV_CF_BUSY:
+                return CommandsInterface.CF_REASON_BUSY;
+            case ImsUtInterface.CDIV_CF_NO_REPLY:
+                return CommandsInterface.CF_REASON_NO_REPLY;
+            case ImsUtInterface.CDIV_CF_NOT_REACHABLE:
+                return CommandsInterface.CF_REASON_NOT_REACHABLE;
+            case ImsUtInterface.CDIV_CF_ALL:
+                return CommandsInterface.CF_REASON_ALL;
+            case ImsUtInterface.CDIV_CF_ALL_CONDITIONAL:
+                return CommandsInterface.CF_REASON_ALL_CONDITIONAL;
+            case ImsUtInterface.CDIV_CF_NOT_LOGGED_IN:
+                return CommandsInterface.CF_REASON_NOT_REGISTERED;
+            default:
+                break;
+        }
+
+        return CommandsInterface.CF_REASON_NOT_REACHABLE;
+    }
+
+    private int getConditionFromCFReason(int reason) {
+        switch(reason) {
+            case CommandsInterface.CF_REASON_UNCONDITIONAL:
+                return ImsUtInterface.CDIV_CF_UNCONDITIONAL;
+            case CommandsInterface.CF_REASON_BUSY:
+                return ImsUtInterface.CDIV_CF_BUSY;
+            case CommandsInterface.CF_REASON_NO_REPLY:
+                return ImsUtInterface.CDIV_CF_NO_REPLY;
+            case CommandsInterface.CF_REASON_NOT_REACHABLE:
+                return ImsUtInterface.CDIV_CF_NOT_REACHABLE;
+            case CommandsInterface.CF_REASON_ALL:
+                return ImsUtInterface.CDIV_CF_ALL;
+            case CommandsInterface.CF_REASON_ALL_CONDITIONAL:
+                return ImsUtInterface.CDIV_CF_ALL_CONDITIONAL;
+            case CommandsInterface.CF_REASON_NOT_REGISTERED:
+                return ImsUtInterface.CDIV_CF_NOT_LOGGED_IN;
+            default:
+                break;
+        }
+
+        return ImsUtInterface.INVALID;
+    }
+
+    private ImsCallForwardInfo getImsCallForwardInfo(CallForwardInfo info) {
+        ImsCallForwardInfo imsCfInfo = new ImsCallForwardInfo();
+        imsCfInfo.mCondition = getConditionFromCFReason(info.reason);
+        imsCfInfo.mStatus = info.status;
+        //imsCfInfo.mServiceClass = info.serviceClass; // TODO: Add video service class
+        imsCfInfo.mToA = info.toa;
+        imsCfInfo.mNumber = info.number;
+        imsCfInfo.mTimeSeconds = info.timeSeconds;
+        return imsCfInfo;
+    }
+
+    /**
+     * Retrieves the configuration of the call barring.
+     * @param cbType Call Barring Type
+     * @return the request ID
+     */
+    public int queryCallBarring(int cbType) {
+        int requestId;
+        String facility;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCallBarring(): requestId = " + requestId);
+        }
+
+        facility = getFacilityFromCBType(cbType);
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CB, requestId, 0, null);
+        mMMTelSSTSL.queryFacilityLock(facility, null, CommandsInterface.SERVICE_CLASS_VOICE, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the configuration of the call forward.
+     * @param condition Call Forward condition
+     * @param number Forwarded to number
+     * @return the request ID
+     */
+    public int queryCallForward(int condition, String number) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCallForward(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CF, requestId, 0, null);
+        mMMTelSSTSL.queryCallForwardStatus(getCFReasonFromCondition(condition),
+                CommandsInterface.SERVICE_CLASS_VOICE, number, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the configuration of the call waiting.
+     * @return the request ID
+     */
+    public int queryCallWaiting() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCallWaiting(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CW, requestId, 0, null);
+        mMMTelSSTSL.queryCallWaiting(CommandsInterface.SERVICE_CLASS_VOICE, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the default CLIR setting.
+     * @return the request ID
+     */
+    public int queryCLIR() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCLIR(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CLIR, requestId, 0, null);
+        mMMTelSSTSL.getCLIR(msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the CLIP call setting.
+     * @return the request ID
+     */
+    public int queryCLIP() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCLIP(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CLIP, requestId, 0, null);
+        mMMTelSSTSL.queryCLIP(msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the COLR call setting.
+     * @return the request ID
+     */
+    public int queryCOLR() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCOLR(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_COLR, requestId, 0, null);
+        mMMTelSSTSL.getCOLR(msg);
+
+        return requestId;
+    }
+
+    /**
+     * Retrieves the COLP call setting.
+     * @return the request ID
+     */
+    public int queryCOLP() {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCOLP(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_COLP, requestId, 0, null);
+        mMMTelSSTSL.getCOLP(msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates or retrieves the supplementary service configuration.
+     * @param ssInfo supplementary service information
+     * @return the request ID
+     */
+    public int transact(Bundle ssInfo) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the call barring.
+     * @param cbType Call Barring Type
+     * @param enable lock state
+     * @param barrList barring list
+     * @return the request ID
+     */
+    public int updateCallBarring(int cbType, boolean enable, String[] barrList) {
+        int requestId;
+        String facility;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCallBarring(): requestId = " + requestId);
+        }
+
+        facility = getFacilityFromCBType(cbType);
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CB, requestId, 0, null);
+        mMMTelSSTSL.setFacilityLock(facility, enable, null,
+                CommandsInterface.SERVICE_CLASS_VOICE, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the call forward.
+     * @param action the call forwarding action
+     * @param condition the call forwarding condition
+     * @param number the call forwarded to number
+     * @param timeSeconds seconds for no reply
+     * @return the request ID
+     */
+    public int updateCallForward(int action, int condition, String number, int serviceClass,
+                                     int timeSeconds) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCallForward(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CF, requestId, 0, null);
+        mMMTelSSTSL.setCallForward(getCFActionFromAction(action),
+                getCFReasonFromCondition(condition), serviceClass,
+                number, timeSeconds, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the call waiting.
+     * @param enable activate flag
+     * @return the request ID
+     */
+    public int updateCallWaiting(boolean enable, int serviceClass) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCallWaiting(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CW, requestId, 0, null);
+        mMMTelSSTSL.setCallWaiting(enable, serviceClass, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the CLIR supplementary service.
+     * @param clirMode CLIR mode
+     * @return the request ID
+     */
+    public int updateCLIR(int clirMode) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCLIR(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CLIR, requestId, 0, null);
+        mMMTelSSTSL.setCLIR(clirMode, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the CLIP supplementary service.
+     * @param enable activate flag
+     * @return the request ID
+     */
+    public int updateCLIP(boolean enable) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCLIP(): requestId = " + requestId);
+        }
+
+        int enableClip = (enable) ? 1 : 0;
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CLIP, requestId, 0, null);
+        mMMTelSSTSL.setCLIP(enableClip, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the COLR supplementary service.
+     * @param presentation presentation flag
+     * @return the request ID
+     */
+    public int updateCOLR(int presentation) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCOLR(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_COLR, requestId, 0, null);
+        mMMTelSSTSL.setCOLR(presentation, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the COLP supplementary service.
+     * @param enable activate flag
+     * @return the request ID
+     */
+    public int updateCOLP(boolean enable) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCOLP(): requestId = " + requestId);
+        }
+
+        int enableColp = (enable) ? 1 : 0;
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_COLP, requestId, 0, null);
+        mMMTelSSTSL.setCOLP(enableColp, msg);
+
+        return requestId;
+    }
+
+    /**
+     * Sets the listener.
+     * @param listener callback interface
+     */
+    public void setListener(IImsUtListener listener) {
+        mListener = listener;
+    }
+
+    /**
+     * Convert XcapExcaption to ImsReasonInfo.
+     * @param xcapEx the XcapExcaption
+     * @return the converted ImsReasonInfo
+     */
+    ImsReasonInfo xcapExceptionToImsReasonInfo(XcapException xcapEx) {
+        ImsReasonInfo reason;
+
+        if ((DBG) && (xcapEx != null)) {
+            Log.d(TAG, "xcapExceptionToImsReasonInfo(): XcapException: "
+                    + "code = " + xcapEx.getExceptionCodeCode()
+                    + ", http error = " + xcapEx.getHttpErrorCode()
+                    + ", isConnectionError = " + xcapEx.isConnectionError());
+        }
+
+        if ((xcapEx != null) && (xcapEx.getHttpErrorCode() == HTTP_ERROR_CODE_403)) {
+            reason = new ImsReasonInfo(ImsReasonInfo.CODE_UT_XCAP_403_FORBIDDEN, 0);
+        } else {
+            reason = new ImsReasonInfo(ImsReasonInfo.CODE_UT_NETWORK_ERROR, 0);
+        }
+
+        return reason;
+    }
+
+    /// For OP01 UT @{
+    /**
+     * Retrieves the configuration of the call forward in a time slot.
+     */
+    public int queryCallForwardInTimeSlot(int condition) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "queryCallForwardInTimeSlot(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_GET_CF_TIME_SLOT,
+                requestId, 0, null);
+        mMMTelSSTSL.queryCallForwardInTimeSlotStatus(
+                getCFReasonFromCondition(condition),
+                CommandsInterface.SERVICE_CLASS_VOICE,
+                msg);
+
+        return requestId;
+    }
+
+    /**
+     * Updates the configuration of the call forward in a time slot.
+     */
+    public int updateCallForwardInTimeSlot(int action, int condition,
+            String number, int timeSeconds, long[] timeSlot) {
+        int requestId;
+
+        synchronized (mLock) {
+            requestId = sRequestId;
+            sRequestId++;
+        }
+        if (DBG) {
+            Log.d(TAG, "updateCallForwardInTimeSlot(): requestId = " + requestId);
+        }
+
+        Message msg = mHandler.obtainMessage(IMS_UT_EVENT_SET_CF_TIME_SLOT, requestId, 0, null);
+        mMMTelSSTSL.setCallForwardInTimeSlot(getCFActionFromAction(action),
+                getCFReasonFromCondition(condition),
+                CommandsInterface.SERVICE_CLASS_VOICE,
+                number, timeSeconds, timeSlot, msg);
+
+        return requestId;
+    }
+    /// @}
+
+    // xen0n
+
+    @Override
+    public int queryCFForServiceClass(int condition, String number, int serviceClass) {
+        Log.e(TAG, "queryCFForServiceClass(" + condition + ", \"" + number + "\", " + serviceClass + "): stub!");
+        return 0;
+    }
+
+    @Override
+    public int updateCallBarring(int cbType, int action, String[] barrList) {
+        Log.e(TAG, "updateCallBarring: stub!");
+        return 0;
+    }
+
+}
diff --git a/packages/Ims/src/com/mediatek/ims/MMTelSSTransport.java b/packages/Ims/src/com/mediatek/ims/MMTelSSTransport.java
new file mode 100644
index 0000000..ab4af48
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/MMTelSSTransport.java
@@ -0,0 +1,5861 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2013. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+
+import android.net.Network;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Parcel;
+import android.os.PowerManager;
+import android.os.SystemProperties;
+import android.os.PowerManager.WakeLock;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+
+import com.android.internal.telephony.CallForwardInfo;
+import com.android.internal.telephony.CallForwardInfoEx;
+import com.android.internal.telephony.CommandException;
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.RILConstants;
+import com.android.internal.telephony.TelephonyProperties;
+
+import java.net.Authenticator;
+import java.net.PasswordAuthentication;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.mediatek.gba.GbaHttpUrlCredential;
+import com.mediatek.simservs.client.SimServs;
+import com.mediatek.simservs.client.CommunicationDiversion;
+import com.mediatek.simservs.client.CommunicationWaiting;
+import com.mediatek.simservs.client.IncomingCommunicationBarring;
+import com.mediatek.simservs.client.SimservType;
+import com.mediatek.simservs.client.OriginatingIdentityPresentation;
+import com.mediatek.simservs.client.OriginatingIdentityPresentationRestriction;
+import com.mediatek.simservs.client.TerminatingIdentityPresentation;
+import com.mediatek.simservs.client.TerminatingIdentityPresentationRestriction;
+
+import com.mediatek.simservs.client.OutgoingCommunicationBarring;
+import com.mediatek.simservs.client.policy.Actions;
+import com.mediatek.simservs.client.policy.Conditions;
+import com.mediatek.simservs.client.policy.ForwardTo;
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/// For OP01 UT @{
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.TimeZone;
+/// @}
+
+/**
+ * {@hide}
+ */
+class MMTelSSRequest {
+    static final String LOG_TAG = "MMTelSSReq";
+
+    //***** Class Variables
+    static int sNextSerial = 0;
+    static Object sSerialMonitor = new Object();
+    private static Object sPoolSync = new Object();
+    private static MMTelSSRequest sPool = null;
+    private static int sPoolSize = 0;
+    private static final int MAX_POOL_SIZE = 4;
+
+    //***** Instance Variables
+    int mSerial;
+    int mRequest;
+    Message mResult;
+    Parcel mp;
+    //For complex SS Operation: It can be used to carry the Rule or RuleSet object for
+    //MMTelSSTransmitter to parse & compare with remote XCAP server's data
+    //Add by mtk01411 2013-0911
+    Object requestParm;
+    MMTelSSRequest mNext;
+
+    /**
+     * Retrieves a new MMTelSSRequest instance from the pool.
+     *
+     * @param request MMTELSS_REQ_*
+     * @param result sent when operation completes
+     * @return a MMTelSSRequest instance from the pool.
+     */
+    static MMTelSSRequest obtain(int request, Message result) {
+        MMTelSSRequest rr = null;
+
+        synchronized (sPoolSync) {
+            if (sPool != null) {
+                rr = sPool;
+                sPool = rr.mNext;
+                rr.mNext = null;
+                sPoolSize--;
+            }
+        }
+
+        if (rr == null) {
+            rr = new MMTelSSRequest();
+        }
+
+        synchronized (sSerialMonitor) {
+            rr.mSerial = sNextSerial++;
+        }
+        rr.mRequest = request;
+        rr.mResult = result;
+        rr.mp = Parcel.obtain();
+
+        if (result != null && result.getTarget() == null) {
+            throw new NullPointerException("Message target must not be null");
+        }
+
+        // first elements in any MMTelSSRequest Parcel (Before returning the rr, it already
+        // fills two elements into the Parcel)
+        rr.mp.writeInt(request);
+        rr.mp.writeInt(rr.mSerial);
+
+        return rr;
+    }
+
+    /**
+     * Returns a MMTelSSRequest instance to the pool.
+     *
+     * Note: This should only be called once per use.
+     */
+    void release() {
+        synchronized (sPoolSync) {
+            if (sPoolSize < MAX_POOL_SIZE) {
+                this.mNext = sPool;
+                sPool = this;
+                sPoolSize++;
+                mResult = null;
+            }
+        }
+    }
+
+    private MMTelSSRequest() {
+    }
+
+    static void
+    resetSerial() {
+        synchronized (sSerialMonitor) {
+            sNextSerial = 0;
+        }
+    }
+
+    String
+    serialString() {
+        //Cheesy way to do %04d
+        StringBuilder sb = new StringBuilder(8);
+        String sn;
+
+        sn = Integer.toString(mSerial);
+
+        //sb.append("J[");
+        sb.append('[');
+        for (int i = 0, s = sn.length() ; i < 4 - s; i++) {
+            sb.append('0');
+        }
+
+        sb.append(sn);
+        sb.append(']');
+        return sb.toString();
+    }
+
+    void
+    onError(int error, Object ret) {
+        CommandException ex;
+
+        //[TBD] It should modify as XCAP Errno & Exception by mtk01411
+        ex = CommandException.fromRilErrno(error);
+
+        if (MMTelSSTransport.DBG) Rlog.d(LOG_TAG, serialString() + "< "
+                + MMTelSSTransport.requestToString(mRequest)
+                + " error: " + ex);
+
+        if (mResult != null) {
+            AsyncResult.forMessage(mResult, ret, ex);
+            mResult.sendToTarget();
+        }
+
+        if (mp != null) {
+            mp.recycle();
+            mp = null;
+        }
+    }
+}
+
+
+/**
+ * Implementation for MMTel SS Transport
+ *
+ * {@hide}
+ *
+ */
+public final class MMTelSSTransport {
+    private static final String LOG_TAG = "MMTelSS";
+    static final boolean DBG = true;
+
+    // Singleton instance
+    private static final MMTelSSTransport INSTANCE = new MMTelSSTransport();
+    private PowerManager pm = null;
+    HandlerThread mSenderThread;
+    MMTelSSTransmitter mSender;
+    String mMCC = "";
+    String mMNC = "";
+    String mXui = "user@chinaTel.com";
+    String mXcapRoot = "http://192.168.1.2:8080/";
+    String mXIntendedId = "user@chinaTel.com";
+    String mUserName = "sip:user@anritsu-cscf.com";
+    //[Modify mUserName as Single_TC_xxx by mtk01411 for UT - get local xml tested string instead
+    // of getting from XCAP server via http]
+    //String mUserName="Single_TC_1";
+    String mPassword = "password";
+    Context mContext = null;
+    private XcapMobileDataNetworkManager mXcapMobileDataNetworkManager = null;
+    private Network mNetwork = null;
+
+    //***** MMTelSSRequest
+    static final int MMTELSS_REQ_SET_CLIR               = 1;
+    static final int MMTELSS_REQ_GET_CLIR               = 2;
+    static final int MMTELSS_REQ_GET_CLIP               = 3;
+    static final int MMTELSS_REQ_GET_COLP               = 4;
+    static final int MMTELSS_REQ_GET_COLR               = 5;
+    static final int MMTELSS_REQ_SET_CB                 = 6;
+    static final int MMTELSS_REQ_GET_CB                 = 7;
+    static final int MMTELSS_REQ_SET_CF                 = 8;
+    static final int MMTELSS_REQ_GET_CF                 = 9;
+    static final int MMTELSS_REQ_SET_CW                 = 10;
+    static final int MMTELSS_REQ_GET_CW                 = 11;
+    //[SET OIP/SET TIP/SET TIR are not supported by 2/3G SS feature set]
+    static final int MMTELSS_REQ_SET_CLIP               = 12;
+    static final int MMTELSS_REQ_SET_COLP               = 13;
+    static final int MMTELSS_REQ_SET_COLR               = 14;
+    /// For OP01 UT @{
+    static final int MMTELSS_REQ_SET_CF_TIME_SLOT       = 15;
+    static final int MMTELSS_REQ_GET_CF_TIME_SLOT       = 16;
+    /// @}
+
+    //***** Events
+    static final int EVENT_SEND                 = 1;
+    static final int EVENT_WAKE_LOCK_TIMEOUT    = 2;
+    //static final int EVENT_RADIO_OFF_OR_NOT_AVAILABLE = 3;
+    //static final int EVENT_RADIO_AVAILABLE = 4;
+    //static final int EVENT_RADIO_ON = 5;
+
+    //[TBD] Need to sync the maximun number of bytes with SimServs's capability
+    static final int MMTELSS_MAX_COMMAND_BYTES = (8 * 1024);
+
+    private static final int DEFAULT_WAKE_LOCK_TIMEOUT = 5000;
+
+    WakeLock mWakeLock;
+    int mWakeLockTimeout;
+    // The number of requests pending to be sent out, it increases before calling
+    // EVENT_SEND and decreases while handling EVENT_SEND. It gets cleared while
+    // WAKE_LOCK_TIMEOUT occurs.
+    int mRequestMessagesPending = 0;
+    // The number of requests sent out but waiting for response. It increases while
+    // sending request and decreases while handling response. It should match
+    // mRequestList.size() unless there are requests no replied while
+    // WAKE_LOCK_TIMEOUT occurs.
+    int mRequestMessagesWaiting;
+
+    //(1) mDisableRuleMode=1:Remove the rule when the user disables it (e.g., user disables the
+    //  CFB/BAOC)
+    //(2) mDisableRuleMode=2:Add <rule-deactivated> into the child node of <conditions> for CF/CB
+    //  cases when the user disables it (e.g., user disables the CFB/BAOC)
+    static final int DISABLE_MODE_DELETE_RULE = 1;
+    static final int DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG = 2;
+    //(3) mDisableRuleMode=3:Change <allow> from false(i.e, call is barred) to true(i.e., call is
+    // allowed)
+    static final int DISABLE_MODE_CHANGE_CB_ALLOW = 3;
+    //Currently,it can decide the mDisableRuleMode from system property "ril.ss.disrulemode" - see
+    // the following APIs usage
+    //handleCreateNewRuleForExistingCF() and handleCreateNewRuleForExistingCB()
+    int mDisableRuleMode = DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG;
+
+    static final int RADIO_TEMPSTATE_AVAILABLE = 0;     /* Radio available */
+    static final int RADIO_TEMPSTATE_UNAVAILABLE = 1;   /* Radio unavailable temporarily */
+    private int radioTemporarilyUnavailable = RADIO_TEMPSTATE_AVAILABLE;
+
+    //I'd rather this be LinkedList or something
+    ArrayList<MMTelSSRequest> mRequestsList = new ArrayList<MMTelSSRequest>();
+
+    private static final SimServs mSimservs = SimServs.getInstance();
+
+    //[MMTelSS] For testing purpose (ref. to SimServsTest.java) Add by mtk01411 2013-0830
+    static final private String XCAP_ROOT = "http://192.168.1.2:8080/";
+    static final private String TEST_USER = "sip:user@anritsu-cscf.com";
+    static final private String TEST_DOC = "simservs";
+
+    //Following Constants definition must be same with EngineerMode/ims/ImsActivity.java
+    private final static String PROP_SS_MODE = "persist.radio.ss.mode";
+    private final static String MODE_SS_XCAP = "Prefer XCAP";
+    private final static String MODE_SS_CS = "Prefer CS";
+    private final static String PROP_SS_DISABLE_METHOD = "persist.radio.ss.xrdm";
+    private final static String PROP_SS_CFNUM = "persist.radio.xcap.cfn";
+    private final static String PROPERTY_CS_CURRENT_PHONE_ID = "gsm.radio.ss.phoneid";
+    private boolean mUpdateSingleRule = true;
+    private int mCsDomainPhoneId = 0;
+
+    private CommunicationDiversion mCdCache = null;
+    private int mCdCachePhoneId;
+    private long mCdCacheLastQueried = 0;
+    private OutgoingCommunicationBarring mOcbCache = null;
+    private int mOcbCachePhoneId;
+    private long mOcbCacheLastQueried = 0;
+    private IncomingCommunicationBarring mIcbCache = null;
+    private int mIcbCachePhoneId;
+    private long mIcbCacheLastQueried = 0;
+    private CommunicationWaiting mCwCache = null;
+    private int mCwCachePhoneId;
+    private long mCwCacheLastQueried = 0;
+    private OriginatingIdentityPresentationRestriction mOirCache = null;
+    private int mOirCachePhoneId;
+    private long mOirCacheLastQueried = 0;
+    private static final long MMTEL_CACHE_VALID_TIME = (2 * 60 * 1000);
+    private static final int HTTP_ERROR_CODE_412 = 412;
+
+    public MMTelSSTransport() {
+        //pm = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);
+        //mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
+        //mWakeLock.setReferenceCounted(false);
+        //mWakeLockTimeout = SystemProperties.getInt(TelephonyProperties.PROPERTY_WAKE_LOCK_TIMEOUT,
+        //        DEFAULT_WAKE_LOCK_TIMEOUT);
+
+        mSenderThread = new HandlerThread("MMTelSSTransmitter");
+        mSenderThread.start();
+        Looper looper = mSenderThread.getLooper();
+        mSender = new MMTelSSTransmitter(looper);
+    }
+
+    public static MMTelSSTransport getInstance() {
+        return INSTANCE;
+    }
+
+    public static SimServs getSimServs() {
+        return mSimservs;
+    }
+
+    public void registerUtService(Context context) {
+        mContext = context;
+        if (mWakeLock == null) {
+            pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+            mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, LOG_TAG);
+            mWakeLock.setReferenceCounted(false);
+            mWakeLockTimeout = SystemProperties.getInt(
+                    TelephonyProperties.PROPERTY_WAKE_LOCK_TIMEOUT, DEFAULT_WAKE_LOCK_TIMEOUT);
+        }
+
+        // Manages XCAP mobile data network connectivity related stuff
+        if (mXcapMobileDataNetworkManager == null) {
+            mXcapMobileDataNetworkManager = new XcapMobileDataNetworkManager(mContext);
+        }
+    }
+
+    private void requestXcapNetwork(int phoneId) {
+        Rlog.d(LOG_TAG, "requestXcapNetwork(): phoneId = " + phoneId
+                + ", mXcapMobileDataNetworkManager = " + mXcapMobileDataNetworkManager);
+        mNetwork = null;
+        if (mXcapMobileDataNetworkManager != null) {
+            mNetwork = mXcapMobileDataNetworkManager.acquireNetwork(phoneId);
+        }
+    }
+
+    /**
+     * Configure Simservs parameters.
+     *
+     * @param xui XUI String
+     * @param xcapRoot XCAP Root URI
+     * @param intendedId XIntended Id String
+     * @param userName username
+     * @param password password
+     * @param phoneId phone index
+     */
+    public void setSimservsInitParameters(String xui, String xcapRoot, String intendedId,
+            String userName, String password, int phoneId) {
+        mXui = xui;
+        mXcapRoot = xcapRoot;
+        mXIntendedId = intendedId;
+        mUserName = userName;
+        mPassword = password;
+
+        mSimservs.setXui(xui);
+        mSimservs.setXcapRoot(MMTelSSUtils.addXcapRootPort(xcapRoot, phoneId));
+        mSimservs.setIntendedId(intendedId);
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+
+        //[MMTelSS UT Purpose]Get userName (i.e,)
+        String tc_name = SystemProperties.get("ril.ss.tcname", "Empty");
+        Rlog.d(LOG_TAG, "setSimservsInitParameters():tc_name=" + tc_name + ", passed userName="
+                + userName);
+        if (tc_name != null && tc_name.startsWith("Single_TC_")) {
+            userName = tc_name;
+            mUserName = userName;
+        }
+
+        //[MMTelSS] In setHttpCredential():UserName will be used as the mUsername value and in
+        // SimservType.java's constructor():loadConfiguration(userName)
+        //If the userName is started with the prefix "Single_TC":It will enter the test mode & use
+        // the test cases written in SimservType.java
+        Rlog.d(LOG_TAG, "persist.mtk.simserv.username:[" +
+                SystemProperties.get("persist.mtk.simserv.username") + "]" +
+                "persist.mtk.simserv.password:[" +
+                SystemProperties.get("persist.mtk.simserv.password") + "]");
+
+        if (SystemProperties.get("persist.mtk.simserv.username") != null &&
+                !SystemProperties.get("persist.mtk.simserv.username").isEmpty() &&
+                SystemProperties.get("persist.mtk.simserv.password") != null &&
+                !SystemProperties.get("persist.mtk.simserv.password").isEmpty()) {
+            //Modify for NSN Lab IOT: Support HTTP Digest
+            //Example:username=sip:+18860000018@srnims3.srnnam.nsn-rdnet and password=ims123456
+            Authenticator.setDefault(new Authenticator() {
+                protected PasswordAuthentication getPasswordAuthentication() {
+                    return new PasswordAuthentication(
+                            SystemProperties.get("persist.mtk.simserv.username"),
+                            SystemProperties.get("persist.mtk.simserv.password").toCharArray());
+                }
+            });
+        } else {
+            GbaHttpUrlCredential gbaCredential =
+                    new GbaHttpUrlCredential(mContext, xcapRoot, subId);
+            if (mNetwork != null) {
+                gbaCredential.setNetwork(mNetwork);
+            }
+            Authenticator.setDefault(gbaCredential.getAuthenticator());
+        }
+    }
+
+    class MMTelSSTransmitter extends Handler implements Runnable {
+        public MMTelSSTransmitter(Looper looper) {
+            super(looper);
+        }
+
+        // Only allocated once
+        byte[] dataLength = new byte[4];
+
+        //***** Runnable implementation
+        public void
+        run() {
+            //setup if needed
+        }
+
+
+
+        public boolean containSpecificMedia(List<String>mediaList, int serviceClass) {
+            if (mediaList == null) return true;
+            if (mediaList.size() == 0) return true;
+            //[Note]Open Question:(1)For a voice call, it only has the "audio" media type
+            // (2)For a video call, it only has the "video" media type or have both "audio+video"
+            //Another implementation:(1)If (serviceCalss == CommandsInterface.SERVICE_CLASS_VOICE
+            // && mediaList.size()==1 && mediaType=="audio") -> return true
+            //                       (2)If (serviceCalss == CommandsInterface.SERVICE_CLASS_VIDEO
+            // && mediaList.size()==2 && one meidaType is audio the other is video") -> return true
+            for (int i = 0; i < mediaList.size(); i++) {
+                String mediaType = mediaList.get(i);
+                Rlog.d(LOG_TAG, "mediaType=" + mediaType + ",serviceClass=" + serviceClass);
+                if (mediaType.equals("audio")
+                        && (serviceClass == CommandsInterface.SERVICE_CLASS_VOICE
+                        || serviceClass == CommandsInterface.SERVICE_CLASS_NONE)) {
+                    return true;
+                } else if (mediaType.equals("video")
+                        && (serviceClass == CommandsInterface.SERVICE_CLASS_VIDEO
+                        || serviceClass == CommandsInterface.SERVICE_CLASS_NONE)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        public boolean hasExtraMedia(List<String>mediaList, int serviceClass) {
+            boolean found = false;
+            found = containSpecificMedia(mediaList, serviceClass);
+            if (found && (mediaList != null) && (mediaList.size() > 1)) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        public String getMediaType(int serviceClass) {
+            if (serviceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                return "audio";
+            } else if (serviceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                return "video";
+            }
+            return "";
+        }
+
+        public boolean isBAOC(Conditions cond, int serviceClass) {
+            //If the <cp:conditions></cp:conditions> is empty, the result of <cp:condition> is
+            // evaluated as true
+            if (cond == null)
+                return true;
+            if (cond.comprehendInternational() == false
+                    && cond.comprehendRoaming() == false
+                    && containSpecificMedia(cond.getMedias(), serviceClass)) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        public boolean isBAIC(Conditions cond, int serviceClass) {
+            //If the <cp:conditions></cp:conditions> is empty, the result of <cp:condition> is
+            // evaluated as true
+            if (cond == null)
+                return true;
+            if (cond.comprehendInternational() == false
+                    && cond.comprehendRoaming() == false
+                    && cond.comprehendAnonymous() == false
+                    && containSpecificMedia(cond.getMedias(), serviceClass)) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+
+        public void handleGetCLIR(MMTelSSRequest rr) {
+            //See ril_ss.c's requestClirOperation() & CLIRListPreference.java
+            //1(Permantently provisioned),3(Temporary presentation disallowed),
+            //4(Temporary presentation allowed),0(CLIR not provisioned),2(network error)
+            int presentation_mode = 1;
+            int get_clir_result = CommandsInterface.CLIR_DEFAULT;
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleGetCLIR(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            //
+            try {
+                OriginatingIdentityPresentationRestriction oir;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleGetCLIR(): mOirCache = " + mOirCache + ", curTime = "
+                        + curTime + ", mOirCacheLastQueried = " + mOirCacheLastQueried);
+                if ((mOirCache != null) && (phoneId == mOirCachePhoneId) &&
+                        (mOirCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleGetCLIR(): using ETAG mOirCache: " + mOirCache);
+                    requestXcapNetwork(phoneId);
+                    oir = mOirCache;
+                    oir.setNetwork(mNetwork);
+                    oir.refresh();
+                    mOirCacheLastQueried = curTime;
+                } else if ((mOirCache != null) && (phoneId == mOirCachePhoneId) &&
+                        ((curTime >= mOirCacheLastQueried)
+                        && ((curTime - mOirCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleGetCLIR(): using mOirCache: " + mOirCache);
+                    oir = mOirCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleGetCLIR(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    oir = mSimservs.getOriginatingIdentityPresentationRestriction(true, mNetwork);
+                    mOirCache = oir;
+                    mOirCachePhoneId = phoneId;
+                    mOirCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleGetCLIR(): new mOirCache = " + mOirCache
+                            + ", curTime = " + curTime);
+                }
+
+                boolean restricted = oir.isDefaultPresentationRestricted();
+                if (restricted == true) {
+                    //restrict CLI presentation
+                    presentation_mode = 3;
+                    get_clir_result = CommandsInterface.CLIR_INVOCATION;
+                } else {
+                    //allow CLI presentation
+                    presentation_mode = 4;
+                    get_clir_result = CommandsInterface.CLIR_SUPPRESSION;
+                }
+
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCLIR(): XcapException");
+                mOirCache = null;
+                mOirCachePhoneId = -1;
+                mOirCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCLIR(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCLIR(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                //Something is wrong:Set presentation_mode=2 for upper application
+                Rlog.d(LOG_TAG, "handleGetCLIR():Start to Print Stack Trace");
+                mOirCache = null;
+                mOirCachePhoneId = -1;
+                mOirCacheLastQueried = 0;
+
+                presentation_mode = 2;
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+            }
+            //
+
+            //[Example]
+            //Note that Spec 22.030 AnnexB. - only CF/CB/CW will have service class to be specified
+            //For CLIP/CLIR/COLP/COLR will not have service class to be specified
+            if (rr.mResult != null) {
+                int get_clir_response [] = new int[2];
+                get_clir_response[0] = get_clir_result;
+                get_clir_response[1] = presentation_mode; //Only 1(Permantently provisioned),
+                                                          //3(Temporary presentation disallowed),
+                                                          //4(Temporary presentation allowed)
+                                                          //are allowed
+                AsyncResult.forMessage(rr.mResult, get_clir_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCLIP(MMTelSSRequest rr) {
+            //GsmMMiCode.java onQueryComplete():0(disabled), 1(enabled)
+            int reqNo = -1;
+            int serialNo = -1;
+            int get_clip_result = 0; //disabled
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleGetCLIP(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleGetCLIP(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                OriginatingIdentityPresentation oip =
+                        mSimservs.getOriginatingIdentityPresentation(true, mNetwork);
+                Rlog.d(LOG_TAG, "handleGetCLIP():active=" + oip.isActive());
+                if (oip.isActive()) {
+                    get_clip_result = 1; //enabled
+                } else {
+                    get_clip_result = 0; //disabled
+                }
+
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCLIP(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCLIP(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCLIP(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCLIP():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+            }
+
+            if (rr.mResult != null) {
+                int get_clip_response [] = new int[1];
+                get_clip_response[0] = get_clip_result;
+                AsyncResult.forMessage(rr.mResult, get_clip_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCOLP(MMTelSSRequest rr) {
+            //+COLP:n,m (n:0(disabled),1(enabled); m:0(not provision),1(provision),2(unknonw))
+            //See GsmMMiCode.java- onGetColpComplete()
+            //In IMS/XCAP, SS service should be provisioned to each user let him/her to configure
+            // this service
+            //Only the service is provisioned to the user, he/she is able to configure
+
+            int reqNo = -1;
+            int serialNo = -1;
+            int get_colp_response [] = new int[2];
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleGetCOLP(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleGetCOLP(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                TerminatingIdentityPresentation tip =
+                        mSimservs.getTerminatingIdentityPresentation(true, mNetwork);
+                Rlog.d(LOG_TAG, "handleGetCOLP():active=" + tip.isActive());
+                if (tip.isActive()) {
+                    //According to TS24.608 Section 4.5.1:The TIP service is activated at
+                    // provisioning and deactived at withdrawal
+                    get_colp_response[0] = 1; //enabled
+                    get_colp_response[1] = 1; //provision
+                } else {
+                    get_colp_response[0] = 0; //disabled
+                    get_colp_response[1] = 0; //Not provision
+                }
+
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCOLP(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCOLP(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCOLP(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCOLP():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                           CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            if (rr.mResult != null) {
+                //get_colp_response[0] = 0; //disabled
+                //2nd parameter: Provios or not (2:un-known In this way, not expect the user will
+                // configure COLP)
+                //get_colp_response[1] = 2; //But GsmMMiCode.java- onGetColpComplete(): only cares
+                // this parameter (provison or not!)
+                AsyncResult.forMessage(rr.mResult, get_colp_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCOLR(MMTelSSRequest rr) {
+            //See GsmMMiCode.java- onGetColrComplete(): Only check result[0] this parameter
+
+            int reqNo = -1;
+            int serialNo = -1;
+            int get_colr_response [] = new int[1];
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleGetCOLR(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleGetCOLR(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                TerminatingIdentityPresentationRestriction tir =
+                        mSimservs.getTerminatingIdentityPresentationRestriction(true, mNetwork);
+                Rlog.d(LOG_TAG, "handleGetCOLR():active=" + tir.isActive());
+                if (tir.isActive()) {
+                    //According to TS24.608 Section 4.5.1:The TIR service is activated at
+                    // provisioning and deactived at withdrawal
+                    get_colr_response[0] = 1; //enabled/Provision
+
+                } else {
+                    get_colr_response[0] = 0; //disabled/Not Provision
+                }
+
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCOLR(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCOLR(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCOLR(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCOLR():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+
+            if (rr.mResult != null) {
+                //But GsmMMiCode.java- onGetColrComplete(): only cares this parameter
+                // (provison or not!)
+                //get_colr_response[0] = 2; //unknown (In this way, not expect the user will
+                // configure COLR)
+                AsyncResult.forMessage(rr.mResult, get_colr_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+
+        public void handleGetCW(MMTelSSRequest rr) {
+            int reqNo = -1;
+            int serialNo = -1;
+            int cwServiceClass = -1;
+            int get_cw_response [] = new int[2];
+            int phoneId = 0;
+
+            //As per 3GPP TS 24.083, section 1.6 UE doesn't need to send service class parameter
+            // in call waiting interrogation  to network
+            //For CW Activation, it can only active for some specific service class but the query
+            // result will be returned supported status of all service classes
+            //[TODO-Question]It seems that XCAP does not support to enable CW according to
+            // different service classes!
+            try {
+                rr.mp.setDataPosition(0);
+                reqNo = rr.mp.readInt();
+                serialNo = rr.mp.readInt();
+                cwServiceClass = rr.mp.readInt();
+                phoneId = rr.mp.readInt();
+                Rlog.d(LOG_TAG, "Read GET_CW serviceClass=" + cwServiceClass);
+
+                if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                    Rlog.d(LOG_TAG, "handleGetCW(): !isPreferXcap()");
+                    throw new UnknownHostException();
+                }
+
+                //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+                if (cwServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                        | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                    cwServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                }
+
+                CommunicationWaiting cw;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleGetCW(): mCwCache = " + mCwCache + ", curTime = "
+                        + curTime + ", mCwCacheLastQueried = " + mCwCacheLastQueried);
+                if ((mCwCache != null) && (phoneId == mCwCachePhoneId) &&
+                        (mCwCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleGetCW(): using ETAG mCwCache: " + mCwCache);
+                    requestXcapNetwork(phoneId);
+                    cw = mCwCache;
+                    cw.setNetwork(mNetwork);
+                    cw.refresh();
+                    mCwCacheLastQueried = curTime;
+                } else if ((mCwCache != null) && (phoneId == mCwCachePhoneId) &&
+                        ((curTime >= mCwCacheLastQueried)
+                        && ((curTime - mCwCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleGetCW(): using mCwCache: " + mCwCache);
+                    cw = mCwCache;
+                } else {
+                    requestXcapNetwork(phoneId);
+
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleGetCW(): XcapRoot = " + mXcapRoot);
+                        throw new UnknownHostException();
+                    }
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    cw = mSimservs.getCommunicationWaiting(true, mNetwork);
+                    mCwCache = cw;
+                    mCwCachePhoneId = phoneId;
+                    mCwCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleGetCW(): new mCwCache = " + mCwCache
+                            + ", curTime = " + curTime);
+                }
+                //[Question] Always support CW in XCAP?
+                if (cw.isActive()) {
+                    get_cw_response[0] = 1;
+                }
+                else {
+                    get_cw_response[0] = 0;
+                }
+                Rlog.d(LOG_TAG, "handleGetCW(): isActive = " + get_cw_response[0]);
+
+            } catch (UnknownHostException unknownHostException) {
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, unknownHostException);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCW(): XcapException");
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCW(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCW(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCW():Start to Print Stack Trace");
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+            }
+            //
+
+            //[Example]
+            if (rr.mResult != null) {
+                //get_cw_response[0] = 1; //0:Disabled, 1:Enabled
+                //serviceClass:SERVICE_CLASS_VOICE(1), SERVICE_CLASS_VIDEO(512)
+                if (get_cw_response[0] == 1) {
+                    //Service Class (If get_cw_response[0] is 1, get_cw_response[1] must set bit#1
+                    // & enable corresponding serviceClass's bit)
+                    //See ril_ss.c's requestCallWaitingOperation()
+                    //In CallWaitingCheckBoxPreference.java's handleGetCallWaitingResponse()
+                    //-> setChecked(((cwArray[0] == 1) && ((cwArray[1] & 0x01) == 0x01)));
+                    //If VIDEO call waiting is enabled, it shoud set: get_cw_response[0]=1
+                    // && get_cw_response[1]= 513 (SERVICE_CLASS_VIDEO | 1);
+                    //In GsmMmiCode.java's onQueryComplete():
+                    //-> createQueryCallWaitingResultMessage(ints[1])
+                    //-> Check each bit:
+                    // sb.append(serviceClassToCFString(classMask & serviceClass):
+                    // Check each bit then append string
+
+                    if (cwServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                        //As per 3GPP TS 24.083, section 1.6 UE doesn't need to send service
+                        // class parameter in call waiting interrogation  to network
+                        //For CW Activation, it can only active for some specific service class
+                        // but the query result will be returned supported status of all service
+                        // classes
+                        get_cw_response[1] |= CommandsInterface.SERVICE_CLASS_VOICE;
+                        get_cw_response[1] |= CommandsInterface.SERVICE_CLASS_VIDEO;
+                    } else {
+                        get_cw_response[1] |= cwServiceClass;
+                        if (cwServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                            //Need to modify:If a user presses MMI string to query CW & only vidoe
+                            // call waiting is enabled
+                            //In this way, MMI code callback handler will regard as both voice
+                            // and video call waitings are enabled
+                            get_cw_response[1] |= CommandsInterface.SERVICE_CLASS_VOICE;
+                        }
+                    }
+                    Rlog.d(LOG_TAG, "handleGetCW(): class = " + get_cw_response[1]);
+                }
+                AsyncResult.forMessage(rr.mResult, get_cw_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCB(MMTelSSRequest rr) {
+            int reqNo = -1;
+            int serialNo = -1;
+            int cbServiceClass = -1;
+            int phoneId = 0;
+            String cBFacility = "";
+            int get_cb_response [] = new int[1];
+            //default: CB is not disabled!
+            get_cb_response[0] = 0;
+
+            try {
+                rr.mp.setDataPosition(0);
+                reqNo = rr.mp.readInt();
+                serialNo = rr.mp.readInt();
+                cBFacility = rr.mp.readString();
+                cbServiceClass = rr.mp.readInt();
+                phoneId = rr.mp.readInt();
+                Rlog.d(LOG_TAG, "Read GET_CB Facility=" + cBFacility + ",serviceClass="
+                        + cbServiceClass);
+
+                if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                    Rlog.d(LOG_TAG, "handleGetCB(): !isPreferXcap()");
+                    throw new UnknownHostException();
+                }
+
+                int num_of_comparision = 0;
+
+                //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+                if (cbServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                        | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                    cbServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                }
+
+                if (cbServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                    cbServiceClass = CommandsInterface.SERVICE_CLASS_VOICE;
+                    //one is to match audio (i.e., serviceClass = SERVICE_CLASS_VOICE),
+                    // the other is to match video (i.e., SERVICE_CLASS_VIDEO)
+                    num_of_comparision = 2;
+                    Rlog.d(LOG_TAG, "cbServiceClass==0, try to 1st match by using"
+                            + " SERVICE_CLASS_VOICE");
+                } else {
+                    //Specific serviceClass (i.e., value is not 0) is carried from the upper layer
+                    num_of_comparision = 1;
+                }
+
+
+                //According to the cBFacility to choose the XML node to check CB's ruleset
+                if (cBFacility.equals(CommandsInterface.CB_FACILITY_BAOC) ||
+                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOIC) ||
+                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                    OutgoingCommunicationBarring ocb;
+                    long curTime = System.currentTimeMillis();
+                    Rlog.d(LOG_TAG, "handleGetCB(): mOcbCache = " + mOcbCache + ", curTime = "
+                            + curTime + ", mOcbCacheLastQueried = " + mOcbCacheLastQueried);
+                    if ((mOcbCache != null) && (phoneId == mOcbCachePhoneId) &&
+                            (mOcbCache.isSupportEtag())) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): using ETAG mOcbCache: " + mOcbCache);
+                        requestXcapNetwork(phoneId);
+                        ocb = mOcbCache;
+                        ocb.setNetwork(mNetwork);
+                        ocb.refresh();
+                        mOcbCacheLastQueried = curTime;
+                    } else if ((mOcbCache != null) && (phoneId == mOcbCachePhoneId) &&
+                            ((curTime >= mOcbCacheLastQueried)
+                            && ((curTime - mOcbCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): using mOcbCache: " + mOcbCache);
+                        ocb = mOcbCache;
+                    } else {
+                        requestXcapNetwork(phoneId);
+
+                        mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                        mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                        mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                        if (TextUtils.isEmpty(mXcapRoot)) {
+                            Rlog.d(LOG_TAG, "handleGetCB(): XcapRoot = " + mXcapRoot);
+                            throw new UnknownHostException();
+                        }
+
+                        setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName,
+                                mPassword, phoneId);
+
+                        ocb = mSimservs.getOutgoingCommunicationBarring(true, mNetwork);
+                        mOcbCache = ocb;
+                        mOcbCachePhoneId = phoneId;
+                        mOcbCacheLastQueried = curTime;
+                        Rlog.d(LOG_TAG, "handleGetCB(): new mOcbCache = " + mOcbCache
+                                + ", curTime = " + curTime);
+                    }
+
+                    RuleSet ruleSet = ocb.getRuleSet();
+                    List<Rule> ruleList = null;
+
+                    if (ruleSet != null) {
+                        ruleList = ruleSet.getRules();
+                        if (ruleList == null) {
+                            Rlog.d(LOG_TAG, "Dump Get MO CB XML: ruleset with empty rules");
+                        } else {
+                            Rlog.d(LOG_TAG, "Dump Get MO CB XML:" + ruleSet.toXmlString());
+                        }
+                    } else {
+                        Rlog.d(LOG_TAG, "No MO related CB rules in remote server");
+                    }
+
+                    //Note that: If no ant configuration is stored in XCAP server (e.g., empty
+                    // xml string), ruleList will be null
+                    if (ruleList != null) {
+                        for (int it = 0; it < num_of_comparision; it++) {
+                            if (it == 1
+                                    && cbServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                                //2nd time to match all rules by using SERVICE_CLASS_VIDEO
+                                cbServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                                Rlog.d(LOG_TAG, "cbServiceClass==0, try to 2nd match by using "
+                                        + "SERVICE_CLASS_VIDEO");
+                            }
+                            //Check each rule & its corresponding condition/action
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                Rlog.d(LOG_TAG, "handleGetCB():MO-facility=" + cBFacility
+                                        + ",action=" + action.isAllow());
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleGetCB():MO-international="
+                                            + cond.comprehendInternational() + ",roaming="
+                                            + cond.comprehendRoaming());
+                                    mediaList = cond.getMedias();
+                                } else {
+                                    Rlog.d(LOG_TAG, "handleGetCB():Empty MO cond (cond==null)"
+                                            + " for this rule=" + r);
+                                }
+
+                                if ((cond != null && cond.comprehendInternational()) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOIC) &&
+                                        containSpecificMedia(mediaList, cbServiceClass)) {
+                                    if (action.isAllow() == false && (cond != null
+                                            && cond.comprehendRuleDeactivated() == false)) {
+                                        //BAOIC is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+                                    break;
+                                } else if ((cond != null && cond.comprehendInternationalExHc()) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOICxH) &&
+                                        containSpecificMedia(mediaList, cbServiceClass)) {
+                                    if (action.isAllow() == false && (cond != null
+                                            && cond.comprehendRuleDeactivated() == false)) {
+                                        //BAOICxH is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+                                } else if (isBAOC(cond, cbServiceClass) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAOC)) {
+                                    //cond == null:BAOC is enabled
+                                    //cond != null && cond.comprehendRuleDeactivated() == false =>
+                                    // E.g., <cp:conditions><media>audio</media></cp:conditions>
+                                    if (action.isAllow() == false && (cond == null ||
+                                            (cond != null
+                                            && cond.comprehendRuleDeactivated() == false))) {
+                                        //BAOC is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+                                    break;
+                                }
+                            } //end of for-loop(check each rule)
+                        } //end of for-loop(check all possible service classes)
+                    } else {
+                        //MO Barring Call is disabled
+                        Rlog.d(LOG_TAG, "ruleList is null, MO CB is disabled");
+                        get_cb_response[0] = 0;
+                    }
+
+                } else if (cBFacility.equals(CommandsInterface.CB_FACILITY_BAIC) ||
+                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                    IncomingCommunicationBarring icb;
+                    long curTime = System.currentTimeMillis();
+                    Rlog.d(LOG_TAG, "handleGetCB(): mIcbCache = " + mIcbCache + ", curTime = "
+                            + curTime + ", mIcbCacheLastQueried = " + mIcbCacheLastQueried);
+                    if ((mIcbCache != null) && (phoneId == mIcbCachePhoneId) &&
+                            (mIcbCache.isSupportEtag())) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): using ETAG mIcbCache: " + mIcbCache);
+                        requestXcapNetwork(phoneId);
+                        icb = mIcbCache;
+                        icb.setNetwork(mNetwork);
+                        icb.refresh();
+                        mIcbCacheLastQueried = curTime;
+                    } else if ((mIcbCache != null) && (phoneId == mIcbCachePhoneId) &&
+                            ((curTime >= mIcbCacheLastQueried)
+                            && ((curTime - mIcbCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): using mIcbCache: " + mIcbCache);
+                        icb = mIcbCache;
+                    } else {
+                        requestXcapNetwork(phoneId);
+
+                        mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                        mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                        mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                        if (TextUtils.isEmpty(mXcapRoot)) {
+                            Rlog.d(LOG_TAG, "handleGetCB(): XcapRoot = " + mXcapRoot);
+                            throw new UnknownHostException();
+                        }
+
+                        setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName,
+                                mPassword, phoneId);
+
+                        icb = mSimservs.getIncomingCommunicationBarring(true, mNetwork);
+                        mIcbCache = icb;
+                        mIcbCachePhoneId = phoneId;
+                        mIcbCacheLastQueried = curTime;
+                        Rlog.d(LOG_TAG, "handleGetCB(): new mIcbCache = " + mIcbCache
+                                + ", curTime = " + curTime);
+                    }
+
+                    RuleSet ruleSet = icb.getRuleSet();
+                    List<Rule> ruleList = null;
+
+                    if (ruleSet != null) {
+                        ruleList = ruleSet.getRules();
+                        if (ruleList == null) {
+                            Rlog.d(LOG_TAG, "Dump Get MT CB XML: ruleset with empty rules");
+                        } else {
+                            Rlog.d(LOG_TAG, "Dump Get MT CB XML:" + ruleSet.toXmlString());
+                        }
+                    } else {
+                        Rlog.d(LOG_TAG, "No MT related CB rules in remote server");
+                    }
+
+                    //Note that: If no ant configuration is stored in XCAP server (e.g.,
+                    // empty xml string), ruleList will be null
+                    if (ruleList != null) {
+                        for (int it = 0; it < num_of_comparision; it++) {
+                            if (it == 1
+                                    && cbServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                                //2nd time to match all rules by using SERVICE_CLASS_VIDEO
+                                cbServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                                Rlog.d(LOG_TAG, "cbServiceClass==0, try to 2nd match by using"
+                                        + " SERVICE_CLASS_VIDEO");
+                            }
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                Rlog.d(LOG_TAG, "handleGetCB():MT-facility=" + cBFacility
+                                        + ",action=" + action.isAllow());
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleGetCB():MT-international="
+                                            + cond.comprehendInternational() + ",roaming="
+                                            + cond.comprehendRoaming() + ",anonymous="
+                                            + cond.comprehendAnonymous());
+                                    mediaList = cond.getMedias();
+                                } else {
+                                    Rlog.d(LOG_TAG, "handleGetCB():Empty MT cond (cond==null)"
+                                            + " for this rule=" + r);
+                                }
+
+                                if ((cond != null && cond.comprehendRoaming()) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAICr) &&
+                                        containSpecificMedia(mediaList, cbServiceClass)) {
+                                    if (action.isAllow() == false && (cond != null
+                                            && cond.comprehendRuleDeactivated() == false)) {
+                                        //BAICr is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+                                } else if (isBAIC(cond, cbServiceClass) &&
+                                        cBFacility.equals(CommandsInterface.CB_FACILITY_BAIC)) {
+                                    //cond == null:BAIC is enabled
+                                    //cond != null && cond.comprehendRuleDeactivated() == false
+                                    // => E.g., <cp:conditions><media>audio</media></cp:conditions>
+                                    if (action.isAllow() == false && (cond == null || (cond != null
+                                            && cond.comprehendRuleDeactivated() == false))) {
+                                        //BAIC is enabled
+                                        get_cb_response[0] |= cbServiceClass;
+                                    } else {
+                                        get_cb_response[0] = 0;
+                                    }
+
+                                }
+                            } //end of for-loop(check each rule)
+                        } //end of for-loop(check each possible service class)
+                    } else {
+                        //MT Barring Call is disabled
+                        Rlog.d(LOG_TAG, "ruleList is null, MT CB is disabled");
+                        get_cb_response[0] = 0;
+                    }
+                } else {
+                    //Add handling Barring Service for 330(AB)/333(AG)/353(AC) cases - Only allow
+                    // to unlock (i.e.,disable)
+                    /***
+                     * "AO" BAOC (Barr All Outgoing Calls) (refer 3GPP TS 22.088 [6] clause 1)
+                     * "OI" BOIC (Barr Outgoing International Calls) (refer 3GPP TS 22.088 [6]
+                     * clause 1)
+                     * "OX" BOIC exHC (Barr Outgoing International Calls except to Home Country)
+                     * (refer 3GPP TS 22.088 [6] clause 1)
+                     * "AI" BAIC (Barr All Incoming Calls) (refer 3GPP TS 22.088 [6] clause 2)
+                     * "IR" BIC Roam (Barr Incoming Calls when Roaming outside the home country)
+                     * (refer 3GPP TS 22.088 [6] clause 2)
+                     * "AB" All Barring services (refer 3GPP TS 22.030 [19]) (applicable only for
+                     * <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                     * "AG" All outGoing barring services (refer 3GPP TS 22.030 [19]) (applicable
+                     * only for <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                     * "AC" All inComing barring services (refer 3GPP TS 22.030 [19]) (applicable
+                     * only for <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                     */
+                    Rlog.d(LOG_TAG, "handleGetCB(): Not support query for CB Facility="
+                            + cBFacility);
+                }
+
+            } catch (UnknownHostException unknownHostException) {
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, unknownHostException);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCB(): XcapException");
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCB(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCB():Start to Print Stack Trace");
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                get_cb_response[0] = 0;
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+            }
+
+            //[Example]Fill the fake-result just for testing first by mtk01411
+            if (rr.mResult != null) {
+                //If response[0] = 0 (means that disable), otherwise response[0] will be set
+                // the corresponding serviceClass for this CallBarring
+                /*
+                if (cBFacility.equals(CommandsInterface.CB_FACILITY_BAOIC)) {
+                    get_cb_response[0] = CommandsInterface.SERVICE_CLASS_VOICE;
+                } else {
+                    //It means that: CB is disabled for this facility
+                    get_cb_response[0] = CommandsInterface.SERVICE_CLASS_NONE;
+                }
+                 */
+
+                //For Call Setting query: In CallBarringBasePreference.java's
+                // handleGetCallBarringResponse()
+                //-> int value = ints[0]; value = value & mServiceClass;
+                //It means that if the query result (e.g., both voice & video calls enable CB):
+                // Please set corresponding bit of this servicClass
+                //E.g., get_cb_response[0] = 513 (SERVICE_CLASS_VIDEO:512 + SERVICE_CLASS_VOICE:1)
+                //For GsmMmiCode query: In GsmMmiCode.java's onQueryComplete()
+                //-> createQueryCallBarringResultMessage(ints[0]):
+                //-> Check each bit then append corresponding string:
+                // sb.append(serviceClassToCFString(classMask & serviceClass));
+                AsyncResult.forMessage(rr.mResult, get_cb_response, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleGetCF(MMTelSSRequest rr) {
+            int reqNo = -1;
+            int serialNo = -1;
+            int numInfos = 1;
+            CallForwardInfo infos[] = null;
+            ArrayList<CallForwardInfo> queriedCallForwardInfoList;
+            queriedCallForwardInfoList = new ArrayList<CallForwardInfo>();
+
+            int cfAction = -1;
+            int reason = -1;
+            int serviceClass = -1;
+            int orgServiceClass = -1;
+            String cfNumber = "";
+            String CFPhoneNum = "";
+            int queryStatus = 0; //0: DISABLE, 1: ENABLE
+            int noReplyTimer = 20;
+            int phoneId = 0;
+
+            try {
+                //Solution#1: Parcel:int(request),int(mSerial),int(status),int(reason),
+                //int(serviceClass)
+                //byte data[];
+                //data = rr.mp.marshall();
+                //Note that: It must invoke Parcel's recycle() here because in obtain():
+                // It gets a Parcel object from pool then writes two int values into this object
+                //Now: It already handles this request, it's time to recycle this object back to
+                // the pool
+                //rr.mp.recycle();
+                //rr.mp = null;
+                //int reqNo = data[0];
+                //int serialNo = data[4];
+                //int status = data[8];
+                //int reason = data[12];
+                //int serviceClass = data[16];
+
+                //Solution#2: Reset Data Position back to 0 (head) to start to read the data
+                // filled previously
+                rr.mp.setDataPosition(0);
+                reqNo = rr.mp.readInt();
+                serialNo = rr.mp.readInt();
+                cfAction = rr.mp.readInt();
+                reason = rr.mp.readInt();
+                serviceClass = rr.mp.readInt();
+                orgServiceClass = serviceClass;
+                cfNumber = rr.mp.readString();
+                phoneId = rr.mp.readInt();
+
+                if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                    Rlog.d(LOG_TAG, "handleGetCF(): !isPreferXcap()");
+                    throw new UnknownHostException();
+                }
+
+                Rlog.d(LOG_TAG, "Read from CF parcel:req=" + requestToString(reqNo) + ",cfAction="
+                        + cfAction + ",reason=" + reason + ",serviceClass=" + serviceClass
+                        + ",number=" + cfNumber);
+
+                CommunicationDiversion cd;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleGetCF(): mCdCache = " + mCdCache + ", curTime = "
+                        + curTime + ", mCdCacheLastQueried = " + mCdCacheLastQueried);
+                if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        (mCdCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleGetCF(): using ETAG mCdCache: " + mCdCache);
+                    requestXcapNetwork(phoneId);
+                    cd = mCdCache;
+                    cd.setNetwork(mNetwork);
+                    cd.refresh();
+                    mCdCacheLastQueried = curTime;
+                } else if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        ((curTime >= mCdCacheLastQueried)
+                        && ((curTime - mCdCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleGetCF(): using mCdCache: " + mCdCache);
+                    cd = mCdCache;
+                } else {
+                    requestXcapNetwork(phoneId);
+
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleGetCF(): XcapRoot = " + mXcapRoot);
+                        throw new UnknownHostException();
+                    }
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+
+                    cd = mSimservs.getCommunicationDiversion(true, mNetwork);
+                    mCdCache = cd;
+                    mCdCachePhoneId = phoneId;
+                    mCdCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleGetCF(): new mCdCache = " + mCdCache
+                            + ", curTime = " + curTime);
+                }
+
+                //[M2]Reference to SimServsTest.java
+                //XcapDocumentSelector documentSelector = new XcapDocumentSelector(
+                //XcapConstants.AUID_RESOURCE_LISTS, TEST_USER, TEST_DOC);
+                //Rlog.d(LOG_TAG, "document selector is " + documentSelector.toString());
+                //XcapUri xcapUri = new XcapUri();
+                //xcapUri.setXcapRoot(XCAP_ROOT).setDocumentSelector(documentSelector);
+                //CommunicationDiversion cd =
+                //  mSimservs.getCommunicationDiversion(xcapUri, TEST_USER,"password");
+                Rlog.d(LOG_TAG, "handleGetCF():GetRuleSet from cd");
+
+                RuleSet ruleSet = cd.getRuleSet();
+                //In Communication Diversion's RuleSet, it may have several rules (e.g., rule
+                // for CFU, rule for CFB, rule for CFNoAnswer, rule for CFNotReachable)
+                List<Rule> ruleList = null;
+
+                if (ruleSet != null) {
+                    ruleList = ruleSet.getRules();
+                } else {
+                    Rlog.d(LOG_TAG, "No CF related rules in remote server");
+                }
+
+                //Note that: If no ant configuration is stored in XCAP server (e.g., empty
+                // xml string), ruleList will be null
+                if (ruleList != null) {
+
+                    int num_of_expansion = 1;
+                    if (reason == CommandsInterface.CF_REASON_ALL_CONDITIONAL) {
+                        //In this case: User inputs "*#004#"
+                        //CF Conditional (BUSY/NO_REPLY/NOT_REACHABLE/NOT_REGISTERED)x4
+                        num_of_expansion = 4;
+                    } else if (reason == CommandsInterface.CF_REASON_ALL) {
+                        //CF Conditional (BUSY/NO_REPLY/NOT_REACHABLE/NOT_REGISTERED)x4 + CFUx1
+                        //In this case: User inputs "*#002#"
+                        num_of_expansion = 5;
+                    }
+
+                    for (int n = 0; n < num_of_expansion; n++) {
+                        if (num_of_expansion != 1) {
+                            if (n == 0) reason = CommandsInterface.CF_REASON_BUSY;
+                            else if (n == 1) reason = CommandsInterface.CF_REASON_NO_REPLY;
+                            else if (n == 2) reason = CommandsInterface.CF_REASON_NOT_REACHABLE;
+                            else if (n == 3) reason = CommandsInterface.CF_REASON_NOT_REGISTERED;
+                            else if (n == 4) reason = CommandsInterface.CF_REASON_UNCONDITIONAL;
+                        }
+
+                        Rlog.d(LOG_TAG, "num_of_expansion=" + num_of_expansion + ": with round="
+                                + (n + 1) + ",with reason=" + reason);
+
+                        //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+                        if (orgServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                                | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                            serviceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                        }
+
+                        //E.g.,GsmMmiCode:MMI String can be :*#21#[CFU] or *#67#[CFB] or
+                        // *#61#[CF NoAnswer] or *#62#[CF Not Reachable]
+                        //=> Without serviceClass information, then serviceClass=0 is passed to
+                        // MMTelSS
+                        int num_of_comparision = 0;
+
+                        if (orgServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                            serviceClass = CommandsInterface.SERVICE_CLASS_VOICE;
+                            //one is to match audio (i.e., serviceClass = SERVICE_CLASS_VOICE), the
+                            // other is to match video (i.e., SERVICE_CLASS_VIDEO)
+                            num_of_comparision = 2;
+                            Rlog.d(LOG_TAG, "serviceClass==0, try to 1st match by using"
+                                    + " SERVICE_CLASS_VOICE");
+                        } else {
+                            //Specific serviceClass (i.e., value is not 0) is carried from the
+                            // upper layer
+                            num_of_comparision = 1;
+                        }
+
+                        for (int it = 0; it < num_of_comparision; it++) {
+
+                            if (it == 1 && serviceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                                //2nd time to match all rules by using SERVICE_CLASS_VIDEO
+                                serviceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                                Rlog.d(LOG_TAG, "serviceClass==0, try to 2nd match by using "
+                                        + "SERVICE_CLASS_VIDEO");
+                            }
+
+                            Rlog.d(LOG_TAG, "num_of_comparision=" + num_of_comparision
+                                    + ": with round=" + (it + 1) + ",with service class="
+                                    + serviceClass);
+
+                            //Check each rule & its corresponding condition/action
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():busy=" + cond.comprehendBusy()
+                                            + ",NoAnswer=" + cond.comprehendNoAnswer()
+                                            + ",NoReachable=" + cond.comprehendNotReachable()
+                                            + ",NotRegistered=" + cond.comprehendNotRegistered());
+                                    mediaList = cond.getMedias();
+                                } else {
+                                    Rlog.d(LOG_TAG, "handleGetCF():Empty cond (cond==null) "
+                                            + "for this rule=" + r);
+                                }
+
+                                //See queryCallForwardStatus(): cfAction is always set to 2
+                                if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_UNCONDITIONAL &&
+                                        ((cond != null && cond.comprehendBusy() == false &&
+                                        cond.comprehendNoAnswer() == false &&
+                                        cond.comprehendNotRegistered() == false &&
+                                        cond.comprehendNotReachable() == false) &&
+                                        cond.comprehendRuleDeactivated() == false || cond == null)
+                                        && containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFU is enabled on server");
+                                    //[CFU]CFU is enabled, set queryStatus as 1
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    //timeSeconds: This field is not required by CFU (Only required
+                                    // by CFNoAnswer)
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_BUSY &&
+                                        (cond != null && cond.comprehendBusy() == true
+                                        && cond.comprehendRuleDeactivated() == false) &&
+                                        containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFB is enabled on server");
+                                    //[CFB]CFB is ensabled, set queryStatus as 0
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_NO_REPLY &&
+                                        (cond != null && cond.comprehendNoAnswer() == true &&
+                                        cond.comprehendRuleDeactivated() == false) &&
+                                        containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFNoAnswer is enabled on "
+                                            + "server");
+                                    //[CFNoAnswer]CFNoReply is ensabled, set queryStatus as 1
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_NOT_REACHABLE &&
+                                        (cond != null && cond.comprehendNotReachable() == true &&
+                                        cond.comprehendRuleDeactivated() == false) &&
+                                        containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFNotReachable is enabled"
+                                            + " on server");
+                                    //[CFNotReachable]CFNotReachable is enabled, set queryStatus
+                                    // as 1
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else if (cfAction == 2
+                                        && reason == CommandsInterface.CF_REASON_NOT_REGISTERED &&
+                                        (cond != null && cond.comprehendNotRegistered() == true &&
+                                        cond.comprehendRuleDeactivated() == false) &&
+                                        containSpecificMedia(mediaList, serviceClass)) {
+                                    Rlog.d(LOG_TAG, "handleGetCF():CFNotRegistered is enabled on "
+                                            + "server");
+                                    //[CFNotRegistered]CFNotRegistered is enabled, set queryStatus
+                                    // as 1
+                                    queryStatus = 1;
+                                    if (action.getFowardTo() != null) {
+                                        CFPhoneNum = action.getFowardTo().getTarget();
+                                    }
+                                    noReplyTimer = cd.getNoReplyTimer();
+                                    break;
+
+                                } else {
+                                    //Something wrong!
+                                    Rlog.d(LOG_TAG, "handleGetCF()from xcap:Not matched "
+                                            + "this rule!");
+                                }
+
+                            } //end of for-loop(ruleList.size())
+                            //Add this queried & matched result into the matchedCallForwardInfoList
+                            CallForwardInfo item = new CallForwardInfo();
+                            item.status = queryStatus;
+                            item.reason = reason;
+                            item.serviceClass = serviceClass;
+                            item.toa = 0;
+                            item.number = CFPhoneNum;
+                            item.timeSeconds = noReplyTimer;
+                            Rlog.d(LOG_TAG, "handleGetCF():add one record with reason=" + reason
+                                    + ",serviceClass=" + serviceClass + ",queryStatus="
+                                    + queryStatus);
+                            queriedCallForwardInfoList.add(item);
+
+                            //Reset some variables for this matching result
+                            queryStatus = 0; //0: DISABLE, 1: ENABLE
+                            CFPhoneNum = "";
+                            noReplyTimer = 20;
+                        } //end of for-loop(num_of_comparision)
+
+                    } //end of for-loop(num_of_expansion)
+
+                    //After checking all rules in the ruleset, it will update the results for this
+                    // serviceClass entry
+                    //For Call Setting query, it will be handled by
+                    // CallForwardEditPreference.java's handleGetCFResponse()
+                    //For GsmMmiCode query, it will be handled by GsmMmiCode.java's
+                    // onQueryCfComplete()
+                    int queriedSize = queriedCallForwardInfoList.size();
+
+                    infos = new CallForwardInfo[queriedSize];
+                    for (int inx = 0; inx < queriedSize; inx++) {
+                        infos[inx] = (CallForwardInfo) queriedCallForwardInfoList.get(inx);
+                    }
+
+                } else {
+                    //Empty XML String:CF is disabled, set queryStatus as 0
+                    Rlog.d(LOG_TAG, "handleGetCF():get null ruleList");
+                    infos = new CallForwardInfo[0];
+                    queryStatus = 0;
+                }
+
+            } catch (UnknownHostException unknownHostException) {
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, unknownHostException);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCF(): XcapException");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCF(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCF(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCF():Start to Print Stack Trace");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                e.printStackTrace();
+
+                //Add by mtk01411 (2014-0128)
+                //If not returns here, it may report infos.size!=0 but both info[0] and info[1] are
+                // null -> Cause JE happens in CallForwardEditPreference.java line#379:Null Pointer
+                // Exception
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+
+                }
+
+            }
+
+
+            //[Example - According to the reason to fill the queryStatus and CFPhoneNum -> These
+            // two fields are checked by application]
+            /*
+            if (reason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                CFPhoneNum = "";
+                //Note that: If CFU's queryStatus=1(active/enabled), then CFB,CFNoAnswer and
+                // CFNotReachable will be disabled on UI
+                //Because CFU means that call must be forwarded unconditionally -> In this way,
+                // UI must also disabled the editable item for others CF
+                //If CFU's queryStatus=0(no active/disabled), UI must provide the editable item
+                // of CFB,CFNoAnswer and CFNotReachable for users to set phone number as their will
+                queryStatus = 0;
+            } else {
+                queryStatus = 1;
+            }
+             */
+
+            //[Example - CF Response Structure]
+            if (rr.mResult != null) {
+                /*
+                infos[0] = new CallForwardInfo();
+                infos[0].status = queryStatus;
+                infos[0].reason = reason;
+                infos[0].serviceClass = serviceClass;
+                infos[0].toa = 0;
+                infos[0].number = CFPhoneNum;
+                infos[0].timeSeconds = noReplyTimer;
+                 */
+
+                AsyncResult.forMessage(rr.mResult, infos, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        // This API is used to create new CF rule matched the serviceclass & reason specified by
+        // the user in user's configuration at this time
+        // E.g., User wants to disable CFB for voice call and XCAP server has one rule - CFB for
+        // both voice & video calls currently
+        // In this way, we can create the rule disabled CFB for voice call first by this API
+        // then copy old rule except voice type into new rule set to present that: BAOC for video
+        // call is still enabled
+        public boolean handleCreateNewRuleForExistingCF(CommunicationDiversion cd,
+                RuleSet newRuleSet, Rule r, int setCFReason, int setCFAction,
+                int setCFServiceClass, String setCFNumber, int setCFTimeSeconds, String ruleID,
+                boolean updateSingleRule, int numExpansion, int phoneId) throws XcapException {
+            Conditions cond = r.getConditions();
+            Actions action = r.getActions();
+
+            //For testing purpose, it will read XCAP Rule Disable Mode (xrdm) from system property
+            String sDisableRuleMode = SystemProperties.get(PROP_SS_DISABLE_METHOD,
+                    Integer.toString(DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG));
+            Rlog.d(LOG_TAG, "handleCreateNewRuleForExistingCF():sDisableRuleMode="
+                    + sDisableRuleMode);
+            mDisableRuleMode = Integer.parseInt(sDisableRuleMode);
+
+            //Find this rule for this time's request
+            if (setCFAction == CommandsInterface.CF_ACTION_ENABLE
+                    || setCFAction == CommandsInterface.CF_ACTION_REGISTRATION) {
+                //Create a new rule (C1:Modify existing CFB (e.g.,forwarded number)
+                Rule cfRule = newRuleSet.createNewRule(ruleID);
+                Conditions cfCond = cfRule.createConditions();
+                Actions cfAction = cfRule.createActions();
+                Rlog.d(LOG_TAG, "handleCreateNewRuleForExistingCF():Enable CF with reason="
+                        + setCFReason + ",serviceClass=" + setCFServiceClass + ",number="
+                        + setCFNumber + ",cfTime=" + setCFTimeSeconds);
+                //Add media into this new rule
+                if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                    && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                    if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                        cfCond.addMedia("audio");
+                    } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                        cfCond.addMedia("video");
+                    } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                        cfCond.addMedia("audio");
+                        cfCond.addMedia("video");
+                    }
+                }
+
+                if (setCFReason == CommandsInterface.CF_REASON_BUSY) {
+                    cfCond.addBusy();
+                } else if (setCFReason == CommandsInterface.CF_REASON_NO_REPLY) {
+                    cfCond.addNoAnswer();
+                } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE) {
+                    cfCond.addNotReachable();
+                } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED) {
+                    cfCond.addNotRegistered();
+                } else if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                    //Not set any conditions -> always evaluate the result as true
+                }
+
+                // + [ALPS02292552] If empty, set the value from server.
+                if (setCFNumber == null || setCFNumber.isEmpty()) {
+                    setCFNumber = action.getFowardTo().getTarget();
+                    Rlog.d(LOG_TAG, "Reason: " + setCFReason +
+                        ", setCFNumber is empty or null, so update to: " + setCFNumber);
+                }
+                // - [ALPS02292552]
+
+                if (MMTelSSUtils.isOp01IccCard(phoneId) && MMTelSSUtils.isNotifyCallerTest()) {
+                    cfAction.setFowardTo(setCFNumber, false);
+                } else {
+                    cfAction.setFowardTo(setCFNumber, true);
+                }
+                cfAction.getFowardTo().setRevealIdentityToCaller(true);
+                cfAction.getFowardTo().setRevealIdentityToTarget(true);
+                if (updateSingleRule && (1 == numExpansion)) {
+                    cd.saveRule(ruleID);
+                }
+                return true;
+            } else {
+                //Disable CFB for existing rule (Remove tihs rule -> i.e., Not copy this existing
+                // rule to newRuleSet)
+                if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                    if (mDisableRuleMode == DISABLE_MODE_DELETE_RULE) {
+                        Rlog.d(LOG_TAG, "Disable CF for serviceClass=0 (all media types):neither "
+                                + "create new rule nor copy old rule to new rule set");
+                        if (updateSingleRule) {
+                            Rlog.e(LOG_TAG, "handleCreateNewRuleForExistingCF(): ERROR: "
+                                    + "DISABLE_MODE_DELETE_RULE but updateSingleRule");
+                        }
+                        return false;
+                    } else if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                        Rlog.d(LOG_TAG, "Disable CF for serviceClass=0 (all media types):copy old "
+                                + "rule with <rule-deactivated> into new rule set");
+                        Rule nr = copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                        nr.getConditions().addRuleDeactivated();
+                        if (updateSingleRule && (1 == numExpansion)) {
+                            cd.saveRule(nr.mId);
+                        }
+                        return true;
+                    }
+                } else if (hasExtraMedia(cond.getMedias(), setCFServiceClass)) {
+                    if (updateSingleRule && (1 == numExpansion)) {
+                        //We just remove one media type which is marked to disable the Call
+                        // Forwarding (but the remaining media types must keep their original rule)
+                        Rule newRule = copyOldRuleToNewRuleSetExceptSpecificMedia(r, newRuleSet,
+                                    setCFServiceClass, phoneId, setCFAction, setCFReason);
+                        if (newRule != null) {
+                            cd.saveRule(newRule.mId);
+                        }
+                        return true;
+                    }
+                    if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                        Rlog.d(LOG_TAG, "Disable" + " " + ruleID + ":copy old rule with "
+                                + "<rule-deactivated> for this media types to new rule set");
+                        Rule nr = copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                        nr.getConditions().addRuleDeactivated();
+                    }
+
+                    Rlog.d(LOG_TAG, "Disable" + " " + ruleID
+                            + ":copy old rule for remaining media types to new rule set");
+                    //We just remove one media type which is marked to disable the Call
+                    // Forwarding (but the remaining media types must keep their original rule)
+                    copyOldRuleToNewRuleSetExceptSpecificMedia(r, newRuleSet, setCFServiceClass,
+                            phoneId, setCFAction, setCFReason);
+                    return true;
+                } else {
+                    //Exactly matched & only one serviceclass!
+                    if (mDisableRuleMode == DISABLE_MODE_DELETE_RULE) {
+                        Rlog.d(LOG_TAG, "Disable" + " " + ruleID
+                                + ":not copy old rule to new rule set");
+                        if (updateSingleRule) {
+                            Rlog.e(LOG_TAG, "handleCreateNewRuleForExistingCF(): ERROR: "
+                                    + "DISABLE_MODE_DELETE_RULE but updateSingleRule");
+                        }
+                        return false;
+                    } else if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                        Rlog.d(LOG_TAG, "Disable" + " " + ruleID
+                                + ":copy old rule with <rule-deactivated> to new rule set");
+                        Rule nr = copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                        nr.getConditions().addRuleDeactivated();
+                        if (updateSingleRule && (1 == numExpansion)) {
+                            cd.saveRule(nr.mId);
+                        }
+                        return true;
+                    }
+                }
+                return false;
+            }
+        }
+
+        // This API is used to create new CB rule matched the serviceclass & reason specified
+        // by the user in user's configuration at this time
+        // E.g., User wants to disable BAOC for voice call and XCAP server has one rule - BAOC
+        // for both voice & video calls currently
+        // In this way, we can create the rule disabled BAOC for voice call first by this API
+        // then copy old rule except voice type into new rule set to present that: BAOC for video
+        // call is still enabled
+        public boolean handleCreateNewRuleForExistingCB(SimservType ssType, RuleSet newRuleSet,
+                Rule r, String facility, int lockState, int setCBServiceClass, String RuleID,
+                boolean updateSingleRule, int num_of_expansion, int phoneId) throws XcapException {
+            Conditions cond = r.getConditions();
+            Actions action = r.getActions();
+            boolean cbAllow = true;
+            boolean addRuleDeactivatedNode = false;
+
+            //For testing purpose, it will read XCAP Rule Disable Mode (xrdm) from system property
+            String sDisableRuleMode = SystemProperties.get(PROP_SS_DISABLE_METHOD,
+                    Integer.toString(DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG));
+            Rlog.d(LOG_TAG, "handleCreateNewRuleForExistingCB():sDisableRuleMode="
+                    + sDisableRuleMode);
+            mDisableRuleMode = Integer.parseInt(sDisableRuleMode);
+
+            if (lockState == 1) {
+                //Enable CB (Because it always creates a new rule for this service class, it will
+                //only have <allow> and no <rule-deactivated>)
+                cbAllow = false;
+            } else {
+                //Disable CB
+                if (mDisableRuleMode == DISABLE_MODE_DELETE_RULE) {
+                    Rlog.d(LOG_TAG, "Disable CB for serviceClass=" + setCBServiceClass
+                            + " ,not create new rule for it to put in the new rule set");
+                    if (updateSingleRule) {
+                        Rlog.e(LOG_TAG, "handleCreateNewRuleForExistingCB(): ERROR:"
+                                + " DISABLE_MODE_DELETE_RULE but updateSingleRule");
+                    }
+                    return false;
+                } else if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                    // Usage: add <rule-deactivated> to disable this CB rule, then keep <allow>
+                    // value as false
+                    addRuleDeactivatedNode = true;
+                    cbAllow = false;
+                } else if (mDisableRuleMode == DISABLE_MODE_CHANGE_CB_ALLOW) {
+                    cbAllow = true;
+                }
+            }
+
+            Rule cbRule = newRuleSet.createNewRule(RuleID);
+            Conditions cbCond = cbRule.createConditions();
+            Actions cbAction = cbRule.createActions();
+
+            //Add media into this new rule
+            if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                    cbCond.addMedia("audio");
+                } else if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                    cbCond.addMedia("video");
+                } else if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                    cbCond.addMedia("audio");
+                    cbCond.addMedia("video");
+                }
+            }
+
+            // Usage: add <rule-deactivated> to disable this CB rule, then keep <allow> value as
+            // false
+            if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG
+                    && addRuleDeactivatedNode == true) {
+                cbCond.addRuleDeactivated();
+            }
+
+            if (facility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                cbCond.addRoaming();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAIC)) {
+                //Bar All Incoming Calls (no conditions -> evaluate the result as true directly)
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOIC)) {
+                cbCond.addInternational();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                cbCond.addInternationalExHc();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOC)) {
+                //Bar All Outgoing Calls (no conditions -> evaluate the result as true directly)
+                cbAction.setAllow(cbAllow);
+            }
+
+            if (updateSingleRule && (1 == num_of_expansion)) {
+                if (ssType instanceof OutgoingCommunicationBarring) {
+                    OutgoingCommunicationBarring ocb = (OutgoingCommunicationBarring) ssType;
+                    ocb.saveRule(RuleID);
+                } else if (ssType instanceof IncomingCommunicationBarring) {
+                    IncomingCommunicationBarring icb = (IncomingCommunicationBarring) ssType;
+                    icb.saveRule(RuleID);
+                }
+            }
+
+            return true;
+        }
+
+        /* This API is used to add one new rule not occurred & matched in the XCAP server */
+        /* E.g., In original XCAP server:Only BAOC, then user enables the BOIC */
+        public boolean handleCreateNewRuleForReqCB(SimservType ssType, RuleSet newRuleSet,
+                String facility, int lockState, int setCBServiceClass, String RuleID,
+                boolean updateSingleRule, int num_of_expansion, int phoneId) throws XcapException {
+            boolean cbAllow = true;
+
+            if (lockState == 1) {
+                //Enable CB
+                cbAllow = false;
+            } else {
+                //Disable CB:It means that the user disable one existed rule!
+                //Note:If the user wants to disable one rule but no any matched one stored in XCAP
+                // server,
+                //It is not allowed to add this disabled rule into the ruleset: retunr from this
+                //API directly
+                cbAllow = true;
+                Rlog.d(LOG_TAG, "Disable one non-existed rule!Return from "
+                        + "handleCreateNewRuleForReqCB() directly!");
+                return false;
+            }
+
+            Rule cbRule = newRuleSet.createNewRule(RuleID);
+            Conditions cbCond = cbRule.createConditions();
+            Actions cbAction = cbRule.createActions();
+
+            //Add media into this new rule
+            if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                    cbCond.addMedia("audio");
+                } else if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                    cbCond.addMedia("video");
+                } else if (setCBServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                    cbCond.addMedia("audio");
+                    cbCond.addMedia("video");
+                }
+            }
+
+            if (facility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                cbCond.addRoaming();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAIC)) {
+                //Bar All Incoming Calls (no conditions -> evaluate the result as true directly)
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOIC)) {
+                cbCond.addInternational();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                cbCond.addInternationalExHc();
+                cbAction.setAllow(cbAllow);
+            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOC)) {
+                //Bar All Outgoing Calls (no conditions -> evaluate the result as true directly)
+                cbAction.setAllow(cbAllow);
+            }
+
+            if (updateSingleRule && (1 == num_of_expansion)) {
+                if (ssType instanceof OutgoingCommunicationBarring) {
+                    OutgoingCommunicationBarring ocb = (OutgoingCommunicationBarring) ssType;
+                    ocb.saveRule(RuleID);
+                } else if (ssType instanceof IncomingCommunicationBarring) {
+                    IncomingCommunicationBarring icb = (IncomingCommunicationBarring) ssType;
+                    icb.saveRule(RuleID);
+                }
+            }
+
+            return true;
+        }
+
+
+        public Rule copyOldRuleToNewRuleSet(Rule oldRule, RuleSet newRuleSet,
+            int cfAction, int cfReason) {
+            Conditions oldCond = oldRule.getConditions();
+            Actions oldAction = oldRule.getActions();
+
+            Rule newRule = newRuleSet.createNewRule(oldRule.mId);
+            Conditions newCond = newRule.createConditions();
+            Actions newAction = newRule.createActions();
+
+            if (oldCond != null) {
+                if (oldCond.comprehendBusy()) {
+                    newCond.addBusy();
+                }
+                if (oldCond.comprehendCommunicationDiverted()) {
+                    newCond.addCommunicationDiverted();
+                }
+                if (oldCond.comprehendInternational()) {
+                    newCond.addInternational();
+                }
+                if (oldCond.comprehendInternationalExHc()) {
+                    newCond.addInternationalExHc();
+                }
+                if (oldCond.comprehendNoAnswer()) {
+                    newCond.addNoAnswer();
+                }
+                if (oldCond.comprehendNotReachable()) {
+                    newCond.addNotReachable();
+                }
+                if (oldCond.comprehendNotRegistered()) {
+                    newCond.addNotRegistered();
+                }
+                if (oldCond.comprehendPresenceStatus()) {
+                    newCond.addPresenceStatus();
+                }
+                if (oldCond.comprehendRoaming()) {
+                    newCond.addRoaming();
+                }
+                if (oldCond.comprehendRuleDeactivated()) {
+                    newCond.addRuleDeactivated();
+                }
+                //Copy Medias
+                List<String>oldMediaList = oldCond.getMedias();
+                if (oldMediaList != null) {
+                    for (int i = 0; i < oldMediaList.size(); i++) {
+                        newCond.addMedia(oldMediaList.get(i));
+                    }
+                }
+                // Condition for OP01 UT
+                newCond.addTime(oldCond.comprehendTime());
+            }
+
+            ForwardTo oldForward = oldAction.getFowardTo();
+            if (oldForward != null) {
+                if (cfAction == CommandsInterface.CF_ACTION_ERASURE &&
+                    cfReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                    Rlog.i(LOG_TAG, "No need to append the original numebr in Erasure.");
+                    newAction.setFowardTo("", oldForward.isNotifyCaller());
+                } else {
+                    newAction.setFowardTo(oldForward.getTarget(), oldForward.isNotifyCaller());
+                }
+                newAction.getFowardTo().setRevealIdentityToCaller(
+                        oldForward.isRevealIdentityToCaller());
+                newAction.getFowardTo().setRevealIdentityToTarget(
+                        oldForward.isRevealIdentityToTarget());
+            } else {
+                 Rlog.i(LOG_TAG, "No need to append the forward number, cfAction: " + cfAction +
+                    ", cfReason: " + cfReason);
+            }
+
+            newAction.setAllow(oldAction.isAllow());
+            return newRule;
+        }
+
+        public void copyOldRuleToNewRuleSetWithDisabledCB(Rule oldRule, RuleSet newRuleSet,
+                boolean allow, int cfAction, int cfReason) {
+            Actions newAction = null;
+            Conditions newCond = null;
+            Actions oldAction = oldRule.getActions();
+            Conditions oldCond = oldRule.getConditions();
+
+            if (mDisableRuleMode == DISABLE_MODE_DELETE_RULE) {
+                if (oldAction.isAllow() == false
+                        && oldCond.comprehendRuleDeactivated() == false) {
+                    //Do nothing:Not copy the old rule (enabled CB) into the new ruleset
+                } else {
+                    copyOldRuleToNewRuleSet(oldRule, newRuleSet, cfAction, cfReason);
+                }
+            } else if (mDisableRuleMode == DISABLE_MODE_ADD_RULE_DEACTIVATED_TAG) {
+                Rule newRule = copyOldRuleToNewRuleSet(oldRule, newRuleSet, cfAction, cfReason);
+                if (newRule != null && oldAction.isAllow() == false
+                        && oldCond.comprehendRuleDeactivated() == false) {
+                    newCond = newRule.createConditions();
+                    newCond.addRuleDeactivated();
+                }
+            } else if (mDisableRuleMode == DISABLE_MODE_CHANGE_CB_ALLOW) {
+                Rule newRule = copyOldRuleToNewRuleSet(oldRule, newRuleSet, cfAction, cfReason);
+                if (newRule != null && oldAction.isAllow() == false
+                        && oldCond.comprehendRuleDeactivated() == false) {
+                    newAction = newRule.createActions();
+                    newAction.setAllow(allow);
+                }
+            }
+        }
+
+
+        public Rule copyOldRuleToNewRuleSetExceptSpecificMedia(Rule oldRule, RuleSet newRuleSet,
+                int requestedServiceClass, int phoneId, int cfAction, int cfReason) {
+            Conditions oldCond = oldRule.getConditions();
+            Actions oldAction = oldRule.getActions();
+
+            //[Example] Both voice call & video call enable CB for All Outgoing International Calls
+            // Now, a user wants to disable CB for All Outgoing International Calls of voice call
+            // <cond>
+            //     internaltional
+            //     <media>
+            //         audio
+            //         video
+            //     </media>
+            // </cond>
+            // <action>
+            //     <allow>false</allow>
+            // </action>
+
+            // One rule will be split into two rules as follows (one for voice call and the other
+            //for video call)
+
+            // Rule#1:
+            // <cond>
+            //     internaltional
+            //     <media>
+            //         audio
+            //
+            //     </media>
+            // </cond>
+            // <action>
+            //     <allow>true</allow>
+            // </action>
+            // Rule#2: (This API is used to create rule such as Rule#2 -- see the following)
+            // <cond>
+            //     internaltional
+            //     <media>
+            //
+            //         video
+            //     </media>
+            // </cond>
+            // <action>
+            //     <allow>false</allow>
+            // </action>
+
+            /*
+            int requestedServicClass = -1;
+            if (media.equals("audio")) {
+                requestedServicClass = CommandsInterface.SERVICE_CLASS_VOICE;
+            } else if (media.equals("video")) {
+                requestedServicClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+            }
+             */
+
+            //Add the check: oldCond!=null - because Barring all calls or Forwarding UnConditional
+            // => <cp:conditions> can be empty by mtk01411 2014-0122
+            if (oldCond != null &&
+                    hasExtraMedia(oldCond.getMedias(), requestedServiceClass) == false) {
+                //If the original rule has no extra media type, because we have already created a
+                // new rule for the requested media type
+                //Only for extra media type: we still must create a new rule with original
+                // configuration then add into new rule set to keep original rule such media
+                return null;
+            }
+
+            Rule newRule = newRuleSet.createNewRule(oldRule.mId);
+            Conditions newCond = newRule.createConditions();
+            Actions newAction = newRule.createActions();
+
+            if (oldCond != null) {
+                if (oldCond.comprehendBusy()) {
+                    newCond.addBusy();
+                }
+                if (oldCond.comprehendCommunicationDiverted()) {
+                    newCond.addCommunicationDiverted();
+                }
+                if (oldCond.comprehendInternational()) {
+                    newCond.addInternational();
+                }
+                if (oldCond.comprehendInternationalExHc()) {
+                    newCond.addInternationalExHc();
+                }
+                if (oldCond.comprehendNoAnswer()) {
+                    newCond.addNoAnswer();
+                }
+                if (oldCond.comprehendNotReachable()) {
+                    newCond.addNotReachable();
+                }
+                if (oldCond.comprehendNotRegistered()) {
+                    newCond.addNotRegistered();
+                }
+                if (oldCond.comprehendPresenceStatus()) {
+                    newCond.addPresenceStatus();
+                }
+                if (oldCond.comprehendRoaming()) {
+                    newCond.addRoaming();
+                }
+                if (oldCond.comprehendRuleDeactivated()) {
+                    newCond.addRuleDeactivated();
+                }
+                //Copy Medias
+                List<String>oldMediaList = oldCond.getMedias();
+                if (oldMediaList != null) {
+                    for (int i = 0; i < oldMediaList.size(); i++) {
+                        if (!getMediaType(requestedServiceClass).equals(oldMediaList.get(i))) {
+                            newCond.addMedia(oldMediaList.get(i));
+                        }
+                    }
+                }
+                // Condition for OP01 UT
+                newCond.addTime(oldCond.comprehendTime());
+            } else {
+                //Add by mtk01411: 2014-0123
+                //oldCond == null:For BAOC or CFU(Unconditional), so its oldMediaList should mean
+                // both for audio & video
+                if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                    && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                    List<String>oldMediaList = new ArrayList<String>();;
+                    oldMediaList.add("audio");
+                    oldMediaList.add("video");
+                    for (int i = 0; i < oldMediaList.size(); i++) {
+                        if (getMediaType(requestedServiceClass).equals(oldMediaList.get(i))
+                                == false) {
+                            newCond.addMedia(oldMediaList.get(i));
+                        }
+                    }
+                }
+            }
+
+            ForwardTo oldForward = oldAction.getFowardTo();
+            if (oldForward != null) {
+                if (cfAction == CommandsInterface.CF_ACTION_ERASURE &&
+                    cfReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                    Rlog.i(LOG_TAG, "No need to append the original numebr in Erasure.");
+                    newAction.setFowardTo("", oldForward.isNotifyCaller());
+                } else {
+                    newAction.setFowardTo(oldForward.getTarget(), oldForward.isNotifyCaller());
+                }
+                newAction.getFowardTo().setRevealIdentityToCaller(
+                        oldForward.isRevealIdentityToCaller());
+                newAction.getFowardTo().setRevealIdentityToTarget(
+                        oldForward.isRevealIdentityToTarget());
+            } else {
+                 Rlog.i(LOG_TAG, "No need to append the forward number, cfAction: " + cfAction +
+                    ", cfReason: " + cfReason);
+            }
+            newAction.setAllow(oldAction.isAllow());
+
+            return newRule;
+        }
+
+
+        public int handleSetCLIR(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int clirMode = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            Rlog.d(LOG_TAG, "Read from CLIR parcel:clirMode=" + clirMode);
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCLIR(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+                OriginatingIdentityPresentationRestriction oir;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleSetCLIR(): mOirCache = " + mOirCache + ", curTime = "
+                        + curTime + ", mOirCacheLastQueried = " + mOirCacheLastQueried
+                        + ", phoneId = " + phoneId);
+                if ((mOirCache != null) && (phoneId == mOirCachePhoneId) &&
+                        (mOirCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleSetCLIR(): using ETAG mOirCache: " + mOirCache);
+                    requestXcapNetwork(phoneId);
+                    oir = mOirCache;
+                    oir.setNetwork(mNetwork);
+                    oir.refresh();
+                    mOirCacheLastQueried = curTime;
+                } else if ((mOirCache != null) && (phoneId == mOirCachePhoneId) &&
+                        ((curTime >= mOirCacheLastQueried)
+                        && ((curTime - mOirCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleSetCLIR(): using mOirCache: " + mOirCache);
+                    oir = mOirCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleSetCLIR(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return 0;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    oir = mSimservs.getOriginatingIdentityPresentationRestriction(true, mNetwork);
+
+                    mOirCache = oir;
+                    mOirCachePhoneId = phoneId;
+                    mOirCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleSetCLIR(): new mOirCache = " + mOirCache
+                            + ", curTime = " + curTime);
+                }
+
+                if (clirMode == CommandsInterface.CLIR_INVOCATION) {
+                    oir.setDefaultPresentationRestricted(true);
+                } else if (clirMode == CommandsInterface.CLIR_SUPPRESSION) {
+                    oir.setDefaultPresentationRestricted(false);
+                } else {
+                    oir.setDefaultPresentationRestricted(false);
+                }
+            } catch (XcapException xcapException) {
+                mOirCache = null;
+                mOirCachePhoneId = -1;
+                mOirCacheLastQueried = 0;
+
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    Rlog.d(LOG_TAG, "handleSetCLIR(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCLIR(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCLIR(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCLIR(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCLIR():Start to Print Stack Trace");
+                mOirCache = null;
+                mOirCachePhoneId = -1;
+                mOirCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            }
+
+            //[Notify upper's application about the SET_CLIR result - Success Case
+            // without exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        public void handleSetCLIP(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int clipEnable = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            Rlog.d(LOG_TAG, "Read from CLIP parcel:clipMode=" + clipEnable);
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCLIP(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleSetCLIP(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                OriginatingIdentityPresentation oip =
+                        mSimservs.getOriginatingIdentityPresentation(true, mNetwork);
+                if (clipEnable == 1) {
+                    oip.setActive(true);
+                } else {
+                    oip.setActive(false);
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleSetCLIP(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCLIP(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCLIP(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCLIP():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            //[Notify upper's application about the SET_CLIP result - Success Case without
+            // exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+
+        public void handleSetCOLR(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int colrMode = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            Rlog.d(LOG_TAG, "Read from COLR parcel:clirMode=" + colrMode);
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCOLR(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleSetCOLR(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                TerminatingIdentityPresentationRestriction tir =
+                        mSimservs.getTerminatingIdentityPresentationRestriction(true, mNetwork);
+                if (colrMode == CommandsInterface.CLIR_INVOCATION) {
+                    tir.setDefaultPresentationRestricted(true);
+                } else if (colrMode == CommandsInterface.CLIR_SUPPRESSION) {
+                    tir.setDefaultPresentationRestricted(false);
+                } else {
+                    tir.setDefaultPresentationRestricted(false);
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleSetCOLR(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCOLR(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCOLR(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCOLR():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            //[Notify upper's application about the SET_COLR result - Success Case without
+            // exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public void handleSetCOLP(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int colpEnable = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            Rlog.d(LOG_TAG, "Read from COLP parcel:colpEnable=" + colpEnable);
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCOLP(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return;
+            }
+
+            try {
+                mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                if (TextUtils.isEmpty(mXcapRoot)) {
+                    Rlog.d(LOG_TAG, "handleSetCOLP(): XcapRoot = " + mXcapRoot);
+                    if (null != rr.mResult) {
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                        rr.mResult.sendToTarget();
+                    }
+                    return;
+                }
+
+                requestXcapNetwork(phoneId);
+
+                setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                        phoneId);
+                TerminatingIdentityPresentation tip =
+                        mSimservs.getTerminatingIdentityPresentation(true, mNetwork);
+                if (colpEnable == 1) {
+                    tip.setActive(true);
+                } else {
+                    tip.setActive(false);
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleSetCOLP(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCOLP(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCOLP(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCOLP():Start to Print Stack Trace");
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            //[Notify upper's application about the SET_COLP result - Success Case without
+            // exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+
+
+        public int handleSetCW(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+            int enabled = rr.mp.readInt();
+            int serviceClass = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCW(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+                CommunicationWaiting cw;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleSetCW(): mCwCache = " + mCwCache + ", curTime = "
+                        + curTime + ", mCwCacheLastQueried = " + mCwCacheLastQueried
+                        + ", phoneId = " + phoneId);
+                if ((mCwCache != null) && (phoneId == mCwCachePhoneId) &&
+                        (mCwCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleSetCW(): using ETAG mCwCache: " + mCwCache);
+                    requestXcapNetwork(phoneId);
+                    cw = mCwCache;
+                    cw.setNetwork(mNetwork);
+                    cw.refresh();
+                    mCwCacheLastQueried = curTime;
+                } else if ((mCwCache != null) && (phoneId == mCwCachePhoneId) &&
+                        ((curTime >= mCwCacheLastQueried)
+                        && ((curTime - mCwCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleSetCW(): using mCwCache: " + mCwCache);
+                    cw = mCwCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleSetCW(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return 0;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    cw = mSimservs.getCommunicationWaiting(true, mNetwork);
+
+                    mCwCache = cw;
+                    mCwCachePhoneId = phoneId;
+                    mCwCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleSetCW(): new mCwCache = " + mCwCache
+                            + ", curTime = " + curTime);
+                }
+                Rlog.d(LOG_TAG, "handleSetCW(): enabled = " + enabled);
+                if (enabled == 1) {
+                    cw.setActive(true);
+                } else {
+                    cw.setActive(false);
+                }
+            } catch (XcapException xcapException) {
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    Rlog.d(LOG_TAG, "handleSetCW(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCW(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCW(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCW(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCW():Start to Print Stack Trace");
+                mCwCache = null;
+                mCwCachePhoneId = -1;
+                mCwCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            }
+
+            //[Notify upper's application about the SET_CW result - Success Case without
+            // exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        public int handleSetCF(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int setCFAction = rr.mp.readInt();
+            int setCFReason = rr.mp.readInt();
+            int setCFServiceClass = rr.mp.readInt();
+            String setCFNumber = rr.mp.readString();
+            int setCFTimeSeconds = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+            int reportFlag = 0;
+
+            boolean AddRuleForCFUWithAllMediaType = false;
+            boolean AddRuleForCFBWithAllMediaType = false;
+            boolean AddRuleForCFNoAnswerWithAllMediaType = false;
+            boolean AddRuleForCFNotReachableWithAllMediaType = false;
+            boolean AddRuleForCFNotRegisteredWithAllMediaType = false;
+
+            String CFU_RuleID = "CFU";
+            String CFB_RuleID = "CFB";
+            String CFNoAnswer_RuleID = "CFNoAnswer";
+            String CFNotReachable_RuleID = "CFNotReachable";
+            String CFNotRegistered_RuleID = "CFNotReachable";
+
+            Rlog.d(LOG_TAG, "Read from CF parcel:req=" + requestToString(reqNo) + ",cfAction="
+                    + setCFAction + ",reason=" + setCFReason + ",serviceClass="
+                    + setCFServiceClass + ",number=" + setCFNumber + ",timeSec="
+                    + setCFTimeSeconds);
+
+            String XcapCFNum = SystemProperties.get(PROP_SS_CFNUM, "");
+            if (XcapCFNum.startsWith("sip:") || XcapCFNum.startsWith("sips:")
+                    || XcapCFNum.startsWith("tel:")) {
+                Rlog.d(LOG_TAG, "handleSetCF():get call forwarding num from EM setting:"
+                        + XcapCFNum);
+                String ss_mode = SystemProperties.get(PROP_SS_MODE, MODE_SS_XCAP);
+                Rlog.d(LOG_TAG, "handleSetCF():ss_mode=" + ss_mode);
+                if (MODE_SS_XCAP.equals(ss_mode)) {
+                    setCFNumber = XcapCFNum;
+                }
+            }
+
+            //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+            if (setCFServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                    | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                setCFServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+            }
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCF(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+
+                int num_of_expansion = 1;
+                //Need several interators to check
+                if (setCFReason == CommandsInterface.CF_REASON_ALL_CONDITIONAL) {
+                    //It means that to check 4
+                    // conditions:CFB/CFNoAnser/CFNotReachable/CFNotRegistered
+                    num_of_expansion = 4;
+                } else if (setCFReason == CommandsInterface.CF_REASON_ALL) {
+                    //It means that to check 4
+                    // conditions:CFB/CFNoAnser/CFNotReachable/CFNotRegistered
+                    // and 1 unconditional:CFU
+                    num_of_expansion = 5;
+                }
+
+                CommunicationDiversion cd;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleSetCF(): mCdCache = " + mCdCache + ", curTime = "
+                        + curTime + ", mCdCacheLastQueried = " + mCdCacheLastQueried
+                        + ", phoneId = " + phoneId);
+                if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        (mCdCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleSetCF(): using ETAG mCdCache: " + mCdCache);
+                    requestXcapNetwork(phoneId);
+                    cd = mCdCache;
+                    cd.setNetwork(mNetwork);
+                    cd.refresh();
+                    mCdCacheLastQueried = curTime;
+                } else if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        ((curTime >= mCdCacheLastQueried)
+                        && ((curTime - mCdCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleSetCF(): using mCdCache: " + mCdCache);
+                    cd = mCdCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleSetCF(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return 0;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    cd = mSimservs.getCommunicationDiversion(true, mNetwork);
+                    mCdCache = cd;
+                    mCdCachePhoneId = phoneId;
+                    mCdCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleSetCF(): new mCdCache = " + mCdCache
+                            + ", curTime = " + curTime);
+                }
+
+                for (int it = 0; it < num_of_expansion; it++) {
+                    if (num_of_expansion != 1) {
+                        if (it == 0) setCFReason = CommandsInterface.CF_REASON_BUSY;
+                        else if (it == 1) setCFReason = CommandsInterface.CF_REASON_NO_REPLY;
+                        else if (it == 2) setCFReason = CommandsInterface.CF_REASON_NOT_REACHABLE;
+                        else if (it == 3) setCFReason = CommandsInterface.CF_REASON_NOT_REGISTERED;
+                        else if (it == 4) setCFReason = CommandsInterface.CF_REASON_UNCONDITIONAL;
+                    }
+
+                    //Only report to upper layer application at the last execution
+                    if (it == (num_of_expansion - 1)) {
+                        reportFlag = 1;
+                    }
+
+                    Rlog.d(LOG_TAG, "handleSetCF():it=" + it + ", num_of_expansion="
+                            + num_of_expansion + ",cfReason=" + setCFReason);
+
+                    RuleSet ruleSet = cd.getRuleSet();
+                    List<Rule> ruleList = null;
+                    RuleSet newRuleSet = cd.createNewRuleSet();
+                    boolean addedNewRule = false;
+
+
+                    if (ruleSet != null) {
+                        ruleList = ruleSet.getRules();
+                    } else {
+                        Rlog.d(LOG_TAG, "No CF related rules in remote server");
+                    }
+
+                    //Note that: If no ant configuration is stored in XCAP server (e.g., empty xml
+                    // string), ruleList will be null
+                    if (ruleList != null) {
+                        //Check each rule & its corresponding condition/action
+                        for (int i = 0; i < ruleList.size(); i++) {
+                            Rule r = ruleList.get(i);
+                            Conditions cond = r.getConditions();
+                            Actions action = r.getActions();
+                            List<String> mediaList = null;
+
+                            if (cond != null) {
+                                mediaList = cond.getMedias();
+                                Rlog.d(LOG_TAG, "handleSetCF():busy=" + cond.comprehendBusy()
+                                        + ",NoAnswer=" + cond.comprehendNoAnswer()
+                                        + ",NoReachable="
+                                        + cond.comprehendNotReachable() + ",NotRegistered="
+                                        + cond.comprehendNotRegistered());
+                                if (cond.comprehendBusy()) {
+                                    CFB_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFB_RuleID=" + CFB_RuleID);
+                                } else if (cond.comprehendNoAnswer()) {
+                                    CFNoAnswer_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFNoAnswer_RuleID="
+                                            + CFNoAnswer_RuleID);
+                                } else if (cond.comprehendNotReachable()) {
+                                    CFNotReachable_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFNotReachable_RuleID="
+                                            + CFNotReachable_RuleID);
+                                } else if (cond.comprehendNotRegistered()) {
+                                    CFNotRegistered_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFNotRegistered_RuleID="
+                                            + CFNotRegistered_RuleID);
+                                } else {
+                                    CFU_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFU_RuleID=" + CFU_RuleID);
+                                }
+                            } else {
+                                Rlog.d(LOG_TAG, "handleSetCF():Empty cond (cond==null) for"
+                                        + " this rule=" + r);
+                                if (CFU_RuleID.equals("CFU")) {
+                                    //CFU rule
+                                    CFU_RuleID = r.mId;
+                                    Rlog.d(LOG_TAG, "Update CFU_RuleID=" + CFU_RuleID);
+                                }
+                            }
+
+                            //Traverse each rule and check if this time's request is already in the
+                            // remote XCAP server
+                            if (setCFReason == CommandsInterface.CF_REASON_BUSY &&
+                                    (cond != null && cond.comprehendBusy() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE) ||
+                                        (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFBWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFB_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFB-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFBWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFBWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFB with serviceClass=0 "
+                                            + "case previously");
+                                }
+
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NO_REPLY &&
+                                    (cond != null && cond.comprehendNoAnswer() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFNoAnswerWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFNoAnswer_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoAnswer-addedNewRule="
+                                            + addedNewRule);
+
+                                    //Add the configuration for NoReplyTimer
+                                    if (addedNewRule == true &&
+                                            (setCFAction == CommandsInterface.CF_ACTION_ENABLE ||
+                                            setCFAction ==
+                                            CommandsInterface.CF_ACTION_REGISTRATION)) {
+                                        Rlog.d(LOG_TAG, "handleSetCF():[C1]Enable CFNoAnswer with "
+                                                + "new_NoReplyTimer=" + setCFTimeSeconds
+                                                + "org_NoReplyTimer=" + cd.getNoReplyTimer());
+                                        if (setCFTimeSeconds > 0 && cd.getNoReplyTimer() > -1) {
+                                            cd.setNoReplyTimer(setCFTimeSeconds);
+                                        } else {
+                                            Rlog.d(LOG_TAG, "No need to append setCFTimeSeconds: " + 
+                                                setCFTimeSeconds);
+                                        }
+                                    }
+
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNoAnswerWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFNoAnswerWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoAnswer with"
+                                            + " serviceClass=0 case previously");
+                                }
+
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE &&
+                                    (cond != null && cond.comprehendNotReachable() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotReachableWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFNotReachable_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoReachable-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNotReachableWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFNotReachableWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoReachable with "
+                                            + "serviceClass=0 case previously");
+                                }
+
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED &&
+                                    (cond != null && cond.comprehendNotReachable() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass) &&
+                                    MMTelSSUtils.isOp06IccCard(phoneId)) {
+                                // set CFNRc as CFNL for OP06
+                                Rlog.d(LOG_TAG, "handleSetCF(): Set CFNRc as CFNL for OP06");
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotReachableWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, CommandsInterface.CF_REASON_NOT_REACHABLE,
+                                            setCFAction, setCFServiceClass, setCFNumber,
+                                            setCFTimeSeconds, CFNotReachable_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoReachable-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNotReachableWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFNotReachableWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoReachable with "
+                                            + "serviceClass=0 case previously");
+                                }
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED &&
+                                    (cond != null && cond.comprehendNotRegistered() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotRegisteredWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFNotRegistered_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoRegistered-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNotRegisteredWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotRegisteredWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoRegistered with "
+                                            + "serviceClass=0 case previously");
+                                }
+                            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE &&
+                                    (cond != null && cond.comprehendNotRegistered() == true) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass) &&
+                                    MMTelSSUtils.isOp06IccCard(phoneId)) {
+                                // set CFNL as CFNRc for OP06
+                                Rlog.d(LOG_TAG, "handleSetCF(): Set CFNL as CFNRc for OP06");
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotRegisteredWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, CommandsInterface.CF_REASON_NOT_REGISTERED,
+                                            setCFAction, setCFServiceClass, setCFNumber,
+                                            setCFTimeSeconds, CFNotRegistered_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFNoRegistered-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFNotRegisteredWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFNotRegisteredWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFNoRegistered with "
+                                            + "serviceClass=0 case previously");
+                                }
+                            } else if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL &&
+                                    ((cond != null && cond.comprehendBusy() == false &&
+                                    cond.comprehendNoAnswer() == false &&
+                                    cond.comprehendNotRegistered() == false &&
+                                    cond.comprehendNotReachable() == false) || cond == null) &&
+                                    containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                                if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                        || (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE
+                                        && AddRuleForCFUWithAllMediaType == false)) {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(cd, newRuleSet,
+                                            r, setCFReason, setCFAction, setCFServiceClass,
+                                            setCFNumber, setCFTimeSeconds, CFU_RuleID,
+                                            mUpdateSingleRule, num_of_expansion, phoneId);
+                                    Rlog.d(LOG_TAG, "handleSetCF():CFU-addedNewRule="
+                                            + addedNewRule);
+                                    if (setCFServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE) {
+                                        AddRuleForCFUWithAllMediaType = true;
+                                    }
+                                } else if (setCFServiceClass ==
+                                        CommandsInterface.SERVICE_CLASS_NONE &&
+                                        AddRuleForCFUWithAllMediaType == true) {
+                                    Rlog.d(LOG_TAG, "Already add rule for CFU with serviceClass=0 "
+                                            + "case previously");
+                                }
+
+                            } else {
+                                //Copy old rule into new rule set
+                                Rlog.d(LOG_TAG, "handleSetCF():Copy old rule to newRuleSet");
+                                copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                            }
+                        } //end-of-for-loop (ruleList)
+                    }
+
+                    //Check if the new rule user wants to be modified is already added to or not
+                    //Remove the check condition "(setCFServiceClass !=
+                    //CommandsInterface.SERVICE_CLASS_NONE)" 2014-0709
+                    //Scenario:User inputs "**67#" to enable CFB (i.e.,with null phonenumber and
+                    // serviceClass is NONE) => Not match any rule, it should be added into the
+                    // rule set
+                    if (addedNewRule == false && (setCFAction == CommandsInterface.CF_ACTION_ENABLE
+                            || setCFAction == CommandsInterface.CF_ACTION_REGISTRATION)
+                            /*&& (setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE)*/
+                            ) {
+                        addedNewRule = true;
+                        Rule rule = newRuleSet.createNewRule("");
+                        Conditions cond = rule.createConditions();
+                        Actions action = rule.createActions();
+                        if (MMTelSSUtils.isOp01IccCard(phoneId)
+                                && MMTelSSUtils.isNotifyCallerTest()) {
+                            action.setFowardTo(setCFNumber, false);
+                        } else {
+                            action.setFowardTo(setCFNumber, true);
+                        }
+                        action.getFowardTo().setRevealIdentityToCaller(true);
+                        action.getFowardTo().setRevealIdentityToTarget(true);
+
+                        Rlog.d(LOG_TAG, "handleSetCF():Add rule for this time's enable reason="
+                                + setCFReason + ",serviceClass=" + setCFServiceClass);
+
+                        if (setCFReason == CommandsInterface.CF_REASON_BUSY) {
+                            rule.setId(CFB_RuleID);
+                            cond.addBusy();
+                        } else if (setCFReason == CommandsInterface.CF_REASON_NO_REPLY) {
+                            //Add the configuration for NoReplyTimer
+                            Rlog.d(LOG_TAG, "handleSetCF():[C2]Enable CFNoAnswer with "
+                                    + "new_NoReplyTimer=" + setCFTimeSeconds + ",org_NoReplyTimer="
+                                    + cd.getNoReplyTimer());
+                            if (setCFTimeSeconds > 0 && cd.getNoReplyTimer() > -1) {
+                                cd.setNoReplyTimer(setCFTimeSeconds);
+                            } else {
+                                Rlog.d(LOG_TAG, "No need to append setCFTimeSeconds: " + 
+                                    setCFTimeSeconds);
+                            }
+                            rule.setId(CFNoAnswer_RuleID);
+                            cond.addNoAnswer();
+                        } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE) {
+                            rule.setId(CFNotReachable_RuleID);
+                            cond.addNotReachable();
+                        } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED) {
+                            rule.setId(CFNotRegistered_RuleID);
+                            cond.addNotRegistered();
+                        } else if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                            rule.setId(CFU_RuleID);
+                            //Don't add any condition (always evaluate the result as true)
+                        }
+                        if (!MMTelSSUtils.isOp06IccCard(phoneId)
+                            && !MMTelSSUtils.isOp07IccCard(phoneId)) {
+                            if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                                cond.addMedia("audio");
+                            } else if (setCFServiceClass
+                                    == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                                cond.addMedia("video");
+                            }
+                        }
+
+                        if (mUpdateSingleRule && num_of_expansion == 1) {
+                            cd.saveRule(rule.mId);
+                        }
+                    }
+
+                    //Finally, update the new rule set back to remote XCAP server
+                    //Debug:
+                    if (newRuleSet.getRules() != null) {
+                        Rlog.d(LOG_TAG, "Dump SetCF XML:" + newRuleSet.toXmlString());
+                    } else {
+                        Rlog.d(LOG_TAG, "Dump SetCF XML: ruleset with empty rules");
+                    }
+
+                    if (!mUpdateSingleRule) {
+                        cd.saveRuleSet();
+                    } else {
+                        if (num_of_expansion > 1) {
+                            List<Rule> newRuleList = null;
+                            newRuleList = newRuleSet.getRules();
+                            for (int i = 0; i < newRuleList.size(); i++) {
+                                Rule newRule = newRuleList.get(i);
+                                cd.saveRule(newRule.mId);
+                            }
+                        }
+                    }
+
+                } //end-of-for-loop (num_of_expansion)
+
+            } catch (XcapException xcapException) {
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    Rlog.d(LOG_TAG, "handleSetCF(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCF(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCF(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCF(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCF():Start to Print Stack Trace");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if ((rr.mResult != null) && (reportFlag == 1)) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            }
+
+            //[Notify upper's application about the SET_CF result - Success Case without exception]
+            if ((rr.mResult != null) && (reportFlag == 1)) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        public int handleSetCB(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+            String facility = rr.mp.readString();
+            String original_facility = facility;
+            int lockState = rr.mp.readInt();
+            int setCBServiceClass = rr.mp.readInt();
+            int phoneId = rr.mp.readInt();
+
+            boolean AddRuleForBAOCWithAllMediaType = false;
+            boolean AddRuleForBAOICWithAllMediaType = false;
+            boolean AddRuleForBAOICxHWithAllMediaType = false;
+            boolean AddRuleForBAICWithAllMediaType = false;
+            boolean AddRuleForBAICrWithAllMediaType = false;
+
+            String BAOC_RuleID = "AO";
+            String BAOIC_RuleID = "OI";
+            String BAOICExHC_RuleID = "OX";
+            String BAIC_RuleID = "AI";
+            String BAICR_RuleID = "IR";
+
+            Rlog.d(LOG_TAG, "Read from CB parcel:req=" + requestToString(reqNo) + ",facility="
+                   + facility + ",serviceClass=" + setCBServiceClass + ",lockState(enabled)="
+                   + lockState);
+
+            //Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+            if (setCBServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO
+                    | CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                setCBServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+            }
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCB(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+
+                //Add handling Barring Service for 330(AB)/333(AG)/353(AC) cases
+                /***
+                 * "AO" BAOC (Barr All Outgoing Calls) (refer 3GPP TS 22.088 [6] clause 1)
+                 * "OI" BOIC (Barr Outgoing International Calls) (refer 3GPP TS 22.088 [6]
+                 * clause 1)
+                 * "OX" BOIC exHC (Barr Outgoing International Calls except to Home Country)
+                 *(refer 3GPP TS 22.088 [6] clause 1)
+                 * "AI" BAIC (Barr All Incoming Calls) (refer 3GPP TS 22.088 [6] clause 2)
+                 * "IR" BIC Roam (Barr Incoming Calls when Roaming outside the home country)
+                 * (refer 3GPP TS 22.088 [6] clause 2)
+                 * "AB" All Barring services (refer 3GPP TS 22.030 [19]) (applicable only for
+                 * <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                 * "AG" All outGoing barring services (refer 3GPP TS 22.030 [19]) (applicable
+                 * only for <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                 * "AC" All inComing barring services (refer 3GPP TS 22.030 [19]) (applicable
+                 * only for <mode>=0: i.e.,unlock - ref: +CLCK & 2/3G SS Spec)
+                 */
+                int num_of_expansion = 1;
+                if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)
+                        && lockState == 0) {
+                    num_of_expansion = 5;
+                } else if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_MO)
+                        && lockState == 0) {
+                    num_of_expansion = 3;
+                } else if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_MT)
+                        && lockState == 0) {
+                    num_of_expansion = 2;
+                }
+
+                if (facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)
+                        || facility.equals(CommandsInterface.CB_FACILITY_BA_MO)
+                        || facility.equals(CommandsInterface.CB_FACILITY_BA_MT)) {
+                    if (lockState != 0) {
+                        //Follow the same behavior with 2/3G CS - AB/AG/AC:Only mode=0
+                        // (i.e.,unlock state operation) is allowed
+                        Rlog.d(LOG_TAG, "Not allow lockState=1 for AB(330)/AG(333)/AC(353)");
+                        //Note that: upper layer application
+                        // (CallBarringBasePreference.java:handleSetCallBarringResponse())
+                        //Only cast the exception to CommandException is allowed (but it may
+                        //happen assertion due to cast failure)
+                        //And handle this exception in TimeConsumingPreferenceActivity.java's
+                        // onError()
+                        if (rr.mResult != null) {
+                            CommandException ce =
+                                    CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                            AsyncResult.forMessage(rr.mResult, null, ce);
+                            rr.mResult.sendToTarget();
+                            return 0;
+                        }
+                    }
+                }
+
+                OutgoingCommunicationBarring ocb = null;
+                IncomingCommunicationBarring icb = null;
+                long curTime = System.currentTimeMillis();
+                if (facility.equals(CommandsInterface.CB_FACILITY_BAOC) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BAOIC) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BAOICxH) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)) {
+                    Rlog.d(LOG_TAG, "handleSetCB(): mOcbCache = " + mOcbCache + ", curTime = "
+                            + curTime + ", mOcbCacheLastQueried = " + mOcbCacheLastQueried
+                            + ", facility = " + facility + ", phoneId = " + phoneId);
+                    if ((mOcbCache != null) && (phoneId == mOcbCachePhoneId) &&
+                            (mOcbCache.isSupportEtag())) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): using ETAG mOcbCache: " + mOcbCache);
+                        requestXcapNetwork(phoneId);
+                        ocb = mOcbCache;
+                        ocb.setNetwork(mNetwork);
+                        ocb.refresh();
+                        mOcbCacheLastQueried = curTime;
+                    } else if ((mOcbCache != null) && (phoneId == mOcbCachePhoneId) &&
+                            ((curTime >= mOcbCacheLastQueried)
+                            && ((curTime - mOcbCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): using mOcbCache: " + mOcbCache);
+                        ocb = mOcbCache;
+                    } else {
+                        //Outgoing Call Barring
+                        mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                        mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                        mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                        if (TextUtils.isEmpty(mXcapRoot)) {
+                            Rlog.d(LOG_TAG, "handleSetCB(): OCB XcapRoot = " + mXcapRoot);
+                            if (null != rr.mResult) {
+                                AsyncResult.forMessage(rr.mResult, null,
+                                        new UnknownHostException());
+                                rr.mResult.sendToTarget();
+                            }
+                            return 0;
+                        }
+
+                        requestXcapNetwork(phoneId);
+
+                        setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName,
+                                mPassword, phoneId);
+                        ocb = mSimservs.getOutgoingCommunicationBarring(true, mNetwork);
+                        mOcbCache = ocb;
+                        mOcbCachePhoneId = phoneId;
+                        mOcbCacheLastQueried = curTime;
+                        Rlog.d(LOG_TAG, "handleSetCB(): new mOcbCache = " + mOcbCache
+                                + ", curTime = " + curTime);
+                    }
+                }
+
+                if (facility.equals(CommandsInterface.CB_FACILITY_BAIC) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BAICr) ||
+                        facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)) {
+                    Rlog.d(LOG_TAG, "handleSetCB(): mIcbCache = " + mIcbCache + ", curTime = "
+                            + curTime + ", mIcbCacheLastQueried = " + mIcbCacheLastQueried
+                            + ", facility = " + facility + ", phoneId = " + phoneId);
+                    if ((mIcbCache != null) && (phoneId == mIcbCachePhoneId) &&
+                            (mIcbCache.isSupportEtag())) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): using ETAG mIcbCache: " + mIcbCache);
+                        requestXcapNetwork(phoneId);
+                        icb = mIcbCache;
+                        icb.setNetwork(mNetwork);
+                        icb.refresh();
+                        mIcbCacheLastQueried = curTime;
+                    } else if ((mIcbCache != null) && (phoneId == mIcbCachePhoneId) &&
+                            ((curTime >= mIcbCacheLastQueried)
+                            && ((curTime - mIcbCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): using mIcbCache: " + mIcbCache);
+                        icb = mIcbCache;
+                    } else {
+                        //Incoming Call Barring
+                        mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                        mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                        mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                        if (TextUtils.isEmpty(mXcapRoot)) {
+                            Rlog.d(LOG_TAG, "handleSetCB(): ICB XcapRoot = " + mXcapRoot);
+                            if (null != rr.mResult) {
+                                AsyncResult.forMessage(rr.mResult, null,
+                                        new UnknownHostException());
+                                rr.mResult.sendToTarget();
+                            }
+                            return 0;
+                        }
+
+                        requestXcapNetwork(phoneId);
+
+                        setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName,
+                                mPassword, phoneId);
+
+                        icb = mSimservs.getIncomingCommunicationBarring(true, mNetwork);
+                        mIcbCache = icb;
+                        mIcbCachePhoneId = phoneId;
+                        mIcbCacheLastQueried = curTime;
+                        Rlog.d(LOG_TAG, "handleSetCB(): new mIcbCache = " + mIcbCache
+                                + ", curTime = " + curTime);
+                    }
+                }
+
+
+                for (int it = 0; it < num_of_expansion; it++) {
+                    if (num_of_expansion != 1) {
+                        if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_MO)) {
+                            if (it == 0) facility = CommandsInterface.CB_FACILITY_BAOIC;
+                            else if (it == 1) facility = CommandsInterface.CB_FACILITY_BAOICxH;
+                            else if (it == 2) facility = CommandsInterface.CB_FACILITY_BAOC;
+
+                        } else if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_MT)) {
+                            if (it == 0) facility = CommandsInterface.CB_FACILITY_BAICr;
+                            else if (it == 1) facility = CommandsInterface.CB_FACILITY_BAIC;
+
+                        } else if (original_facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)) {
+                            if (it == 0) facility = CommandsInterface.CB_FACILITY_BAOIC;
+                            else if (it == 1) facility = CommandsInterface.CB_FACILITY_BAOICxH;
+                            else if (it == 2) facility = CommandsInterface.CB_FACILITY_BAOC;
+                            else if (it == 3) facility = CommandsInterface.CB_FACILITY_BAICr;
+                            else if (it == 4) facility = CommandsInterface.CB_FACILITY_BAIC;
+                        }
+                    }
+
+                    Rlog.d(LOG_TAG, "handleSetCB():num_of_expansion=" + num_of_expansion
+                            + ", round=" + it + ",for facility=" + facility + ",with lockState="
+                            + lockState);
+
+                    if (facility.equals(CommandsInterface.CB_FACILITY_BAOC) ||
+                            facility.equals(CommandsInterface.CB_FACILITY_BAOIC) ||
+                            facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                        RuleSet oRuleSet = ocb.getRuleSet();
+                        List<Rule> ruleList = null;
+                        RuleSet newRuleSet = ocb.createNewRuleSet();
+                        boolean addedNewRule = false;
+
+                        if (oRuleSet != null) {
+                            ruleList = oRuleSet.getRules();
+                        } else {
+                            Rlog.d(LOG_TAG, "No MO related CB rules in remote server");
+                        }
+
+                        //Note that: If no ant configuration is stored in XCAP server (e.g., empty
+                        // xml string), ruleList will be null
+                        if (ruleList != null) {
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleSetCB():MO-facility=" + facility
+                                            + ",action=" + action.isAllow() + ",international="
+                                            + cond.comprehendInternational()
+                                            + ",internationalExHC="
+                                            + cond.comprehendInternationalExHc());
+                                    mediaList = cond.getMedias();
+                                    if (cond.comprehendInternational()) {
+                                        BAOIC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAOIC_RuleID=" + BAOIC_RuleID);
+                                    } else if (cond.comprehendInternationalExHc()) {
+                                        BAOICExHC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAOICExHC_RuleID="
+                                            + BAOICExHC_RuleID);
+                                    } else {
+                                        BAOC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAOC_RuleID=" + BAOC_RuleID);
+                                    }
+                                } else {
+                                    //Add by mtk01411: 2014-0123
+                                    if (cond == null
+                                            && facility.equals(
+                                            CommandsInterface.CB_FACILITY_BAOC)) {
+                                        Rlog.d(LOG_TAG, "handleSetCB():cond=null"
+                                                + " but AO case!MO-facility="
+                                                + facility + ",action=" + action.isAllow());
+                                        mediaList = null;
+                                        if (BAOC_RuleID.equals("AO")) {
+                                            BAOC_RuleID = r.mId;
+                                            Rlog.d(LOG_TAG, "Update BAOC_RuleID=" + BAOC_RuleID);
+                                        }
+                                    } else {
+                                        Rlog.d(LOG_TAG, "handleSetCB():Empty MO cond "
+                                                + "(cond==null) for this rule=" + r);
+                                        if (BAOC_RuleID.equals("AO")) {
+                                            BAOC_RuleID = r.mId;
+                                            Rlog.d(LOG_TAG, "Update BAOC_RuleID=" + BAOC_RuleID);
+                                        }
+                                    }
+                                }
+
+                                if (facility.equals(CommandsInterface.CB_FACILITY_BAOIC) &&
+                                        (cond != null && cond.comprehendInternational()) &&
+                                        containSpecificMedia(mediaList, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                             || (setCBServiceClass
+                                             == CommandsInterface.SERVICE_CLASS_NONE
+                                             && AddRuleForBAOICWithAllMediaType == false)) {
+                                        addedNewRule = handleCreateNewRuleForExistingCB(ocb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAOIC_RuleID, mUpdateSingleRule,
+                                                num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():OI-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        // handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                    copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                    newRuleSet, setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                ocb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAOICWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAOICWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAOIC with"
+                                                + " serviceClass=0 case previously");
+                                    }
+
+                                } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)
+                                        && (cond != null && cond.comprehendInternationalExHc())
+                                        && containSpecificMedia(mediaList, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                            || (setCBServiceClass
+                                            == CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAOICxHWithAllMediaType == false)) {
+                                        addedNewRule = handleCreateNewRuleForExistingCB(ocb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAOICExHC_RuleID,
+                                                mUpdateSingleRule, num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():OX-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        //handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                    copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                    newRuleSet, setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                ocb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAOICxHWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAOICxHWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAOICxH with " +
+                                                "serviceClass=0 case previously");
+                                    }
+
+                                } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOC) &&
+                                        isBAOC(cond, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                            || (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE &&
+                                            AddRuleForBAOCWithAllMediaType == false)) {
+                                        addedNewRule = handleCreateNewRuleForExistingCB(ocb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAOC_RuleID, mUpdateSingleRule,
+                                                num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():AO-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        // handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                     copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                     newRuleSet, setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                ocb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAOCWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAOCWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAOC with"
+                                                + " serviceClass=0 case previously");
+                                    }
+
+                                } else {
+                                    //Copy old rule into new rule set
+                                    Rlog.d(LOG_TAG, "handleSetCB():MO Copy old rule inot"
+                                            + " newRuleSet");
+                                    copyOldRuleToNewRuleSet(r, newRuleSet, -1, -1);
+                                }
+                            }
+                        }
+
+                        //Add this new setting into the ruleset
+                        //[Scenario#1]For disable CB:Because the mDisableRuleMode is
+                        // DISABLE_MODE_DELETE_RULEL: Not necessary to add rule for this
+                        // serviceClass into new rule set
+                        // -> In handleCreateNewRuleForReqCB():It will return directly if lockState
+                        // is 0 (CB DISABLE)
+                        //[Scenario#2]For enable CB instead of modification one existing rule's
+                        // case: Because there is no any rule is matched in the original rule
+                        // set, it must add a new one!
+                        if (addedNewRule == false) {
+                            //XML stored in remote XCAP server is empty string
+                            //Use facility as the RuleID
+                            //E.g., XCAP server only BAIC but this time's request is BAOC with
+                            // serviceClass=0
+                            Rlog.d(LOG_TAG, "handleSetCB():MO add new rule for this time's"
+                                    + " request-facility=" + facility + ",lockState="
+                                    + lockState + ",serviceClass=" + setCBServiceClass);
+                            String newRuleID = "";
+                            //According to facility to decide the rule-id
+                            if (facility.equals(CommandsInterface.CB_FACILITY_BAOC)) {
+                                newRuleID = BAOC_RuleID;
+                            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOIC)) {
+                                newRuleID = BAOIC_RuleID;
+                            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAOICxH)) {
+                                newRuleID = BAOICExHC_RuleID;
+                            }
+                            Rlog.d(LOG_TAG, "handleSetCB():MO add new rule with id=" + newRuleID);
+                            addedNewRule = handleCreateNewRuleForReqCB(ocb, newRuleSet, facility,
+                                    lockState, setCBServiceClass, newRuleID, mUpdateSingleRule,
+                                    num_of_expansion, phoneId);
+
+                        }
+
+                        //Finally, update the new rule set back to remote XCAP server
+                        if (newRuleSet.getRules() != null) {
+                            Rlog.d(LOG_TAG, "Dump MO SetCB  XML:" + newRuleSet.toXmlString());
+                        } else {
+                            Rlog.d(LOG_TAG, "Dump MO SetCB XML: ruleset with empty rules");
+                        }
+
+                        if (!mUpdateSingleRule) {
+                            ocb.saveRuleSet();
+                        } else {
+                            if (num_of_expansion > 1) {
+                                List<Rule> newRuleList = null;
+                                newRuleList = newRuleSet.getRules();
+                                for (int i = 0; i < newRuleList.size(); i++) {
+                                    Rule newRule = newRuleList.get(i);
+                                    ocb.saveRule(newRule.mId);
+                                }
+                            }
+                        }
+                    } else if (facility.equals(CommandsInterface.CB_FACILITY_BAIC) ||
+                            facility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                        //Incoming Call Barring
+                        RuleSet iRuleSet = icb.getRuleSet();
+                        List<Rule> ruleList = null;
+                        RuleSet newRuleSet = icb.createNewRuleSet();
+                        boolean addedNewRule = false;
+
+                        if (iRuleSet != null) {
+                            ruleList = iRuleSet.getRules();
+                        } else {
+                            Rlog.d(LOG_TAG, "No MT related CB rules in remote server");
+                        }
+
+                        //Note that: If no ant configuration is stored in XCAP server (e.g., empty
+                        // xml string), ruleList will be null
+                        if (ruleList != null) {
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                Conditions cond = r.getConditions();
+                                Actions action = r.getActions();
+                                List<String> mediaList = null;
+
+                                if (cond != null) {
+                                    Rlog.d(LOG_TAG, "handleSetCB():MT-facility=" + facility
+                                            + ",action=" + action.isAllow() + ",international="
+                                            + cond.comprehendInternational() + ",roaming="
+                                            + cond.comprehendRoaming());
+                                    mediaList = cond.getMedias();
+                                    if (cond.comprehendRoaming()) {
+                                        BAICR_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAICR_RuleID=" + BAICR_RuleID);
+                                    } else {
+                                        BAIC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAIC_RuleID=" + BAIC_RuleID);
+                                    }
+                                } else {
+                                    Rlog.d(LOG_TAG, "handleSetCB():Empty MT cond (cond==null)"
+                                            + " for this rule=" + r);
+                                    if (BAIC_RuleID.equals("AI")) {
+                                        BAIC_RuleID = r.mId;
+                                        Rlog.d(LOG_TAG, "Update BAIC_RuleID=" + BAIC_RuleID);
+                                    }
+                                }
+
+                                if (facility.equals(CommandsInterface.CB_FACILITY_BAICr) &&
+                                        (cond != null && cond.comprehendRoaming() == true) &&
+                                        containSpecificMedia(mediaList, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                            || (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAICrWithAllMediaType == false)) {
+                                        //Change enable BAICr to disable BAICr
+                                        addedNewRule = handleCreateNewRuleForExistingCB(icb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAICR_RuleID, mUpdateSingleRule,
+                                                num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():IR-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        // handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                    copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                    newRuleSet, setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                icb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAICrWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAICrWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAICr with "
+                                                + "serviceClass=0 case previously");
+                                    }
+
+                                } else if (facility.equals(CommandsInterface.CB_FACILITY_BAIC) &&
+                                        isBAIC(cond, setCBServiceClass) &&
+                                        containSpecificMedia(mediaList, setCBServiceClass)) {
+
+                                    if ((setCBServiceClass != CommandsInterface.SERVICE_CLASS_NONE)
+                                            || (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAICWithAllMediaType == false)) {
+                                        addedNewRule = handleCreateNewRuleForExistingCB(icb,
+                                                newRuleSet, r, facility, lockState,
+                                                setCBServiceClass, BAIC_RuleID, mUpdateSingleRule,
+                                                num_of_expansion, phoneId);
+                                        Rlog.d(LOG_TAG, "handleSetCB():AI-addedNewRule="
+                                                + addedNewRule);
+                                        //Add this check by mtk01411: If serviceClass=0, it already
+                                        // adds alllow or disallow tag for all mediatype in
+                                        // handleCreateNewRuleForExistingCB()
+                                        if (setCBServiceClass !=
+                                                CommandsInterface.SERVICE_CLASS_NONE) {
+                                            Rule newRule =
+                                                    copyOldRuleToNewRuleSetExceptSpecificMedia(r,
+                                                    newRuleSet,
+                                                    setCBServiceClass, phoneId, -1, -1);
+                                            if ((null != newRule) && mUpdateSingleRule
+                                                    && (1 == num_of_expansion)) {
+                                                icb.saveRule(newRule.mId);
+                                            }
+                                        } else {
+                                            AddRuleForBAICWithAllMediaType = true;
+                                        }
+                                    } else if (setCBServiceClass ==
+                                            CommandsInterface.SERVICE_CLASS_NONE
+                                            && AddRuleForBAICWithAllMediaType == true) {
+                                        Rlog.d(LOG_TAG, "Already add rule for BAIC with"
+                                                + " serviceClass=0 case previously");
+                                    }
+
+                                } else {
+                                    //Copy old rule into new rule set
+                                    Rlog.d(LOG_TAG, "handleSetCB():MT Copy old rule inot "
+                                            + "newRuleSet");
+                                    copyOldRuleToNewRuleSet(r, newRuleSet, -1, -1);
+
+                                }
+                            }
+                        }
+
+                        //Add this new setting into the ruleset
+                        if (addedNewRule == false) {
+                            //XML stored in remote XCAP server is empty string
+                            //Use facility as the RuleID
+                            //E.g., XCAP server only BAICr but this time's request is BAIC with
+                            // serviceClass=0
+                            Rlog.d(LOG_TAG, "handleSetCB():MT add new rule for this time's "
+                                    + "request-facility=" + facility + ",lockState=" + lockState
+                                    + ",serviceClass=" + setCBServiceClass);
+                            String newRuleID = "";
+                            //According to facility to decide the rule-id
+                            if (facility.equals(CommandsInterface.CB_FACILITY_BAIC)) {
+                                newRuleID = BAIC_RuleID;
+                            } else if (facility.equals(CommandsInterface.CB_FACILITY_BAICr)) {
+                                newRuleID = BAICR_RuleID;
+                            }
+                            Rlog.d(LOG_TAG, "handleSetCB():MT add new rule with id=" + newRuleID);
+                            addedNewRule = handleCreateNewRuleForReqCB(icb, newRuleSet, facility,
+                                    lockState, setCBServiceClass, newRuleID, mUpdateSingleRule,
+                                    num_of_expansion, phoneId);
+
+                        }
+
+                        //Finally, update the new rule set back to remote XCAP server
+                        if (newRuleSet.getRules() != null) {
+                            Rlog.d(LOG_TAG, "Dump MT SetCB XML:" + newRuleSet.toXmlString());
+                        } else {
+                            Rlog.d(LOG_TAG, "Dump MT SetCB XML: ruleset with empty rules");
+                        }
+
+                        if (!mUpdateSingleRule) {
+                            icb.saveRuleSet();
+                        } else {
+                            if (num_of_expansion > 1) {
+                                List<Rule> newRuleList = null;
+                                newRuleList = newRuleSet.getRules();
+                                for (int i = 0; i < newRuleList.size(); i++) {
+                                    Rule newRule = newRuleList.get(i);
+                                    icb.saveRule(newRule.mId);
+                                }
+                            }
+                        }
+                    } else if (facility.equals(CommandsInterface.CB_FACILITY_BA_ALL)
+                            && lockState == 0) {
+                        //Disable All Call Barring Cases (Triggered by
+                        // CallBarringResetPreference.java)
+
+                        RuleSet iNewRuleSet = null;
+                        RuleSet oNewRuleSet = null;
+                        RuleSet oldRuleSet = null;
+                        List<Rule> ruleList = null;
+
+                        //Note that:If no rule in RuleSet: In RuleSet.java's toXmlString(): get
+                        // null rule -> Null Pointer Exception
+                        //Read original rule first then copy each rule to new rule set but with
+                        // allow as true!
+                        oldRuleSet = ocb.getRuleSet();
+                        if (oldRuleSet != null) {
+                            ruleList = oldRuleSet.getRules();
+                        } else {
+                            Rlog.d(LOG_TAG, "No MO related CB rules in remote server");
+                        }
+
+                        if (ruleList != null) {
+                            oNewRuleSet = ocb.createNewRuleSet();
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                copyOldRuleToNewRuleSetWithDisabledCB(r, oNewRuleSet, true, -1, -1);
+                            }
+
+                            if (oNewRuleSet.getRules() != null) {
+                                Rlog.d(LOG_TAG, "Dump MO Disable All CB XML:"
+                                        + oNewRuleSet.toXmlString());
+                            } else {
+                                Rlog.d(LOG_TAG, "Dump MO Disable All CB XML: ruleset with empty "
+                                        + "rules");
+                            }
+                            if (!mUpdateSingleRule) {
+                                ocb.saveRuleSet();
+                            } else {
+                                List<Rule> newRuleList = null;
+                                newRuleList = oNewRuleSet.getRules();
+                                for (int i = 0; i < newRuleList.size(); i++) {
+                                    Rule newRule = newRuleList.get(i);
+                                    ocb.saveRule(newRule.mId);
+                                }
+                            }
+                        } else {
+                            Rlog.d(LOG_TAG, "No MO related CB rules in remote server");
+                        }
+
+                        oldRuleSet = icb.getRuleSet();
+                        if (oldRuleSet != null) {
+                            ruleList = oldRuleSet.getRules();
+                        } else {
+                            Rlog.d(LOG_TAG, "No MT related CB rules in remote server");
+                        }
+
+                        if (ruleList != null) {
+                            iNewRuleSet = icb.createNewRuleSet();
+                            for (int i = 0; i < ruleList.size(); i++) {
+                                Rule r = ruleList.get(i);
+                                copyOldRuleToNewRuleSetWithDisabledCB(r, iNewRuleSet, true, -1, -1);
+                            }
+
+                            if (iNewRuleSet.getRules() != null) {
+                                Rlog.d(LOG_TAG, "Dump MT Disable All CB XML:"
+                                        + iNewRuleSet.toXmlString());
+                            } else {
+                                Rlog.d(LOG_TAG, "Dump MT Disable All CB XML: ruleset with empty"
+                                        + " rules");
+                            }
+                            if (!mUpdateSingleRule) {
+                                icb.saveRuleSet();
+                            } else {
+                                List<Rule> newRuleList = null;
+                                newRuleList = iNewRuleSet.getRules();
+                                for (int i = 0; i < newRuleList.size(); i++) {
+                                    Rule newRule = newRuleList.get(i);
+                                    icb.saveRule(newRule.mId);
+                                }
+                            }
+                        } else {
+                            Rlog.d(LOG_TAG, "No MT related CB rules in remote server");
+                        }
+
+                    } else {
+                        //Not supported request & parameters
+                        throw new RuntimeException("Unrecognized SET_CB facility= "
+                               + facility + " and its parameters");
+                    }
+                } //end-of-for-loop (num_of_expansion)
+
+            } catch (XcapException xcapException) {
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    Rlog.d(LOG_TAG, "handleSetCB(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCB(): XcapException");
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): xcapException.isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCB(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+
+                //Get XCAP's configuration failed or set new configuration failed
+                //Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCB():Start to Print Stack Trace");
+                mOcbCache = null;
+                mOcbCachePhoneId = -1;
+                mOcbCacheLastQueried = 0;
+                mIcbCache = null;
+                mIcbCachePhoneId = -1;
+                mIcbCacheLastQueried = 0;
+
+                e.printStackTrace();
+
+                //Note that: upper layer application
+                // (CallBarringBasePreference.java:handleSetCallBarringResponse())
+                //Only cast the exception to CommandException is allowed (but it may happen
+                // assertion due to cast failure)
+                //And handle this exception in TimeConsumingPreferenceActivity.java's onError()
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+
+            }
+
+            //[Notify upper's application about the SET_CB result - Success Case without exception]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        /// For OP01 UT @{
+        public void handleGetCFInTimeSlot(MMTelSSRequest rr) {
+            int reqNo = -1;
+            int serialNo = -1;
+            CallForwardInfoEx infos[] = null;
+            ArrayList<CallForwardInfoEx> queriedCallForwardInfoList =
+                    new ArrayList<CallForwardInfoEx>();
+
+            int reason = -1;
+            int serviceClass = -1;
+            int orgServiceClass = -1;
+            String cfPhoneNum = "";
+            int queryStatus = 0; // 0: DISABLE, 1: ENABLE
+            int noReplyTimer = 20;
+            long[] timeSlot = null;
+            int phoneId = 0;
+
+            try {
+                rr.mp.setDataPosition(0);
+                reqNo = rr.mp.readInt();
+                serialNo = rr.mp.readInt();
+                reason = rr.mp.readInt();
+                serviceClass = rr.mp.readInt();
+                phoneId = rr.mp.readInt();
+                orgServiceClass = serviceClass;
+
+                Rlog.d(LOG_TAG, "Read from CF parcel: req = " + requestToString(reqNo) +
+                        ", reason = " + reason + ", serviceClass = " + serviceClass);
+
+                if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): !isPreferXcap()");
+                    throw new UnknownHostException();
+                }
+
+                CommunicationDiversion cd;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): mCdCache = " + mCdCache + ", curTime = "
+                        + curTime + ", mCdCacheLastQueried = " + mCdCacheLastQueried);
+                if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        (mCdCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): using ETAG mCdCache: " + mCdCache);
+                    requestXcapNetwork(phoneId);
+                    cd = mCdCache;
+                    cd.setNetwork(mNetwork);
+                    cd.refresh();
+                    mCdCacheLastQueried = curTime;
+                } else if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        ((curTime >= mCdCacheLastQueried)
+                        && ((curTime - mCdCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): using mCdCache: " + mCdCache);
+                    cd = mCdCache;
+                } else {
+                    requestXcapNetwork(phoneId);
+
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): XcapRoot = " + mXcapRoot);
+                        throw new UnknownHostException();
+                    }
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+
+                    cd = mSimservs.getCommunicationDiversion(true, mNetwork);
+                    mCdCache = cd;
+                    mCdCachePhoneId = phoneId;
+                    mCdCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): new mCdCache = " + mCdCache
+                            + ", curTime = " + curTime);
+                }
+
+                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): GetRuleSet from cd");
+
+                RuleSet ruleSet = cd.getRuleSet();
+                // In Communication Diversion's RuleSet, it may have several rules
+                // (e.g., rule for CFU, rule for CFB, rule for CFNoAnswer, rule for CFNotReachable)
+                List<Rule> ruleList = null;
+
+                if (ruleSet != null) {
+                    ruleList = ruleSet.getRules();
+                } else {
+                    Rlog.d(LOG_TAG, "No CF related rules in remote server");
+                }
+
+                // Note that: If no ant configuration is stored in XCAP server
+                // (e.g., empty xml string), ruleList will be null
+                if (ruleList != null) {
+                    // Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+                    if (orgServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO |
+                            CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                        serviceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                    }
+
+                    int numOfComparision = 0;
+
+                    if (orgServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                        serviceClass = CommandsInterface.SERVICE_CLASS_VOICE;
+                        // one is to match audio (i.e., serviceClass = SERVICE_CLASS_VOICE),
+                        // the other is to match video (i.e., SERVICE_CLASS_VIDEO)
+                        numOfComparision = 2;
+                        Rlog.d(LOG_TAG, "serviceClass == 0, " +
+                                "try to 1st match by using SERVICE_CLASS_VOICE");
+                    } else {
+                        // Specific serviceClass (i.e., value is not 0)
+                        // is carried from the upper layer
+                        numOfComparision = 1;
+                    }
+
+                    for (int it = 0; it < numOfComparision; it++) {
+                        if (it == 1 && serviceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                            // 2nd time to match all rules by using SERVICE_CLASS_VIDEO
+                            serviceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+                            Rlog.d(LOG_TAG, "serviceClass == 0, " +
+                                    "try to 2nd match by using SERVICE_CLASS_VIDEO");
+                        }
+
+                        Rlog.d(LOG_TAG, "numOfComparision = " + numOfComparision +
+                                ": with round = " + (it + 1) +
+                                ", with service class = " + serviceClass);
+
+                        // Check each rule & its corresponding condition/action
+                        for (int i = 0; i < ruleList.size(); i++) {
+                            Rule r = ruleList.get(i);
+                            Conditions cond = r.getConditions();
+                            Actions action = r.getActions();
+                            List<String> mediaList = null;
+
+                            if (cond != null) {
+                                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): " +
+                                        "busy = " + cond.comprehendBusy() +
+                                        ", NoAnswer = " + cond.comprehendNoAnswer() +
+                                        ", NoReachable = " + cond.comprehendNotReachable() +
+                                        ", NotRegistered = " + cond.comprehendNotRegistered());
+                                mediaList = cond.getMedias();
+                            } else {
+                                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): " +
+                                        "Empty cond (cond==null) for this rule=" + r);
+                            }
+
+                            if (reason == CommandsInterface.CF_REASON_UNCONDITIONAL &&
+                                    ((cond != null && cond.comprehendBusy() == false &&
+                                    cond.comprehendNoAnswer() == false &&
+                                    cond.comprehendNotRegistered() == false &&
+                                    cond.comprehendNotReachable() == false) &&
+                                    cond.comprehendRuleDeactivated() == false || cond == null) &&
+                                    containSpecificMedia(mediaList, serviceClass)) {
+                                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): " +
+                                        "CFU is enabled on server");
+                                // [CFU]CFU is enabled, set queryStatus as 1
+                                queryStatus = 1;
+                                if (action.getFowardTo() != null) {
+                                    cfPhoneNum = action.getFowardTo().getTarget();
+                                }
+                                // timeSeconds: This field is not required by CFU
+                                // (Only required by CFNoAnswer)
+                                noReplyTimer = cd.getNoReplyTimer();
+                                if (cond != null) {
+                                    timeSlot = convertToLocalTime(cond.comprehendTime());
+                                }
+                                break;
+                            } else {
+                                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot()from xcap: " +
+                                        "Not matched this rule!");
+                            }
+                        }
+                        CallForwardInfoEx item = new CallForwardInfoEx();
+                        item.status = queryStatus;
+                        item.reason = reason;
+                        item.serviceClass = serviceClass;
+                        item.toa = 0;
+                        item.number = cfPhoneNum;
+                        item.timeSeconds = noReplyTimer;
+                        item.timeSlot = timeSlot;
+                        Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): " +
+                                "add one record with reason = " + reason +
+                                ", serviceClass = " + serviceClass +
+                                ", queryStatus = " + queryStatus +
+                                ", timeSlot = " + Arrays.toString(timeSlot));
+                        queriedCallForwardInfoList.add(item);
+
+                        // Reset some variables for this matching result
+                        queryStatus = 0; // 0: DISABLE, 1: ENABLE
+                        cfPhoneNum = "";
+                        noReplyTimer = 20;
+                        timeSlot = null;
+                    }
+                    // end of for-loop(numOfComparision)
+
+                    int queriedSize = queriedCallForwardInfoList.size();
+
+                    infos = new CallForwardInfoEx[queriedSize];
+                    for (int inx = 0; inx < queriedSize; inx++) {
+                        infos[inx] = (CallForwardInfoEx) queriedCallForwardInfoList.get(inx);
+                    }
+                } else {
+                    // Empty XML String:CF is disabled, set queryStatus as 0
+                    Rlog.d(LOG_TAG, "handleGetCFInTimeSlot():get null ruleList");
+                    infos = new CallForwardInfoEx[0];
+                    queryStatus = 0;
+                }
+            } catch (UnknownHostException unknownHostException) {
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, unknownHostException);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (XcapException xcapException) {
+                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): XcapException");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                xcapException.printStackTrace();
+                if (null != rr.mResult) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            } catch (Exception e) {
+                Rlog.d(LOG_TAG, "handleGetCFInTimeSlot(): Start to Print Stack Trace");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return;
+                }
+            }
+
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, infos, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+        }
+
+        public int handleSetCFInTimeSlot(MMTelSSRequest rr) {
+            rr.mp.setDataPosition(0);
+            int reqNo = rr.mp.readInt();
+            int serialNo = rr.mp.readInt();
+
+            int setCFAction = rr.mp.readInt();
+            int setCFReason = rr.mp.readInt();
+            int setCFServiceClass = rr.mp.readInt();
+            String setCFNumber = rr.mp.readString();
+            int setCFTimeSeconds = rr.mp.readInt();
+            long[] timeSlot = new long[2];
+            try {
+                rr.mp.readLongArray(timeSlot);
+            } catch (Exception e) {
+                timeSlot = null;
+            }
+            String timeSlotString = convertToSeverTime(timeSlot);
+            int phoneId = rr.mp.readInt();
+
+            boolean addRuleForCFUWithAllMediaType = false;
+            String cfuRuleID = "CFU";
+
+            Rlog.d(LOG_TAG, "Read from CF parcel: req = " + requestToString(reqNo) +
+                    ", cfAction = " + setCFAction + ", reason = " + setCFReason +
+                    ", serviceClass = " + setCFServiceClass + ", number = " + setCFNumber +
+                    ", timeSec = " + setCFTimeSeconds +
+                    ", timsSlot = " + timeSlotString);
+
+            String xcapCFNum = SystemProperties.get(PROP_SS_CFNUM, "");
+            if (xcapCFNum.startsWith("sip:") ||
+                    xcapCFNum.startsWith("sips:") ||
+                    xcapCFNum.startsWith("tel:")) {
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): " +
+                        "get call forwarding num from EM setting: " + xcapCFNum);
+                String ssMode = SystemProperties.get(PROP_SS_MODE, MODE_SS_XCAP);
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): ssMode = " + ssMode);
+                if (MODE_SS_XCAP.equals(ssMode)) {
+                    setCFNumber = xcapCFNum;
+                }
+            }
+
+            // Change the serviceClass (VIDEO + DATA_SYNC) to VIDEO directly
+            if (setCFServiceClass == (CommandsInterface.SERVICE_CLASS_VIDEO |
+                    CommandsInterface.SERVICE_CLASS_DATA_SYNC)) {
+                setCFServiceClass = CommandsInterface.SERVICE_CLASS_VIDEO;
+            }
+
+            if (!MMTelSSUtils.isPreferXcap(phoneId)) {
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): !isPreferXcap()");
+                if (null != rr.mResult) {
+                    AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    rr.mResult.sendToTarget();
+                }
+                return 0;
+            }
+
+            try {
+                CommunicationDiversion cd;
+                long curTime = System.currentTimeMillis();
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): mCdCache = " + mCdCache + ", curTime = "
+                        + curTime + ", mCdCacheLastQueried = " + mCdCacheLastQueried
+                        + ", phoneId = " + phoneId);
+                if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        (mCdCache.isSupportEtag())) {
+                    Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): using ETAG mCdCache: " + mCdCache);
+                    requestXcapNetwork(phoneId);
+                    cd = mCdCache;
+                    cd.setNetwork(mNetwork);
+                    cd.refresh();
+                    mCdCacheLastQueried = curTime;
+                } else if ((mCdCache != null) && (phoneId == mCdCachePhoneId) &&
+                        ((curTime >= mCdCacheLastQueried)
+                        && ((curTime - mCdCacheLastQueried) < MMTEL_CACHE_VALID_TIME))) {
+                    Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): using mCdCache: " + mCdCache);
+                    cd = mCdCache;
+                } else {
+                    mXui = MMTelSSUtils.getXui(phoneId, mContext);
+                    mXcapRoot = MMTelSSUtils.getXcapRootUri(phoneId);
+                    mXIntendedId = MMTelSSUtils.getXIntendedId(phoneId, mContext);
+
+                    if (TextUtils.isEmpty(mXcapRoot)) {
+                        Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): XcapRoot = " + mXcapRoot);
+                        if (null != rr.mResult) {
+                            AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                            rr.mResult.sendToTarget();
+                        }
+                        return 0;
+                    }
+
+                    requestXcapNetwork(phoneId);
+
+                    setSimservsInitParameters(mXui, mXcapRoot, mXIntendedId, mUserName, mPassword,
+                            phoneId);
+                    cd = mSimservs.getCommunicationDiversion(true, mNetwork);
+                    mCdCache = cd;
+                    mCdCachePhoneId = phoneId;
+                    mCdCacheLastQueried = curTime;
+                    Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): new mCdCache = " + mCdCache
+                            + ", curTime = " + curTime);
+                }
+
+                RuleSet ruleSet = cd.getRuleSet();
+                List<Rule> ruleList = null;
+                RuleSet newRuleSet = cd.createNewRuleSet();
+                boolean addedNewRule = false;
+
+                if (ruleSet != null) {
+                    ruleList = ruleSet.getRules();
+                } else {
+                    Rlog.d(LOG_TAG, "No CF related rules in remote server");
+                }
+
+                // Note that: If no ant configuration is stored in XCAP server
+                // (e.g., empty xml string), ruleList will be null
+                if (ruleList != null) {
+                    // Check each rule & its corresponding condition/action
+                    for (int i = 0; i < ruleList.size(); i++) {
+                        Rule r = ruleList.get(i);
+                        Conditions cond = r.getConditions();
+                        Actions action = r.getActions();
+                        List<String> mediaList = null;
+
+                        if (cond != null) {
+                            mediaList = cond.getMedias();
+                            Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): " +
+                                    "busy = " + cond.comprehendBusy() +
+                                    ", NoAnswer = " + cond.comprehendNoAnswer() +
+                                    ", NoReachable = " + cond.comprehendNotReachable() +
+                                    ", NotRegistered = " + cond.comprehendNotRegistered());
+                            if (cond.comprehendBusy()) {
+                                Rlog.d(LOG_TAG, "The rule is CFB");
+                            } else if (cond.comprehendNoAnswer()) {
+                                Rlog.d(LOG_TAG, "The rule is CFNoAnswer");
+                            } else if (cond.comprehendNotReachable()) {
+                                Rlog.d(LOG_TAG, "The rule is CFNotReachable");
+                            } else if (cond.comprehendNotRegistered()) {
+                                Rlog.d(LOG_TAG, "The rule is CFNotRegistered");
+                            } else {
+                                cfuRuleID = r.mId;
+                                Rlog.d(LOG_TAG, "Update cfuRuleID = " + cfuRuleID);
+                            }
+                        } else {
+                            Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): " +
+                                    "Empty cond (cond==null) for this rule = " + r);
+                            if (cfuRuleID.equals("CFU")) {
+                                //CFU rule
+                                cfuRuleID = r.mId;
+                                Rlog.d(LOG_TAG, "Update cfuRuleID = " + cfuRuleID);
+                            }
+                        }
+
+                        if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL &&
+                                ((cond != null && cond.comprehendBusy() == false &&
+                                cond.comprehendNoAnswer() == false &&
+                                cond.comprehendNotRegistered() == false &&
+                                cond.comprehendNotReachable() == false) || cond == null) &&
+                                containSpecificMedia(mediaList, setCFServiceClass)) {
+
+                            if ((setCFServiceClass != CommandsInterface.SERVICE_CLASS_NONE) ||
+                                    (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE &&
+                                    addRuleForCFUWithAllMediaType == false)) {
+                                if (setCFAction == CommandsInterface.CF_ACTION_ENABLE ||
+                                        setCFAction == CommandsInterface.CF_ACTION_REGISTRATION) {
+                                    addedNewRule = handleCreateNewRuleForCFInTimeSlot(
+                                            cd, newRuleSet, setCFReason, setCFAction,
+                                            setCFServiceClass, setCFNumber, setCFTimeSeconds,
+                                            timeSlotString, cfuRuleID, mUpdateSingleRule);
+                                } else {
+                                    addedNewRule = handleCreateNewRuleForExistingCF(
+                                            cd, newRuleSet, r, setCFReason, setCFAction,
+                                            setCFServiceClass, setCFNumber, setCFTimeSeconds,
+                                            cfuRuleID, mUpdateSingleRule, 1, phoneId);
+                                }
+                                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): CFU-addedNewRule = " +
+                                        addedNewRule);
+                                if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                                    addRuleForCFUWithAllMediaType = true;
+                                }
+                            } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE &&
+                                    addRuleForCFUWithAllMediaType == true) {
+                                Rlog.d(LOG_TAG, "Already add rule for CFU previously");
+                            }
+                        } else {
+                            // Copy old rule into new rule set
+                            Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): " +
+                                    "Copy old rule to newRuleSet");
+                            copyOldRuleToNewRuleSet(r, newRuleSet, setCFAction, setCFReason);
+                        }
+                    }
+                    // end-of-for-loop (ruleList)
+                }
+
+                // Check if the new rule user wants to be modified is already added to or not
+                if (addedNewRule == false &&
+                        (setCFAction == CommandsInterface.CF_ACTION_ENABLE ||
+                        setCFAction == CommandsInterface.CF_ACTION_REGISTRATION)) {
+                    addedNewRule = true;
+                    handleCreateNewRuleForCFInTimeSlot(
+                            cd, newRuleSet, setCFReason, setCFAction,
+                            setCFServiceClass, setCFNumber, setCFTimeSeconds,
+                            timeSlotString, cfuRuleID, mUpdateSingleRule);
+                }
+
+                // Finally, update the new rule set back to remote XCAP server
+                // Debug:
+                if (newRuleSet.getRules() != null) {
+                    Rlog.d(LOG_TAG, "Dump SetCF XML: " + newRuleSet.toXmlString());
+                } else {
+                    Rlog.d(LOG_TAG, "Dump SetCF XML: ruleset with empty rules");
+                }
+
+                if (!mUpdateSingleRule) {
+                    cd.saveRuleSet();
+                }
+            } catch (XcapException xcapException) {
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+                if (xcapException.getHttpErrorCode() == HTTP_ERROR_CODE_412) {
+                    
+                    Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): HTTP_ERROR_CODE_412");
+                    return HTTP_ERROR_CODE_412;
+                }
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): XcapException");
+                xcapException.printStackTrace();
+                if (rr.mResult != null) {
+                    if (xcapException.isConnectionError()) {
+                        Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): isConnectionError()");
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else if (MMTelSSUtils.isOp06IccCard(phoneId)
+                            && (xcapException.getHttpErrorCode() != 0)) {
+                        Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): OP06 with http Error: "
+                                + xcapException.getHttpErrorCode());
+                        AsyncResult.forMessage(rr.mResult, null, new UnknownHostException());
+                    } else {
+                        AsyncResult.forMessage(rr.mResult, null, xcapException);
+                    }
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            } catch (Exception e) {
+                // Get XCAP's configuration failed or set new configuration failed
+                // Generate an exception result callback to upper application
+                Rlog.d(LOG_TAG, "handleSetCFInTimeSlot(): Start to Print Stack Trace");
+                mCdCache = null;
+                mCdCachePhoneId = -1;
+                mCdCacheLastQueried = 0;
+
+                e.printStackTrace();
+                if (rr.mResult != null) {
+                    CommandException ce =
+                            CommandException.fromRilErrno(RILConstants.GENERIC_FAILURE);
+                    AsyncResult.forMessage(rr.mResult, null, ce);
+                    rr.mResult.sendToTarget();
+                    if (mXcapMobileDataNetworkManager != null) {
+                        mXcapMobileDataNetworkManager.releaseNetwork();
+                    }
+                    return 0;
+                }
+            }
+
+            // [Notify upper's application about the SET_CF result - Success Case]
+            if (rr.mResult != null) {
+                AsyncResult.forMessage(rr.mResult, null, null);
+                rr.mResult.sendToTarget();
+            }
+            if (mXcapMobileDataNetworkManager != null) {
+                mXcapMobileDataNetworkManager.releaseNetwork();
+            }
+
+            return 0;
+        }
+
+        public boolean handleCreateNewRuleForCFInTimeSlot(CommunicationDiversion cd,
+                RuleSet newRuleSet, int setCFReason, int setCFAction,
+                int setCFServiceClass, String setCFNumber, int setCFTimeSeconds,
+                String timeSlot, String ruleID, boolean updateSingleRule) throws XcapException {
+            // Create a new rule
+            Rule cfRule = newRuleSet.createNewRule(ruleID);
+            Conditions cfCond = cfRule.createConditions();
+            Actions cfAction = cfRule.createActions();
+            Rlog.d(LOG_TAG, "handleCreateNewRuleForCFInTimeSlot(): reason = " + setCFReason +
+                    ", serviceClass = " + setCFServiceClass + ", number = " + setCFNumber +
+                    ", cfTime = " + setCFTimeSeconds +
+                    ", timeSlot = " + timeSlot);
+            // Add media into this new rule
+            if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VOICE) {
+                cfCond.addMedia("audio");
+            } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_VIDEO) {
+                cfCond.addMedia("video");
+            } else if (setCFServiceClass == CommandsInterface.SERVICE_CLASS_NONE) {
+                cfCond.addMedia("audio");
+                cfCond.addMedia("video");
+            }
+
+            if (setCFReason == CommandsInterface.CF_REASON_BUSY) {
+                cfCond.addBusy();
+            } else if (setCFReason == CommandsInterface.CF_REASON_NO_REPLY) {
+                cfCond.addNoAnswer();
+            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REACHABLE) {
+                cfCond.addNotReachable();
+            } else if (setCFReason == CommandsInterface.CF_REASON_NOT_REGISTERED) {
+                cfCond.addNotRegistered();
+            } else if (setCFReason == CommandsInterface.CF_REASON_UNCONDITIONAL) {
+                // Not set any conditions -> always evaluate the result as true
+            }
+            cfCond.addTime(timeSlot);
+            if (MMTelSSUtils.isNotifyCallerTest()) {
+                cfAction.setFowardTo(setCFNumber, false);
+            } else {
+                cfAction.setFowardTo(setCFNumber, true);
+            }
+            cfAction.getFowardTo().setRevealIdentityToCaller(true);
+            cfAction.getFowardTo().setRevealIdentityToTarget(true);
+
+            if (updateSingleRule) {
+                cd.saveRule(ruleID);
+            }
+            return true;
+        }
+
+        public long[] convertToLocalTime(String timeSlotString) {
+            long[] timeSlot = null;
+            if (timeSlotString != null) {
+                String[] timeArray = timeSlotString.split(",", 2);
+                if (timeArray.length == 2) {
+                    timeSlot = new long[2];
+                    for (int i = 0; i < 2; i++) {
+                        SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm");
+                        dateFormat.setTimeZone(TimeZone.getTimeZone("GMT+8"));
+                        try {
+                            Date date = dateFormat.parse(timeArray[i]);
+                            timeSlot[i] = date.getTime();
+                        } catch (ParseException e) {
+                            e.printStackTrace();
+                            return null;
+                        }
+                    }
+                }
+            }
+            return timeSlot;
+        }
+
+        public String convertToSeverTime(long[] timeSlot) {
+            String timeSlotString = null;
+            if (timeSlot == null || timeSlot.length != 2) {
+                return null;
+            }
+            for (int i = 0; i < timeSlot.length; i++) {
+                Date date = new Date(timeSlot[i]);
+                SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm");
+                dateFormat.setTimeZone(TimeZone.getTimeZone("GMT+8"));
+                if (i == 0) {
+                    timeSlotString = dateFormat.format(date);
+                } else {
+                    timeSlotString += "," + dateFormat.format(date);
+                }
+            }
+            return timeSlotString;
+        }
+        /// @}
+
+        //***** Handler implementation
+        @Override public void
+        handleMessage(Message msg) {
+            MMTelSSRequest rr = (MMTelSSRequest) (msg.obj);
+            MMTelSSRequest req = null;
+
+            switch (msg.what) {
+                case EVENT_SEND:
+                    /**
+                     * mRequestMessagePending++ already happened for every
+                     * EVENT_SEND, thus we must make sure
+                     * mRequestMessagePending-- happens once and only once
+                     */
+                    boolean alreadySubtracted = false;
+                    int reqNo = -1;
+                    int serialNo = -1;
+
+                    Rlog.d(LOG_TAG, "handleMessage(): EVENT_SEND:"
+                            + "mRequestMessagesPending = " + mRequestMessagesPending
+                            + ", mRequestsList.size() = " + mRequestsList.size());
+                    try {
+                        synchronized (mRequestsList) {
+                            mRequestsList.add(rr);
+                        }
+
+                        mRequestMessagesPending--;
+                        alreadySubtracted = true;
+                        //MTK-END [mtk04070][111121][ALPS00093395]MTK modified
+
+
+                        //[MMTelSS] Because it always gets response from simServs immediately,
+                        // it must invoke findAndRemoveRequestFromList() here instead of RIL's
+                        // invoking at proceeResponse()
+                        findAndRemoveRequestFromList(rr.mSerial);
+
+                        //Rlog.d(LOG_TAG, "Receive MMTelSS Request:" + requestToString(rr.mRequest)
+                        // + ", parcel dataLen=" + data.length);
+                        Rlog.d(LOG_TAG, "Receive MMTelSS Request:" + requestToString(rr.mRequest));
+
+                        switch (rr.mRequest) {
+                            case MMTELSS_REQ_SET_CLIR:
+                                if (HTTP_ERROR_CODE_412 == handleSetCLIR(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCLIR() again");
+                                    handleSetCLIR(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CLIR:
+                                handleGetCLIR(rr);
+                                break;
+                            case MMTELSS_REQ_GET_CLIP:
+                                handleGetCLIP(rr);
+                                break;
+                            case MMTELSS_REQ_GET_COLP:
+                                handleGetCOLP(rr);
+                                break;
+                            case MMTELSS_REQ_GET_COLR:
+                                handleGetCOLR(rr);
+                                break;
+                            case MMTELSS_REQ_SET_CW:
+                                if (HTTP_ERROR_CODE_412 == handleSetCW(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCW() again");
+                                    handleSetCW(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CW:
+                                handleGetCW(rr);
+                                break;
+                            case MMTELSS_REQ_SET_CB:
+                                if (HTTP_ERROR_CODE_412 == handleSetCB(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCB() again");
+                                    handleSetCB(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CB:
+                                handleGetCB(rr);
+                                break;
+                            case MMTELSS_REQ_SET_CF:
+                                if (HTTP_ERROR_CODE_412 == handleSetCF(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCF() again");
+                                    handleSetCF(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CF:
+                                handleGetCF(rr);
+                                break;
+                            case MMTELSS_REQ_SET_CLIP:
+                                handleSetCLIP(rr);
+                                break;
+                            case MMTELSS_REQ_SET_COLP:
+                                handleSetCOLP(rr);
+                                break;
+                            case MMTELSS_REQ_SET_COLR:
+                                handleSetCOLR(rr);
+                                break;
+                            /// For OP01 UT @{
+                            case MMTELSS_REQ_SET_CF_TIME_SLOT:
+                                if (HTTP_ERROR_CODE_412 == handleSetCFInTimeSlot(rr)) {
+                                    Rlog.d(LOG_TAG, "Cache out of date, handleSetCFInTimeSlot()"
+                                            + " again");
+                                    handleSetCFInTimeSlot(rr);
+                                }
+                                break;
+                            case MMTELSS_REQ_GET_CF_TIME_SLOT:
+                                handleGetCFInTimeSlot(rr);
+                                break;
+                            /// @}
+                            default:
+                                Rlog.d(LOG_TAG, "Invalid MMTelSS Request:" + rr.mRequest);
+                                throw new RuntimeException("Unrecognized MMTelSS Request: "
+                                        + rr.mRequest);
+                        }
+
+                        //Rlog.v(LOG_TAG, "writing packet: " + data.length + " bytes");
+
+                    } catch (RuntimeException exc) {
+                        Rlog.e(LOG_TAG, "Uncaught exception ", exc);
+                        req = findAndRemoveRequestFromList(rr.mSerial);
+                        // make sure this request has not already been handled,
+                        // eg, if RILReceiver cleared the list.
+                        Rlog.d(LOG_TAG, "handleMessage(): RuntimeException:"
+                                + "mRequestMessagesPending = " + mRequestMessagesPending
+                                + ", mRequestsList.size() = " + mRequestsList.size());
+                        if (req != null || !alreadySubtracted) {
+                            rr.onError(RILConstants.GENERIC_FAILURE, null);
+                            rr.release();
+                        }
+                    } finally {
+                        // Note: We are "Done" only if there are no outstanding
+                        // requests or replies. Thus this code path will only release
+                        // the wake lock on errors.
+                        releaseWakeLockIfDone();
+                    }
+
+                    //MTK-START [mtk04070][111121][ALPS00093395]MTK modified
+                    if (!alreadySubtracted) {
+                        Rlog.d(LOG_TAG, "handleMessage(): !alreadySubtracted:"
+                                + "mRequestMessagesPending = " + mRequestMessagesPending
+                                + ", mRequestsList.size() = " + mRequestsList.size());
+                        mRequestMessagesPending--;
+                    }
+                    //MTK-END [mtk04070][111121][ALPS00093395]MTK modified
+
+                    //Recycle the Parcel object back to the pool by mtk01411
+                    if (rr.mp != null) {
+                        rr.mp.recycle();
+                        rr.mp = null;
+                    }
+
+                    if ((mRequestMessagesPending != 0) || (mRequestsList.size() != 0)) {
+                        Rlog.d(LOG_TAG, "handleMessage(): ERROR wakeLock:"
+                                + "mRequestMessagesPending = " + mRequestMessagesPending
+                                + ", mRequestsList.size() = " + mRequestsList.size());
+                    }
+                    break;
+
+                case EVENT_WAKE_LOCK_TIMEOUT:
+                    // Haven't heard back from the last request.  Assume we're
+                    // not getting a response and  release the wake lock.
+                    // TODO should we clean up mRequestList and mRequestPending
+                    synchronized (mWakeLock) {
+                        if (mWakeLock.isHeld()) {
+                            if (DBG) {
+                                synchronized (mRequestsList) {
+                                    int count = mRequestsList.size();
+                                    Rlog.d(LOG_TAG, "WAKE_LOCK_TIMEOUT " +
+                                            " mReqPending=" + mRequestMessagesPending +
+                                            " mRequestList=" + count);
+
+                                    for (int i = 0; i < count; i++) {
+                                        rr = mRequestsList.get(i);
+                                        Rlog.d(LOG_TAG, i + ": [" + rr.mSerial + "] " +
+                                                requestToString(rr.mRequest));
+
+                                    }
+                                }
+                            }
+                            mWakeLock.release();
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+
+
+    /**
+     * Get the Phone ID for Ut/XCAP request. If IMS is registered, use IMS Phone ID.
+     * Ohterwise, use the CS domain Phone ID.
+     */
+    private int getUtXcapPhoneId() {
+        int imsPhoneId = MMTelSSUtils.getDefaultImsPhoneId(mContext);
+
+        if (imsPhoneId < 0) {
+            int csDomainPhoneId = SystemProperties.getInt(PROPERTY_CS_CURRENT_PHONE_ID, 0);
+            Rlog.d(LOG_TAG, "getUtXcapPhoneId(): use CS domain phoneId by SystemProperties = " + 
+                csDomainPhoneId);
+            return csDomainPhoneId;
+        } else {
+            Rlog.d(LOG_TAG, "getUtXcapPhoneId(): use IMS phoneId = " + imsPhoneId);
+            return imsPhoneId;
+        }
+    }
+
+    // Only Support 2/3G SS Feature Sets
+    public void
+    setCLIR(int clirMode, Message result) {
+        setCLIR(clirMode, result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set CLIR for the specific phoneId.
+     * @param clirMode enable/disable CLIR
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCLIR(int clirMode, Message result, int phoneId) {
+        //OriginatingIdentityPresentation oip =
+        // SimServs.getOriginatingIdentityPresentation(xcapUri, TEST_USER, "password");
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CLIR, result);
+        //clirMode: 0-CommandsInterface.CLIR_DEFAULT , 1-CommandsInterface.CLIR_INVOCATION
+        // (restrict CLI presentation), 2-CommandsInterface.CLIR_SUPPRESSION
+        // (allow CLI presentation)
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    getCLIR(Message result) {
+        getCLIR(result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get CLIR mode for the specific phoneId.
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    getCLIR(Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CLIR, result);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    setCLIP(int clipEnable, Message result) {
+        setCLIP(clipEnable, result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set CLIP for the specific phoneId.
+     * @param clipEnable enable/disable CLIP
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCLIP(int clipEnable, Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CLIP, result);
+        rr.mp.writeInt(clipEnable);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    queryCLIP(Message result) {
+        queryCLIP(result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get CLIP for the specific phoneId.
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryCLIP(Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CLIP, result);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    setCOLP(int colpEnable, Message result) {
+        setCOLP(colpEnable, result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set COLP for the specific phoneId.
+     * @param colpEnable enable/disable COLP
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCOLP(int colpEnable, Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_COLP, result);
+        rr.mp.writeInt(colpEnable);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    getCOLP(Message result) {
+        getCOLP(result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get COLP for the specific phoneId.
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    getCOLP(Message result, int phoneId) {
+        MMTelSSRequest rr
+        = MMTelSSRequest.obtain(MMTELSS_REQ_GET_COLP, result);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    setCOLR(int colrMode, Message result) {
+        setCOLR(colrMode, result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set COLR for the specific phoneId.
+     * @param colrMode enable/disable COLR
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCOLR(int colrMode, Message result, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_COLR, result);
+        rr.mp.writeInt(colrMode);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    getCOLR(Message result) {
+        getCOLR(result, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get COLR for the specific phoneId.
+     * @param result Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    getCOLR(Message result, int phoneId) {
+        MMTelSSRequest rr
+        = MMTelSSRequest.obtain(MMTELSS_REQ_GET_COLR, result);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    setCallWaiting(boolean enable, int serviceClass, Message response) {
+        setCallWaiting(enable, serviceClass, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set Call Waiting for the specific phoneId.
+     * @param enable enable/disable Call Waiting
+     * @param serviceClass service class for Call Waiting
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCallWaiting(boolean enable, int serviceClass, Message response, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CW, response);
+        rr.mp.writeInt((enable == true) ? 1 : 0);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    queryCallWaiting(int serviceClass, Message response) {
+        queryCallWaiting(serviceClass, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get Call Waiting mode for the specific phoneId.
+     * @param serviceClass service class for Call Waiting
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryCallWaiting(int serviceClass, Message response, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CW, response);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    setFacilityLock(String facility, boolean lockState, String password,
+            int serviceClass, Message response) {
+        setFacilityLock(facility, lockState, password,
+                serviceClass, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set Call Barring for the specific phoneId.
+     * @param facility Call Barring type
+     * @param lockState enable/disable Call Barring
+     * @param password password
+     * @param serviceClass service class for Call Barring
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setFacilityLock(String facility, boolean lockState, String password,
+            int serviceClass, Message response, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CB, response);
+        rr.mp.writeString(facility);
+        rr.mp.writeInt((lockState == true) ? 1 : 0);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    queryFacilityLock(String facility, String password, int serviceClass,
+            Message response) {
+        queryFacilityLock(facility, password, serviceClass,
+                response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get Call Barring mode for the specific phoneId.
+     * @param facility Call Barring type
+     * @param password password
+     * @param serviceClass service class for Call Barring
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryFacilityLock(String facility, String password, int serviceClass,
+            Message response, int phoneId) {
+
+        //[Example]Testing fake-result by mtk01411 2013-0904
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CB, response);
+        rr.mp.writeString(facility);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    setCallForward(int action, int cfReason, int serviceClass,
+            String number, int timeSeconds, Message response) {
+        setCallForward(action, cfReason, serviceClass,
+                number, timeSeconds, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set Call Forwarding for the specific phoneId.
+     * @param action CommandsInterface Call Forwarding action
+     * @param cfReason CommandsInterface Call Forwarding reason
+     * @param serviceClass service class for Call Barring
+     * @param number forwarded-to number
+     * @param timeSeconds no-reply time
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCallForward(int action, int cfReason, int serviceClass,
+            String number, int timeSeconds, Message response, int phoneId) {
+        // target should be a SIP URI (IETF RFC 3261 [6]) or TEL URL (IETF RFC 3966 [7])
+        if (number != null && !number.startsWith("sip:") && !number.startsWith("sips:")
+                && !number.startsWith("tel:")) {
+            number = "tel:" + number;
+        }
+
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CF, response);
+        rr.mp.writeInt(action);
+        rr.mp.writeInt(cfReason);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeString(number);
+        rr.mp.writeInt(timeSeconds);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+
+    public void
+    queryCallForwardStatus(int cfReason, int serviceClass,
+            String number, Message response) {
+        queryCallForwardStatus(cfReason, serviceClass,
+                number, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get Call Forwarding status for the specific phoneId.
+     * @param cfReason CommandsInterface Call Forwarding reason
+     * @param serviceClass service class for Call Barring
+     * @param number forwarded-to number
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryCallForwardStatus(int cfReason, int serviceClass,
+            String number, Message response, int phoneId) {
+        //[Example]Testing fake-result by mtk01411 2013-0904
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CF, response);
+
+        rr.mp.writeInt(2); // cfAction filed: 2 is for query action, not in used anyway
+                           // (See ril.h RIL_CallForwardInfo: 2 = interrogate)
+        rr.mp.writeInt(cfReason);
+        rr.mp.writeInt(serviceClass);
+        //Only through GsmMMICode:It will carry the dialNumber
+        if (number != null) {
+            rr.mp.writeString(number);
+        } else {
+            rr.mp.writeString("");
+        }
+        rr.mp.writeInt(phoneId);
+
+        send(rr);
+
+    }
+
+    /// For OP01 UT @{
+    public void
+    setCallForwardInTimeSlot(int action, int cfReason, int serviceClass,
+                String number, int timeSeconds, long[] timeSlot, Message response) {
+        setCallForwardInTimeSlot(action, cfReason, serviceClass,
+                number, timeSeconds, timeSlot, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Set Call Forwarding with timeSolt for the specific phoneId.
+     * @param action CommandsInterface Call Forwarding action
+     * @param cfReason CommandsInterface Call Forwarding reason
+     * @param serviceClass service class for Call Barring
+     * @param number forwarded-to number
+     * @param timeSeconds no-reply time
+     * @param timeSlot time slot for CFU
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    setCallForwardInTimeSlot(int action, int cfReason, int serviceClass,
+                String number, int timeSeconds, long[] timeSlot, Message response, int phoneId) {
+        // target should be a SIP URI (IETF RFC 3261 [6]) or TEL URL (IETF RFC 3966 [7])
+        if (number != null && !number.startsWith("sip:") && !number.startsWith("sips:")
+                && !number.startsWith("tel:")) {
+            number = "tel:" + number;
+        }
+
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_SET_CF_TIME_SLOT, response);
+        rr.mp.writeInt(action);
+        rr.mp.writeInt(cfReason);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeString(number);
+        rr.mp.writeInt(timeSeconds);
+        rr.mp.writeLongArray(timeSlot);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+
+    public void
+    queryCallForwardInTimeSlotStatus(int cfReason,
+            int serviceClass, Message response) {
+        queryCallForwardInTimeSlotStatus(cfReason,
+                serviceClass, response, getUtXcapPhoneId());
+    }
+
+    /**
+     * Get Call Forwarding with timeSolt for the specific phoneId.
+     * @param cfReason CommandsInterface Call Forwarding reason
+     * @param serviceClass service class for Call Barring
+     * @param response Message callback
+     * @param phoneId the phone index
+     */
+    public void
+    queryCallForwardInTimeSlotStatus(int cfReason,
+            int serviceClass, Message response, int phoneId) {
+        MMTelSSRequest rr = MMTelSSRequest.obtain(MMTELSS_REQ_GET_CF_TIME_SLOT, response);
+        rr.mp.writeInt(cfReason);
+        rr.mp.writeInt(serviceClass);
+        rr.mp.writeInt(phoneId);
+        send(rr);
+    }
+    /// @}
+
+    private void
+    acquireWakeLock() {
+        Rlog.d(LOG_TAG, "=>wakeLock() "
+                + "mRequestMessagesPending = " + mRequestMessagesPending
+                + ", mRequestsList.size() = " + mRequestsList.size());
+        synchronized (mWakeLock) {
+            mWakeLock.acquire();
+            mRequestMessagesPending++;
+
+            mSender.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+            Message msg = mSender.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
+            mSender.sendMessageDelayed(msg, mWakeLockTimeout);
+        }
+    }
+
+    private void
+    releaseWakeLockIfDone() {
+        Rlog.d(LOG_TAG, "wakeLock()=> "
+                + "mRequestMessagesPending = " + mRequestMessagesPending
+                + ", mRequestsList.size() = " + mRequestsList.size());
+        synchronized (mWakeLock) {
+            if (mWakeLock.isHeld() &&
+                    (mRequestMessagesPending == 0) &&
+                    //MTK-START [mtk04070][111121][ALPS00093395]MTK modified
+                    (mRequestsList.size() == 0)) {
+                //MTK-END [mtk04070][111121][ALPS00093395]MTK modified
+                mSender.removeMessages(EVENT_WAKE_LOCK_TIMEOUT);
+                mWakeLock.release();
+            }
+        }
+    }
+
+    private MMTelSSRequest findAndRemoveRequestFromList(int serial) {
+        synchronized (mRequestsList) {
+            for (int i = 0, s = mRequestsList.size() ; i < s ; i++) {
+                MMTelSSRequest rr = mRequestsList.get(i);
+
+                if (rr.mSerial == serial) {
+                    mRequestsList.remove(i);
+                    if (mRequestMessagesWaiting > 0)
+                        mRequestMessagesWaiting--;
+                    return rr;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    static String
+    requestToString(int request) {
+        switch (request) {
+            case MMTELSS_REQ_SET_CLIR: return "SET_CLIR";
+            case MMTELSS_REQ_GET_CLIR: return "GET_CLIR";
+            case MMTELSS_REQ_GET_CLIP: return "GET_CLIP";
+            case MMTELSS_REQ_GET_COLP: return "GET_COLP";
+            case MMTELSS_REQ_GET_COLR: return "GET_COLR";
+            case MMTELSS_REQ_SET_CW: return "SET_CW";
+            case MMTELSS_REQ_GET_CW: return "GET_CW";
+            case MMTELSS_REQ_SET_CB: return "SET_CB";
+            case MMTELSS_REQ_GET_CB: return "GET_CB";
+            case MMTELSS_REQ_SET_CF: return "SET_CF";
+            case MMTELSS_REQ_GET_CF: return "GET_CF";
+            /// For OP01 UT @{
+            case MMTELSS_REQ_SET_CF_TIME_SLOT: return "SET_CF_TIME_SLOT";
+            case MMTELSS_REQ_GET_CF_TIME_SLOT: return "GET_CF_TIME_SLOT";
+            /// @}
+            default: return "UNKNOWN MMTELSS REQ";
+        }
+
+    }
+
+
+    //[MMTelSS] Dump Call Forwarding Rule
+    public void dumpCFRule(Rule rule) {
+        Conditions cond = null;
+        Actions action = null;
+        ForwardTo forward = null;
+
+        if (rule != null) {
+            cond = rule.getConditions();
+            action = rule.getActions();
+            if (cond == null || action == null) {
+                return;
+            }
+        } else {
+            return;
+        }
+
+        forward = action.getFowardTo();
+        Rlog.d(LOG_TAG, "Dump CF Rule:busy=" + cond.comprehendBusy() + ",noAns="
+                + cond.comprehendNoAnswer() + ",noReachable=" + cond.comprehendNotReachable()
+                + ",noRegistered=" + cond.comprehendNotRegistered() + ",forward_to_Target="
+                + forward.getTarget() + ",isNotifyCaller=" + forward.isNotifyCaller());
+        List<String> mediaList = cond.getMedias();
+        String mediaTypeList = "";
+        if (mediaList != null) {
+            for (int i = 0; i < mediaList.size(); i++) {
+                mediaTypeList += (" " + mediaList.get(i));
+            }
+            Rlog.d(LOG_TAG, "Dump CF Rule:mediaTypeList=" + mediaTypeList);
+        }
+    }
+
+    public void dumpCBRule(Rule rule) {
+        Conditions cond = null;
+        Actions action = null;
+
+        if (rule != null) {
+            cond = rule.getConditions();
+            action = rule.getActions();
+            if (cond == null || action == null) {
+                return;
+            }
+        } else {
+            return;
+        }
+
+        Rlog.d(LOG_TAG, "Dump CB Rule: international=" + cond.comprehendInternational()
+                + ",roaming=" + cond.comprehendRoaming());
+        List<String> mediaList = cond.getMedias();
+        String mediaTypeList = "";
+        if (mediaList != null) {
+            for (int i = 0; i < mediaList.size(); i++) {
+                mediaTypeList += (" " + mediaList.get(i));
+            }
+            Rlog.d(LOG_TAG, "Dump CB Rule:mediaTypeList=" + mediaTypeList);
+        }
+
+    }
+
+    private void
+    send(MMTelSSRequest rr) {
+        Message msg;
+        msg = mSender.obtainMessage(EVENT_SEND, rr);
+        acquireWakeLock();
+        msg.sendToTarget();
+
+    }
+}
+
diff --git a/packages/Ims/src/com/mediatek/ims/MMTelSSUtils.java b/packages/Ims/src/com/mediatek/ims/MMTelSSUtils.java
new file mode 100644
index 0000000..bde8582
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/MMTelSSUtils.java
@@ -0,0 +1,707 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.content.Context;
+import android.net.Network;
+
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+/// SS OP01 Ut @{
+import java.util.Arrays;
+import java.util.List;
+/// @}
+import javax.net.SocketFactory;
+
+import android.os.Build;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.text.TextUtils;
+
+import com.android.ims.ImsException;
+import com.android.ims.ImsManager;
+/// SS OP01 Ut
+import com.mediatek.ims.internal.ImsXuiManager;
+import com.mediatek.simservs.client.SimServs;
+import com.mediatek.telephony.TelephonyManagerEx;
+
+/**
+ * Implementation for MMTel SS Utils.
+ *
+ * {@hide}
+ *
+ */
+public class MMTelSSUtils {
+    private static final String LOG_TAG = "MMTelSSUtils";
+    static String sXcapUri;
+    static String remoteIp = null;
+    static boolean queryXcapSrvDone = false;
+
+    //Following Constants definition must be same with EngineerMode/ims/ImsActivity.java
+    private final static String PROP_SS_MODE = "persist.radio.ss.mode";
+    private final static String MODE_SS_XCAP = "Prefer XCAP";
+    private final static String MODE_SS_CS = "Prefer CS";
+
+    private static boolean IS_USER_BUILD = "user".equals(Build.TYPE);
+    private static boolean IS_ENG_BUILD = "eng".equals(Build.TYPE);
+
+    /// SS OP01 Ut @{
+    private static final List<String> OP01_MCCMNC_LIST = Arrays.asList("46000", "46002",
+            "46007", "46008");
+    /// @}
+
+    private static final List<String> OP06_MCCMNC_LIST = Arrays.asList("26202", "26204",
+            "26209", "20205", "21670", "27402", "27403", "27201", "22210", "27801", "20404",
+            "26801", "22601", "21401", "21406", "28602", "23415", "23591", "90128");
+
+    private static final List<String> OP07_MCCMNC_LIST = Arrays.asList("31030", "31080",
+            "310150", "310170", "310280", "310380", "310410", "310560", "310680");
+
+    private static final List<String> OP15_MCCMNC_LIST = Arrays.asList("26207", "26208",
+            "26211");
+
+    /// SS OP18 Ut @{
+    private static final List<String> OP18_MCCMNC_LIST = Arrays.asList("405854",
+            "405855",
+            "405856",
+            "405872",
+            "405857",
+            "405858",
+            "405859",
+            "405860",
+            "405861",
+            "405862",
+            "405873",
+            "405863",
+            "405864",
+            "405874",
+            "405865",
+            "405866",
+            "405867",
+            "405868",
+            "405869",
+            "405871",
+            "405870",
+            "405840");
+    /// @}
+
+    private static final List<String> MCCMNC_BLOCK_LIST = Arrays.asList("22210");
+
+    /**
+     * Get the XCAP Root URI for the specific phone ID.
+     *
+     * @param phoneId phone index
+     * @return the Root URI String
+     */
+    public static String getXcapRootUri(int phoneId) {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return "";
+        }
+        SimServs simSrv = SimServs.getInstance();
+
+        if (isOp01IccCard(phoneId)) {
+            simSrv.setUseHttpProtocolScheme(true);
+            simSrv.setElementUpdateContentType(true, null);
+            simSrv.setHandleError409(false);
+            simSrv.setFillCompleteForwardTo(true);
+            simSrv.setXcapNSPrefixSS(false);
+        } else if (isOp06IccCard(phoneId)) {
+            simSrv.setUseHttpProtocolScheme(true);
+            simSrv.setElementUpdateContentType(true, null);
+            simSrv.setHandleError409(false);
+            simSrv.setFillCompleteForwardTo(false);
+            simSrv.setXcapNSPrefixSS(false);
+        } else if (isOp07IccCard(phoneId)) {
+            simSrv.setUseHttpProtocolScheme(true); //use http in op07.
+            simSrv.setElementUpdateContentType(true, null);
+            simSrv.setHandleError409(true);
+            simSrv.setFillCompleteForwardTo(false);
+            simSrv.setXcapNSPrefixSS(false);
+        } else if (isOp15IccCard(phoneId)) {
+            simSrv.setUseHttpProtocolScheme(true);
+            simSrv.setElementUpdateContentType(true, null);
+            simSrv.setHandleError409(false);
+            simSrv.setFillCompleteForwardTo(false);
+            simSrv.setXcapNSPrefixSS(false);
+        } else if (isOp18IccCard(phoneId)) {
+            simSrv.setUseHttpProtocolScheme(true);
+            simSrv.setElementUpdateContentType(true, null);
+            simSrv.setHandleError409(false);
+            simSrv.setFillCompleteForwardTo(false);
+            simSrv.setXcapNSPrefixSS(true);
+        } else {
+            simSrv.setUseHttpProtocolScheme(false);
+            simSrv.setElementUpdateContentType(true, null);
+            simSrv.setHandleError409(false);
+            simSrv.setFillCompleteForwardTo(false);
+            simSrv.setXcapNSPrefixSS(false);
+        }
+
+        String rootUri = simSrv.getXcapRoot();
+        Rlog.d(LOG_TAG, "getXcapRootUri():" + rootUri);
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        if (rootUri == null) {
+            // get from IMS MO
+            //rootUri = IMSMO.getRootUri();
+            if (rootUri != null) {
+                // verify?
+                simSrv.setXcapRoot(rootUri);
+            }
+            else {
+                // still null, assemble it
+                String impi = null;
+                impi = TelephonyManagerEx.getDefault().getIsimImpi(subId);
+
+                if (impi != null && !impi.isEmpty()) {  // ISIM
+                    Rlog.d(LOG_TAG, "getXcapRootUri():get APP_FAM_IMS and impi=" + impi);
+                    simSrv.setXcapRootByImpi(impi);
+                } else {
+                    String mccMnc = null;
+                    mccMnc = TelephonyManager.getDefault().getSimOperator(subId);
+                    String mcc = "";
+                    String mnc = "";
+                    if (!TextUtils.isEmpty(mccMnc)) {
+                        mcc = mccMnc.substring(0, 3);
+                        mnc = mccMnc.substring(3);
+                    }
+
+                    if (mnc.length() == 2) {
+                        mccMnc = mcc + 0 + mnc;
+                        Rlog.d(LOG_TAG, "add 0 to mnc =" + mnc);
+                    }
+                    Rlog.d(LOG_TAG, "get mccMnc=" + mccMnc + " from the IccRecrods");
+
+                    if (!TextUtils.isEmpty(mccMnc)) {
+                        if (mccMnc.equals("460000") || mccMnc.equals("460002")
+                                || mccMnc.equals("460007") || mccMnc.equals("460008")
+                                || mccMnc.equals("460011")) {
+                            simSrv.setXcapRootByMccMnc("460", "000");
+                        } else {
+                            simSrv.setXcapRootByMccMnc(mccMnc.substring(0, 3),
+                                    mccMnc.substring(3));
+                        }
+                    }
+                }
+                rootUri = simSrv.getXcapRoot();
+                Rlog.d(LOG_TAG, "getXcapRoot():rootUri=" + rootUri);
+            }
+        }
+
+        return rootUri;
+    }
+
+    /**
+     * Get the XCAP XUI for the specific phone ID.
+     * @param phoneId phone index
+     * @return the XUI String
+     */
+    public static String getXui(int phoneId, Context context) {
+        SimServs simSrv = SimServs.getInstance();
+        String sXui = simSrv.getXui();
+        Rlog.d(LOG_TAG, "getXui():sXui from simSrv=" + sXui);
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        if (sXui == null) {
+            //Get XUI (P-Associated-URI header) from storage (updated by IMSA) (IR.92) - wait for
+            // XuiManager check-in by AF10
+            //[ALPS01654778] As XCAP User Identity (XUI) the UE must use the default public user
+            // identity received in P-Associated-URI header in 200 OK for REGISTER
+            //IMS Stack will update IMPUs to ImsSimservsDispatcher's handleXuiUpdate(): Store
+            // IMPUs to ImsXuiManager
+            //Example (from main log):ImsSimservsDispatcher: [ims] ImsSimservsDispatcher
+            // handleXuiUpdate xui=sip:14253269846@msg.pc.t-mobile.com,
+            //sip:+14253269846@msg.pc.t-mobile.com,
+            //sip:+14253269846@ims.mnc260.mcc310.3gppnetwork.org,
+            //sip:310260007540985@ims.mnc260.mcc310.3gppnetwork.org
+            sXui = ImsXuiManager.getInstance().getXui(phoneId);
+            Rlog.d(LOG_TAG, "getXui():sXui from XuiManager=" + sXui);
+            if (sXui != null) {
+                sXui = sXui.split(",")[0];
+                simSrv.setXui(sXui);
+                return sXui;
+            } else {
+                //Check if ISIM or SIM is inserted or not
+                //ISIM is ready but it may not read all records successfully at this time
+                //[TODO] getImpu() from ISIM:API is not available (Set IMPU if ISIM inserted)
+                String sImpu = "";
+                String[] impu = null;
+                impu = TelephonyManagerEx.getDefault().getIsimImpu(subId);
+
+                if (impu != null) {
+                    sImpu = impu[0];
+                    Rlog.d(LOG_TAG, "getXui():sImpu=" + sImpu);
+                    simSrv.setXuiByImpu(sImpu);
+                } else {
+                    //SIM/USIM is ready but it may not read all records successfully at this time
+                    TelephonyManager telephonyManager =
+                        (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+                    String sImsi = telephonyManager.getSubscriberId(
+                        SubscriptionManager.getSubIdUsingPhoneId(phoneId));
+                    Rlog.d(LOG_TAG, "getXui():IMS uiccApp is null, try to select USIM uiccApp");
+
+                    String mccMnc = TelephonyManager.getDefault().getSimOperator(subId);
+                    Rlog.d(LOG_TAG, "getXui():Imsi=" + sImsi + ", mccMnc=" + mccMnc);
+
+                    if (!TextUtils.isEmpty(mccMnc)) {
+                        simSrv.setXuiByImsiMccMnc(sImsi, mccMnc.substring(0, 3),
+                                mccMnc.substring(3));
+                    }
+                }
+
+                //Originally:sXui is null. Now:re-obtain sXui again
+                sXui = simSrv.getXui();
+                Rlog.d(LOG_TAG, "getXui():sXui=" + sXui);
+                return sXui;
+            }
+        } else {
+            sXui = sXui.split(",")[0];
+            return sXui;
+        }
+    }
+
+    /**
+     * Get the XIntended Id for the specific phone ID.
+     * @param phoneId phone index
+     * @return the XIntendedId String
+     */
+    public static String getXIntendedId(int phoneId, Context context) {
+        //[ALPS01654778] Modify for TMO-US XCAP Test: It requires that XUI and
+        // X-3GPP-Intended-Identify must be same
+        return getXui(phoneId, context);
+        /*
+        SimServs simSrv = SimServs.getInstance();
+        String sIntendedId = "";
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        //Check if ISIM or SIM is inserted or not
+        UiccController uiccCtl = UiccController.getInstance();
+        UiccCardApplication uiccApp = uiccCtl.getUiccCardApplication(phoneId,
+                UiccController.APP_FAM_IMS);
+        if (uiccApp != null) {
+            //Only ISIM is inserted, it is necessary to update X-3GPP-Intended-Identity
+            //Set IMPU for X-3GPP-Intended-Identity
+            //ISIM is ready but it may not read all records successfully at this time
+            //[TODO] getImpu() from ISIM:API is not available
+            String[] impu = null;
+            impu = TelephonyManagerEx.getIsimImpu(subId);
+            if (impu != null) {
+                String sImpu = impu[0];
+                sIntendedId = sImpu;
+                Rlog.d(LOG_TAG, "getXIntendedId ():sImpu=" + sImpu);
+            }
+            simSrv.setIntendedId(sIntendedId);
+        }
+
+        return sIntendedId;
+        */
+    }
+
+    public static String getHttpCredentialUserName() {
+        //[TODO]Wait for IMS MO API
+        String sUserName = "";
+
+        return sUserName;
+    }
+
+    public static String getHttpCredentialPassword() {
+        //[TODO]Wait for IMS MO API
+        String sPassword = "";
+
+        return sPassword;
+    }
+
+    /**
+     * Check if we use Ut/XCAP.
+     * @param phoneId phone index
+     * @return ture if use Ut/XCAP
+     */
+    public static boolean isPreferXcap(int phoneId) {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        }
+
+        String ssMode = MODE_SS_CS;
+        if (SystemProperties.get("ro.mtk_ims_support").equals("1") &&
+                SystemProperties.get("ro.mtk_volte_support").equals("1")) {
+            ssMode = SystemProperties.get(PROP_SS_MODE, MODE_SS_XCAP);
+            if (isNotSupportXcap(phoneId)) {
+                ssMode = MODE_SS_CS;
+            }
+        } else {
+            ssMode = SystemProperties.get(PROP_SS_MODE, MODE_SS_CS);
+        }
+
+        if (!SystemProperties.get("ro.mtk_ims_support").equals("1") ||
+                !SystemProperties.get("ro.mtk_volte_support").equals("1")) {
+            Rlog.d(LOG_TAG, "isPreferXcap(): Not Enable VOLTE feature! "
+                    + "Return directly to use CSFB SS");
+            return false;
+        }
+
+        if (MODE_SS_CS.equals(ssMode)) {
+            Rlog.d(LOG_TAG, "isPreferXcap(): Config SS via CS! Return directly!");
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Check if we can connect with the XCAP server.
+     * @param phoneId phone index
+     * @param network specific Network for XCAP server
+     * @return ture if we can connect with the XCAP server
+     */
+    public static boolean isSupportXcap(int phoneId, Network network) {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        }
+
+        sXcapUri = getXcapRootUri(phoneId);
+        remoteIp = null;
+        InetAddress[] ia = null;
+        queryXcapSrvDone = false;
+
+        String ss_mode = "";
+        if (SystemProperties.get("ro.mtk_ims_support").equals("1") &&
+                SystemProperties.get("ro.mtk_volte_support").equals("1")) { //@L
+        //if (FeatureOption.MTK_IMS_SUPPORT == true && FeatureOption.MTK_VOLTE_SUPPORT == true) {
+            ss_mode = SystemProperties.get(PROP_SS_MODE, MODE_SS_XCAP);
+        } else {
+            ss_mode = SystemProperties.get(PROP_SS_MODE, MODE_SS_CS);
+        }
+        Rlog.d(LOG_TAG, "isSupportXcap(): sXcapUri=" + sXcapUri + ",ss_mode=" + ss_mode);
+
+        String preConfigPort = "";
+
+        if (!SystemProperties.get("ro.mtk_ims_support").equals("1") ||
+                !SystemProperties.get("ro.mtk_volte_support").equals("1")) { //@L
+        //if (FeatureOption.MTK_IMS_SUPPORT == false && FeatureOption.MTK_VOLTE_SUPPORT == false) {
+            Rlog.d(LOG_TAG, "Not Enable VOLTE feature! Return directly to use CSFB SS");
+            return false;
+        }
+
+        if (MODE_SS_CS.equals(ss_mode)) {
+            Rlog.d(LOG_TAG, "Config SS via CS! Return directly!");
+            return false;
+        }
+
+        if (sXcapUri != null) {
+            //get IP for uri & put in non-main thread to avoid exception in Android
+            //new Thread(new Runnable() {
+                //public void run() {
+                    try {
+                        //Note by mtk01411: sXcapUri=xcap.ims.mnc01.mcc001.pub.3gppnetwork.org/
+                        //It should check if / is existed, it must skip the / to avoid DNS lookup
+                        // failed
+                        String XcapSrvHostName = null;
+
+                        //Add for NSN Lab IOT Testing
+                        if (IS_ENG_BUILD) {
+                            String TestingXcapRoot =
+                                    SystemProperties.get("mediatek.simserv.xcaproot",
+                                    "NON_CONFIG");
+                            Rlog.d(LOG_TAG, "mediatek.simserv.xcaproot=" + TestingXcapRoot);
+                            if (!"NON_CONFIG".equals(TestingXcapRoot)) {
+                                sXcapUri = TestingXcapRoot;
+                                Rlog.d(LOG_TAG, "Replace sXcapUri=" + sXcapUri);
+                            }
+
+                            if (!"http".equals(sXcapUri.substring(0, sXcapUri.lastIndexOf(':')))
+                               && !"https".equals(
+                                       sXcapUri.substring(0, sXcapUri.lastIndexOf(':')))) {
+                                //Has port - Example:For NSN Lab IOT (In adb shell: setprop
+                                // mediatek.simserv.xcaproot
+                                //   http://xcap.srnims3.srnnam.nsn-rdnet.net:8090/)
+                                //Then sXcapUri =
+                                //     http://xcap.srnims3.srnnam.nsn-rdnet.net:8090/myService/
+                                String portSubString =
+                                        sXcapUri.substring(sXcapUri.lastIndexOf(':') + 1);
+                                Rlog.d(LOG_TAG, "portSubString=" + portSubString);
+                                preConfigPort =  portSubString.substring(0,
+                                        portSubString.indexOf("/"));
+                                sXcapUri = sXcapUri.substring(0, sXcapUri.lastIndexOf(':'));
+                                //At this time - sXcapUri=http://xcap.srnims3.srnnam.nsn-rdnet.net
+                                sXcapUri += "/";
+                                //At this time - sXcapUri=http://xcap.srnims3.srnnam.nsn-rdnet.net/
+                                Rlog.d(LOG_TAG, "preConfig sXcapUri=" + sXcapUri
+                                        + " with preConfigPort=" + preConfigPort);
+                            }
+                        }
+
+                        if (sXcapUri.startsWith("http://")) {
+                            XcapSrvHostName = sXcapUri.substring(7, sXcapUri.lastIndexOf("/"));
+                        } else if (sXcapUri.startsWith("https://")) {
+                            XcapSrvHostName = sXcapUri.substring(8, sXcapUri.lastIndexOf("/"));
+                        }
+                        Rlog.d(LOG_TAG, "isSupportXcap():XcapSrvHostName=" + XcapSrvHostName);
+                        if (network != null) {
+                            ia = network.getAllByName(XcapSrvHostName);
+                        } else {
+                            ia = InetAddress.getAllByName(XcapSrvHostName);
+                        }
+                        //For Testing non-main thread query DNS functionality
+                        //ia = InetAddress.getByName("www.ntu.edu.tw");
+                        for (InetAddress addr : ia) {
+                            remoteIp = addr.getHostAddress();
+                            if (remoteIp != null) {
+                                Rlog.d(LOG_TAG, "xcap server ip : " + remoteIp);
+                                break;
+                            }
+                        }
+                    //} catch (UnknownHostException ex) {
+                    } catch (Exception ex) {
+                        Rlog.d(LOG_TAG, "sXcapUri getHostAddress fail : ");
+                        ex.printStackTrace();
+                        //For testing purpose
+                        if (IS_ENG_BUILD) {
+                            //[ALPS01713098]CMCC XCAP IP =
+                            // 183.221.242.172(xcap.ims.mnc02.mcc460.pub.3gppnetwork.org)
+                            //Example: TMO-US: XCAP IP=66.94.0.187(xcap.msg.pc.t-mobile.com)
+                            remoteIp = SystemProperties.get("mediatek.simserv.xcapip", "");
+                        }
+                    }
+                    queryXcapSrvDone = true;
+                //}
+            //}).start();
+
+            while (queryXcapSrvDone != true) {
+                //Wait for check again
+            }
+
+            Rlog.d(LOG_TAG, "QueryXcapSrvDone:xcap server ip : " + remoteIp);
+            //If the user configures as XCAP Preferred and IP for XCAP server is also available:
+            // Execute SS via XCAP
+            if (remoteIp != null && MODE_SS_XCAP.equals(ss_mode)) {
+                //Check if this ip & port can be reachable or not: For XCAP, it should be port
+                // 80/443/or specific Lab IOT Test's port
+                SocketFactory sf = SocketFactory.getDefault();
+                Socket s = null;
+                boolean reachable = false;
+
+
+                String testingPort = "";
+                if (IS_ENG_BUILD) {
+                    testingPort = SystemProperties.get("mediatek.simserv.port", "");
+                }
+
+                //For Normal Case, XCAP needs authentication (GBA or HTTP Digest), port must be 443
+                //But for LAB IOT, user can configure the port by the property
+                // "mediatek.simserv.port"
+                String portList[] = null;
+                if ((isOp01IccCard(phoneId)) || (isOp06IccCard(phoneId))) {
+                    portList = new String[3];
+                    portList[0] = "80";
+                    portList[1] = preConfigPort;
+                    portList[2] = testingPort;
+                } else if (isOp18IccCard(phoneId)) {
+                    portList = new String[4];
+                    portList[0] = "7077";
+                    portList[1] = "443";
+                    portList[2] = preConfigPort;
+                    portList[3] = testingPort;
+                } else {
+                    portList = new String[4];
+                    portList[0] = "443";
+                    portList[1] = "80";
+                    portList[2] = preConfigPort;
+                    portList[3] = testingPort;
+                }
+                for (int i = 0; i < portList.length; i++) {
+                    int tempPort = 0;
+                    if (!portList[i].equals("")) {
+                        tempPort = Integer.parseInt(portList[i]);
+                    }
+
+                    Rlog.d(LOG_TAG, "testingPort=" + testingPort + "try connecting to IP="
+                            + remoteIp + " and port=" + tempPort);
+
+                    if (portList[i].equals("")) {
+                        continue;
+                    } else {
+                        try {
+                            InetSocketAddress sa = new InetSocketAddress(remoteIp, tempPort);
+                            s = sf.createSocket();
+                            s.connect(sa, 10000);
+                            reachable = s.isConnected();
+                            Rlog.d(LOG_TAG, "Connect to XCAP_IP=" + remoteIp + " with port=" +
+                                portList[i] + ", reachable=" + reachable);
+                            s.close();
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                        if (reachable) {
+                            return true;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (IS_ENG_BUILD) {
+            Rlog.d(LOG_TAG, "isSupportXcap(): start to get ss tcname");
+            //[MMTelSS]Add testing mode by mtk01411 (test case mode is necessary to co-work with
+            // simserv's modification)
+            String tc_name = SystemProperties.get("ril.ss.tcname", "Empty");
+            Rlog.d(LOG_TAG, "isSupportXcap():tc_name=" + tc_name);
+            if (tc_name != null && tc_name.startsWith("Single_TC_")) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    /// SS OP01 Ut @{
+
+    public static boolean isOp01IccCard(int phoneId) {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        }
+
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        String mccMnc = TelephonyManager.getDefault().getSimOperator(subId);
+        Rlog.d(LOG_TAG, "isOp01IccCard(): mccMnc is " + mccMnc);
+        return OP01_MCCMNC_LIST.contains(mccMnc);
+    }
+
+    public static boolean isOp06IccCard(int phoneId) {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        }
+
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        String mccMnc = TelephonyManager.getDefault().getSimOperator(subId);
+        Rlog.d(LOG_TAG, "isOp06IccCard(): mccMnc is " + mccMnc);
+        boolean retVal = OP06_MCCMNC_LIST.contains(mccMnc);
+        Rlog.d(LOG_TAG, "isOp06IccCard()=>" + retVal);
+        return retVal;
+    }
+
+    public static boolean isOp07IccCard(int phoneId) {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        }
+
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        String mccMnc = TelephonyManager.getDefault().getSimOperator(subId);
+        Rlog.d(LOG_TAG, "isOp07IccCard(): mccMnc is " + mccMnc);
+        return OP07_MCCMNC_LIST.contains(mccMnc);
+    }
+
+    public static boolean isOp15IccCard(int phoneId) {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        }
+
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        String mccMnc = TelephonyManager.getDefault().getSimOperator(subId);
+        Rlog.d(LOG_TAG, "isOp15IccCard(): mccMnc is " + mccMnc);
+        return OP15_MCCMNC_LIST.contains(mccMnc);
+    }
+
+    public static boolean isOp18IccCard(int phoneId) {
+        if (SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            return false;
+        }
+
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        String mccMnc = TelephonyManager.getDefault().getSimOperator(subId);
+        Rlog.d(LOG_TAG, "isOp18IccCard(): mccMnc is " + mccMnc);
+        return OP18_MCCMNC_LIST.contains(mccMnc);
+    }
+
+    public static String addXcapRootPort(String xcapRoot, int phoneId) {
+        //xcapRoot without specific port number
+        if ("http".equals(xcapRoot.substring(0, xcapRoot.lastIndexOf(':')))
+               || "https".equals(
+               xcapRoot.substring(0, xcapRoot.lastIndexOf(':')))) {
+            if (xcapRoot.charAt(xcapRoot.length() - 1) == '/') {
+                xcapRoot = xcapRoot.substring(0, xcapRoot.length() - 1);
+            }
+
+            if (isOp18IccCard(phoneId)) {
+                xcapRoot += ":7077";
+            }
+
+            xcapRoot += "/";
+        }
+
+
+        return xcapRoot;
+    }
+
+    public static boolean isNotifyCallerTest() {
+        if (SystemProperties.get("persist.xcap.notifycaller.test").equals("test")) {
+            return true;
+        }
+        return false;
+    }
+    /// @}
+
+    /**
+     * Get the default IMS Phone Id.
+     *
+     * @return phoneId with IMS enabled
+     */
+    public static int getDefaultImsPhoneId(Context context) {
+        int phoneCount = TelephonyManager.getDefault().getPhoneCount();
+
+        try {
+            for (int i = 0; i < phoneCount; i++) {
+                if (ImsManager.getInstance(context, i).getImsRegInfo()) {
+                    Rlog.d(LOG_TAG, "getDefaultImsPhoneId(): IMS registered. phoneId = " + i);
+                    return i;
+                }
+            }
+        } catch (ImsException e) {
+            Rlog.d(LOG_TAG, "getDefaultImsPhoneId(): ImsException: " + e);
+        }
+
+        return -1;
+    }
+
+    public static boolean isNotSupportXcap(int phoneId) {
+        int subId = SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        String mccMnc = TelephonyManager.getDefault().getSimOperator(subId);
+        Rlog.d(LOG_TAG, "isNotSupportXcap, mccMnc is " + mccMnc);
+        return MCCMNC_BLOCK_LIST.contains(mccMnc);
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/VaConstants.java b/packages/Ims/src/com/mediatek/ims/VaConstants.java
new file mode 100644
index 0000000..7946766
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/VaConstants.java
@@ -0,0 +1,37 @@
+
+package com.mediatek.ims;
+
+public interface VaConstants {
+
+    /* system */
+    // MSG_ID_WRAP_IMSPA_START = 900000;
+    int MSG_ID_WRAP_IMSPA_IMSM_INFORMATION_IND = 900001;
+    int MSG_ID_WRAP_IMSM_IMSPA_INFORMATION_REQ = 900002;
+    int MSG_ID_IMS_ENABLE_IND = 900003; // MSG_ID_WRAP_IMSPA_IMSM_ENABLE_IND
+    int MSG_ID_IMS_DISABLE_IND = 900004; // MSG_ID_WRAP_IMSPA_IMSM_DISABLE_IND,
+    // MSG_ID_WRAP_IMSM_IMSPA_STATE_IND,
+    int MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ = 900008;
+    int MSG_ID_WRAP_IMSPA_IMSM_PDN_ACT_ACK_RESP = 900009;
+    int MSG_ID_WRAP_IMSPA_IMSM_PDN_ACT_REJ_RESP = 900010;
+    int MSG_ID_WRAP_IMSM_IMSPA_PDN_DEACT_REQ = 900011;
+    int MSG_ID_WRAP_IMSPA_IMSM_PDN_DEACT_ACK_RESP = 900012;
+    int MSG_ID_WRAP_IMSPA_IMSM_PDN_DEACT_REJ_RESP = 900013;
+    int MSG_ID_WRAP_IMSPA_IMSM_PDN_DEACT_IND = 900014;
+
+    /* timer */
+    // MSG_ID_WRAP_TIMER_START = 900200
+    int MSG_ID_REQUEST_TIMER_CREATE = 900201; // MSG_ID_WRAP_TIMER_START_REQ
+    int MSG_ID_REQUEST_TIMER_CANCEL = 900202; // MSG_ID_WRAP_TIMER_CANCEL_REQ
+    int MSG_ID_NOTIFY_TIMER_EXPIRY = 900203; // MSG_ID_WRAP_IMSPA_IMSM_TIMER_TIMEOUT_IND
+
+    /* others */
+    // MSG_ID_WRAP_OTHERS_START = 900400
+    int MSG_ID_NOTIFY_XUI_IND = 900401; // MSG_ID_WRAP_IMSM_IMSPA_XUI_REQ
+    int MSG_ID_NOTIFY_SS_PROGRESS_INDICATION = 900402; // MSG_ID_WRAP_IMSM_IMSPA_SS_PROGRESS_REQ
+    int MSG_ID_REQUEST_PCSCF_DISCOVERY = 900403; // MSG_ID_WRAP_IMSM_IMSPA_PCSCF_REQ,
+    int MSG_ID_RESPONSE_PCSCF_DISCOVERY = 900404; // MSG_ID_WRAP_IMSPA_PCSCF_ACK_RESP,
+    int MSG_ID_REJECT_PCSCF_DISCOVERY = 900405; // MSG_ID_WRAP_IMSPA_IMSM_PCSCF_REJ_RESP,
+
+    /* IMSA internal used */
+    int MSG_ID_IMSA_ENABLE_IMS_SEND_APN_IND = 900501;
+}
diff --git a/packages/Ims/src/com/mediatek/ims/XcapMobileDataNetworkManager.java b/packages/Ims/src/com/mediatek/ims/XcapMobileDataNetworkManager.java
new file mode 100644
index 0000000..123684e
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/XcapMobileDataNetworkManager.java
@@ -0,0 +1,307 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.ims;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkRequest;
+import android.os.SystemClock;
+//import android.os.SystemProperties;
+import android.provider.Settings;
+import android.telephony.Rlog;
+import android.telephony.SubscriptionManager;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+/**
+ * Manages the XCAP mobile data network connectivity.
+ */
+public class XcapMobileDataNetworkManager {
+    private static final String LOG_TAG = "XcapMobileDataNetworkManager";
+
+    // Timeout used to call ConnectivityManager.requestNetwork
+    private static final int NETWORK_REQUEST_TIMEOUT_MILLIS = 18 * 1000; // previous: 8 * 1000
+    // Wait timeout for this class, a little bit longer than the above timeout
+    // to make sure we don't bail prematurely
+    private static final int NETWORK_ACQUIRE_TIMEOUT_MILLIS =
+            NETWORK_REQUEST_TIMEOUT_MILLIS + (2 * 1000);
+
+    private Context mContext;
+    // The requested XCAP mobile data network {@link android.net.Network} we are holding
+    // We need this when we unbind from it. This is also used to indicate if the
+    // XCAP mobile data network network is available.
+    private Network mNetwork;
+    // The current count of XCAP mobile data network requests that require the network
+    // If mXcapMobileDataNetworkRequestCount is 0, we should release the XCAP mobile data network.
+    private int mXcapMobileDataNetworkRequestCount;
+
+    // The callback to register when we request XCAP mobile data network
+    private ConnectivityManager.NetworkCallback mNetworkCallback;
+
+    private ConnectivityManager mConnectivityManager;
+
+    // TODO: we need to re-architect this when we support MSIM, like maybe one manager for each SIM?
+    /**
+     * Manages the XCAP mobile data network connectivity.
+     * @param context context
+     */
+    public XcapMobileDataNetworkManager(Context context) {
+        mContext = context;
+        mNetworkCallback = null;
+        mNetwork = null;
+        mXcapMobileDataNetworkRequestCount = 0;
+        mConnectivityManager = null;
+    }
+
+    /**
+     * Get the network acquired.
+     * @return mNetwork
+     */
+    public Network getNetwork() {
+        synchronized (this) {
+            return mNetwork;
+        }
+    }
+
+    /**
+     * Acquire the XCAP mobile data network.
+     * @param phoneId the phone index
+     * @return the acquired network
+     */
+    public Network acquireNetwork(int phoneId) {
+        Rlog.d(LOG_TAG, "acquireNetwork(): phoneId = " + phoneId);
+        if (inAirplaneMode()) {
+            // Fast fail airplane mode
+            return null;
+        }
+        if (!(MMTelSSUtils.isOp01IccCard(phoneId))
+                && !(MMTelSSUtils.isOp06IccCard(phoneId))
+                && !(MMTelSSUtils.isOp07IccCard(phoneId))
+                && !(MMTelSSUtils.isOp15IccCard(phoneId))
+                && !(MMTelSSUtils.isOp18IccCard(phoneId))
+//                && !(SystemProperties.getInt("ro.mtk_epdg_support", 0) == 1)
+                ) {
+            Rlog.d(LOG_TAG, "XcapMobileDataNetworkManager: acquireNetwork not supported");
+            return null;
+        }
+        Rlog.d(LOG_TAG, "XcapMobileDataNetworkManager: acquireNetwork start");
+        synchronized (this) {
+            mXcapMobileDataNetworkRequestCount += 1;
+            if (mNetwork != null) {
+                // Already available
+                Rlog.d(LOG_TAG, "XcapMobileDataNetworkManager: already available");
+                return mNetwork;
+            }
+            Rlog.d(LOG_TAG, "XcapMobileDataNetworkManager: start new network request");
+            // Not available, so start a new request
+            newRequest(phoneId);
+            final long shouldEnd = SystemClock.elapsedRealtime()
+                    + NETWORK_ACQUIRE_TIMEOUT_MILLIS;
+            long waitTime = NETWORK_ACQUIRE_TIMEOUT_MILLIS;
+            while (waitTime > 0) {
+                try {
+                    this.wait(waitTime);
+                } catch (InterruptedException e) {
+                    Rlog.d(LOG_TAG, "XcapMobileDataNetworkManager: acquire network wait "
+                            + "interrupted");
+                }
+                if (mNetwork != null) {
+                    // Success
+                    return mNetwork;
+                }
+                // Calculate remaining waiting time to make sure we wait the full timeout period
+                waitTime = shouldEnd - SystemClock.elapsedRealtime();
+            }
+            // Timed out, so release the request and fail
+            Rlog.d(LOG_TAG, "XcapMobileDataNetworkManager: timed out");
+            releaseRequest(mNetworkCallback);
+            resetLocked();
+        }
+
+        return null;
+    }
+
+    /**
+     * Release the XCAP mobile data network when nobody is holding on to it.
+     */
+    public void releaseNetwork() {
+        synchronized (this) {
+            if (mXcapMobileDataNetworkRequestCount > 0) {
+                mXcapMobileDataNetworkRequestCount -= 1;
+                Rlog.d(LOG_TAG, "XcapMobileDataNetworkManager: release, count="
+                        + mXcapMobileDataNetworkRequestCount);
+                if (mXcapMobileDataNetworkRequestCount < 1) {
+                    releaseRequest(mNetworkCallback);
+                    resetLocked();
+                }
+            }
+        }
+    }
+
+    /**
+     * Start a new {@link android.net.NetworkRequest} for XCAP mobile data network.
+     */
+    private void newRequest(int phoneId) {
+        final ConnectivityManager connectivityManager = getConnectivityManager();
+        int subId = (int) SubscriptionManager.getSubIdUsingPhoneId(phoneId);
+        mNetworkCallback = new ConnectivityManager.NetworkCallback() {
+            @Override
+            public void onAvailable(Network network) {
+                super.onAvailable(network);
+                Rlog.d(LOG_TAG, "NetworkCallbackListener.onAvailable: network=" + network);
+                synchronized (XcapMobileDataNetworkManager.this) {
+                    mNetwork = network;
+                    XcapMobileDataNetworkManager.this.notifyAll();
+                }
+            }
+
+            @Override
+            public void onLost(Network network) {
+                super.onLost(network);
+                Rlog.d(LOG_TAG, "NetworkCallbackListener.onLost: network=" + network);
+                synchronized (XcapMobileDataNetworkManager.this) {
+                    releaseRequest(this);
+                    if (mNetworkCallback == this) {
+                        resetLocked();
+                    }
+                    XcapMobileDataNetworkManager.this.notifyAll();
+                }
+            }
+
+            @Override
+            public void onUnavailable() {
+                super.onUnavailable();
+                Rlog.d(LOG_TAG, "NetworkCallbackListener.onUnavailable");
+                synchronized (XcapMobileDataNetworkManager.this) {
+                    releaseRequest(this);
+                    if (mNetworkCallback == this) {
+                        resetLocked();
+                    }
+                    XcapMobileDataNetworkManager.this.notifyAll();
+                }
+            }
+        };
+        Rlog.d(LOG_TAG, "newRequest, subId = " + subId);
+        NetworkRequest.Builder networkBuilder = new NetworkRequest.Builder()
+                .addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR)
+                .setNetworkSpecifier(Integer.toString(subId));
+
+        //if (SystemProperties.getInt("ro.mtk_epdg_support", 0) == 1) {
+        //    networkBuilder.addTransportType(NetworkCapabilities.TRANSPORT_EPDG);
+        //}
+
+        if ((MMTelSSUtils.isOp01IccCard(phoneId))
+                || (MMTelSSUtils.isOp06IccCard(phoneId))
+                || (MMTelSSUtils.isOp07IccCard(phoneId))
+                || (MMTelSSUtils.isOp15IccCard(phoneId))
+                || (MMTelSSUtils.isOp18IccCard(phoneId))) {
+            networkBuilder.addCapability(NetworkCapabilities.NET_CAPABILITY_XCAP);
+        }
+        NetworkRequest networkRequest = networkBuilder.build();
+        connectivityManager.requestNetwork(
+                networkRequest, mNetworkCallback, NETWORK_REQUEST_TIMEOUT_MILLIS);
+    }
+
+    /**
+     * Release the current {@link android.net.NetworkRequest} for XCAP mobile data network.
+     *
+     * @param callback the {@link android.net.ConnectivityManager.NetworkCallback} to unregister
+     */
+    private void releaseRequest(ConnectivityManager.NetworkCallback callback) {
+        if (callback != null) {
+            final ConnectivityManager connectivityManager = getConnectivityManager();
+            connectivityManager.unregisterNetworkCallback(callback);
+        }
+    }
+
+    /**
+     * Reset the state.
+     */
+    private void resetLocked() {
+        mNetworkCallback = null;
+        mNetwork = null;
+        mXcapMobileDataNetworkRequestCount = 0;
+    }
+
+    /**
+     * Uset the acquired network to route to the XCAP root URI.
+     * @param network the acquired network
+     * @param xcapRootUri XCAP root URI
+     * @param phoneId phone index
+     */
+    public void useAcquiredNetwork(Network network, String xcapRootUri, int phoneId) {
+        String xcapSrvHostName = null;
+        if (xcapRootUri != null) {
+            if (xcapRootUri.startsWith("http://")) {
+                xcapSrvHostName = xcapRootUri.substring(7, xcapRootUri.lastIndexOf("/"));
+            } else if (xcapRootUri.startsWith("https://")) {
+                xcapSrvHostName = xcapRootUri.substring(8, xcapRootUri.lastIndexOf("/"));
+            } else {
+                xcapSrvHostName = xcapRootUri.substring(0, xcapRootUri.lastIndexOf("/"));
+            }
+        }
+
+        if (xcapSrvHostName != null) {
+            int portStartIndex = xcapSrvHostName.lastIndexOf(":");
+            if (portStartIndex != -1) {
+                xcapSrvHostName = xcapSrvHostName.substring(0, portStartIndex);
+            }
+        }
+
+        Rlog.d(LOG_TAG, "useAcquiredNetwork(): xcapRootUri = " + xcapRootUri
+                + ", xcapSrvHostName=" + xcapSrvHostName);
+
+        if (xcapSrvHostName != null) {
+            int networkType = ConnectivityManager.TYPE_MOBILE_XCAP;
+            //if (SystemProperties.getInt("ro.mtk_epdg_support", 0) == 1) {
+            //    networkType = ConnectivityManager.TYPE_WIFI;
+            //}
+            try {
+                for (final InetAddress address : network.getAllByName(xcapSrvHostName)) {
+                    if (!getConnectivityManager().requestRouteToHostAddress(
+                            networkType, address)) {
+                        Rlog.e(LOG_TAG, "useAcquiredNetwork(): requestRouteToHostAddress() failed");
+                        return;
+                    }
+                }
+            } catch (UnknownHostException ex) {
+                Rlog.e(LOG_TAG, "useAcquiredNetwork(): UnknownHostException");
+            }
+        }
+    }
+
+    private ConnectivityManager getConnectivityManager() {
+        if (mConnectivityManager == null) {
+            mConnectivityManager = (ConnectivityManager) mContext.getSystemService(
+                    Context.CONNECTIVITY_SERVICE);
+        }
+        return mConnectivityManager;
+    }
+
+    private boolean inAirplaneMode() {
+        return Settings.System.getInt(mContext.getContentResolver(),
+                Settings.Global.AIRPLANE_MODE_ON, 0) != 0;
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/CallControlDispatcher.java b/packages/Ims/src/com/mediatek/ims/internal/CallControlDispatcher.java
new file mode 100644
index 0000000..41a718a
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/CallControlDispatcher.java
@@ -0,0 +1,104 @@
+package com.mediatek.ims.internal;
+
+import android.content.Context;
+import android.content.Intent;
+import android.telephony.Rlog;
+
+import com.mediatek.ims.ImsAdapter.VaSocketIO;
+import com.mediatek.ims.ImsAdapter.VaEvent;
+import com.mediatek.ims.ImsEventDispatcher;
+import static com.mediatek.ims.VaConstants.*;
+
+
+
+public class CallControlDispatcher implements ImsEventDispatcher.VaEventDispatcher {
+
+    private Context mContext;
+    private VaSocketIO mSocket;
+    private static final String TAG = "[CallControlDispatcher]";
+    private static final int IMC_PROGRESS_NOTIFY_CONFERENCE = 257;
+    private static final int IMC_PROGRESS_NOTIFY_MWI = 258;
+
+    public static final String ACTION_LTE_MESSAGE_WAITING_INDICATION = "android.intent.action.lte.mwi";
+    public static final String ACTION_IMS_CONFERENCE_CALL_INDICATION = "android.intent.action.ims.conference";
+    public static final String EXTRA_LTE_MWI_BODY = "lte_mwi_body";
+    public static final String EXTRA_MESSAGE_CONTENT = "message.content";
+    public static final String EXTRA_CALL_ID = "call.id";
+    public static final String EXTRA_PHONE_ID = "phone.id";
+
+    public CallControlDispatcher(Context context, VaSocketIO IO) {
+        mContext = context;
+        mSocket = IO;
+    }
+
+    public void enableRequest() {
+        Rlog.d(TAG, "enableRequest()");
+    }
+
+    public void disableRequest() {
+        Rlog.d(TAG, "disableRequest()");
+    }
+
+    public void vaEventCallback(VaEvent event) {
+        try {
+            int requestId;
+            int len;
+            int callId;
+            int phoneId;
+            int serviceId;
+            String data;
+            byte[] byteData;
+
+            requestId = event.getRequestID();
+            len = event.getDataLen();
+            callId = event.getInt();
+            phoneId = event.getPhoneId();
+            serviceId = event.getInt();
+            byteData = event.getBytes(4000);
+            data  = new String(byteData);
+            len = getDataLength(byteData, 4000);
+            Rlog.d(TAG, "requestId = " + requestId + ", length = " + len +
+                    ", callId = " + callId + ", phoneId = " + phoneId +
+                    ", serviceId = " + serviceId + ", data = " + data.substring(0, len));
+
+            switch (serviceId) {
+                case IMC_PROGRESS_NOTIFY_MWI:
+                    /* Send to APP directly */
+                    Intent intent = new Intent(ACTION_LTE_MESSAGE_WAITING_INDICATION);
+                    intent.putExtra(EXTRA_LTE_MWI_BODY, data);
+                    intent.putExtra(EXTRA_PHONE_ID, phoneId);
+                    mContext.sendBroadcast(intent);
+                    Rlog.d(TAG, "Message Waiting Message is sent.");
+                    break;
+                case IMC_PROGRESS_NOTIFY_CONFERENCE:
+                    /* Send to GSMPhone object */
+                    Intent intent1 = new Intent(ACTION_IMS_CONFERENCE_CALL_INDICATION);
+                    intent1.putExtra(EXTRA_MESSAGE_CONTENT, data.substring(0, len));
+                    intent1.putExtra(EXTRA_CALL_ID, callId);
+                    intent1.putExtra(EXTRA_PHONE_ID, phoneId);
+                    mContext.sendBroadcast(intent1);
+                    Rlog.d(TAG, "Conference call XML message is sent.");
+                    break;
+                default:
+                    Rlog.d(TAG, "Unkonwn serviceId: " + serviceId);
+                    break;
+            }
+
+
+        } catch (Exception e) {
+            e.printStackTrace();
+        } /* Enf of try */
+    }
+
+    /* Caculate the data length except 0x0 */
+    private int getDataLength(byte[] data, int originLen) {
+       int i;
+       for (i = 0; i < originLen; i++) {
+          if (data[i] == 0x0) {
+             return i;
+          }
+       }
+
+       return i;
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/DataDispatcher.java b/packages/Ims/src/com/mediatek/ims/internal/DataDispatcher.java
new file mode 100644
index 0000000..1626340
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/DataDispatcher.java
@@ -0,0 +1,1016 @@
+
+package com.mediatek.ims.internal;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.util.Log;
+
+import com.android.internal.telephony.Phone;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.dataconnection.DcFailCause;
+import com.mediatek.ims.ImsAdapter;
+import com.mediatek.ims.ImsAdapter.VaSocketIO;
+import com.mediatek.ims.ImsAdapter.VaEvent;
+import com.mediatek.ims.ImsEventDispatcher;
+import com.mediatek.ims.VaConstants;
+
+import java.util.HashMap;
+
+import android.net.ConnectivityManager;
+import android.net.ConnectivityManager.NetworkCallback;
+import android.net.LinkProperties;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkInfo;
+import android.net.NetworkRequest;
+import android.net.NetworkRequest.Builder;
+import android.os.Looper;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemProperties;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.telephony.PreciseDataConnectionState;
+import android.text.TextUtils;
+
+public class DataDispatcher implements ImsEventDispatcher.VaEventDispatcher {
+    private static final String TAG = DataDispatcherUtil.TAG;
+    private static final boolean DUMP_TRANSACTION = true;
+    // private static final boolean DBG = true;
+
+    private static DataDispatcher mInstance;
+    private Context mContext;
+    private boolean mIsEnable;
+    private VaSocketIO mSocket;
+
+    private static final int MSG_ON_NOTIFY_DATA_CONNECTED = 7000;
+    private static final int MSG_ON_NOTIFY_DATA_DISCONNECTED = 7100;
+    private static final int MSG_ON_NOTIFY_DEACTIVE_DATA_TIMEOUT = 7200;
+    private static final int MSG_ON_NOTIFY_ACTIVE_DATA_TIMEOUT = 7300;
+
+    private static final int MAX_NETWORK_ACTIVE_TIMEOUT_MS = 30000;
+    private static final int MAX_NETWORK_DEACTIVE_TIMEOUT_MS = 20000;
+    private static final int WAITING_FRAMEWORK_STATUS_SYNC = 5000;
+
+    private static final String IMS_INTERFACE_NAME = "ccmni4";
+    private static final String EMERGENCY_INTERFACE_NAME = "ccmni5";
+
+    DataDispatcherNetworkRequest[] mDataNetworkRequests;
+    private static final int[] APN_CAP_LIST = new int[] {
+            NetworkCapabilities.NET_CAPABILITY_IMS,
+            NetworkCapabilities.NET_CAPABILITY_EIMS
+    };
+
+    private HashMap<Integer, TransactionParam> mTransactions = new HashMap<Integer, TransactionParam>();
+    private DataDispatcherUtil mDataDispatcherUtil;
+
+    private static final int FAILCAUSE_NONE = 0;
+    private static final int FAILCAUSE_UNKNOWN = 65536;
+
+    private HashMap<String, Integer> failCauses = new HashMap<String, Integer>() {
+        private static final long serialVersionUID = 1L;
+        {
+            put("", 0);
+            put("OPERATOR_BARRED", 0x08);
+            put("MBMS_CAPABILITIES_INSUFFICIENT", 0x18);
+            put("LLC_SNDCP_FAILURE", 0x19);
+            put("INSUFFICIENT_RESOURCES", 0x1A);
+            put("MISSING_UNKNOWN_APN", 0x1B);
+            put("UNKNOWN_PDP_ADDRESS_TYPE", 0x1C);
+            put("USER_AUTHENTICATION", 0x1D);
+            put("ACTIVATION_REJECT_GGSN", 0x1E);
+            put("ACTIVATION_REJECT_UNSPECIFIED", 0x1F);
+            put("SERVICE_OPTION_NOT_SUPPORTED", 0x20);
+            put("SERVICE_OPTION_NOT_SUBSCRIBED", 0x21);
+            put("SERVICE_OPTION_OUT_OF_ORDER", 0x22);
+            put("NSAPI_IN_USE", 0x23);
+            put("REGULAR_DEACTIVATION", 0x24);
+            put("QOS_NOT_ACCEPTED", 0x25);
+            put("NETWORK_FAILURE", 0x26);
+            put("REACTIVATION_REQUESTED", 0x27);
+            put("FEATURE_NOT_SUPPORTED", 0x28);
+            put("SEMANTIC_ERROR_IN_TFT", 0x29);
+            put("SYNTACTICAL_ERROR_IN_TFT", 0x2A);
+            put("UNKNOWN_PDP_CONTEXT", 0x2B);
+            put("SEMANTIC_ERROR_IN_PACKET_FILTER", 0x2C);
+            put("SYNTACTICAL_ERROR_IN_PACKET_FILTER", 0x2D);
+            put("PDP_CONTEXT_WITHOU_TFT_ALREADY_ACTIVATED", 0x2E);
+            put("MULTICAST_GROUP_MEMBERSHIP_TIMEOUT", 0x2F);
+            put("BCM_VIOLATION", 0x30);
+            put("LAST_PDN_DISC_NOT_ALLOWED", 0x31);
+            put("ONLY_IPV4_ALLOWED", 0x32);
+            put("ONLY_IPV6_ALLOWED", 0x33);
+            put("ONLY_SINGLE_BEARER_ALLOWED", 0x34);
+            put("INFORMATION_NOT_RECEIVED", 0x35);
+            put("PDN_CONNECTION_NOT_EXIST", 0x36);
+            put("MULTIPLE_PDN_APN_NOT_ALLOWED", 0x037);
+            put("COLLISION_WITH_NW_INITIATED_REQUEST", 0x38);
+            put("UNSUPPORTED_QCI_VALUE", 0x3B);
+            put("BEARER_HANDLING_NOT_SUPPORT", 0x3C);
+            put("MAX_PDP_NUMBER_REACHED", 0x41);
+            put("APN_NOT_SUPPORT_IN_RAT_PLMN", 0x42);
+            put("INVALID_TRANSACTION_ID_VALUE", 0x51);
+            put("SEMENTICALLY_INCORRECT_MESSAGE", 0x5F);
+            put("INVALID_MANDATORY_INFO", 0x60);
+            put("MESSAGE_TYPE_NONEXIST_NOT_IMPLEMENTED", 0x61);
+            put("MESSAGE_TYPE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE", 0x62);
+            put("INFO_ELEMENT_NONEXIST_NOT_IMPLEMENTED", 0x63);
+            put("CONDITIONAL_IE_ERROR", 0x64);
+            put("MESSAGE_NOT_COMPATIBLE_WITH_PROTOCOL_STATE", 0x65);
+            put("PROTOCOL_ERRORS", 0x6F);
+            put("PN_RESTRICTION_VALUE_INCOMPATIBLE_WITH_PDP_CONTEXT", 0x70);
+
+            // Local errors generated by Vendor RIL
+            // specified in ril.h
+            put("REGISTRATION_FAIL", -1);
+            put("GPRS_REGISTRATION_FAIL", -2);
+            put("SIGNAL_LOST", -3);
+            put("PREF_RADIO_TECH_CHANGED", -4);
+            put("RADIO_POWER_OFF", -5);
+            put("TETHERED_CALL_ACTIVE", -6);
+            put("PDP_FAIL_FALLBACK_RETRY", -1000);
+            put("INSUFFICIENT_LOCAL_RESOURCES", 0xFFFFE);
+            put("ERROR_UNSPECIFIED", 0xFFFF);
+
+            // Errors generated by the Framework
+            put("UNKNOWN", 0x10000);
+            put("RADIO_NOT_AVAILABLE", 0x10001);
+            put("UNACCEPTABLE_NETWORK_PARAMETER", 0x10002);
+            put("CONNECTION_TO_DATACONNECTIONAC_BROKEN", 0x10003);
+            put("LOST_CONNECTION", 0x10004);
+            put("RESET_BY_FRAMEWORK", 0x10005);
+
+            put("PAM_ATT_PDN_ACCESS_REJECT_IMS_PDN_BLOCK_TEMP", 0x1402);
+            put("TCM_ESM_TIMER_TIMEOUT", 0x1502A);
+
+            put("DUE_TO_REACH_RETRY_COUNTER", 0x0E0F);
+        }
+    };
+
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            log("onReceive, intent action is " + intent.getAction());
+
+            if (action.equalsIgnoreCase(
+                    TelephonyManager.ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED)) {
+                int mState = intent.getIntExtra(PhoneConstants.STATE_KEY,
+                        TelephonyManager.DATA_UNKNOWN);
+                int mNetworkType = intent.getIntExtra(PhoneConstants.DATA_NETWORK_TYPE_KEY,
+                        TelephonyManager.NETWORK_TYPE_UNKNOWN);
+                String mAPNType = intent.getStringExtra(PhoneConstants.DATA_APN_TYPE_KEY);
+                String mAPN = intent.getStringExtra(PhoneConstants.DATA_APN_KEY);
+                String mReason = intent.getStringExtra(PhoneConstants.STATE_CHANGE_REASON_KEY);
+                String mFailCause = intent.getStringExtra(PhoneConstants.DATA_FAILURE_CAUSE_KEY);
+
+                PreciseDataConnectionState state = new PreciseDataConnectionState(
+                        mState, mNetworkType, mAPNType, mAPN, mReason, null, mFailCause);
+
+                if (mAPNType.equalsIgnoreCase(PhoneConstants.APN_TYPE_IMS) ||
+                        mAPNType.equalsIgnoreCase(PhoneConstants.APN_TYPE_EMERGENCY)) {
+                    log("data state: " + state.toString());
+
+                    if (mState == TelephonyManager.DATA_CONNECTING) {
+                        log("[ " + mAPNType + " ] setupData starting, remove timeout handler.....");
+                        mHandler.removeMessages(MSG_ON_NOTIFY_ACTIVE_DATA_TIMEOUT);
+                    }
+                    if (isReasonAllowedToDetach(mReason)
+                            || (mFailCause != null && mFailCause.length() > 0)) {
+                        if (mState == TelephonyManager.DATA_DISCONNECTED
+                                || mState == TelephonyManager.DATA_UNKNOWN) {
+                            synchronized (mAPNStatuses) {
+                                ApnStatus apnStatus = mAPNStatuses.get(mAPNType);
+                                log("ApnStatus: " + apnStatus);
+                                // checking valid for notify deactivation
+                                if (apnStatus.mStatus == TelephonyManager.DATA_CONNECTING
+                                        || apnStatus.mStatus == TelephonyManager.DATA_CONNECTED)
+                                {
+                                    log("send [ " + apnStatus.mName
+                                            + " ] disconnected notify to message queue");
+                                    mHandler.sendMessage(mHandler.obtainMessage(
+                                            MSG_ON_NOTIFY_DATA_DISCONNECTED, state));
+                                }
+                            }
+                        }
+                    } else {
+                        log("Igonre, It is not data conneciton event mReason: " + mReason
+                                + " failCause: " + mFailCause);
+                    }
+                }
+            }
+        }
+
+    };
+
+    private HashMap<String, ApnStatus> mAPNStatuses = new HashMap<String, ApnStatus>();
+
+    private Handler mHandler;
+    private Thread mHandlerThread = new Thread() {
+        @Override
+        public void run() {
+            Looper.prepare();
+            mHandler = new Handler() { // create handler here
+                @Override
+                synchronized public void handleMessage(Message msg) {
+                    if (!mIsEnable) {
+                        loge("receives message [" + msg.what
+                                + "] but DataDispatcher is not enabled, ignore");
+                        return;
+                    }
+
+                    if (msg.obj instanceof VaEvent) {
+                        VaEvent event = (VaEvent) msg.obj;
+                        log("receives request [" + msg.what + ", " + event.getDataLen() +
+                                ", phoneId: " + event.getPhoneId() + "]");
+                        switch (msg.what) {
+                            case VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ:
+                                handleDefaultBearerActivationRequest(event);
+                                break;
+
+                            case VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_DEACT_REQ:
+                                handleDefaultBearerDeactivationRequest(event);
+                                break;
+                            case VaConstants.MSG_ID_REQUEST_PCSCF_DISCOVERY:
+                                rejectPcscfDiscovery(event.getByte(), FAILCAUSE_UNKNOWN);
+                                break;
+                            default:
+                                log("receives unhandled message [" + msg.what + "]");
+                        }
+                    } else {
+                        log("receives request [" + msg.what + "]");
+                        switch (msg.what) {
+                            case MSG_ON_NOTIFY_DATA_CONNECTED:
+                                Network network = (Network) msg.obj;
+                                handleDefaultBearerActivationResponse(network,
+                                        getApnTypeByCap(msg.arg1));
+                                break;
+
+                            case MSG_ON_NOTIFY_DATA_DISCONNECTED:
+                                PreciseDataConnectionState state =
+                                        (PreciseDataConnectionState) msg.obj;
+                                handleDefaultBearerDeactivationResonse(state);
+                                break;
+
+                            case MSG_ON_NOTIFY_ACTIVE_DATA_TIMEOUT:
+                                TransactionParam param = (TransactionParam) msg.obj;
+                                rejectDefaultBearerDataConnActivation(param, FAILCAUSE_UNKNOWN,
+                                        WAITING_FRAMEWORK_STATUS_SYNC);
+                                break;
+
+                            case MSG_ON_NOTIFY_DEACTIVE_DATA_TIMEOUT:
+                                log("deactive PDN timeout, clear transation of  IMCB");
+                                ApnStatus apnStatus = (ApnStatus) msg.obj;
+                                responseDefaultBearerDataConnDeactivated(findTransaction(
+                                        VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_DEACT_REQ,
+                                        apnStatus.mName), FAILCAUSE_NONE, apnStatus.ifaceName);
+                                break;
+                            default:
+                                log("receives unhandled message [" + msg.what + "]");
+                        }
+                    }
+                }
+            };
+            Looper.loop();
+        }
+    };
+
+    public DataDispatcher(Context context, VaSocketIO IO) {
+        mContext = context;
+        mSocket = IO;
+        mDataDispatcherUtil = new DataDispatcherUtil();
+        mInstance = this;
+        mHandlerThread.start();
+        createNetworkRequest();
+    }
+
+    public static DataDispatcher getInstance() {
+        return mInstance;
+    }
+
+    public void enableRequest() {
+        synchronized (mHandler) {
+            log("receive enableRequest");
+            mIsEnable = true;
+
+            log("registerReceiver");
+            IntentFilter filter = new IntentFilter();
+            filter.addAction(TelephonyManager.ACTION_PRECISE_DATA_CONNECTION_STATE_CHANGED);
+            mContext.registerReceiver(mBroadcastReceiver, filter);
+        }
+    }
+
+    public void disableRequest() {
+        synchronized (mHandler) {
+            log("receive disableRequest");
+            mIsEnable = false;
+
+            log("unregisterReceiver");
+            mContext.unregisterReceiver(mBroadcastReceiver);
+            synchronized (mTransactions) {
+                log("disableRequest to clear transactions");
+                mTransactions.clear();
+            }
+            releaseNwRequest(PhoneConstants.APN_TYPE_IMS);
+            releaseNwRequest(PhoneConstants.APN_TYPE_EMERGENCY);
+            synchronized (mAPNStatuses) {
+                for (String apnType : mAPNStatuses.keySet())
+                {
+                    ApnStatus status = (ApnStatus) mAPNStatuses.get(apnType);
+                    status.mName = "";
+                    status.mStatus = TelephonyManager.DATA_DISCONNECTED;
+                }
+            }
+        }
+    }
+
+    private void handleDefaultBearerActivationRequest(VaEvent event) {
+        String apnType = PhoneConstants.APN_TYPE_IMS;
+        int phoneId = event.getPhoneId();
+
+        log("handleDefaultBearerActivationRequest");
+
+        DataDispatcherUtil.PdnActivationInd actInd = mDataDispatcherUtil
+                .extractDefaultPdnActInd(event);
+
+        TransactionParam param = new TransactionParam(actInd.transactionId,
+                event.getRequestID(), phoneId, apnType);
+
+        if (actInd.isEmergency) {
+            apnType = PhoneConstants.APN_TYPE_EMERGENCY;
+            param.isEmergency = true;
+            param.apnName = apnType;
+        }
+
+        putTransaction(param);
+        if (apnType == PhoneConstants.APN_TYPE_IMS) {
+            mHandler.removeMessages(MSG_ON_NOTIFY_ACTIVE_DATA_TIMEOUT);
+            mHandler.sendMessageDelayed(mHandler.obtainMessage(
+                    MSG_ON_NOTIFY_ACTIVE_DATA_TIMEOUT, param),
+                    MAX_NETWORK_ACTIVE_TIMEOUT_MS);
+        }
+
+        if (requestNwRequest(apnType, phoneId) < 0) {
+            rejectDefaultBearerDataConnActivation(param, FAILCAUSE_UNKNOWN, 0);
+        }
+    }
+
+    private void responseDefaultBearerDataConnActivated(TransactionParam param,
+            int netId, String ifaceName) {
+        log("responseDefaultBearerDataConnActivated ");
+
+        if (param == null) {
+            loge("TransactionParam can not be null");
+            return;
+        }
+
+        if (hasTransaction(param.transactionId)) {
+            ImsAdapter.VaEvent event = new ImsAdapter.VaEvent(
+                    param.phoneId,
+                    VaConstants.MSG_ID_WRAP_IMSPA_IMSM_PDN_ACT_ACK_RESP);
+            event.putByte(param.transactionId);
+            event.putBytes(new byte[3]);
+            event.putInt(netId);
+            event.putString(ifaceName, 16);
+
+            // log("netId =  " + network.netId + " IfaceName = " + mLink.getInterfaceName());
+            removeTransaction(param.transactionId);
+            sendVaEvent(event);
+
+        } else {
+            loge("responseDefaultBearerDataConnActivated "
+                    + "but transactionId does not existed, ignore");
+        }
+
+    }
+
+    private void rejectDefaultBearerDataConnActivation(TransactionParam param, int failCause,
+            int delayMs) {
+
+        if (param == null) {
+            loge("TransactionParam can not be null");
+            return;
+        }
+
+        if (hasTransaction(param.transactionId)) {
+            releaseNwRequest(param.isEmergency ? PhoneConstants.APN_TYPE_EMERGENCY :
+                    PhoneConstants.APN_TYPE_IMS);
+
+            removeTransaction(param.transactionId);
+            // prevent timing issue, cause framework state not sync with native
+            delayForSeconds(delayMs);
+
+            sendVaEvent(makeRejectDefaultBearerEvent(param, failCause));
+        } else {
+            loge("rejectDefaultBearerDataConnActivation "
+                    + "but transactionId does not existed, ignore");
+        }
+    }
+
+    private ImsAdapter.VaEvent makeRejectDefaultBearerEvent(TransactionParam trans, int failCause) {
+        ImsAdapter.VaEvent event;
+
+        if (trans.requestId == VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ) {
+            event = new ImsAdapter.VaEvent(trans.phoneId,
+                    VaConstants.MSG_ID_WRAP_IMSPA_IMSM_PDN_ACT_REJ_RESP);
+            log("rejectDefaultBearerDataConnActivation param" + trans + ", failCause=" + failCause);
+        } else {
+            event = new ImsAdapter.VaEvent(trans.phoneId,
+                    VaConstants.MSG_ID_WRAP_IMSPA_IMSM_PDN_DEACT_REJ_RESP);
+            log("rejectDefaultBearerDataConnDeactivation param" + trans + ", failCause="
+                    + failCause);
+        }
+
+        event.putByte(trans.transactionId);
+        event.putByte(failCause);
+        event.putBytes(new byte[2]);
+
+        return event;
+    }
+
+    private void handleDefaultBearerDeactivationRequest(VaEvent event) {
+        log("handleDefaultBearerDeactivationRequest");
+        DataDispatcherUtil.PdnDeactivationInd deactInd = mDataDispatcherUtil.extractDeactInd(event);
+        int phoneId = event.getPhoneId();
+        String apnType = PhoneConstants.APN_TYPE_IMS;
+
+        if (deactInd.isEmergency) {
+            apnType = PhoneConstants.APN_TYPE_EMERGENCY;
+        }
+
+        TransactionParam trans = new TransactionParam(deactInd.transactionId,
+                event.getRequestID()
+                , phoneId, apnType);
+
+        synchronized (mAPNStatuses) {
+            ApnStatus apnStatus = mAPNStatuses.get(apnType);
+
+            mHandler.removeMessages(MSG_ON_NOTIFY_ACTIVE_DATA_TIMEOUT);
+            mHandler.removeMessages(MSG_ON_NOTIFY_DEACTIVE_DATA_TIMEOUT);
+            mHandler.sendMessageDelayed(mHandler.obtainMessage(
+                    MSG_ON_NOTIFY_DEACTIVE_DATA_TIMEOUT, apnStatus),
+                    MAX_NETWORK_DEACTIVE_TIMEOUT_MS);
+
+            putTransaction(trans);
+
+            // deactivate default bearer
+            if (deactInd.isValid) {
+                log("transactionId = " + deactInd.transactionId + " deactivation " + apnType
+                        + " PDN");
+                if (apnStatus.mStatus == TelephonyManager.DATA_DISCONNECTED) {
+                    log("PDN: [" + apnType + "] already deactivation.");
+                    responseDefaultBearerDataConnDeactivated(
+                            trans, FAILCAUSE_UNKNOWN, apnStatus.ifaceName);
+                    return;
+                } else {
+                    if (releaseNwRequest(apnType) < 0) {
+                        rejectDefaultBearerDataConnDeactivation(trans, 1);
+                        return;
+                    }
+                }
+            } else {
+                // abort default bearer
+                log("transactionId = " + deactInd.transactionId + " abort transactionId = "
+                        + deactInd.abortTransactionId + " " + apnType
+                        + " PDN");
+
+                if (releaseNwRequest(apnType) < 0) {
+                    rejectDefaultBearerDataConnDeactivation(trans, 1);
+                    return;
+                }
+
+                apnStatus.mStatus = TelephonyManager.DATA_DISCONNECTED;
+                log("IMCB send abort [" + apnType + "] connection");
+                TransactionParam deactTrans = findTransaction
+                        (VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_DEACT_REQ, apnType);
+                if (deactTrans != null) {
+                    TransactionParam actTrans = findTransaction
+                            (VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ, apnType);
+                    if (actTrans != null) {
+                        log("[Abort] send reject activation transaction to IMSM");
+                        rejectDefaultBearerDataConnActivation(actTrans,
+                                FAILCAUSE_UNKNOWN, WAITING_FRAMEWORK_STATUS_SYNC);
+                    } else {
+                        loge("Be aborted transaction not in queue...");
+                        rejectDefaultBearerDataConnDeactivation(deactTrans, FAILCAUSE_NONE);
+                        return;
+                    }
+                    log("[Abort] send response abort transaction to IMSM");
+                    responseDefaultBearerDataConnDeactivated(deactTrans,
+                            FAILCAUSE_NONE, apnStatus.ifaceName);
+                } else {
+                    // deactImsTrans == null
+                    loge("abort transaction not in queue...");
+                }
+            }
+        }
+    }
+
+    private void rejectDefaultBearerDataConnDeactivation(TransactionParam param, int failCause) {
+        mHandler.removeMessages(MSG_ON_NOTIFY_DEACTIVE_DATA_TIMEOUT);
+        if (hasTransaction(param.transactionId)) {
+            removeTransaction(param.transactionId);
+            sendVaEvent(makeRejectDefaultBearerEvent(param, failCause));
+        } else {
+            loge("rejectDefaultBearerDataConnDeactivation "
+                    + "but transactionId does not existed, ignore");
+        }
+    }
+
+    private void createNetworkRequest() {
+        final int count = APN_CAP_LIST.length;
+        mDataNetworkRequests = new DataDispatcherNetworkRequest[count];
+
+        for (int i = 0; i < count; i++) {
+            NetworkCapabilities netCap = new NetworkCapabilities();
+            int cap = APN_CAP_LIST[i];
+            netCap.addCapability(cap);
+            netCap.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
+            mDataNetworkRequests[i] = new DataDispatcherNetworkRequest(getNwCBbyCap(cap),
+                    getApnTypeByCap(cap));
+            mDataNetworkRequests[i].nwCap = netCap;
+
+            // Configure APN Status
+            mAPNStatuses.put(getApnTypeByCap(cap), new ApnStatus(
+                    getApnTypeByCap(cap)));
+        }
+    }
+
+    private int releaseNwRequest(String requestApnType) {
+        int nRet = 0;
+        int endPos = mDataNetworkRequests.length;
+        int pos = getNetworkRequetsPos(requestApnType, endPos);
+
+        if (pos > -1 && pos < endPos) {
+            log("releaseNwRequest pos: " + pos + ", requestApnType: "
+                    + requestApnType);
+            NetworkCallback nwCb = mDataNetworkRequests[pos].nwCb;
+            try {
+                getConnectivityManager().unregisterNetworkCallback(nwCb);
+            } catch (IllegalArgumentException ex) {
+                loge("cb already has been released!!");
+            }
+        } else {
+            loge("unknown apnType: " + requestApnType + " skip requestNetwork ");
+            nRet = -1;
+        }
+
+        return nRet;
+    }
+
+    private int requestNwRequest(String requestApnType, int phoneId) {
+        int nRet = 0;
+        int endPos = mDataNetworkRequests.length;
+        int pos = getNetworkRequetsPos(requestApnType, endPos);
+
+        if (pos > -1 && pos < endPos) {
+            log("requestNwRequest pos: " + pos + ", requestApnType: "
+                    + requestApnType);
+            NetworkCallback nwCb = mDataNetworkRequests[pos].nwCb;
+
+            // generator network request
+            Builder builder = new NetworkRequest.Builder();
+            builder.addCapability(APN_CAP_LIST[pos]);
+            builder.addTransportType(NetworkCapabilities.TRANSPORT_CELLULAR);
+
+            mDataNetworkRequests[pos].nwRequest = builder.build();
+            NetworkRequest nwRequest = mDataNetworkRequests[pos].nwRequest;
+
+            log("before start requestNetwork, first relaseNetwork!");
+            releaseNwRequest(requestApnType);
+            synchronized (mAPNStatuses) {
+                if (SystemProperties.getInt("persist.net.wo.debug.no_ims", 0) != 1) {
+                    log("start requestNetwork for " + requestApnType);
+                    ApnStatus apnStatus = mAPNStatuses.get(requestApnType);
+                    apnStatus.mName = requestApnType;
+                    apnStatus.mStatus = TelephonyManager.DATA_CONNECTING;
+                    apnStatus.ifaceName = "";
+                    log("ApnStatus: " + apnStatus);
+                    getConnectivityManager().requestNetwork(nwRequest, nwCb,
+                            ConnectivityManager.MAX_NETWORK_REQUEST_TIMEOUT_MS);
+                }
+            }
+        } else {
+            loge("unknow apnType: " + requestApnType + " skip requestNetwork ");
+            nRet = -1;
+        }
+
+        return nRet;
+    }
+
+    NetworkCallback mImsNetworkCallback = new NetworkCallback() {
+
+        @Override
+        public void onAvailable(Network network) {
+            NetworkInfo netInfo = getConnectivityManager().getNetworkInfo(network);
+            log("onAvailable: networInfo: " + netInfo);
+
+            if ("connected".equalsIgnoreCase(netInfo.getReason())) {
+                mHandler.sendMessage(mHandler.obtainMessage(MSG_ON_NOTIFY_DATA_CONNECTED,
+                        NetworkCapabilities.NET_CAPABILITY_IMS, 0, network));
+            } else {
+                rejectDefaultBearerDataConnActivation(
+                        findTransaction(VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ,
+                                PhoneConstants.APN_TYPE_IMS), FAILCAUSE_UNKNOWN,
+                        WAITING_FRAMEWORK_STATUS_SYNC);
+            }
+
+        }
+    };
+
+    NetworkCallback mEImsNetworkCallback = new NetworkCallback() {
+
+        @Override
+        public void onAvailable(Network network) {
+            NetworkInfo netInfo = getConnectivityManager().getNetworkInfo(network);
+            log("onAvailable: networInfo: " + netInfo);
+            if ("connected".equalsIgnoreCase(netInfo.getReason())) {
+                mHandler.sendMessage(mHandler.obtainMessage(MSG_ON_NOTIFY_DATA_CONNECTED,
+                        NetworkCapabilities.NET_CAPABILITY_EIMS, 0, network));
+            } else {
+                rejectDefaultBearerDataConnActivation(
+                        findTransaction(VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ,
+                                PhoneConstants.APN_TYPE_EMERGENCY), FAILCAUSE_UNKNOWN,
+                        WAITING_FRAMEWORK_STATUS_SYNC);
+            }
+
+        }
+    };
+
+    private void handleDefaultBearerActivationResponse(Network network, String type) {
+        log("handleDefaultBearerActivationResponse for APN: " + type);
+        synchronized (mAPNStatuses) {
+            ApnStatus mApnStatus = mAPNStatuses.get(type);
+            mApnStatus.mStatus = TelephonyManager.DATA_CONNECTED;
+            ConnectivityManager cm = (ConnectivityManager) mContext
+                    .getSystemService(Context.CONNECTIVITY_SERVICE);
+            LinkProperties mLink = cm.getLinkProperties(network);
+            if (mLink == null) {
+                loge("Link Propertiys is null at network");
+                rejectDefaultBearerDataConnActivation(
+                        findTransaction(VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ,
+                                type), FAILCAUSE_NONE, 0);
+                return;
+            }
+            mApnStatus.ifaceName = mLink.getInterfaceName();
+            log("APNStatus: " + mApnStatus);
+            log("netId =  " + network.netId + " IfaceName = " + mLink.getInterfaceName());
+            if (IMS_INTERFACE_NAME.equals(mApnStatus.ifaceName)
+                    || EMERGENCY_INTERFACE_NAME.equals(mApnStatus.ifaceName)) {
+                responseDefaultBearerDataConnActivated(
+                        findTransaction(VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ, type),
+                        network.netId, mApnStatus.ifaceName);
+            } else {
+                loge("interface name not valid");
+                rejectDefaultBearerDataConnActivation(
+                        findTransaction(VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ,
+                                type), FAILCAUSE_NONE, 0);
+            }
+
+        }
+    }
+
+    private boolean isReasonAllowedToDetach(String reason) {
+        boolean bRet = false;
+        if (Phone.REASON_DATA_DISABLED.equals(reason) || Phone.REASON_DATA_DETACHED.equals(reason)
+                || Phone.REASON_APN_CHANGED.equals(reason)
+                || Phone.REASON_APN_SWITCHED.equals(reason)
+                || Phone.REASON_APN_FAILED.equals(reason)
+                || Phone.REASON_PDP_RESET.equals(reason)
+                || Phone.REASON_LOST_DATA_CONNECTION.equals(reason)
+                // || Phone.REASON_QUERY_PLMN.equals(reason)  // MTK TODO
+                || Phone.REASON_RADIO_TURNED_OFF.equals(reason)
+                || DcFailCause.LOST_CONNECTION.toString().equals(reason)
+                || reason == null) {
+            bRet = true;
+        }
+        log("isReasonAllowedToDetach ret: " + bRet);
+        return bRet;
+    }
+
+    private NetworkCallback getNwCBbyCap(int cap) {
+        NetworkCallback nwCb = null;
+        switch (cap) {
+            case NetworkCapabilities.NET_CAPABILITY_IMS:
+                nwCb = mImsNetworkCallback;
+                break;
+            case NetworkCapabilities.NET_CAPABILITY_EIMS:
+                nwCb = mEImsNetworkCallback;
+                break;
+            default:
+                loge("error: nwCB=null for invalid cap (" + cap + ")");
+        }
+        return nwCb;
+    }
+
+    private String getApnTypeByCap(int cap) {
+        String apnType = "";
+        switch (cap) {
+            case NetworkCapabilities.NET_CAPABILITY_IMS:
+                apnType = PhoneConstants.APN_TYPE_IMS;
+                break;
+            case NetworkCapabilities.NET_CAPABILITY_EIMS:
+                apnType = PhoneConstants.APN_TYPE_EMERGENCY;
+                break;
+            default:
+                loge("error: apnType=\"\" for invalid cap (" + cap + ")");
+        }
+        return apnType;
+    }
+
+    private int getNetworkRequetsPos(String requestApnType, int endPos) {
+        int pos = -1;
+        for (int i = 0; i < endPos; i++) {
+            if (TextUtils.equals(mDataNetworkRequests[i].apnType, requestApnType)) {
+                pos = i;
+                break;
+            }
+        }
+        return pos;
+    }
+
+    private static class DataDispatcherNetworkRequest {
+        Network currentNw;
+        NetworkRequest nwRequest;
+        NetworkCapabilities nwCap;
+        NetworkCallback nwCb;
+        String apnType = "";
+
+        public DataDispatcherNetworkRequest(NetworkCallback nwCb, String apnType) {
+            this.nwCb = nwCb;
+            this.apnType = apnType;
+        }
+
+        public String toString() {
+            return "apnType: " + apnType + ", nwRequest: "
+                    + nwRequest + ", network: " + currentNw;
+        }
+    }
+
+    private void handleDefaultBearerDeactivationResonse(
+            PreciseDataConnectionState state) {
+
+        String apnType = state.getDataConnectionAPNType();
+        String failCause = state.getDataConnectionFailCause();
+
+        log("start [" + apnType + "] deactivation flow......");
+        synchronized (mAPNStatuses) {
+            ApnStatus apnStatus = mAPNStatuses.get(apnType);
+            apnStatus.mStatus = TelephonyManager.DATA_DISCONNECTED;
+
+            TransactionParam deacTrans = findTransaction
+                    (VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_DEACT_REQ, apnType);
+            if (deacTrans == null) {
+                TransactionParam actTrans = findTransaction
+                        (VaConstants.MSG_ID_WRAP_IMSM_IMSPA_PDN_ACT_REQ, apnType);
+                if (actTrans == null) {
+                    log("Network/Framework send deactivation IMS connection");
+                    notifyDefaultBearerDataConnDeactivated(
+                            failCauses.get(failCause), apnStatus.ifaceName, apnType);
+                } else {
+                    log("IMCB requestNetwork fail");
+                    rejectDefaultBearerDataConnActivation(actTrans,
+                            failCauses.get(failCause), WAITING_FRAMEWORK_STATUS_SYNC);
+                }
+            } else {
+                log("IMCB send deactivation IMS connection");
+                responseDefaultBearerDataConnDeactivated(deacTrans,
+                        failCauses.get(failCause), apnStatus.ifaceName);
+            }
+        }
+    }
+
+    private void responseDefaultBearerDataConnDeactivated(TransactionParam param, int cause,
+            String IntlName) {
+        log("responseDefaultBearerDataConnDeactivated");
+        mHandler.removeMessages(MSG_ON_NOTIFY_DEACTIVE_DATA_TIMEOUT);
+        releaseNwRequest(param.isEmergency ? PhoneConstants.APN_TYPE_EMERGENCY :
+                PhoneConstants.APN_TYPE_IMS);
+        if (hasTransaction(param.transactionId)) {
+            ImsAdapter.VaEvent event = new ImsAdapter.VaEvent(param.phoneId,
+                    VaConstants.MSG_ID_WRAP_IMSPA_IMSM_PDN_DEACT_ACK_RESP);
+            log("responseDataConnectionDeactivated param" + param);
+
+            event.putByte(param.transactionId);
+            event.putByte(cause);
+            event.putBytes(new byte[2]); // padding
+            event.putString(IntlName, 16);
+
+            removeTransaction(param.transactionId);
+            sendVaEvent(event);
+        } else {
+            loge("responseDataConnectionDeactivated but transactionId does not existed, ignore");
+        }
+
+    }
+
+    private void notifyDefaultBearerDataConnDeactivated(
+            int cause, String intlName, String apnType) {
+        log("notifyDefaultBearerDataConnDeactivated for [" + apnType + "]");
+        releaseNwRequest(apnType);
+
+        ImsAdapter.VaEvent event = new ImsAdapter.VaEvent(ImsAdapter.Util.getDefaultVoltePhoneId(),
+                VaConstants.MSG_ID_WRAP_IMSPA_IMSM_PDN_DEACT_IND);
+
+        event.putByte(cause);
+        event.putBytes(new byte[3]);
+        event.putString(intlName, 16);
+
+        sendVaEvent(event);
+    }
+
+    private void rejectPcscfDiscovery(int transactionId, int failCause) {
+
+        ImsAdapter.VaEvent event = new ImsAdapter.VaEvent(
+                ImsAdapter.Util.getDefaultVoltePhoneId(),
+                VaConstants.MSG_ID_REJECT_PCSCF_DISCOVERY);
+        log("rejectPcscfDiscovery transId= " + transactionId + ", failCause=" + failCause);
+
+        // imcf_uint8 transaction_id
+        // imc_ps_cause_enum ps_caus
+        // imcf_uint8 pad [2]
+        event.putByte(transactionId);
+        event.putByte(failCause);
+        event.putBytes(new byte[2]); // padding
+
+        sendVaEvent(event);
+    }
+
+    private void delayForSeconds(int seconds) {
+        try {
+            Thread.sleep(seconds);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Handle Data related event from IMCB.
+     *
+     * @param VaEvent event from IMCB.
+     */
+    public void vaEventCallback(VaEvent event) {
+        // relay to main thread to keep rceiver and callback handler is working under the same
+        // thread
+        mHandler.sendMessage(mHandler.obtainMessage(event.getRequestID(), event));
+    }
+
+    private void sendVaEvent(VaEvent event) {
+        log("DataDispatcher send event [" + event.getRequestID() + ", " + event.getDataLen() + "]");
+        mSocket.writeEvent(event);
+    }
+
+    private static void log(String text) {
+        Log.d(TAG, "[dedicate] DataDispatcher " + text);
+    }
+
+    private static void loge(String text) {
+        Log.e(TAG, "[dedicate] DataDispatcher " + text);
+    }
+
+    private ConnectivityManager getConnectivityManager() {
+        return (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+    }
+
+    protected boolean hasTransaction(int transactionId) {
+        synchronized (mTransactions) {
+            return (mTransactions.get(transactionId) != null);
+        }
+    }
+
+    protected TransactionParam findTransaction(int reqId, String apn) {
+        synchronized (mTransactions) {
+            Integer[] keys = getTransactionKeyArray();
+            for (Integer transactionId : keys) {
+                TransactionParam param = getTransaction(transactionId);
+                if (param.requestId == reqId &&
+                        param.apnName.equalsIgnoreCase(apn)) {
+                    return param;
+                }
+            }
+            return null;
+        }
+    }
+
+    protected void putTransaction(TransactionParam param) {
+        synchronized (mTransactions) {
+            mTransactions.put(param.transactionId, param);
+            if (DUMP_TRANSACTION) {
+                dumpTransactions();
+            }
+        }
+    }
+
+    protected void removeTransaction(int transactionId) {
+        synchronized (mTransactions) {
+            mTransactions.remove(transactionId);
+            if (DUMP_TRANSACTION) {
+                dumpTransactions();
+            }
+        }
+    }
+
+    protected TransactionParam getTransaction(int transactionId) {
+        synchronized (mTransactions) {
+            return mTransactions.get(transactionId);
+        }
+    }
+
+    protected Integer[] getTransactionKeyArray() {
+        synchronized (mTransactions) {
+            Object[] array = mTransactions.keySet().toArray();
+            if (array == null) {
+                return new Integer[0];
+            } else {
+                Integer[] intArray = new Integer[array.length];
+                for (int i = 0; i < array.length; i++)
+                    intArray[i] = (Integer) array[i];
+                return intArray;
+            }
+        }
+    }
+
+    protected void dumpTransactions() {
+        if (mTransactions.size() > 0) {
+            log("====Start dump [transactions]====");
+            for (TransactionParam param : mTransactions.values()) {
+                log("dump transactions" + param);
+            }
+            log("====End dump [transactions]====");
+        } else {
+            log("====dump [transactions] but empty====");
+        }
+    }
+
+    private class TransactionParam {
+        public int transactionId;
+        public int requestId;
+        public String apnName = "";
+        public boolean isEmergency = false;
+        public int phoneId = SubscriptionManager.INVALID_PHONE_INDEX;
+
+        public TransactionParam(int tid, int reqId, int phoneId, String apn) {
+            transactionId = tid;
+            requestId = reqId;
+            this.phoneId = phoneId;
+            apnName = apn;
+        }
+
+        @Override
+        public String toString() {
+            return "[transactionId= " + transactionId + ", request= " + requestId + ", apn= "
+                    + apnName +
+                    ", phoneId= " + phoneId + "]";
+        }
+    }
+
+    private class ApnStatus {
+
+        String mName = "";
+        int mStatus = 0;
+        String ifaceName = "";
+
+        // boolean isAbort;
+
+        public ApnStatus(String name) {
+            log("new apn status for: " + name);
+            mName = name;
+            mStatus = TelephonyManager.DATA_DISCONNECTED;
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+
+            sb.append("name: " + mName);
+            sb.append(", status: " + statusToString(mStatus));
+            sb.append(", ifaceName: " + ifaceName);
+
+            return sb.toString();
+        }
+
+        private String statusToString(int status) {
+            String rs = "";
+
+            switch (status) {
+                case TelephonyManager.DATA_CONNECTED:
+                    rs = "DATA_CONNECTED";
+                    break;
+
+                case TelephonyManager.DATA_CONNECTING:
+                    rs = "DATA_CONNECTING";
+                    break;
+
+                case TelephonyManager.DATA_DISCONNECTED:
+                    rs = "DATA_DISCONNECTED";
+                    break;
+            }
+
+            return rs;
+        }
+
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/DataDispatcherUtil.java b/packages/Ims/src/com/mediatek/ims/internal/DataDispatcherUtil.java
new file mode 100644
index 0000000..a1d3921
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/DataDispatcherUtil.java
@@ -0,0 +1,74 @@
+
+package com.mediatek.ims.internal;
+
+import android.util.Log;
+
+import com.mediatek.ims.ImsAdapter.VaEvent;
+
+public class DataDispatcherUtil {
+    protected static final String TAG = "GSM";
+
+    static final int IMC_MAXIMUM_NW_IF_NAME_STRING_SIZE = 100;
+    static final int IMC_PCSCF_MAX_NUM = 10;
+    static final int IMC_IPV4_ADDR_LEN = 0x04;
+    static final int IMC_IPV6_ADDR_LEN = 0x10;
+    static final boolean DBG = true;
+
+    public DataDispatcherUtil() {
+    }
+
+    PdnActivationInd extractDefaultPdnActInd(VaEvent event) {
+        PdnActivationInd defaultPdnActInd = new PdnActivationInd();
+
+        defaultPdnActInd.transactionId = event.getByte();
+        defaultPdnActInd.rat_type = event.getByte();
+        defaultPdnActInd.isEmergency = (event.getByte() == 1);
+        defaultPdnActInd.pad = event.getBytes(defaultPdnActInd.pad.length); // skip pad size 1
+
+        log("extractDefaultPdnActInd DefaultPdnActInd" + defaultPdnActInd);
+        return defaultPdnActInd;
+    }
+
+    PdnDeactivationInd extractDeactInd(VaEvent event) {
+        PdnDeactivationInd deact = new PdnDeactivationInd();
+        deact.transactionId = event.getByte();
+        deact.abortTransactionId = event.getByte();
+        deact.isValid = (event.getByte() == 1);
+        deact.isEmergency = (event.getByte() == 1);
+
+        log("extractDeactInd PdnDeactivationInd" + deact);
+        return deact;
+    }
+
+    public class PdnActivationInd {
+        public int transactionId;
+        public boolean isEmergency;
+        public int rat_type;
+        public byte[] pad = new byte[1];
+
+        @Override
+        public String toString() {
+            return "[ transactionId= " + transactionId + ", isEmergency= "
+                    + isEmergency + ", rat_type= " + rat_type + " ]";
+        }
+    }
+
+    public class PdnDeactivationInd {
+        public int transactionId;
+        public int abortTransactionId;
+        public boolean isValid;
+        public boolean isEmergency;
+
+        @Override
+        public String toString() {
+            return "[ transactionId= " + transactionId + ", abortTransactionId= "
+                    + abortTransactionId + ", isValid= " + isValid + ", isEmergency= "
+                    + isEmergency + " ]";
+        }
+    }
+
+    static void log(String text) {
+        Log.d(TAG, "[dedicate] DataDispatcherUtil " + text);
+    }
+
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/ImsSimservsDispatcher.java b/packages/Ims/src/com/mediatek/ims/internal/ImsSimservsDispatcher.java
new file mode 100644
index 0000000..0c549ee
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/ImsSimservsDispatcher.java
@@ -0,0 +1,151 @@
+package com.mediatek.ims.internal;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.provider.ContactsContract.CommonDataKinds.Phone;
+import android.util.Log;
+
+import com.mediatek.ims.ImsAdapter.VaEvent;
+import com.mediatek.ims.ImsAdapter.VaSocketIO;
+import com.mediatek.ims.ImsEventDispatcher;
+import com.mediatek.ims.VaConstants;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * IMS Simserv dispatcher class.
+ * To handle IMS event for Simserv from ImsEventDispatcher
+ *
+ */
+public class ImsSimservsDispatcher implements ImsEventDispatcher.VaEventDispatcher {
+    private static final String TAG = "ImsSimservsDispatcher";
+    private static final boolean DUMP_TRANSACTION = true;
+
+    private static final int IMC_MAX_XUI_LEN = 512;
+
+    private static ImsSimservsDispatcher sInstance;
+
+    private Context mContext;
+    private VaSocketIO mSocket;
+
+    private Phone mPhone;
+
+    private Handler mHandler;
+    private Thread mHandlerThread = new Thread() {
+        @Override
+        public void run() {
+            Looper.prepare();
+            mHandler = new Handler() { // create handler here
+                @Override
+                public void handleMessage(Message msg) {
+                    if (msg.obj instanceof VaEvent) {
+                        VaEvent event = (VaEvent) msg.obj;
+                        log("ImsSimservsDispatcher receives request [" + msg.what + ", "
+                                + event.getDataLen() + "]");
+                        switch (msg.what) {
+                            case VaConstants.MSG_ID_NOTIFY_XUI_IND:
+                                handleXuiUpdate(event);
+                                break;
+                            default:
+                                log("ImsSimservsDispatcher receives unhandled message [" + msg.what
+                                        + "]");
+                        }
+                    }
+                }
+            };
+            Looper.loop();
+        }
+    };
+
+    /**
+     * Constructor.
+     *
+     * @param context   Context
+     * @param io        VaSocketIO
+     *
+     */
+    public ImsSimservsDispatcher(Context context, VaSocketIO io) {
+        mContext = context;
+        mSocket = io;
+        sInstance = this;
+        mHandlerThread.start();
+    }
+
+    public static ImsSimservsDispatcher getInstance() {
+        return sInstance;
+    }
+
+    /**
+     * Enable request.
+     *
+     */
+    public void enableRequest() {
+    }
+
+    /**
+     * Disable Request.
+     *
+     */
+    public void disableRequest() {
+    }
+
+    /**
+     * Event callback for ImsEventDispatcher.
+     *
+     * @param event     VaEvent
+     *
+     */
+    public void vaEventCallback(VaEvent event) {
+        // relay to main thread to keep receiver and callback handler is working
+        // under the same thread
+        mHandler.sendMessage(mHandler.obtainMessage(event.getRequestID(), event));
+    }
+
+    public void setSocket(VaSocketIO socket) {
+        // this method is used for testing
+        // we could set a dummy socket used to verify the response
+        mSocket = socket;
+    }
+
+    private void sendVaEvent(VaEvent event) {
+        log("ImsSimservsDispatcher send event [" + event.getRequestID() + ", " + event.getDataLen()
+                + "]");
+        mSocket.writeEvent(event);
+    }
+
+    private void handleXuiUpdate(VaEvent event) {
+        /*
+         * typedef struct {
+         * imcf_uint32 xui_len;
+         * imcf_uint8 xui[IMC_MAX_XUI_LEN];
+         * } imsa_imcb_xui_ind_struct;
+         * imcf_uint32 ==unsigned
+         * int IMX_MAX_XUI_LEN == 512
+         */
+        int length = event.getInt();
+        byte[] byteArray = event.getBytes(length);
+        String xui = null;
+        int phoneId = event.getPhoneId();
+
+        if (byteArray == null) {
+            log("handleXuiUpdate event.getBytes() = null");
+            return;
+        }
+
+        try {
+            xui = new String(byteArray, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+            e.printStackTrace();
+        }
+
+        log("handleXuiUpdate xui=" + xui);
+        ImsXuiManager xuim = ImsXuiManager.getInstance();
+        xuim.setXui(phoneId, xui);
+    }
+
+    private static void log(String text) {
+        Log.d("@M_" + TAG, "[ims] ImsSimservsDispatcher " + text);
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/ImsVTProvider.java b/packages/Ims/src/com/mediatek/ims/internal/ImsVTProvider.java
new file mode 100644
index 0000000..49c732b
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/ImsVTProvider.java
@@ -0,0 +1,484 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims.internal;
+
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.telecom.VideoProfile.CameraCapabilities;
+import android.telecom.Connection;
+import android.telecom.VideoProfile;
+import android.view.Surface;
+import android.util.Log;
+
+import java.util.List;
+import java.lang.Integer;
+
+import com.android.ims.internal.ImsVideoCallProvider;
+import com.mediatek.ims.internal.ImsVTProviderUtil.Size;
+
+public class ImsVTProvider extends ImsVideoCallProvider {
+
+    static {
+        System.loadLibrary("mtk_vt_service");
+    }
+
+    public static final int VT_PROVIDER_INVALIDE_ID                             = -10000;
+
+    public static final int SESSION_EVENT_RECEIVE_FIRSTFRAME                       = 1001;
+    public static final int SESSION_EVENT_SNAPSHOT_DONE                            = 1002;
+    public static final int SESSION_EVENT_RECORDER_EVENT_INFO_UNKNOWN              = 1003;
+    public static final int SESSION_EVENT_RECORDER_EVENT_INFO_REACH_MAX_DURATION   = 1004;
+    public static final int SESSION_EVENT_RECORDER_EVENT_INFO_REACH_MAX_FILESIZE   = 1005;
+    public static final int SESSION_EVENT_RECORDER_EVENT_INFO_NO_I_FRAME           = 1006;
+    public static final int SESSION_EVENT_RECORDER_EVENT_INFO_COMPLETE             = 1007;
+    public static final int SESSION_EVENT_CALL_END                                 = 1008;
+    public static final int SESSION_EVENT_CALL_ABNORMAL_END                        = 1009;
+    public static final int SESSION_EVENT_START_COUNTER                            = 1010;
+    public static final int SESSION_EVENT_PEER_CAMERA_OPEN                         = 1011;
+    public static final int SESSION_EVENT_PEER_CAMERA_CLOSE                        = 1012;
+
+    public static final int SESSION_EVENT_RECV_SESSION_CONFIG_REQ                  = 4001;
+    public static final int SESSION_EVENT_RECV_SESSION_CONFIG_RSP                  = 4002;
+    public static final int SESSION_EVENT_HANDLE_CALL_SESSION_EVT                  = 4003;
+    public static final int SESSION_EVENT_PEER_SIZE_CHANGED                        = 4004;
+    public static final int SESSION_EVENT_LOCAL_SIZE_CHANGED                       = 4005;
+    public static final int SESSION_EVENT_DATA_USAGE_CHANGED                       = 4006;
+    public static final int SESSION_EVENT_CAM_CAP_CHANGED                          = 4007;
+    public static final int SESSION_EVENT_BAD_DATA_BITRATE                         = 4008;
+
+    public static final int SESSION_EVENT_ERROR_SERVICE                            = 8001;
+    public static final int SESSION_EVENT_ERROR_SERVER_DIED                        = 8002;
+    public static final int SESSION_EVENT_ERROR_CAMERA                             = 8003;
+    public static final int SESSION_EVENT_ERROR_CODEC                              = 8004;
+    public static final int SESSION_EVENT_ERROR_REC                                = 8005;
+
+    static final String                         TAG = "ImsVTProvider";
+
+    private int                                 mId = 1;
+    private ImsVTProviderUtil                   mUtil;
+    private static int                          mDefaultId = VT_PROVIDER_INVALIDE_ID;
+
+    public ImsVTProvider(int id) {
+        super();
+
+        Log.d(TAG, "New ImsVTProvider id = " + id);
+
+        mId = id;
+        mUtil = new ImsVTProviderUtil();
+        ImsVTProviderUtil.recordAdd(mId, this);
+
+        updateEMParam(mId);
+
+        nInitialization(mId);
+
+        if (mDefaultId == VT_PROVIDER_INVALIDE_ID) {
+            mDefaultId = mId;
+        }
+    }
+
+    public ImsVTProvider() {
+        super();
+        Log.d(TAG, "New ImsVTProvider without id");
+        mId = VT_PROVIDER_INVALIDE_ID;
+    }
+
+    public void setId(int id) {
+        Log.d(TAG, "setId id = " + id);
+        Log.d(TAG, "setId mId = " + mId);
+
+        if (mId == VT_PROVIDER_INVALIDE_ID) {
+            mId = id;
+            mUtil = new ImsVTProviderUtil();
+            ImsVTProviderUtil.recordAdd(mId, this);
+            nInitialization(mId);
+
+            updateEMParam(mId);
+
+            if (mDefaultId == VT_PROVIDER_INVALIDE_ID) {
+                mDefaultId = mId;
+            }
+        }
+    }
+
+    public int getId() {
+        return mId;
+    }
+
+    private static void updateDefaultId() {
+
+        if (!ImsVTProviderUtil.recordContain(mDefaultId)) {
+            if (ImsVTProviderUtil.recordSize() != 0) {
+                mDefaultId = ImsVTProviderUtil.recordPopId();
+                return;
+            }
+            mDefaultId = VT_PROVIDER_INVALIDE_ID;
+        }
+        return;
+    }
+
+    public static native int nInitialization(int id);
+    public static native int nFinalization(int id);
+    public static native int nSetCamera(int id, int cam);
+    public static native int nSetPreviewSurface(int id, Surface surface);
+    public static native int nSetDisplaySurface(int id, Surface surface);
+    public static native int nSetCameraParameters(int id, String config);
+    public static native int nSetDeviceOrientation(int id, int rotation);
+    public static native int nSetUIMode(int id, int mode);
+    public static native String nGetCameraParameters(int id);
+    public static native int nGetCameraSensorCount(int id);
+    public static native int nRequestPeerConfig(int id, String config);
+    public static native int nResponseLocalConfig(int id, String config);
+    public static native int nRequestCameraCapabilities(int id);
+    public static native int nRequestCallDataUsage(int id);
+    public static native int nSnapshot(int id, int type, String uri);
+    public static native int nStartRecording(int id, int type, String url, long maxSize);
+    public static native int nStopRecording(int id);
+    public static native int nSetEM(int id, int item, int arg1, int arg2);
+
+    private void updateEMParam(int id) {
+    }
+
+    public void onSetCamera(String cameraId) {
+        if (cameraId != null) {
+            if (cameraId == ImsVTProviderUtil.DUMMY_CAMERA + "") {
+                nFinalization(mId);
+            } else {
+                nSetCamera(mId, Integer.valueOf(cameraId));
+            }
+        } else {
+            nSetCamera(mId, ImsVTProviderUtil.TURN_OFF_CAMERA);
+        }
+    }
+
+    public void onSetPreviewSurface(Surface surface) {
+        nSetPreviewSurface(mId, surface);
+
+        if(surface == null) {
+            ImsVTProviderUtil.surfaceSet(mId, true, false);
+        } else {
+            ImsVTProviderUtil.surfaceSet(mId, true, true);
+        }
+
+        if (ImsVTProviderUtil.surfaceGet(mId) == 0) {
+            ImsVTProvider vp = ImsVTProviderUtil.recordGet(mId);
+            if (vp != null) {
+                vp.handleCallSessionEvent(SESSION_EVENT_CALL_END);
+            }
+        }
+    }
+
+    public void onSetDisplaySurface(Surface surface) {
+        nSetDisplaySurface(mId, surface);
+
+        if(surface == null) {
+            ImsVTProviderUtil.surfaceSet(mId, false, false);
+        } else {
+            ImsVTProviderUtil.surfaceSet(mId, false, true);
+        }
+
+        if (ImsVTProviderUtil.surfaceGet(mId) == 0) {
+            ImsVTProvider vp = ImsVTProviderUtil.recordGet(mId);
+            if (vp != null) {
+                vp.handleCallSessionEvent(SESSION_EVENT_CALL_END);
+            }
+        }
+    }
+
+    public void onSetDeviceOrientation(int rotation) {
+        nSetDeviceOrientation(mId, rotation);
+    }
+
+    public void onSetZoom(float value) {
+        mUtil.getSetting().set(ImsVTProviderUtil.ParameterSet.KEY_ZOOM, (int) value);
+        String currentSeeting = mUtil.getSetting().flatten();
+        nSetCameraParameters(mId, currentSeeting);
+    }
+
+    public void onSendSessionModifyRequest(VideoProfile fromProfile, VideoProfile toProfile) {
+        /*
+        VideoProfile.STATE_AUDIO_ONLY = 0x0;
+        VideoProfile.STATE_TX_ENABLED = 0x1;
+        VideoProfile.STATE_RX_ENABLED = 0x2;
+        VideoProfile.STATE_BIDIRECTIONAL = VideoProfile.STATE_TX_ENABLED |
+            VideoProfile.STATE_RX_ENABLED;
+        VideoProfile.STATE_PAUSED = 0x4;
+        */
+        nRequestPeerConfig(mId, ImsVTProviderUtil.packFromVdoProfile(toProfile));
+    }
+
+    public void onSendSessionModifyResponse(VideoProfile responseProfile) {
+        /*
+        VideoProfile.STATE_AUDIO_ONLY = 0x0;
+        VideoProfile.STATE_TX_ENABLED = 0x1;
+        VideoProfile.STATE_RX_ENABLED = 0x2;
+        VideoProfile.STATE_BIDIRECTIONAL = VideoProfile.STATE_TX_ENABLED |
+            VideoProfile.STATE_RX_ENABLED;
+        VideoProfile.STATE_PAUSED = 0x4;
+        */
+        nResponseLocalConfig(mId, ImsVTProviderUtil.packFromVdoProfile(responseProfile));
+    }
+
+    public void onRequestCameraCapabilities() {
+        nRequestCameraCapabilities(mId);
+    }
+
+    public void onRequestCallDataUsage() {
+        nRequestCallDataUsage(mId);
+    }
+
+    public void onSetPauseImage(Uri uri) {
+    }
+
+    public void onSetUIMode(int mode) {
+        nSetUIMode(mId, mode);
+    }
+
+    public static void postEventFromNative(
+            int msg,
+            int id,
+            int arg1,
+            int arg2,
+            int arg3,
+            Object obj1,
+            Object obj2,
+            Object obj3) {
+
+        ImsVTProvider vp = ImsVTProviderUtil.recordGet(id);
+
+        if (null == vp) {
+            Log.e(TAG, "Error: post event to Call is already release or has happen error before!");
+            return;
+        }
+
+        Log.i(TAG, "postEventFromNative [" + msg + "]");
+        switch (msg) {
+            case SESSION_EVENT_RECEIVE_FIRSTFRAME:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_RECEIVE_FIRSTFRAME");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_SNAPSHOT_DONE:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_SNAPSHOT_DONE");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_RECORDER_EVENT_INFO_UNKNOWN:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_RECORDER_EVENT_INFO_UNKNOWN");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_RECORDER_EVENT_INFO_REACH_MAX_DURATION:
+                Log.d(TAG, "postEventFromNative : msg = " +
+                     "SESSION_EVENT_RECORDER_EVENT_INFO_REACH_MAX_DURATION");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_RECORDER_EVENT_INFO_REACH_MAX_FILESIZE:
+                Log.d(TAG, "postEventFromNative : msg = " +
+                     "SESSION_EVENT_RECORDER_EVENT_INFO_REACH_MAX_FILESIZE");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_RECORDER_EVENT_INFO_NO_I_FRAME:
+                Log.d(TAG, "postEventFromNative : msg = " +
+                    "SESSION_EVENT_RECORDER_EVENT_INFO_NO_I_FRAME");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_RECORDER_EVENT_INFO_COMPLETE:
+                Log.d(TAG, "postEventFromNative : msg = " +
+                    "SESSION_EVENT_RECORDER_EVENT_INFO_COMPLETE");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_CALL_END:
+            case SESSION_EVENT_CALL_ABNORMAL_END:
+                Log.d(TAG, "postEventFromNative : msg = " +
+                      "SESSION_EVENT_CALL_END / SESSION_EVENT_CALL_ABNORMAL_END");
+
+                ImsVTProviderUtil.recordRemove(id);
+                updateDefaultId();
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_START_COUNTER:
+                Log.d(TAG, "postEventFromNative : msg = MSG_START_COUNTER");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_PEER_CAMERA_OPEN:
+                Log.d(TAG, "postEventFromNative : msg = MSG_PEER_CAMERA_OPEN");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_PEER_CAMERA_CLOSE:
+                Log.d(TAG, "postEventFromNative : msg = MSG_PEER_CAMERA_CLOSE");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_RECV_SESSION_CONFIG_REQ:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_RECV_SESSION_CONFIG_REQ");
+
+                vp.receiveSessionModifyRequest(
+                        ImsVTProviderUtil.unPackToVdoProfile((String) obj1));
+                break;
+
+            case SESSION_EVENT_RECV_SESSION_CONFIG_RSP:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_RECV_SESSION_CONFIG_RSP");
+
+                vp.receiveSessionModifyResponse(
+                        arg1,
+                        ImsVTProviderUtil.unPackToVdoProfile((String) obj1),
+                        ImsVTProviderUtil.unPackToVdoProfile((String) obj2));
+                break;
+
+            case SESSION_EVENT_HANDLE_CALL_SESSION_EVT:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_HANDLE_CALL_SESSION_EVT");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_PEER_SIZE_CHANGED:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_PEER_SIZE_CHANGED");
+
+                vp.changePeerDimensions(arg1, arg2);
+                // MTK TODO
+                // vp.changePeerDimensionsWithAngle(arg1, arg2, arg3);
+                break;
+
+            case SESSION_EVENT_LOCAL_SIZE_CHANGED:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_LOCAL_SIZE_CHANGED");
+
+                break;
+
+            case SESSION_EVENT_DATA_USAGE_CHANGED:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_DATA_USAGE_CHANGED");
+
+                vp.changeCallDataUsage(arg1);
+                break;
+
+            case SESSION_EVENT_CAM_CAP_CHANGED:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_CAM_CAP_CHANGED");
+
+                Log.d(TAG, (String) obj1);
+
+                ImsVTProviderUtil.getSetting().unflatten((String) obj1);
+                ImsVTProviderUtil.ParameterSet set = ImsVTProviderUtil.getSetting();
+
+                int zoom_max = set.getInt(ImsVTProviderUtil.ParameterSet.KEY_MAX_ZOOM, 0);
+                boolean zoom_support =
+                  "true".equals(set.get(ImsVTProviderUtil.ParameterSet.KEY_ZOOM_SUPPORTED));
+                List<Size> size = set.getSizeList(ImsVTProviderUtil.ParameterSet.KEY_PREVIEW_SIZE);
+
+                // default size
+                int width = 320;
+                int height = 240;
+
+                if (size != null) {
+                    width = size.get(0).width;
+                    height = size.get(0).height;
+                }
+
+                CameraCapabilities camCap =
+                  new CameraCapabilities(width, height, zoom_support, zoom_max);
+
+                vp.changeCameraCapabilities(camCap);
+                break;
+
+            case SESSION_EVENT_BAD_DATA_BITRATE:
+                Log.d(TAG, "postEventFromNative : msg = SESSION_EVENT_BAD_DATA_BITRATE");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_ERROR_SERVICE:
+                Log.d(TAG, "postEventFromNative : msg = MSG_ERROR_SERVICE");
+                ImsVTProviderUtil.recordRemove(id);
+                updateDefaultId();
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_ERROR_SERVER_DIED:
+                Log.d(TAG, "postEventFromNative : msg = MSG_ERROR_SERVER_DIED");
+                ImsVTProviderUtil.recordRemove(id);
+                updateDefaultId();
+
+                // because the event may happen when no call exist
+                // need to check firstly
+                if (vp != null) {
+                    vp.handleCallSessionEvent(msg);
+                }
+                break;
+
+            case SESSION_EVENT_ERROR_CAMERA:
+                Log.d(TAG, "postEventFromNative : msg = MSG_ERROR_CAMERA");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_ERROR_CODEC:
+                Log.d(TAG, "postEventFromNative : msg = MSG_ERROR_CODEC");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            case SESSION_EVENT_ERROR_REC:
+                Log.d(TAG, "postEventFromNative : msg = MSG_ERROR_REC");
+
+                vp.handleCallSessionEvent(msg);
+                break;
+
+            default:
+                Log.d(TAG, "postEventFromNative : msg = UNKNOWB");
+                break;
+        }
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/ImsVTProviderUtil.java b/packages/Ims/src/com/mediatek/ims/internal/ImsVTProviderUtil.java
new file mode 100644
index 0000000..332bd01
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/ImsVTProviderUtil.java
@@ -0,0 +1,582 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims.internal;
+
+import android.telecom.VideoProfile.CameraCapabilities;
+import android.telecom.Connection;
+import android.telecom.VideoProfile;
+import android.view.Surface;
+
+import android.hardware.camera2.CameraCharacteristics;
+import android.telecom.VideoProfile;
+import java.util.StringTokenizer;
+import java.util.Map;
+import java.util.HashMap;
+
+import android.util.Log;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.StringTokenizer;
+import java.lang.Integer;
+
+import com.mediatek.ims.internal.ImsVTProvider;
+
+public class ImsVTProviderUtil {
+
+    private static final String TAG = "ImsVTProviderUtil";
+
+    public static final int HIDE_ME_TYPE_NONE           = 0;
+    public static final int HIDE_ME_TYPE_DISABLE        = 1;
+    public static final int HIDE_ME_TYPE_FREEZE         = 2;
+    public static final int HIDE_ME_TYPE_PICTURE        = 3;
+
+    public static final int HIDE_YOU_TYPE_DISABLE       = 0;
+    public static final int HIDE_YOU_TYPE_ENABLE        = 1;
+
+    public static final int TURN_OFF_CAMERA             = -1;
+    public static final int DUMMY_CAMERA                = 255; // for Loopback call end event
+
+    public static class Size {
+        /**
+         * Sets the dimensions for pictures.
+         *
+         * @param w the photo width (pixels)
+         * @param h the photo height (pixels)
+         */
+        public Size(int w, int h) {
+            width = w;
+            height = h;
+        }
+
+        /**
+         * Compares {@code obj} to this size.
+         *
+         * @param obj the object to compare this size with.
+         * @return {@code true} if the width and height of {@code obj} is the
+         *         same as those of this size. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Size)) {
+                return false;
+            }
+            Size s = (Size) obj;
+            return width == s.width && height == s.height;
+        }
+
+        @Override
+        public int hashCode() {
+            return width * 32713 + height;
+        }
+
+        /** width of the picture */
+        public int width;
+        /** height of the picture */
+        public int height;
+    };
+
+    public class ParameterSet {
+        // Parameter keys to communicate with the camera driver.
+        public static final String KEY_PREVIEW_SIZE = "preview-size";
+        public static final String KEY_PREVIEW_FORMAT = "preview-format";
+        public static final String KEY_PREVIEW_FRAME_RATE = "preview-frame-rate";
+        public static final String KEY_PICTURE_SIZE = "picture-size";
+        public static final String KEY_PICTURE_FORMAT = "picture-format";
+        public static final String KEY_JPEG_THUMBNAIL_SIZE = "jpeg-thumbnail-size";
+        public static final String KEY_JPEG_THUMBNAIL_WIDTH = "jpeg-thumbnail-width";
+        public static final String KEY_JPEG_THUMBNAIL_HEIGHT = "jpeg-thumbnail-height";
+        public static final String KEY_JPEG_THUMBNAIL_QUALITY = "jpeg-thumbnail-quality";
+        public static final String KEY_JPEG_QUALITY = "jpeg-quality";
+        public static final String KEY_ROTATION = "rotation";
+        public static final String KEY_GPS_LATITUDE = "gps-latitude";
+        public static final String KEY_GPS_LONGITUDE = "gps-longitude";
+        public static final String KEY_GPS_ALTITUDE = "gps-altitude";
+        public static final String KEY_GPS_TIMESTAMP = "gps-timestamp";
+        public static final String KEY_GPS_PROCESSING_METHOD = "gps-processing-method";
+        public static final String KEY_WHITE_BALANCE = "whitebalance";
+        public static final String KEY_EFFECT = "effect";
+        public static final String KEY_ANTIBANDING = "antibanding";
+        public static final String KEY_SCENE_MODE = "scene-mode";
+        public static final String KEY_FLASH_MODE = "flash-mode";
+        public static final String KEY_FOCUS_MODE = "focus-mode";
+        public static final String KEY_FOCAL_LENGTH = "focal-length";
+        public static final String KEY_HORIZONTAL_VIEW_ANGLE = "horizontal-view-angle";
+        public static final String KEY_VERTICAL_VIEW_ANGLE = "vertical-view-angle";
+        public static final String KEY_EXPOSURE_COMPENSATION = "exposure-compensation";
+        public static final String KEY_MAX_EXPOSURE_COMPENSATION = "max-exposure-compensation";
+        public static final String KEY_MIN_EXPOSURE_COMPENSATION = "min-exposure-compensation";
+        public static final String KEY_EXPOSURE_COMPENSATION_STEP = "exposure-compensation-step";
+        public static final String KEY_ZOOM = "zoom";
+        public static final String KEY_MAX_ZOOM = "max-zoom";
+        public static final String KEY_ZOOM_RATIOS = "zoom-ratios";
+        public static final String KEY_ZOOM_SUPPORTED = "zoom-supported";
+        public static final String KEY_SMOOTH_ZOOM_SUPPORTED = "smooth-zoom-supported";
+        public static final String KEY_FOCUS_METER = "focus-meter";
+        public static final String KEY_ISOSPEED_MODE = "iso-speed";
+        public static final String KEY_EXPOSURE = "exposure";
+        public static final String KEY_EXPOSURE_METER = "exposure-meter";
+        public static final String KEY_FD_MODE = "fd-mode";
+        public static final String KEY_EDGE_MODE = "edge";
+        public static final String KEY_HUE_MODE = "hue";
+        public static final String KEY_SATURATION_MODE = "saturation";
+        public static final String KEY_BRIGHTNESS_MODE = "brightness";
+        public static final String KEY_CONTRAST_MODE = "contrast";
+        public static final String KEY_CAPTURE_MODE = "cap-mode";
+        public static final String KEY_CAPTURE_PATH = "capfname";
+        public static final String KEY_BURST_SHOT_NUM = "burst-num";
+
+        // Parameter key suffix for supported values.
+        public static final String SUPPORTED_VALUES_SUFFIX = "-values";
+
+        // Values for white balance settings.
+        public static final String WHITE_BALANCE_AUTO = "auto";
+        public static final String WHITE_BALANCE_INCANDESCENT = "incandescent";
+        public static final String WHITE_BALANCE_FLUORESCENT = "fluorescent";
+        public static final String WHITE_BALANCE_WARM_FLUORESCENT = "warm-fluorescent";
+        public static final String WHITE_BALANCE_DAYLIGHT = "daylight";
+        public static final String WHITE_BALANCE_CLOUDY_DAYLIGHT = "cloudy-daylight";
+        public static final String WHITE_BALANCE_TWILIGHT = "twilight";
+        public static final String WHITE_BALANCE_SHADE = "shade";
+
+        // Values for color effect settings.
+        public static final String EFFECT_NONE = "none";
+        public static final String EFFECT_MONO = "mono";
+        public static final String EFFECT_NEGATIVE = "negative";
+        public static final String EFFECT_SOLARIZE = "solarize";
+        public static final String EFFECT_SEPIA = "sepia";
+        public static final String EFFECT_POSTERIZE = "posterize";
+        public static final String EFFECT_WHITEBOARD = "whiteboard";
+        public static final String EFFECT_BLACKBOARD = "blackboard";
+        public static final String EFFECT_AQUA = "aqua";
+
+        // Values for antibanding settings.
+        public static final String ANTIBANDING_AUTO = "auto";
+        public static final String ANTIBANDING_50HZ = "50hz";
+        public static final String ANTIBANDING_60HZ = "60hz";
+        public static final String ANTIBANDING_OFF = "off";
+
+        public static final String CONTRAST_HIGH = "high";
+        public static final String CONTRAST_MIDDLE = "middle";
+        public static final String CONTRAST_LOW = "low";
+
+        // Values for flash mode settings.
+        public static final String FLASH_MODE_OFF = "off";
+        public static final String FLASH_MODE_AUTO = "auto";
+        public static final String FLASH_MODE_ON = "on";
+        public static final String FLASH_MODE_RED_EYE = "red-eye";
+        public static final String FLASH_MODE_TORCH = "torch";
+
+        // Values for scene mode settings.
+        public static final String SCENE_MODE_AUTO = "auto";
+        public static final String SCENE_MODE_ACTION = "action";
+        public static final String SCENE_MODE_PORTRAIT = "portrait";
+        public static final String SCENE_MODE_LANDSCAPE = "landscape";
+        public static final String SCENE_MODE_NIGHT = "night";
+        public static final String SCENE_MODE_NIGHT_PORTRAIT = "night-portrait";
+        public static final String SCENE_MODE_THEATRE = "theatre";
+        public static final String SCENE_MODE_BEACH = "beach";
+        public static final String SCENE_MODE_SNOW = "snow";
+        public static final String SCENE_MODE_SUNSET = "sunset";
+        public static final String SCENE_MODE_STEADYPHOTO = "steadyphoto";
+        public static final String SCENE_MODE_FIREWORKS = "fireworks";
+        public static final String SCENE_MODE_SPORTS = "sports";
+        public static final String SCENE_MODE_PARTY = "party";
+        public static final String SCENE_MODE_CANDLELIGHT = "candlelight";
+        public static final String SCENE_MODE_BARCODE = "barcode";
+
+        // Values for focus mode settings.
+        public static final String FOCUS_MODE_AUTO = "auto";
+        public static final String FOCUS_MODE_INFINITY = "infinity";
+        public static final String FOCUS_MODE_MACRO = "macro";
+        public static final String FOCUS_MODE_FIXED = "fixed";
+        public static final String FOCUS_MODE_EDOF = "edof";
+
+        // Values for capture mode settings.
+        public static final String CAPTURE_MODE_NORMAL = "normal";
+        public static final String CAPTURE_MODE_BEST_SHOT = "bestshot";
+        public static final String CAPTURE_MODE_EV_BRACKET_SHOT = "evbracketshot";
+        public static final String CAPTURE_MODE_BURST_SHOT = "burstshot";
+
+        // Formats for setPreviewFormat and setPictureFormat.
+        private static final String PIXEL_FORMAT_YUV422SP = "yuv422sp";
+        private static final String PIXEL_FORMAT_YUV420SP = "yuv420sp";
+        private static final String PIXEL_FORMAT_YUV422I = "yuv422i-yuyv";
+        private static final String PIXEL_FORMAT_RGB565 = "rgb565";
+        private static final String PIXEL_FORMAT_JPEG = "jpeg";
+
+        private HashMap<String, String> mMap;
+
+        /**
+         * Handles the picture size (dimensions).
+         */
+
+
+        public ParameterSet() {
+            mMap = new HashMap<String, String>();
+        }
+
+        public void dump() {
+            Log.e(TAG, "dump: size=" + mMap.size());
+            for (String k : mMap.keySet()) {
+                Log.e(TAG, "dump: " + k + "=" + mMap.get(k));
+            }
+        }
+
+        public String flatten() {
+            StringBuilder flattened = new StringBuilder();
+            for (String k : mMap.keySet()) {
+                flattened.append(k);
+                flattened.append("=");
+                flattened.append(mMap.get(k));
+                flattened.append(";");
+            }
+            // chop off the extra semicolon at the end
+            flattened.deleteCharAt(flattened.length() - 1);
+            return flattened.toString();
+        }
+
+        public void unflatten(String flattened) {
+            mMap.clear();
+
+            StringTokenizer tokenizer = new StringTokenizer(flattened, ";");
+            while (tokenizer.hasMoreElements()) {
+                String kv = tokenizer.nextToken();
+                int pos = kv.indexOf('=');
+                if (pos == -1) {
+                    continue;
+                }
+                String k = kv.substring(0, pos);
+                String v = kv.substring(pos + 1);
+                mMap.put(k, v);
+            }
+        }
+
+        public void remove(String key) {
+            mMap.remove(key);
+        }
+
+
+        public void set(String key, String value) {
+            if (key.indexOf('=') != -1 || key.indexOf(';') != -1) {
+                Log.e(TAG, "Key \"" + key + "\" contains invalid character (= or ;)");
+                return;
+            }
+            if (value.indexOf('=') != -1 || value.indexOf(';') != -1) {
+                Log.e(TAG, "Value \"" + value + "\" contains invalid character (= or ;)");
+                return;
+            }
+
+            mMap.put(key, value);
+        }
+
+        public void set(String key, int value) {
+            mMap.put(key, Integer.toString(value));
+        }
+
+        public String get(String key) {
+            return mMap.get(key);
+        }
+
+        public int getInt(String key, int defaultValue) {
+            try {
+                return Integer.parseInt(mMap.get(key));
+            } catch (NumberFormatException ex) {
+                return defaultValue;
+            }
+        }
+
+        public float getFloat(String key, float defaultValue) {
+            try {
+                return Float.parseFloat(mMap.get(key));
+            } catch (NumberFormatException ex) {
+                return defaultValue;
+            }
+        }
+
+        public Size getSize(String key) {
+            return strToSize(get(key));
+        }
+
+        public List<String> getStrList(String key) {
+            return split(get(key));
+        }
+
+        public List<Integer> getIntList(String key) {
+            return splitInt(get(key));
+        }
+
+        public List<Size> getSizeList(String key) {
+            return splitSize(get(key));
+        }
+
+
+        // Splits a comma delimited string to an ArrayList of String.
+        // Return null if the passing string is null or the size is 0.
+        private ArrayList<String> split(String str) {
+            if (str == null) {
+                return null;
+            }
+            // Use StringTokenizer because it is faster than split.
+            StringTokenizer tokenizer = new StringTokenizer(str, ",");
+            ArrayList<String> substrings = new ArrayList<String>();
+            while (tokenizer.hasMoreElements()) {
+                substrings.add(tokenizer.nextToken());
+            }
+            return substrings;
+        }
+
+        // Splits a comma delimited string to an ArrayList of Integer.
+        // Return null if the passing string is null or the size is 0.
+        private ArrayList<Integer> splitInt(String str) {
+            if (str == null) {
+                return null;
+            }
+            StringTokenizer tokenizer = new StringTokenizer(str, ",");
+            ArrayList<Integer> substrings = new ArrayList<Integer>();
+            while (tokenizer.hasMoreElements()) {
+                String token = tokenizer.nextToken();
+                substrings.add(Integer.parseInt(token));
+            }
+            if (substrings.size() == 0) {
+                return null;
+            }
+            return substrings;
+        }
+
+        // Splits a comma delimited string to an ArrayList of Size.
+        // Return null if the passing string is null or the size is 0.
+        private ArrayList<Size> splitSize(String str) {
+            if (str == null) {
+                return null;
+            }
+            StringTokenizer tokenizer = new StringTokenizer(str, ",");
+            ArrayList<Size> sizeList = new ArrayList<Size>();
+            while (tokenizer.hasMoreElements()) {
+                Size size = strToSize(tokenizer.nextToken());
+                if (size != null) {
+                    sizeList.add(size);
+                }
+            }
+            if (sizeList.size() == 0) {
+                return null;
+            }
+            return sizeList;
+        }
+
+        // Parses a string (ex: "480x320") to Size object.
+        // Return null if the passing string is null.
+        private Size strToSize(String str) {
+            if (str == null) {
+                return null;
+            }
+            int pos = str.indexOf('x');
+            if (pos != -1) {
+                String width = str.substring(0, pos);
+                String height = str.substring(pos + 1);
+                return new Size(Integer.parseInt(width),
+                                Integer.parseInt(height));
+            }
+            Log.e(TAG, "Invalid size parameter string=" + str);
+            return null;
+        }
+    }
+
+    public static class ImsVTMessagePacker {
+
+        public String packFromVdoProfile(VideoProfile videoProfile) {
+
+            StringBuilder flattened = new StringBuilder();
+
+            flattened.append("mVideoState");
+            flattened.append("=");
+            flattened.append("" + videoProfile.getVideoState());
+            flattened.append(";");
+            flattened.append("mQuality");
+            flattened.append("=");
+            flattened.append("" + videoProfile.getQuality());
+            flattened.append(";");
+
+            // chop off the extra semicolon at the end
+            flattened.deleteCharAt(flattened.length() - 1);
+
+            Log.d(TAG, "[packFromVdoProfile] profile = " + flattened.toString());
+
+            return flattened.toString();
+        }
+
+        public VideoProfile unPackToVdoProfile(String flattened) {
+
+            Log.d(TAG, "[unPackToVdoProfile] flattened = " + flattened);
+
+            StringTokenizer tokenizer = new StringTokenizer(flattened, ";");
+            int state = VideoProfile.STATE_BIDIRECTIONAL;
+            int qty = VideoProfile.QUALITY_DEFAULT;
+
+            while (tokenizer.hasMoreElements()) {
+                String kv = tokenizer.nextToken();
+                int pos = kv.indexOf('=');
+                if (pos == -1) {
+                    continue;
+                }
+                String k = kv.substring(0, pos);
+                String v = kv.substring(pos + 1);
+
+                Log.d(TAG, "[unPackToVdoProfile] k = " + k + ", v = " + v);
+
+                if (k.equals("mVideoState")) {
+                    state = Integer.valueOf(v).intValue();
+                } else if (k.equals("mQuality")) {
+                    qty = Integer.valueOf(v).intValue();
+                }
+            }
+            Log.d(TAG, "[unPackToVdoProfile] state = " + state + ", qty = " + qty);
+            return new VideoProfile(state, qty);
+        }
+
+    }
+
+    private static ParameterSet                     mParamSet;
+    private static ImsVTMessagePacker               mPacker = new ImsVTMessagePacker();
+    private static Map<String, Object>              mProviderById = new HashMap<>();
+    private static Map<String, Object>              mSurfaceStatusById = new HashMap<>();
+
+    ImsVTProviderUtil() {
+        mParamSet = new ParameterSet();
+    }
+
+    public static ParameterSet getSetting() {
+        return mParamSet;
+    }
+
+    public static String packFromVdoProfile(VideoProfile VideoProfile) {
+        return mPacker.packFromVdoProfile(VideoProfile);
+    }
+
+    public static VideoProfile unPackToVdoProfile(String flattened) {
+        return mPacker.unPackToVdoProfile(flattened);
+    }
+
+    public static void surfaceSet(int Id, boolean isLocal, boolean isSet) {
+        Integer status = (Integer) mSurfaceStatusById.get("" + Id);
+        int statusInt;
+
+        Log.d(TAG, "[surfaceSet] isLocal = " + isLocal + ", isSet = " + isSet);
+
+        if (status != null) {
+            statusInt = status.intValue();
+            Log.d(TAG, "[surfaceSet] state (before) = " + statusInt);
+            if (isLocal) {
+                if (!isSet) {
+                    statusInt &= ~0x1;
+                } else {
+                    statusInt |= 0x1;
+                }
+            } else {
+                if (!isSet) {
+                    statusInt &= ~0x2;
+                } else {
+                    statusInt |= 0x2;
+                }
+            }
+        } else {
+            Log.d(TAG, "[surfaceSet] state (before) = null");
+            if (isLocal) {
+                if (!isSet) {
+                    statusInt = 0x0;
+                } else {
+                    statusInt = 0x1;
+                }
+            } else {
+                if (!isSet) {
+                    statusInt = 0x0;
+                } else {
+                    statusInt = 0x2;
+                }
+            }
+        }
+        Log.d(TAG, "[surfaceSet] state (after) = " + statusInt + ", Id = " + Id);
+
+        mSurfaceStatusById.put("" + Id, new Integer(statusInt));
+        return;
+    }
+
+    public static int surfaceGet(int Id) {
+        Integer status = (Integer) mSurfaceStatusById.get("" + Id);
+        if (status != null) {
+            Log.d(TAG, "[surfaceGet] state = " + status.intValue() + ", Id = " + Id);
+            return status.intValue();
+        } else {
+            Log.d(TAG, "[surfaceGet] state = 0" + ", Id = " + Id);
+            return 0;
+        }
+    }
+
+    public static void recordAdd(int Id, ImsVTProvider p) {
+        Log.d(TAG, "recordAdd id = " + Id + ", size = " + recordSize());
+        mProviderById.put("" + Id, p);
+        return;
+    }
+
+    public static void recordRemove(int Id) {
+        Log.d(TAG, "recordRemove id = " + Id + ", size = " + recordSize());
+        mProviderById.remove("" + Id);
+        return;
+    }
+
+    public static ImsVTProvider recordGet(int Id) {
+        Log.d(TAG, "recordGet id = " + Id + ", size = " + recordSize());
+        return (ImsVTProvider) mProviderById.get("" + Id);
+    }
+
+    public static int recordPopId() {
+
+        if (mProviderById.size() != 0) {
+            for (Object p : mProviderById.values()) {
+                return ((ImsVTProvider) p).getId();
+            }
+        }
+        return ImsVTProvider.VT_PROVIDER_INVALIDE_ID;
+    }
+
+    public static boolean recordContain(int Id) {
+        return mProviderById.containsKey(Id);
+    }
+
+    public static int recordSize() {
+        return mProviderById.size();
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/ImsXuiManager.java b/packages/Ims/src/com/mediatek/ims/internal/ImsXuiManager.java
new file mode 100644
index 0000000..db188ed
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/ImsXuiManager.java
@@ -0,0 +1,79 @@
+package com.mediatek.ims.internal;
+
+import android.telephony.TelephonyManager;
+
+/**
+ * ImsXuiManager class.
+ * To manage XUI
+ *
+ */
+public class ImsXuiManager {
+    public String[] mXui;
+    static ImsXuiManager sInstance;
+
+    /**
+     * Constructor.
+     */
+    private ImsXuiManager() {
+        int numPhones = TelephonyManager.getDefault().getPhoneCount();
+        mXui = new String[numPhones];
+    }
+
+    /**
+     * Instance constructor.
+     *
+     * @return ImsXuiManager instance
+     */
+    static public ImsXuiManager getInstance() {
+        if (sInstance == null) {
+            sInstance = new ImsXuiManager();
+            sInstance.loadXui();
+        }
+        return sInstance;
+    }
+
+
+    public String getXui() {
+        return mXui[0];
+    }
+
+    public String getXui(int phoneId) {
+        return mXui[phoneId];
+    }
+
+
+    /**
+     * Clear XUI.
+     * Should be called if SIM card changed
+     *
+     */
+    public void clearStoredXui() {
+        mXui = null;
+        // Todo: Clear the NV storage that XUI belongs to.
+    }
+
+    /**
+     * Update from IMSA.
+     *
+     * @param xui  XUI
+     */
+    public void setXui(String xui) {
+        mXui[0] = xui;
+        // Todo: Save XUI to a NV storage
+    }
+
+    /**
+     * Update from IMSA.
+     *
+     * @param phoneId IMS Phone Id
+     * @param xui  XUI
+     */
+    public void setXui(int phoneId, String xui) {
+        mXui[phoneId] = xui;
+        // Todo: Save XUI to a NV storage
+    }
+
+    private void loadXui() {
+        // Todo: load XUI from a NV storage
+    }
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/PcscfAddr.java b/packages/Ims/src/com/mediatek/ims/internal/PcscfAddr.java
new file mode 100644
index 0000000..092f3ba
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/PcscfAddr.java
@@ -0,0 +1,79 @@
+package com.mediatek.ims.internal;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class PcscfAddr implements Parcelable {
+    public static final int IMC_PDP_ADDR_NONE_ADDR_TYPE = 0X0;
+    public static final int IMC_PDP_ADDR_IPV4_ADDR_TYPE = 0X21;
+    public static final int IMC_PDP_ADDR_IPV6_ADDR_TYPE = 0X57;
+    public static final int IMC_PDP_ADDR_IPV4V6_ADDR_TYPE = 0X8D;
+    public static final int IMC_PDP_ADDR_NULL_PDP_ADDR_TYPE = 0X03;
+
+    public int protocol;
+    public int port;
+    public String address;
+
+    public PcscfAddr() {
+}
+
+    public PcscfAddr(String addr) {
+        address = addr;
+        if (address == null) {
+            protocol = IMC_PDP_ADDR_NONE_ADDR_TYPE;
+        } else {
+            if (address.split("\\.").length > 4) //dot is the reserved symbol
+                protocol = IMC_PDP_ADDR_IPV6_ADDR_TYPE;
+            else
+                protocol = IMC_PDP_ADDR_IPV4_ADDR_TYPE;
+        }
+    }
+
+    public void readFrom(Parcel p) {
+        protocol = p.readInt();
+        port = p.readInt();
+        address = p.readString();
+    }
+
+    public void writeTo(Parcel p) {
+        p.writeInt(protocol);
+        p.writeInt(port);
+        p.writeString(address);
+    }
+
+    public void reset() {
+        protocol = 0;
+        port = 0;
+        address = null;
+    }
+
+    @Override
+    public String toString() {
+        return "[protocol=" + protocol + ", port=" + port + ", address=" + address + "]";
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        writeTo(dest);
+    }
+
+    public static final Parcelable.Creator<PcscfAddr> CREATOR =
+            new Parcelable.Creator<PcscfAddr>() {
+        @Override
+        public PcscfAddr createFromParcel(Parcel source) {
+            PcscfAddr pcscfAddr = new PcscfAddr();
+            pcscfAddr.readFrom(source);
+            return pcscfAddr;
+        }
+
+        @Override
+        public PcscfAddr[] newArray(int size) {
+            return new PcscfAddr[size];
+        }
+    };
+}
\ No newline at end of file
diff --git a/packages/Ims/src/com/mediatek/ims/internal/PcscfInfo.java b/packages/Ims/src/com/mediatek/ims/internal/PcscfInfo.java
new file mode 100644
index 0000000..bc07413
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/PcscfInfo.java
@@ -0,0 +1,160 @@
+package com.mediatek.ims.internal;
+
+import java.util.ArrayList;
+import java.lang.StringBuffer;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.text.TextUtils;
+
+public class PcscfInfo implements Parcelable {
+    public static final int IMC_PCSCF_ACQUIRE_BY_NONE = 0;
+    public static final int IMC_PCSCF_ACQUIRE_BY_SIM = 1;
+    public static final int IMC_PCSCF_ACQUIRE_BY_MO = 2;
+    public static final int IMC_PCSCF_ACQUIRE_BY_PCO = 3;
+    public static final int IMC_PCSCF_ACQUIRE_BY_DHCPv4 = 4;
+    public static final int IMC_PCSCF_ACQUIRE_BY_DHCPv6 = 5;
+    public static final int IMC_PCSCF_ACQUIRE_BY_MANUAL = 6;
+
+    public int source = IMC_PCSCF_ACQUIRE_BY_NONE;
+    public ArrayList<PcscfAddr> v4AddrList = new ArrayList<PcscfAddr>();
+    public ArrayList<PcscfAddr> v6AddrList = new ArrayList<PcscfAddr>();
+
+    public PcscfInfo() {
+    }
+
+    public PcscfInfo(int sourceNum, String[] pcscfArray) {
+        if (pcscfArray != null && pcscfArray.length > 0) {
+            source = sourceNum;
+            for (String pcscf : pcscfArray)
+                add(pcscf, 0); //port is not specified
+        }
+    }
+
+    public PcscfInfo(int sourceNum, byte[] pcscfBytes, int port) {
+        source = sourceNum;
+        add(new String(pcscfBytes), port);
+    }
+
+    public void add(String pcscf, int port) {
+        PcscfAddr pcscfAddr = new PcscfAddr(pcscf);
+        pcscfAddr.port = port;
+
+        if (pcscfAddr.protocol == PcscfAddr.IMC_PDP_ADDR_IPV4_ADDR_TYPE)
+            v4AddrList.add(pcscfAddr);
+        else
+            v6AddrList.add(pcscfAddr);
+    }
+
+    public int getPcscfAddressCount() {
+        return v4AddrList.size() + v6AddrList.size();
+    }
+
+    public void readFrom(Parcel p) {
+        source = p.readInt();
+        int v4AddrNumber = p.readInt();
+        for (int i=0; i<v4AddrNumber; i++) {
+            PcscfAddr addr = new PcscfAddr();
+            addr.readFrom(p);
+            v4AddrList.add(addr);
+        }
+
+        int v6AddrNumber = p.readInt();
+        for (int i=0; i<v6AddrNumber; i++) {
+            PcscfAddr addr = new PcscfAddr();
+            addr.readFrom(p);
+            v6AddrList.add(addr);
+        }
+    }
+
+    public void writeTo(Parcel p) {
+        p.writeInt(source);
+        p.writeInt(v4AddrList.size());
+        for (PcscfAddr addr : v4AddrList)
+            addr.writeTo(p);
+
+        p.writeInt(v6AddrList.size());
+        for (PcscfAddr addr : v6AddrList)
+            addr.writeTo(p);
+    }
+
+    public void readAddressFrom(int sourceNum, Parcel p) {
+        String pcscfStr = p.readString();
+        if (!TextUtils.isEmpty(pcscfStr)) {
+            String[] pcscfArray = pcscfStr.split(" ");
+            if (pcscfArray != null && pcscfArray.length > 0) {
+                for (String pcscf : pcscfArray)
+                    add(pcscf, 0); //port is not specified
+            }
+        }
+    }
+
+    public void writeAddressTo(Parcel p) {
+        int count = 0;
+        for (PcscfAddr addr : v4AddrList) {
+            if (count == 0)
+                p.writeString(addr.address);
+            else
+                p.writeString(" " + addr.address);
+
+            ++count;
+        }
+        for (PcscfAddr addr : v6AddrList) {
+            if (count == 0)
+                p.writeString(addr.address);
+            else
+                p.writeString(" " + addr.address);
+
+            ++count;
+        }
+    }
+
+    //This method does not clone data to a new instance
+    public void copyFrom(PcscfInfo pcscfInfo) {
+        source = pcscfInfo.source;
+        v4AddrList = pcscfInfo.v4AddrList;
+        v6AddrList = pcscfInfo.v6AddrList;
+    }
+
+    public void reset() {
+        source = IMC_PCSCF_ACQUIRE_BY_NONE;
+        v4AddrList.clear();
+        v6AddrList.clear();
+    }
+
+    @Override
+    public String toString() {
+        StringBuffer buf = new StringBuffer("[source=" + source + ", V4[");
+        for (PcscfAddr addr : v4AddrList)
+            buf.append(addr.toString());
+        buf.append("] V6[");
+        for (PcscfAddr addr : v6AddrList)
+            buf.append(addr.toString());
+        buf.append("]");
+        return buf.toString();
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        writeTo(dest);
+    }
+
+    public static final Parcelable.Creator<PcscfInfo> CREATOR =
+            new Parcelable.Creator<PcscfInfo>() {
+        @Override
+        public PcscfInfo createFromParcel(Parcel source) {
+            PcscfInfo pcscfInfo = new PcscfInfo();
+            pcscfInfo.readFrom(source);
+            return pcscfInfo;
+        }
+
+        @Override
+        public PcscfInfo[] newArray(int size) {
+            return new PcscfInfo[size];
+        }
+    };
+}
diff --git a/packages/Ims/src/com/mediatek/ims/internal/TimerDispatcher.java b/packages/Ims/src/com/mediatek/ims/internal/TimerDispatcher.java
new file mode 100644
index 0000000..cb72c3a
--- /dev/null
+++ b/packages/Ims/src/com/mediatek/ims/internal/TimerDispatcher.java
@@ -0,0 +1,166 @@
+    package com.mediatek.ims.internal;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+
+import android.os.SystemClock;
+import android.os.Bundle;
+import android.app.AlarmManager;
+import android.app.PendingIntent;
+
+import android.util.Log;
+
+import com.mediatek.ims.ImsAdapter;
+import com.mediatek.ims.ImsAdapter.VaSocketIO;
+import com.mediatek.ims.ImsAdapter.VaEvent;
+import com.mediatek.ims.ImsEventDispatcher;
+
+import static com.mediatek.ims.VaConstants.*;
+
+public class TimerDispatcher implements ImsEventDispatcher.VaEventDispatcher {
+
+    private Context mContext;
+    private VaSocketIO mSocket;
+    private static final String TAG = "Timer-IMSA";
+
+    private static final Object mLock = new Object();
+    private static ImsAdapter imsAdapt;
+
+    protected static final String INTENT_VOLTE_TIMER_ALARM = "com.android.internal.telephony.volte_timer_alarm";
+
+    public TimerDispatcher(Context context, VaSocketIO IO) {
+        mContext = context;
+        mSocket = IO;
+
+        log("TimerDispatcher()");
+
+        if (imsAdapt == null) {
+            log("ImsAdapter.getInstance");
+            imsAdapt = ImsAdapter.getInstance();
+        }
+
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(INTENT_VOLTE_TIMER_ALARM);
+        mContext.registerReceiver(mResultReceiver, filter);
+    }
+
+    public void enableRequest() {
+        log("enableRequest()");
+    }
+
+    public void disableRequest() {
+        log("disableRequest()");
+    }
+
+
+    private void sendResponse(int request_id, int timer_id, int user_data) {
+        int phone_id = ImsAdapter.Util.getDefaultVoltePhoneId();
+        VaEvent event = new ImsAdapter.VaEvent(phone_id, request_id);
+
+        // timer_id
+        event.putInt(timer_id);
+
+        // timeout
+        event.putInt(0);
+
+        // user_data
+        event.putInt(user_data);
+
+        // send the event to va
+        mSocket.writeEvent(event);
+
+        log("send event, request_id = " + request_id + ", timer_id = " + timer_id + ", user_data = " + user_data);
+    }
+
+    private final BroadcastReceiver mResultReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            if (intent.getAction() != null) {
+                if (intent.getAction().equals(INTENT_VOLTE_TIMER_ALARM)) {
+                    Bundle bundle  = intent.getExtras();
+                    if (bundle != null) {
+                        int timer_id = bundle.getInt("timer_id");
+                        int user_data = bundle.getInt("user_data");
+
+                        sendResponse(MSG_ID_NOTIFY_TIMER_EXPIRY, timer_id, user_data);
+
+                        log("timer timeout, timer_id = " + timer_id + ", user_data = " + user_data);
+
+                    } else {
+                        log("receive intent = " + intent.getAction());
+                    }
+                } else {
+                    log("receive intent = " + intent.getAction());
+                }
+            } else {
+                log("receive intent = " + intent.getAction());
+            }
+        }
+    };
+
+    public void vaEventCallback(VaEvent event) {
+
+        try {
+            int request_id;
+
+            request_id = event.getRequestID();
+            int timer_id  = event.getInt();
+            int timeout   = event.getInt();
+            int user_data = event.getInt();
+
+            // log("reqeust_id = " + request_id + ", timer_id = " + timer_id + ", user_data = " + user_data + ", timeout = " + timeout);
+            switch (request_id) {
+                case MSG_ID_REQUEST_TIMER_CREATE : {
+                    AlarmManager am = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+
+                    Bundle bundle = new Bundle();
+                    bundle.putInt("timer_id", timer_id);
+                    bundle.putInt("user_data", user_data);
+
+                    Intent intent = new Intent(INTENT_VOLTE_TIMER_ALARM);
+                    intent.putExtras(bundle);
+
+                    PendingIntent pi = PendingIntent.getBroadcast(mContext, user_data, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+                    long triggerAtTime = SystemClock.elapsedRealtime() + (timeout * 1000);
+                    am.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi);
+
+                    log("timer set, timer_id = " + timer_id + ", user_data = " + user_data + ", timeout = " + timeout + ",triggerAtTime = " + triggerAtTime);
+                    break;
+                }
+
+                case MSG_ID_REQUEST_TIMER_CANCEL : {
+                    Bundle bundle = new Bundle();
+
+                    bundle.putInt("timer_id", timer_id);
+                    bundle.putInt("user_data", user_data);
+
+                    Intent intent = new Intent(INTENT_VOLTE_TIMER_ALARM);
+                    intent.putExtras(bundle);
+
+                    PendingIntent pi = PendingIntent.getBroadcast(mContext, user_data, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+                    if (pi != null) {
+                        AlarmManager am = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+                        am.cancel(pi);
+                        // pi.cancel();
+                    }
+
+                    log("timer cancel, timer_id = " + timer_id + ", user_data = " + user_data);
+                    break;
+                }
+
+                default:
+                    log("Unknown request: " + request_id);
+                    break;
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+
+    protected void log(String s) {
+        Log.d(TAG, s);
+    }
+
+}
diff --git a/packages/WifiOffload/Android.mk b/packages/WifiOffload/Android.mk
new file mode 100644
index 0000000..b5972b8
--- /dev/null
+++ b/packages/WifiOffload/Android.mk
@@ -0,0 +1,58 @@
+LOCAL_PATH:= $(call my-dir)
+
+# interface lib
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(call all-java-files-under, lib/src)
+
+LOCAL_AIDL_INCLUDES := $(LOCAL_PATH)/lib/src
+
+# aidl
+LOCAL_SRC_FILES += \
+    lib/src/com/mediatek/wfo/IWifiOffloadService.aidl \
+    lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl
+
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := wfo-common
+
+include $(BUILD_STATIC_JAVA_LIBRARY)
+
+# JNI
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+    jni/com_mediatek_wfo_WifiOffloadService.c
+
+LOCAL_MULTILIB := both
+LOCAL_ARM_MODE := arm
+
+LOCAL_SHARED_LIBRARIES := \
+    libnativehelper \
+    libcutils \
+    liblog \
+    libutils \
+    libmal \
+    libmdfx
+
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE := libwfo_jni
+
+include $(BUILD_SHARED_LIBRARY)
+
+# apk
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_JAVA_LIBRARIES += telephony-common ims-common
+LOCAL_STATIC_JAVA_LIBRARIES += wfo-common
+
+LOCAL_MODULE_TAGS := optional
+LOCAL_PACKAGE_NAME := WfoService
+LOCAL_CERTIFICATE := platform
+LOCAL_PRIVILEGED_MODULE := true
+
+LOCAL_PROGUARD_ENABLED := disabled
+LOCAL_PROGUARD_FLAGS := $(proguard.flags)
+
+include $(BUILD_PACKAGE)
diff --git a/packages/WifiOffload/AndroidManifest.xml b/packages/WifiOffload/AndroidManifest.xml
new file mode 100644
index 0000000..13386e4
--- /dev/null
+++ b/packages/WifiOffload/AndroidManifest.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+        xmlns:androidprv="http://schemas.android.com/apk/prv/res/android"
+        package="com.mediatek.wfo.impl"
+        coreApp="true"
+        android:sharedUserId="android.uid.phone">
+
+    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
+
+    <application android:name="WfoApp"
+                 android:persistent="true">
+<!--        <uses-library android:name="wfo-common"
+                      android:required="true" /> -->
+    </application>
+</manifest>
diff --git a/packages/WifiOffload/README b/packages/WifiOffload/README
new file mode 100644
index 0000000..3599153
--- /dev/null
+++ b/packages/WifiOffload/README
@@ -0,0 +1,22 @@
+The WfoService apk is a service for communication between Java layer and MAL module to achieve
+Wifi-Offload functionality.
+
+WHAT IT DOES?
+=============
+The main tasks of WfoService are
+ - Passes user profiles such as VoLTE enabled, WifiCalling enabled and WifiCalling mode informations
+   to MAL module.
+ - Passes Wifi states such as MAC address, IP address and interface name to MAL module.
+ - Provides API to get ran type from MAL.
+ - Provides listener registration to receive handover events.
+
+HOW IT WAS BUILT?
+==================
+WfoService apk is built from MTK internal build process if ePDG feature is enable.
+
+HOW TO USE IT?
+==============
+It's a persist apk. It will be launched by AMS and add WifiOffloadService when application is
+created. Client can get WifiOffloadService by
+ServiceManager.getService(WifiOffloadManager.WFO_SERVICE),and use it by interfaces defined in
+wfo-common library.
diff --git a/packages/WifiOffload/jni/com_mediatek_wfo_WifiOffloadService.c b/packages/WifiOffload/jni/com_mediatek_wfo_WifiOffloadService.c
new file mode 100644
index 0000000..b858dfb
--- /dev/null
+++ b/packages/WifiOffload/jni/com_mediatek_wfo_WifiOffloadService.c
@@ -0,0 +1,283 @@
+#include <jni.h>
+#include <JNIHelp.h>
+#include <utils/Log.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <mal.h>
+#include <entity/rds/rds_if.h>
+
+#define LOG_TAG "WifiOffloadService"
+#define LOG_NDEBUG 0
+
+JavaVM* g_vm = 0;
+jobject g_obj = 0;
+
+void *g_conn_ptr = NULL;
+
+/**
+ * Define the values of handover stages.
+ */
+int HANDOVER_START = 0;
+int HANDOVER_END = 1;
+int HANDOVER_FAILED = -1;
+
+int handover_callback(rds_ho_status_t *status)
+{
+    JNIEnv *env = 0;
+    if (g_vm == NULL)
+    {
+        ALOGE("[handover_callback] NULL JVM");
+        return 0;
+    }
+    if ((*g_vm)->AttachCurrentThread(g_vm, &env, NULL) != JNI_OK)
+    {
+        ALOGE("[handover_callback] AttachCurrentThread failure");
+        return 0;
+    }
+    jclass clazz = (*env)->GetObjectClass(env, g_obj);
+    if (clazz == NULL)
+    {
+        ALOGD("handover_callback() clazz is NULL");
+        return 0;
+    }
+    jmethodID mid = (*env)->GetMethodID(env, clazz, "onHandover", "(II)V");
+    if (mid != NULL)
+    {
+        int stage = -1;
+        if (status->fgho_result == 0) {
+            // HANDOVER_FAILED
+            (*env)->CallVoidMethod(env, g_obj, mid, HANDOVER_FAILED, status->etarget_ran_type);
+        } else {
+            // HANDOVER_START(0) or HANDOVER_END(1)
+            (*env)->CallVoidMethod(env, g_obj, mid, status->ucho_status, status->etarget_ran_type);
+        }
+    }
+    (*g_vm)->DetachCurrentThread(g_vm);
+    return 0;
+}
+
+int roveout_callback(rds_rvout_alert_t *pralert)
+{
+    JNIEnv *env = 0;
+    if (g_vm == NULL)
+    {
+        ALOGE("[roveout_callback] NULL JVM");
+        return 0;
+    }
+    if ((*g_vm)->AttachCurrentThread(g_vm, &env, NULL) != JNI_OK)
+    {
+        ALOGE("[roveout_callback] AttachCurrentThread failure");
+        return 0;
+    }
+    jclass clazz = (*env)->GetObjectClass(env, g_obj);
+    if (clazz == NULL)
+    {
+        ALOGD("roveout_callback() clazz is NULL");
+        return 0;
+    }
+    jmethodID mid = (*env)->GetMethodID(env, clazz, "onRoveOut", "(ZI)V");
+    if (mid != NULL)
+    {
+        (*env)->CallVoidMethod(env, g_obj, mid, pralert->rvalert_en, pralert->i4wifirssi);
+    }
+    (*g_vm)->DetachCurrentThread(g_vm);
+    return 0;
+}
+
+int pdnStateChanged_callback(rds_wifi_pdnact_t *pralert)
+{
+    JNIEnv *env = 0;
+    if (g_vm == NULL)
+    {
+        ALOGE("[roveout_callback] NULL JVM");
+        return 0;
+    }
+    if ((*g_vm)->AttachCurrentThread(g_vm, &env, NULL) != JNI_OK)
+    {
+        ALOGE("[roveout_callback] AttachCurrentThread failure");
+        return 0;
+    }
+    jclass clazz = (*env)->GetObjectClass(env, g_obj);
+    if (clazz == NULL)
+    {
+        ALOGD("roveout_callback() clazz is NULL");
+        return 0;
+    }
+    jmethodID mid = (*env)->GetMethodID(env, clazz, "onPdnStateChanged", "(Z)V");
+    if (mid != NULL)
+    {
+        (*env)->CallVoidMethod(env, g_obj, mid, pralert->pdn_rdy);
+    }
+    (*g_vm)->DetachCurrentThread(g_vm);
+    return 0;
+}
+
+void init(JNIEnv *env, jobject obj)
+{
+    (*env)->GetJavaVM(env, &g_vm);
+    g_obj = (*env)->NewGlobalRef(env, obj);
+    // rds_get_verno();
+    rds_notify_funp_t rds_fp = {0};
+    rds_fp.pfrds_ho_status_ind = handover_callback;
+    rds_fp.pfrds_rvout_alert_ind = roveout_callback;
+    rds_fp.pfrds_wifi_pdnact_ind = pdnStateChanged_callback;
+    g_conn_ptr = epdgs_rds_conn_init(&rds_fp);
+}
+
+jint get_rat_type(JNIEnv *env, jobject obj)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("get_rat_type conn_ptr is NULL");
+        return RDS_RAN_UNSPEC;
+    }
+    rds_rb_get_demand_req_t req;
+    // TODO: set req.u4pdn_id
+    rds_rb_get_ran_type_rsp_t rsp = {.i4rds_ret = RDS_FALSE, .u4ran_type = RDS_RAN_UNSPEC};
+    rds_get_ran_type(&req, &rsp, g_conn_ptr);
+    return rsp.u4ran_type;
+}
+
+jobject get_disconnect_cause(JNIEnv *env, jobject obj)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("get_disconnect_cause conn_ptr is NULL");
+        return NULL;
+    }
+    rds_rb_get_demand_req_t req;
+    // TODO: set req.u4pdn_id
+    rds_rb_get_last_err_rsp_t rsp = {.i4rds_ret = RDS_FALSE, .i4lasterr = 0, .i4lastsuberr = 0};
+    rds_get_last_err(&req, &rsp, g_conn_ptr);
+    // new DisconnectCause object
+    jclass clazz = (*env)->FindClass(env, "com/mediatek/wfo/DisconnectCause");
+    if (clazz == NULL)
+    {
+        ALOGE("get_disconnect_cause FindClass return NULL");
+        return NULL;
+    }
+    jmethodID ctor = (*env)->GetMethodID(env, clazz, "<init>", "(II)V");
+    if (ctor == NULL)
+    {
+        ALOGE("get_disconnect_cause GetMethodID return NULL");
+        return NULL;
+    }
+    return (*env)->NewObject(env, clazz, ctor, rsp.i4lasterr, rsp.i4lastsuberr);
+}
+
+void set_wos_profile(JNIEnv *env, jobject obj, jboolean volte_enabled, jboolean wfc_enabled, jstring fqdn,
+        jboolean wifi_enabled, jint wifi_mode, jint dataRoaming_enabled)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("get_rat_type conn_ptr is NULL");
+        return;
+    }
+    rds_ru_set_uiparam_req_t req = {
+        .fgimsolte_en = volte_enabled,
+        .fgwfc_en = wfc_enabled,
+        .omacp_fqdn = {0},
+        .fgwifiui_en = wifi_enabled,
+        .rdspolicy = wifi_mode,
+        .fgdata_roaming_ui_en = dataRoaming_enabled
+    };
+    const char *pcFqdn = (*env)->GetStringUTFChars(env, fqdn, 0);
+    strncpy(req.omacp_fqdn, pcFqdn, RDS_FQDN_LEN - 1);
+    ALOGD("set_wos_profile wfc_enabled is %d, req.omacp_fqdn is %s\n", req.fgwfc_en, req.omacp_fqdn);
+    rds_set_ui_param(&req, g_conn_ptr);
+    (*env)->ReleaseStringUTFChars(env, fqdn, pcFqdn);
+}
+
+void set_wifi_state(JNIEnv *env, jobject obj, jboolean wifi_connected, jstring if_name, jstring ipv4, jstring ipv6, jstring mac)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("set_wifi_state conn_ptr is NULL");
+        return;
+    }
+    rds_ru_set_wifistat_req_t req = {
+        .fgwifi_en = wifi_connected,
+        .szwifi_ifname = {0},
+        .szwifi_ipv4addr = {0},
+        .szwifi_ipv6addr = {0},
+        .szwifi_macaddr = {0}
+    };
+
+    const char *pcIfName = (*env)->GetStringUTFChars(env, if_name, 0);
+    const char *pcIpv4 = (*env)->GetStringUTFChars(env, ipv4, 0);
+    const char *pcIpv6 = (*env)->GetStringUTFChars(env, ipv6, 0);
+    const char *pcMac = (*env)->GetStringUTFChars(env, mac, 0);
+    strncpy(req.szwifi_ifname, pcIfName, RDS_STR_LEN - 1);
+    strncpy(req.szwifi_ipv4addr, pcIpv4, 2 * RDS_STR_LEN - 1);
+    strncpy(req.szwifi_ipv6addr, pcIpv6, 2 * RDS_STR_LEN - 1);
+    strncpy(req.szwifi_macaddr, pcMac, 2 * RDS_STR_LEN - 1);
+    ALOGD("set_wifi_state req.szwifi_ifname is %s\n", req.szwifi_ifname);
+    ALOGD("set_wifi_state req.szwifi_ipv4addr is %s\n", req.szwifi_ipv4addr);
+    ALOGD("set_wifi_state req.szwifi_ipv6addr is %s\n", req.szwifi_ipv6addr);
+    ALOGD("set_wifi_state req.szwifi_macaddr is %s\n", req.szwifi_macaddr);
+    rds_set_wifistat(&req, g_conn_ptr);
+    (*env)->ReleaseStringUTFChars(env, if_name, pcIfName);
+    (*env)->ReleaseStringUTFChars(env, ipv4, pcIpv4);
+    (*env)->ReleaseStringUTFChars(env, ipv6, pcIpv6);
+    (*env)->ReleaseStringUTFChars(env, mac, pcMac);
+}
+
+void set_call_state(JNIEnv *env, jobject obj, jboolean in_call, jint call_type)
+{
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("set_call_state conn_ptr is NULL");
+        return;
+    }
+    ALOGD("set_call_state: In call is %d, call type is %d\n", in_call, call_type);
+    rds_ru_set_callstat_req_t req = {
+        .in_call = in_call,
+        .call_type = call_type
+    };
+    rds_set_callstat(&req, g_conn_ptr);
+}
+
+void setServiceState(JNIEnv *env, jobject obj,
+        jint mdIdx, jint simIdx, jboolean isDataRoaming, jint ratType, jint serviceState) {
+    if (g_conn_ptr == NULL)
+    {
+        ALOGE("set_call_state conn_ptr is NULL");
+        return;
+    }
+    ALOGD("set_service_state: isDataRoaming is %d, ratType is %d, serviceState is %d\n",
+            isDataRoaming, ratType, serviceState);
+
+    rds_ru_set_mdstat_req_t req = {
+        .md_idx = mdIdx,
+        .sim_idx = simIdx,
+        .fgisroaming = isDataRoaming,
+        .md_rat = ratType,
+        .srv_state = serviceState
+    };
+    rds_set_mdstat(&req, g_conn_ptr);
+}
+
+static JNINativeMethod method_table[] = {
+    { "nativeInit", "()V", (void *)init },
+    { "nativeGetRatType", "()I", (void *)get_rat_type },
+    { "nativeGetDisconnectCause", "()Lcom/mediatek/wfo/DisconnectCause;", (void *)get_disconnect_cause },
+    { "nativeSetWosProfile", "(ZZLjava/lang/String;ZII)V", (void *)set_wos_profile },
+    { "nativeSetWifiStatus", "(ZLjava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", (void *)set_wifi_state },
+    { "nativeSetCallState", "(ZI)V", (void *)set_call_state },
+    { "nativeSetServiceState", "(IIZII)V", (void *)setServiceState }
+};
+
+jint JNI_OnLoad(JavaVM* vm, void* reserved)
+{
+    JNIEnv* env;
+    if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_4) != JNI_OK) {
+        return JNI_FALSE;
+    }
+
+    jniRegisterNativeMethods(env, "com/mediatek/wfo/impl/WifiOffloadService",
+            method_table, NELEM(method_table));
+
+    return JNI_VERSION_1_4;
+}
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.aidl b/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.aidl
new file mode 100644
index 0000000..a1e3c4f
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.aidl
@@ -0,0 +1,6 @@
+/**
+ * {@hide}
+ */
+package com.mediatek.wfo;
+
+parcelable DisconnectCause;
\ No newline at end of file
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.java b/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.java
new file mode 100644
index 0000000..980e8bd
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/DisconnectCause.java
@@ -0,0 +1,50 @@
+package com.mediatek.wfo;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class DisconnectCause implements Parcelable {
+    private int errorCause;
+    private int subErrorCause;
+
+    public DisconnectCause(int error, int subError) {
+        errorCause = error;
+        subErrorCause = subError;
+    }
+
+    public int getErrorCause() {
+        return errorCause;
+    }
+
+    public int getSubErrorCause() {
+        return subErrorCause;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(errorCause);
+        dest.writeInt(subErrorCause);
+    }
+
+    public static final Creator<DisconnectCause> CREATOR = new Creator<DisconnectCause>() {
+        public DisconnectCause createFromParcel(Parcel source) {
+            int error = source.readInt();
+            int subError = source.readInt();
+            return new DisconnectCause(error, subError);
+        }
+
+        public DisconnectCause[] newArray(int size) {
+            return new DisconnectCause[size];
+        }
+    };
+
+    public String toString() {
+        return "DisconnectCause {errorCause=" + errorCause + ", subErrorCause=" + subErrorCause
+                + "}";
+    }
+}
\ No newline at end of file
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl b/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl
new file mode 100644
index 0000000..1fc0e31
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadListener.aidl
@@ -0,0 +1,9 @@
+/**
+ * {@hide}
+ */
+package com.mediatek.wfo;
+
+interface IWifiOffloadListener {
+    void onHandover(in int stage, in int ratType);
+    void onRoveOut(in boolean roveOut, in int rssi);
+}
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadService.aidl b/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadService.aidl
new file mode 100644
index 0000000..fd55bbd
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/IWifiOffloadService.aidl
@@ -0,0 +1,15 @@
+/**
+ * {@hide}
+ */
+package com.mediatek.wfo;
+
+import com.mediatek.wfo.IWifiOffloadListener;
+import com.mediatek.wfo.DisconnectCause;
+
+interface IWifiOffloadService {
+    void registerForHandoverEvent(in IWifiOffloadListener listener);
+    void unregisterForHandoverEvent(in IWifiOffloadListener listener);
+    int getRatType();
+    DisconnectCause getDisconnectCause();
+    void setEpdgFqdn(in String fqdn, in boolean wfcEnabled);
+}
\ No newline at end of file
diff --git a/packages/WifiOffload/lib/src/com/mediatek/wfo/WifiOffloadManager.java b/packages/WifiOffload/lib/src/com/mediatek/wfo/WifiOffloadManager.java
new file mode 100644
index 0000000..34082e9
--- /dev/null
+++ b/packages/WifiOffload/lib/src/com/mediatek/wfo/WifiOffloadManager.java
@@ -0,0 +1,43 @@
+package com.mediatek.wfo;
+
+public class WifiOffloadManager {
+    /**
+     * For accessing the WifiOffload related service.
+     * Internal use only.
+     */
+    public static final String WFO_SERVICE = "wfo";
+
+    public static final String ACTION_NOTIFY_CONNECTION_ERROR =
+            "android.intent.action.NOTIFY_CONNECTION_ERROR";
+
+    public static final String EXTRA_ERROR_CODE = "error_code";
+
+    /**
+     * Alert need to send when user moves out of Wifi area
+     * and no LTE is available to camp on
+     */
+    public static final String ACTION_ROVE_OUT_ALERT = "android.intent.action.ROVE_OUT_ALERT";
+
+    public static final int RAN_TYPE_UNSPEC = 0;
+    public static final int RAN_TYPE_MOBILE_3GPP = 1;
+    public static final int RAN_TYPE_WIFI = 2;
+    public static final int RAN_TYPE_MOBILE_3GPP2 = 3;
+    // deny by PS
+    public static final int RAN_TYPE_NONE = -2;
+    // deny by RDS
+    public static final int RAN_TYPE_DENY = -1;
+
+    public static final int HANDOVER_START = 0;
+    public static final int HANDOVER_END = 1;
+    public static final int HANDOVER_FAILED = -1;
+
+    /**
+     * Listener interface for WifiOffload events.
+     */
+    public abstract static class Listener extends IWifiOffloadListener.Stub {
+        @Override
+        public void onHandover(int stage, int ratType) {};
+        @Override
+        public void onRoveOut(boolean roveOut, int rssi) {};
+    }
+}
diff --git a/packages/WifiOffload/proguard.flags b/packages/WifiOffload/proguard.flags
new file mode 100644
index 0000000..e69de29
diff --git a/packages/WifiOffload/src/com/mediatek/wfo/impl/WfoApp.java b/packages/WifiOffload/src/com/mediatek/wfo/impl/WfoApp.java
new file mode 100644
index 0000000..8500bf4
--- /dev/null
+++ b/packages/WifiOffload/src/com/mediatek/wfo/impl/WfoApp.java
@@ -0,0 +1,63 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2015. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.wfo.impl;
+
+import android.app.Application;
+import android.os.ServiceManager;
+import android.os.UserHandle;
+import android.util.Log;
+
+import com.mediatek.wfo.WifiOffloadManager;
+import com.mediatek.wfo.impl.WifiOffloadService;
+
+/**
+ * Top-level Application class for the WifiOffload app.
+ */
+public class WfoApp extends Application {
+    private static final String TAG = "WfoApp";
+
+    public WfoApp() {
+    }
+
+    @Override
+    public void onCreate() {
+        if (UserHandle.myUserId() == 0) {
+            Log.d(TAG, "WfoApp new WifiOffloadService");
+            WifiOffloadService service = new WifiOffloadService(this);
+            ServiceManager.addService(WifiOffloadManager.WFO_SERVICE, service.asBinder(), true);
+        }
+    }
+}
\ No newline at end of file
diff --git a/packages/WifiOffload/src/com/mediatek/wfo/impl/WifiOffloadService.java b/packages/WifiOffload/src/com/mediatek/wfo/impl/WifiOffloadService.java
new file mode 100644
index 0000000..1873ec1
--- /dev/null
+++ b/packages/WifiOffload/src/com/mediatek/wfo/impl/WifiOffloadService.java
@@ -0,0 +1,719 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2015. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.wfo.impl;
+
+import java.net.Inet4Address;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.INetworkManagementEventObserver;
+import android.net.LinkAddress;
+import android.net.LinkProperties;
+import android.net.Network;
+import android.net.NetworkCapabilities;
+import android.net.NetworkInfo;
+import android.net.NetworkRequest;
+import android.net.Uri;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.INetworkManagementService;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.provider.Settings;
+
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.mediatek.internal.telephony.RadioCapabilitySwitchUtil;
+
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
+import com.android.server.net.BaseNetworkObserver;
+
+import com.mediatek.wfo.DisconnectCause;
+import com.mediatek.wfo.IWifiOffloadService;
+import com.mediatek.wfo.IWifiOffloadListener;
+import com.mediatek.wfo.WifiOffloadManager;
+
+public class WifiOffloadService extends IWifiOffloadService.Stub {
+    static {
+        System.loadLibrary("wfo_jni");
+    }
+
+    private native void nativeInit();
+    private native int nativeGetRatType();
+    private native DisconnectCause nativeGetDisconnectCause();
+    private native void nativeSetWosProfile(boolean volteEnabled, boolean wfcEnabled,
+            String fqdn, boolean wifiEnabled, int wfcMode, int dataRoaming_enabled);
+    private native void nativeSetWifiStatus(boolean wifiConnected, String ifNmae, String ipv4, String ipv6, String mac);
+    private native void nativeSetCallState(boolean inCall, int callType);
+    private native void nativeSetServiceState(
+            int mdIdx, int simIdx, boolean isDataRoaming, int ratType, int serviceState);
+
+    static final String TAG = "WifiOffloadService";
+
+    private Set<IWifiOffloadListener> mListeners = new CopyOnWriteArraySet<IWifiOffloadListener>();
+
+    private Context mContext;
+    private WifiManager mWifiManager;
+    private ConnectivityManager mConnectivityManager;
+    private INetworkManagementService mNetworkManager;
+    private SubscriptionManager mSubscriptionManager;
+    private TelephonyManager mTelephonyManager;
+
+    // from user settings
+    private boolean mIsVolteEnabled;
+    private boolean mIsWfcEnabled;
+    private int mWfcMode;
+    private boolean mIsWifiEnabled;
+
+    // for VoWiFi Provisioning utilising SMS
+    private String mFqdn = "";
+
+    // wifi state
+    private boolean mIsWifiConnected = false;
+    private String mWifiApMac = "";
+    private String mWifiIpv4Address = "";
+    private String mWifiIpv6Address = "";
+    private String mIfName ="";
+
+    // call type
+    private static final int IMSCALL_NONE = 0;
+    private static final int IMSCALL_IR92_VOICE_CALL = 1;
+    private static final int IMSCALL_IR94_VIDEO_CALL = 2;
+
+    // data roaming, service states.
+    private int mSimCount;
+    private int mDataRoamingEnabled = SubscriptionManager.DATA_ROAMING_DISABLE;
+    private boolean[] mIsCurDataRoaming;
+    private int[] mRadioTechnology;
+
+    // subId -> PhoneStateListener
+    private Map<Integer, PhoneStateListener> mPhoneServicesStateListeners
+            = new ConcurrentHashMap<Integer, PhoneStateListener>();
+
+     /**
+     * @see ServiceState
+     * STATE_IN_SERVICE, STATE_OUT_OF_SERVICE, STATE_EMERGENCY_ONLY, STATE_POWER_OFF
+     */
+    private int[] mDataRegState;
+
+    private WifiManager.WifiLock mWifiLock;
+
+    private SettingsObserver mSettingsObserver = new SettingsObserver(null);
+
+    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Log.d(TAG, "onReceive action:" + intent.getAction());
+            if (intent.getAction().equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
+                if (mWifiManager == null) {
+                    Log.d(TAG, "Unexpected error, mWifiManager is null!");
+                    return;
+                }
+
+                boolean isWifiEnabled = mWifiManager.isWifiEnabled();
+                if (isWifiEnabled != mIsWifiEnabled) {
+                    mIsWifiEnabled = isWifiEnabled;
+                    notifyMalUserProfile();
+                }
+            } else if (intent.getAction().equals(
+                    PhoneConstants.ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED)) {
+                int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY,
+                        RILConstants.NO_PHONE);
+                if (phoneType != RILConstants.IMS_PHONE) {
+                    Log.d(TAG, "not IMS phone");
+                    return;
+                }
+                boolean inCall = false;
+                int callType = IMSCALL_NONE;
+                String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+                if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                        || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                    inCall = true;
+                    // TODO: detect voice or video call if MAL needs it
+                    callType = IMSCALL_IR92_VOICE_CALL;
+                }
+                notifyCallState(inCall, callType);
+            }
+        }
+    };
+
+    private INetworkManagementEventObserver mNetworkObserver = new BaseNetworkObserver() {
+        @Override
+        public void addressUpdated(String iface, LinkAddress address) {
+            Log.d(TAG, "mNetworkObserver.addressUpdated: iface=" + iface
+                    + ", address = " + address);
+            if (iface != null && iface.startsWith("wlan")
+                    && address != null && address.getAddress() instanceof Inet6Address
+                    && address.isGlobalPreferred()) {
+                // At this timing, just refresh IPV6 address without changing 'mIsWifiConnected'.
+                // mIsWifiConnected depends on ConnectivityManager.NetworkCallback.onAvailable.
+                Message msg = mHandler.obtainMessage(
+                        EVENT_WIFI_NETWORK_STATE_CHANGE,
+                        mIsWifiConnected?1:0,  // isConnected
+                        0, null);
+                mHandler.sendMessage(msg);
+            }
+        }
+    };
+
+    private class SettingsObserver extends ContentObserver {
+        private final Uri VOLTE_ENABLED_URI = Settings.Global
+                .getUriFor(android.provider.Settings.Global.ENHANCED_4G_MODE_ENABLED);
+        private final Uri WFC_ENABLED_URI = Settings.Global
+                .getUriFor(android.provider.Settings.Global.WFC_IMS_ENABLED);
+        private final Uri WFC_MODE_URI = Settings.Global
+                .getUriFor(android.provider.Settings.Global.WFC_IMS_MODE);
+
+        public SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        private void register() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(VOLTE_ENABLED_URI, false, this);
+            resolver.registerContentObserver(WFC_ENABLED_URI, false, this);
+            resolver.registerContentObserver(WFC_MODE_URI, false, this);
+        }
+
+        private void unregister() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.unregisterContentObserver(this);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            onChange(selfChange, null);
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            if (VOLTE_ENABLED_URI.equals(uri)) {
+                mIsVolteEnabled = ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mContext);
+            }
+            if (WFC_ENABLED_URI.equals(uri)) {
+                mIsWfcEnabled = ImsManager.isWfcEnabledByUser(mContext);
+            }
+            if (WFC_MODE_URI.equals(uri)) {
+                mWfcMode = ImsManager.getWfcMode(mContext);
+            }
+            notifyMalUserProfile();
+        }
+    }
+
+    private SubscriptionManager.OnSubscriptionsChangedListener mSubscriptionsChangedlistener =
+            new SubscriptionManager.OnSubscriptionsChangedListener() {
+
+            @Override
+            public void onSubscriptionsChanged() {
+                mHandler.sendMessage(mHandler.obtainMessage(EVENT_SUBSCRIPTION_INFO_CHANGED));
+           }
+    };
+
+    // Message codes. See mHandler below.
+    private static final int EVENT_WIFI_NETWORK_STATE_CHANGE = 1;
+    private static final int EVENT_SUBSCRIPTION_INFO_CHANGED = 2;
+    private static final int EVENT_NOTIFY_SERVICE_STATE_CHANGE = 3;
+
+    private Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case EVENT_WIFI_NETWORK_STATE_CHANGE:
+                    updateWifiConnectedInfo(msg.arg1);
+                    break;
+                case EVENT_SUBSCRIPTION_INFO_CHANGED:
+                    updateServiceStateListeners();
+                    updateDataRoamingSetting();
+                    break;
+                case EVENT_NOTIFY_SERVICE_STATE_CHANGE:
+                    updateServiceState(msg.arg1, (ServiceState)msg.obj);
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+
+    public WifiOffloadService(Context context) {
+        nativeInit();
+        mContext = context;
+        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        mConnectivityManager = ConnectivityManager.from(mContext);
+        IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
+        mNetworkManager = INetworkManagementService.Stub.asInterface(b);
+
+        mSubscriptionManager = SubscriptionManager.from(mContext);
+        mSubscriptionManager.addOnSubscriptionsChangedListener(mSubscriptionsChangedlistener);
+
+        mTelephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+
+        mIsVolteEnabled = ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mContext);
+        mIsWfcEnabled = ImsManager.isWfcEnabledByUser(mContext);
+        mWfcMode = ImsManager.getWfcMode(mContext);
+        mIsWifiEnabled = mWifiManager.isWifiEnabled();
+        mDataRoamingEnabled = getDataRoamingSetting();
+
+        if (mTelephonyManager != null) {
+            mSimCount = mTelephonyManager.getSimCount();
+            mIsCurDataRoaming = new boolean[mSimCount];
+            mRadioTechnology = new int[mSimCount];
+            mDataRegState = new int[mSimCount];
+        }
+
+        if (mWifiManager != null) {
+            mWifiLock = mWifiManager.createWifiLock("WifiOffloadService-Wifi Lock");
+            if (mWifiLock != null) {
+                mWifiLock.setReferenceCounted(false);
+            }
+        }
+
+        // force update user profile to MAL at first time.
+        notifyMalUserProfile();
+
+        mSettingsObserver.register();
+        registerForBroadcast();
+        setupCallbacksForWifiStatus();
+        updateServiceStateListeners();
+        Log.d(TAG, "Initialize finish");
+    }
+
+    private void updateServiceStateListeners() {
+        if (mSubscriptionManager == null) {
+            Log.d(TAG, "Unexpected error, mSubscriptionManager=null");
+            return;
+        }
+        if (mTelephonyManager == null) {
+            Log.d(TAG, "Unexpected error, mTelephonyManager=null");
+            return;
+        }
+
+        HashSet<Integer> unUsedSubscriptions =
+                new HashSet<Integer>(mPhoneServicesStateListeners.keySet());
+        final List<SubscriptionInfo> slist = mSubscriptionManager.getActiveSubscriptionInfoList();
+
+        if (slist != null) {
+            for (SubscriptionInfo subInfoRecord : slist) {
+                int subId = subInfoRecord.getSubscriptionId();
+                if (mPhoneServicesStateListeners.get(subId) == null) {
+                    // Create listeners for new subscriptions.
+                    Log.d(TAG, "create ServicesStateListener for " + subId);
+                    PhoneStateListener listener = new PhoneStateListener(subId) {
+                            @Override
+                            public void onServiceStateChanged(ServiceState serviceState) {
+                                if (serviceState == null) {
+                                    Log.d(TAG, "onServiceStateChanged-" + this.mSubId
+                                            + ": serviceState is null");
+                                    return;
+                                }
+                                mHandler.sendMessage(
+                                mHandler.obtainMessage(EVENT_NOTIFY_SERVICE_STATE_CHANGE,
+                                        this.mSubId, 0, serviceState));
+                            }
+                    };
+
+                    mTelephonyManager.listen(
+                            listener, PhoneStateListener.LISTEN_SERVICE_STATE);
+                    mPhoneServicesStateListeners.put(subId, listener);
+                } else {
+                    // this is still a valid subscription.
+                    Log.d(TAG, "ServicesStateListener-" + subId + " is used.");
+                    unUsedSubscriptions.remove(subId);
+                }
+            }
+        }
+
+        for (Integer key: unUsedSubscriptions) {
+            Log.d(TAG, "remove unused ServicesStateListener for " + key);
+            mTelephonyManager.listen(mPhoneServicesStateListeners.get(key), 0);
+            mPhoneServicesStateListeners.remove(key);
+        }
+    }
+
+    @Override
+    public void registerForHandoverEvent(IWifiOffloadListener listener) {
+        mListeners.add(listener);
+    }
+
+    @Override
+    public void unregisterForHandoverEvent(IWifiOffloadListener listener) {
+        mListeners.remove(listener);
+    }
+
+    @Override
+    public int getRatType() {
+        int result = nativeGetRatType();
+        Log.d(TAG, "rat type is " + result);
+        return result;
+    }
+
+    @Override
+    public DisconnectCause getDisconnectCause() {
+        DisconnectCause result = nativeGetDisconnectCause();
+        Log.d(TAG, "disconnect cause is " + result);
+        return result;
+    }
+
+    @Override
+    public void setEpdgFqdn(String fqdn, boolean wfcEnabled) {
+        if (fqdn == null) {
+            Log.d(TAG, "fqdn is null");
+            return;
+        }
+        mFqdn = fqdn;
+        mIsWfcEnabled = wfcEnabled;
+        notifyMalUserProfile();
+    }
+
+    private void registerForBroadcast() {
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(PhoneConstants.ACTION_SUBSCRIPTION_PHONE_STATE_CHANGED);
+        mContext.registerReceiver(mReceiver, filter);
+    }
+
+    private void updateWifiConnectedInfo(int isConnected) {
+        Log.d(TAG, "updateWifiConnectedInfo isConnected=" + isConnected);
+
+        boolean changed = false;
+
+        if (isConnected == 0) {
+            if (mIsWifiConnected) {
+                mIsWifiConnected = false;
+                mWifiApMac = "";
+                mWifiIpv4Address = "";
+                mWifiIpv6Address = "";
+                mIfName ="";
+                changed = true;
+            }
+        } else {
+            String wifiApMac = "", ipv4Address = "", ipv6Address = "", ifName = "";
+
+            if (!mIsWifiConnected) {
+                mIsWifiConnected = true;
+                changed = true;
+            }
+
+            // get MAC address of the current access point
+            WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
+            if (wifiInfo != null) {
+                wifiApMac = wifiInfo.getBSSID();
+                if (!mWifiApMac.equals(wifiApMac)) {
+                    mWifiApMac = (wifiApMac == null ? "" : wifiApMac);
+                    changed = true;
+                }
+            }
+
+            // get ip
+            for (Network nw : mConnectivityManager.getAllNetworks()) {
+                LinkProperties prop = mConnectivityManager.getLinkProperties(nw);
+                // MAL only care about wlan
+                if (prop == null || prop.getInterfaceName() == null
+                        || !prop.getInterfaceName().startsWith("wlan")) {
+                    continue;
+                }
+                for (InetAddress address : prop.getAddresses()) {
+                    if (address instanceof Inet4Address) {
+                        ipv4Address = address.getHostAddress();
+                    } else if (address instanceof Inet6Address && !address.isLinkLocalAddress()) {
+                        // Filters out link-local address. If cannot find non-link-local address,
+                        // pass empty string to MAL.
+                        ipv6Address = address.getHostAddress();
+                    }
+                }
+                // get interface name
+                ifName = prop.getInterfaceName();
+            }
+            if (!mWifiIpv4Address.equals(ipv4Address)) {
+                mWifiIpv4Address = (ipv4Address == null ? "" : ipv4Address);
+                changed = true;
+            }
+            if (!mWifiIpv6Address.equals(ipv6Address)) {
+                mWifiIpv6Address = (ipv6Address == null ? "" : ipv6Address);
+                changed = true;
+            }
+            if (!mIfName.equals(ifName)) {
+                mIfName = (ifName == null ? "" : ifName);
+                changed = true;
+            }
+        }
+
+        if (changed) {
+            notifyMalWifiState();
+        }
+    }
+
+    // Currently it only care about MD1's data roaming setting.
+    private int getDataRoamingSetting() {
+        if (mSubscriptionManager == null) {
+            Log.d(TAG, "Unexpected error, mSubscriptionManager=null");
+            return SubscriptionManager.DATA_ROAMING_DISABLE;
+        }
+
+        int mainCapabilityPhoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(
+                mainCapabilityPhoneId);
+        Log.d(TAG, "getDataRoamingSetting: mainCapabilityPhoneId=" + mainCapabilityPhoneId
+                + " , subInfo=" + subInfo);
+
+        if (subInfo != null) {
+            return subInfo.getDataRoaming();
+        } else {
+            Log.d(TAG, "Cannot get subscription information for slot:" + mainCapabilityPhoneId);
+            return SubscriptionManager.DATA_ROAMING_DISABLE;
+        }
+    }
+
+    private void updateDataRoamingSetting() {
+        int isDataRoamingEnabled = getDataRoamingSetting();
+        if (isDataRoamingEnabled != mDataRoamingEnabled) {
+            mDataRoamingEnabled = isDataRoamingEnabled;
+            notifyMalUserProfile();
+        }
+    }
+
+    private void updateServiceState(int subId, ServiceState state) {
+        boolean isDataRoaming = state.getDataRoaming();
+        int radioTechnology = state.getRilDataRadioTechnology();
+        int dataRegState = state.getDataRegState();
+
+        if (radioTechnology == ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
+            dataRegState = ServiceState.STATE_OUT_OF_SERVICE;
+        }
+
+        int simId = SubscriptionManager.getPhoneId(subId);
+        int mainCapabilityPhoneId = RadioCapabilitySwitchUtil.getMainCapabilityPhoneId();
+        int mdIdx = mainCapabilityPhoneId==simId?0:1;
+
+        if (simId < 0 || simId >= mSimCount) {
+            Log.d(TAG, "updateServiceState: sim-" + simId + " sub-" + subId
+                    + ": invalid simId");
+            return;
+        }
+
+        Log.d(TAG, "updateServiceState: sim-" + simId + " sub-" + subId
+                + ", isDataRoaming=" + isDataRoaming
+                + ", radioTechnology=" + radioTechnology
+                + ", dataRegState=" + dataRegState);
+
+        if (mIsCurDataRoaming[simId] != isDataRoaming
+                || mRadioTechnology[simId] != radioTechnology
+                || mDataRegState[simId] != dataRegState) {
+            mIsCurDataRoaming[simId] = isDataRoaming;
+            mRadioTechnology[simId] = radioTechnology;
+            mDataRegState[simId] = dataRegState;
+            notifyMalServiceState(simId, subId);
+        }
+    }
+
+    private void notifyMalUserProfile() {
+        Log.d(TAG, "notifyMalUserProfile mIsVolteEnabled: " + mIsVolteEnabled + " mIsWfcEnabled: "
+                + mIsWfcEnabled + " mFqdn: " + mFqdn + " mIsWifiEnabled: " + mIsWifiEnabled
+                + " mWfcMode: " + mWfcMode + " mDataRoamingEnabled: " + mDataRoamingEnabled);
+        nativeSetWosProfile(mIsVolteEnabled, mIsWfcEnabled, mFqdn,
+                mIsWifiEnabled, mWfcMode, mDataRoamingEnabled);
+    }
+
+    private void notifyMalWifiState() {
+        Log.d(TAG, "notifyMalWifiState mIsWifiConnected: " + mIsWifiConnected + " mIfaceName: "
+                + mIfName + " mWifiIpv4Address: " + mWifiIpv4Address + " mWifiIpv6Address: "
+                + mWifiIpv6Address + " mWifiApMac: " + mWifiApMac);
+        nativeSetWifiStatus(mIsWifiConnected, mIfName, mWifiIpv4Address, mWifiIpv6Address,
+                mWifiApMac);
+    }
+
+    private void notifyCallState(boolean inCall, int callType) {
+        Log.d(TAG, "notifyCallState inCall: " + inCall + " callType: " + callType);
+        nativeSetCallState(inCall, callType);
+    }
+
+    private void notifyMalServiceState(int simIdx, int mdIdx) {
+        Log.d(TAG, "nativeSetServiceState simIdx: " + simIdx
+                + "mdIdx: " + mdIdx
+                + "mIsCurDataRoaming: " + mIsCurDataRoaming[simIdx]
+                + ", mRadioTechnology: " + mRadioTechnology[simIdx]
+                + ", mDataRegState: " + mDataRegState[simIdx]);
+        nativeSetServiceState(mdIdx, simIdx, mIsCurDataRoaming[simIdx],
+                mRadioTechnology[simIdx], mDataRegState[simIdx]);
+    }
+
+    /**
+     * callback from MAL when IMS PDN handover.
+     * @param stage handover start/end
+     * @param ratType current rat type
+     */
+    private void onHandover(int stage, int ratType) {
+        for (IWifiOffloadListener listener : mListeners) {
+            if (listener != null) {
+                try {
+                    listener.onHandover(stage, ratType);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onHandover: RemoteException occurs!");
+                }
+            }
+        }
+    }
+
+    /**
+     * callback from MAL when rove out condition meets.
+     * @param roveOut is rove out or not
+     * @param rssi current WiFi rssi
+     */
+    private void onRoveOut(boolean roveOut, int rssi) {
+        Log.d(TAG, "onRoveOut: roveOut is " + roveOut + " rssi " + rssi);
+        for (IWifiOffloadListener listener : mListeners) {
+            if (listener != null) {
+                try {
+                    listener.onRoveOut(roveOut, rssi);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onRoveOut: RemoteException occurs!");
+                }
+            }
+        }
+    }
+
+    /**
+     * callback from MAL when IMS PDN is lost
+     */
+    private void onLost() {
+        // TODO: broadcast
+    }
+
+    /**
+     * callback from MAL when IMS PDN is unavailable
+     */
+    private void onUnavailable() {
+        // TODO: broadcast
+    }
+
+    /**
+     * callback from MAL when PDN over ePDG is active.
+     * @param active is PDN over ePDG active or in-active.
+     */
+    private void onPdnStateChanged(boolean active) {
+        Log.d(TAG, "onPdnStateChanged: active=" + active);
+        if (mWifiLock == null) {
+            Log.d(TAG, "Unexpected error, mWifiLock is null");
+        }
+
+        if (active) {
+            mWifiLock.acquire();
+        } else {
+            mWifiLock.release();
+        }
+    }
+
+    /**
+     * setup callbacks from ConnectivityService when WiFi is changed.
+     */
+    private void setupCallbacksForWifiStatus() {
+        if (mConnectivityManager == null) {
+            Log.d(TAG, "Unexpected error, mConnectivityManager=null");
+            return;
+        }
+
+        if (mNetworkManager == null) {
+            Log.d(TAG, "Unexpected error, mNetworkManager=null");
+            return;
+        }
+
+
+        NetworkRequest request = new NetworkRequest.Builder()
+                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
+                .build();
+        mConnectivityManager.registerNetworkCallback(request,
+                new ConnectivityManager.NetworkCallback() {
+                    /**
+                     * @param network
+                     */
+                    @Override
+                    public void onAvailable(Network network) {
+                        Log.d(TAG, "NetworkCallback.onAvailable, network=" + network);
+
+                        Message msg = mHandler.obtainMessage(
+                                EVENT_WIFI_NETWORK_STATE_CHANGE,
+                                1,  // isConnected
+                                0, null);
+                        mHandler.sendMessage(msg);
+                    }
+
+                    /**
+                     * @param network
+                     */
+                    @Override
+                    public void onLost(Network network) {
+                        Log.d(TAG, "NetworkCallback.onLost, network=" + network);
+
+                        Message msg = mHandler.obtainMessage(
+                                EVENT_WIFI_NETWORK_STATE_CHANGE,
+                                0,  // isConnected
+                                0, null);
+                        mHandler.sendMessage(msg);
+                    }
+                });
+
+        try {
+            mNetworkManager.registerObserver(mNetworkObserver);
+        } catch (Exception e) {
+            Log.d(TAG, "mNetworkManager.registerObserver failed: " + e);
+        }
+    }
+}
diff --git a/packages/simservs/Android.mk b/packages/simservs/Android.mk
new file mode 100644
index 0000000..573551b
--- /dev/null
+++ b/packages/simservs/Android.mk
@@ -0,0 +1,18 @@
+
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_JAVA_LIBRARIES := okhttp
+LOCAL_STATIC_JAVA_LIBRARIES := xcap
+
+# Include all the java files.
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_MODULE_TAGS := optional
+
+# The name of the jar file to create.
+LOCAL_MODULE := Simservs
+
+# Build a static jar file.
+include $(BUILD_STATIC_JAVA_LIBRARY)
+
diff --git a/packages/simservs/README b/packages/simservs/README
new file mode 100644
index 0000000..4a85f26
--- /dev/null
+++ b/packages/simservs/README
@@ -0,0 +1,23 @@
+Library of MTK IMS VoLTE Supplementary Service features, including call forwarding (communication diversion),
+call barring (communication barring), call waiting (communication waiting).
+
+This library is pre-built by MediaTek internal.
+
+
+WHAT IT DOES?
+=============
+MMTelSS module will depend on Simservs to query/update each and every VoLTE Supplementary Service.
+
+HOW IT WAS BUILT?
+==================
+It needs the following library from MediaTek:
+1.  xcap
+
+All source/dependency modules of this module are already put in
+'vendor/mediatek/proprietary/protect/external' folder.
+
+HOW TO USE IT?
+==============
+Provide api for MMTelSS to communicate with XCAP server.
+
+All the source code of this library were written by MediaTek co..
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/ActionCapabilities.java b/packages/simservs/src/com/mediatek/simservs/capability/ActionCapabilities.java
new file mode 100644
index 0000000..5681eff
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/ActionCapabilities.java
@@ -0,0 +1,134 @@
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * Action capability class.
+ */
+public class ActionCapabilities extends ServiceCapabilities implements ConfigureType {
+
+    public static final String NODE_NAME = "serv-cap-actions";
+
+    static final String TAG_TARGET = "serv-cap-target";
+    static final String TAG_NOTIFY_CALLER = "serv-cap-notify-caller";
+    static final String TAG_NOTIFY_SERVED_USER = "serv-cap-notify-served-user";
+    static final String TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL =
+            "serv-cap-notify-served-user-on-outbound-call";
+    static final String TAG_REVEAL_IDENTITY_TO_CALLER = "serv-cap-reveal-identity-to-caller";
+    static final String TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER =
+            "serv-cap-reveal-served-user-identity-to-caller";
+    static final String TAG_REVEAL_IDENTITY_TO_TARGET = "serv-cap-reveal-identity-to-target";
+
+    public boolean mNotifyCallerProvisioned = false;
+    public boolean mNotifyServedUserProvisioned = false;
+    public boolean mNotifyServedUserOnOutboundCallProvisioned = false;
+    public boolean mRevealIdentityToCallerProvisioned = false;
+    public boolean mRevealServedUserIdentityToCallerProvisioned = false;
+    public boolean mRevealIdentityToTargetProvisioned = false;
+
+    /**
+     * Constructor without XML Node.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public ActionCapabilities(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor without XML Node.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param nodes         pre-define action capability node
+     */
+    public ActionCapabilities(XcapUri xcapUri, String parentUri, String intendedId,
+            Node nodes) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(nodes);
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+
+        NodeList conditionNode = domElement.getElementsByTagName(TAG_NOTIFY_CALLER);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mNotifyCallerProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_NOTIFY_SERVED_USER);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mNotifyServedUserProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mNotifyServedUserOnOutboundCallProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_REVEAL_IDENTITY_TO_CALLER);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRevealIdentityToCallerProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRevealServedUserIdentityToCallerProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_REVEAL_IDENTITY_TO_TARGET);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRevealIdentityToTargetProvisioned = provisioned.equals(TRUE);
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    public boolean isNotifyCallerProvisioned() {
+        return mNotifyCallerProvisioned;
+    }
+
+    public boolean isNotifyServedUserProvisioned() {
+        return mNotifyServedUserProvisioned;
+    }
+
+    public boolean isNotifyServedUserOnOutboundCallProvisioned() {
+        return mNotifyServedUserOnOutboundCallProvisioned;
+    }
+
+    public boolean isRevealIdentityToCallerProvisioned() {
+        return mRevealIdentityToCallerProvisioned;
+    }
+
+    public boolean isRevealServedUserIdentityToCallerProvisioned() {
+        return mRevealServedUserIdentityToCallerProvisioned;
+    }
+
+    public boolean isRevealIdentityToTargetProvisioned() {
+        return mRevealIdentityToTargetProvisioned;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/BarringServiceCapability.java b/packages/simservs/src/com/mediatek/simservs/capability/BarringServiceCapability.java
new file mode 100644
index 0000000..1f16bb6
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/BarringServiceCapability.java
@@ -0,0 +1,56 @@
+
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Barring Service Capability class.
+ *
+ */
+public class BarringServiceCapability extends CapabilitiesType {
+
+    public static final String NODE_NAME = "communication-barring-serv-cap";
+
+    ConditionCapabilities mConditionCapabilities;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public BarringServiceCapability(XcapUri xcapUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    public ConditionCapabilities getConditionCapabilities() {
+        return mConditionCapabilities;
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList conditionsNode = domDoc.getElementsByTagName(ConditionCapabilities.NODE_NAME);
+        if (conditionsNode.getLength() > 0) {
+            Element conditionNode = (Element) conditionsNode.item(0);
+            mConditionCapabilities = new ConditionCapabilities(mXcapUri, NODE_NAME, mIntendedId,
+                    conditionNode);
+        }
+
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/CapabilitiesType.java b/packages/simservs/src/com/mediatek/simservs/capability/CapabilitiesType.java
new file mode 100644
index 0000000..c971a69
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/CapabilitiesType.java
@@ -0,0 +1,125 @@
+
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.InquireType;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+import java.io.StringReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Capability type abstract class.
+ *
+ */
+public abstract class CapabilitiesType extends InquireType {
+
+    static final String ATT_ACTIVE = "active";
+
+    public boolean mActived = false;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public CapabilitiesType(XcapUri xcapUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(xcapUri, parentUri, intendedId);
+        loadConfiguration();
+    }
+
+    /**
+     * Instantiate from server XML text.
+     *
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    private void loadConfiguration() throws XcapException, ParserConfigurationException {
+        String xmlContent = getContent();
+        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+        InputSource is = new InputSource();
+        is.setCharacterStream(new StringReader(xmlContent));
+        Document doc;
+        try {
+            doc = db.parse(is);
+        } catch (SAXException e) {
+            e.printStackTrace();
+            // Throws a server error
+            throw new XcapException(500);
+        } catch (IOException e) {
+            e.printStackTrace();
+            // Throws a server error
+            throw new XcapException(500);
+        }
+        NodeList currentNode = doc.getElementsByTagName(getNodeName());
+
+        if (currentNode.getLength() > 0) {
+            Element activeElement = (Element) currentNode.item(0);
+            NamedNodeMap map = activeElement.getAttributes();
+            if (map.getLength() > 0) {
+                for (int i = 0; i < map.getLength(); i++) {
+                    Node node = map.item(i);
+                    if (node.getNodeName().equals(ATT_ACTIVE)) {
+                        mActived = node.getNodeValue().endsWith(TRUE);
+                        break;
+                    }
+                }
+            }
+        }
+        initServiceInstance(doc);
+    }
+
+    /**
+     * Decide Active by attribute.
+     *
+     * @return active value
+     * @throws XcapException    if XCAP error
+     */
+    public boolean isActive() throws XcapException {
+        String value = getByAttrName("active");
+        if (value == null) {
+            return true;
+        } else {
+            return getByAttrName("active").equals("true");
+        }
+    }
+
+    /**
+     * Set Active.
+     *
+     * @param active           active value
+     * @throws XcapException    if XCAP error
+     */
+    public void setActive(boolean active) throws XcapException {
+        if (active) {
+            setByAttrName("active", "true");
+        } else {
+            setByAttrName("active", "false");
+        }
+    }
+
+    /**
+     * Instantiate from XML text.
+     *
+     * @param domDoc  DOM document source
+     */
+    public abstract void initServiceInstance(Document domDoc);
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/ConditionCapabilities.java b/packages/simservs/src/com/mediatek/simservs/capability/ConditionCapabilities.java
new file mode 100644
index 0000000..517074e
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/ConditionCapabilities.java
@@ -0,0 +1,227 @@
+
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * Condition Capabilities class.
+ *
+ */
+public class ConditionCapabilities extends ServiceCapabilities implements ConfigureType {
+    public static final String NODE_NAME = "serv-cap-conditions";
+
+    static final String TAG_ANONYMOUS = "serv-cap-anonymous";
+    static final String TAG_REQUEST_NAME = "serv-cap-request-name";
+    static final String TAG_COMMUNICATION_DIVERTED = "serv-cap-communication-diverted";
+    static final String TAG_EXTERNAL_LIST = "serv-cap-external-list";
+    static final String TAG_IDENTITY = "serv-cap-identity";
+    static final String TAG_INTERNATIONAL = "serv-cap-international";
+    static final String TAG_INTERNATIONAL_EXHC = "serv-cap-international-exHC";
+    static final String TAG_MEDIA = "serv-cap-media";
+    static final String TAG_OTHER_IDENTITY = "serv-cap-other-identity";
+    static final String TAG_PRESENCE_STATUS = "serv-cap-presence-status";
+    static final String TAG_ROAMING = "serv-cap-roaming";
+    static final String TAG_RULE_DEACTIVATED = "serv-cap-rule-deactivated";
+    static final String TAG_VALIDITY = "serv-cap-validity";
+    static final String TAG_BUSY = "serv-cap-busy";
+    static final String TAG_NOT_REGISTERED = "serv-cap-not-registered";
+    static final String TAG_NO_ANSWER = "serv-cap-no-answer";
+    static final String TAG_NOT_REACHABLE = "serv-cap-not-reachable";
+
+    public boolean mAnonymousProvisioned = false;
+    public boolean mRequestNameProvisioned = false;
+    public boolean mCommunicationDivertedProvisioned = false;
+    public boolean mExternalListProvisioned = false;
+    public boolean mIdentityProvisioned = false;
+    public boolean mInternationalProvisioned = false;
+    public boolean mInternationalexHCProvisioned = false;
+    public boolean mOtherIdentityProvisioned = false;
+    public boolean mPresenceStatusProvisioned = false;
+    public boolean mRoamingProvisioned = false;
+    public boolean mRuleDeactivatedProvisioned = false;
+    public boolean mValidityProvisioned = false;
+
+    MediaConditions mMediaConditions;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public ConditionCapabilities(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor with XML nodes.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param nodes         XML nodes
+     */
+    public ConditionCapabilities(XcapUri xcapUri, String parentUri, String intendedId,
+            Node nodes) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(nodes);
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+
+        NodeList conditionNode = domElement.getElementsByTagName(TAG_ANONYMOUS);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mAnonymousProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_REQUEST_NAME);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRequestNameProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_COMMUNICATION_DIVERTED);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mCommunicationDivertedProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_EXTERNAL_LIST);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mExternalListProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_IDENTITY);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mIdentityProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_INTERNATIONAL);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mInternationalProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_INTERNATIONAL_EXHC);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mInternationalexHCProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_OTHER_IDENTITY);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mOtherIdentityProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_PRESENCE_STATUS);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mPresenceStatusProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_ROAMING);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRoamingProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_RULE_DEACTIVATED);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mRuleDeactivatedProvisioned = provisioned.equals(TRUE);
+        }
+
+        conditionNode = domElement.getElementsByTagName(TAG_VALIDITY);
+        if (conditionNode.getLength() > 0) {
+            Element conditionElement = (Element) conditionNode.item(0);
+            String provisioned = conditionElement.getAttribute(ATT_PROVISIONED);
+            mValidityProvisioned = provisioned.equals(TRUE);
+        }
+
+        NodeList mediassNode = domElement.getElementsByTagName(TAG_MEDIA);
+        if (mediassNode.getLength() > 0) {
+            mMediaConditions = new MediaConditions(mXcapUri, NODE_NAME, mIntendedId,
+                    (Element) mediassNode.item(0));
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    public boolean isAnonymousProvisioned() {
+        return mAnonymousProvisioned;
+    }
+
+    public boolean isRequestNameProvisioned() {
+        return mRequestNameProvisioned;
+    }
+
+    public boolean isCommunicationDivertedProvisioned() {
+        return mCommunicationDivertedProvisioned;
+    }
+
+    public boolean isExternalListProvisioned() {
+        return mExternalListProvisioned;
+    }
+
+    public boolean isIdentityProvisioned() {
+        return mIdentityProvisioned;
+    }
+
+    public boolean isInternationalProvisioned() {
+        return mInternationalProvisioned;
+    }
+
+    public boolean isInternationalexHCProvisioned() {
+        return mInternationalexHCProvisioned;
+    }
+
+    public boolean isOtherIdentityProvisioned() {
+        return mOtherIdentityProvisioned;
+    }
+
+    public boolean isPresenceStatusProvisioned() {
+        return mPresenceStatusProvisioned;
+    }
+
+    public boolean isRoamingProvisioned() {
+        return mRoamingProvisioned;
+    }
+
+    public boolean isRuleDeactivatedProvisioned() {
+        return mRuleDeactivatedProvisioned;
+    }
+
+    public boolean isValidityProvisioned() {
+        return mValidityProvisioned;
+    }
+
+    public MediaConditions getMediaConditions() {
+        return mMediaConditions;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/DiversionServiceCapability.java b/packages/simservs/src/com/mediatek/simservs/capability/DiversionServiceCapability.java
new file mode 100644
index 0000000..f97aec8
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/DiversionServiceCapability.java
@@ -0,0 +1,76 @@
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Communication Diversion Capability class.
+ *
+ */
+public class DiversionServiceCapability extends CapabilitiesType {
+    public static final String NODE_NAME = "communication-diversion-serv-cap";
+
+    ConditionCapabilities mConditionCapabilities;
+    ActionCapabilities mActionCapabilities;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public DiversionServiceCapability(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Get available condition configuration items.
+     *
+     * @return  condition capabilities
+     */
+    public ConditionCapabilities getConditionCapabilities() {
+        return mConditionCapabilities;
+    }
+
+    /**
+     * Get available action configuration items.
+     *
+     * @return  action capabilities
+     */
+    public ActionCapabilities getActionCapabilities() {
+        return mActionCapabilities;
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList actionsNode = domDoc.getElementsByTagName(ActionCapabilities.NODE_NAME);
+        if (actionsNode.getLength() > 0) {
+            Element actionNode = (Element) actionsNode.item(0);
+            mActionCapabilities = new ActionCapabilities(mXcapUri, NODE_NAME, mIntendedId,
+                    actionNode);
+        }
+
+        NodeList conditionsNode = domDoc.getElementsByTagName(ConditionCapabilities.NODE_NAME);
+        if (conditionsNode.getLength() > 0) {
+            Element conditionNode = (Element) conditionsNode.item(0);
+            mConditionCapabilities = new ConditionCapabilities(mXcapUri, NODE_NAME, mIntendedId,
+                    conditionNode);
+        }
+
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/MediaConditions.java b/packages/simservs/src/com/mediatek/simservs/capability/MediaConditions.java
new file mode 100644
index 0000000..71a8897
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/MediaConditions.java
@@ -0,0 +1,70 @@
+
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Media Conditions class.
+ */
+public class MediaConditions extends XcapElement implements ConfigureType {
+    public static final String NODE_NAME = "serv-cap-media";
+
+    static final String TAG_MEDIA = "media";
+
+    List<String> mMedias;
+
+    /**
+     * Construct without XML.
+     *
+     * @param xcapUri           XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     */
+    public MediaConditions(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Construct with XML.
+     *
+     * @param xcapUri           XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @param domElement        XML element
+     */
+    public MediaConditions(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        NodeList mediasNode = domElement.getElementsByTagName(TAG_MEDIA);
+        mMedias = new LinkedList<String>();
+        for (int i = 0; i < mediasNode.getLength(); i++) {
+            Element mediaElement = (Element) mediasNode.item(i);
+            mMedias.add(mediaElement.getTextContent());
+        }
+
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    public List<String> getMedias() {
+        return mMedias;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/capability/ServiceCapabilities.java b/packages/simservs/src/com/mediatek/simservs/capability/ServiceCapabilities.java
new file mode 100644
index 0000000..fad7807
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/capability/ServiceCapabilities.java
@@ -0,0 +1,29 @@
+package com.mediatek.simservs.capability;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Service Capability class.
+ */
+public class ServiceCapabilities extends XcapElement {
+
+    public static final String ATT_PROVISIONED = "provisioned";
+
+    /**
+     * Construct ServiceCapabilities instance.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public ServiceCapabilities(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return null;
+    }
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/CommunicationDiversion.java b/packages/simservs/src/com/mediatek/simservs/client/CommunicationDiversion.java
new file mode 100644
index 0000000..15c2638
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/CommunicationDiversion.java
@@ -0,0 +1,346 @@
+
+package com.mediatek.simservs.client;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.RuleType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import java.util.LinkedList;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Communication Diversion class.
+ *
+ */
+public class CommunicationDiversion extends SimservType implements RuleType {
+
+    public static final String NODE_NAME = "communication-diversion";
+
+    NoReplyTimer mNoReplyTimer;
+    RuleSet mRuleSet;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri XCAP document URI
+     * @param parentUri   XCAP root directory URI
+     * @param intendedId  X-3GPP-Intended-Id
+     * @throws XcapException if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public CommunicationDiversion(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Instantiate from DOM XML.
+     *
+     * @param   domDoc  DOM document
+     */
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList noReplyTimerNode = domDoc.getElementsByTagName("NoReplyTimer");
+        if (noReplyTimerNode.getLength() > 0) {
+            Log.d("CommunicationDiversion", "Got NoReplyTimer");
+            Element noReplyTimerElement = (Element) noReplyTimerNode.item(0);
+            String val = noReplyTimerElement.getTextContent();
+            int noReplyTimer = Integer.parseInt(val);
+            mNoReplyTimer = new NoReplyTimer(mXcapUri, NODE_NAME, mIntendedId,
+                    noReplyTimer);
+            if (mNetwork != null) {
+                mNoReplyTimer.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mNoReplyTimer.setContext(mContext);
+            }
+
+            if (mEtag != null) {
+                mNoReplyTimer.setEtag(mEtag);
+            }
+        } else {
+            noReplyTimerNode = domDoc.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    "NoReplyTimer");
+            if (noReplyTimerNode.getLength() > 0) {
+                Log.d("CommunicationDiversion", "Got NoReplyTimer");
+                Element noReplyTimerElement = (Element) noReplyTimerNode.item(0);
+                String val = noReplyTimerElement.getTextContent();
+                int noReplyTimer = Integer.parseInt(val);
+                mNoReplyTimer = new NoReplyTimer(mXcapUri, NODE_NAME, mIntendedId,
+                        noReplyTimer);
+                if (mNetwork != null) {
+                    mNoReplyTimer.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mNoReplyTimer.setContext(mContext);
+                }
+
+                if (mEtag != null) {
+                    mNoReplyTimer.setEtag(mEtag);
+                }
+            } else {
+                noReplyTimerNode = domDoc.getElementsByTagName(XCAP_ALIAS + ":" + "NoReplyTimer");
+                if (noReplyTimerNode.getLength() > 0) {
+                    Log.d("CommunicationDiversion", "Got NoReplyTimer");
+                    Element noReplyTimerElement = (Element) noReplyTimerNode.item(0);
+                    String val = noReplyTimerElement.getTextContent();
+                    int noReplyTimer = Integer.parseInt(val);
+                    mNoReplyTimer = new NoReplyTimer(mXcapUri, NODE_NAME, mIntendedId,
+                            noReplyTimer);
+                    if (mNetwork != null) {
+                        mNoReplyTimer.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mNoReplyTimer.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mNoReplyTimer.setEtag(mEtag);
+                    }
+                } else {
+                    mNoReplyTimer = new NoReplyTimer(mXcapUri, NODE_NAME, mIntendedId,
+                            -1);
+                    if (mNetwork != null) {
+                        mNoReplyTimer.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mNoReplyTimer.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mNoReplyTimer.setEtag(mEtag);
+                    }
+                }
+            }
+        }
+
+        NodeList ruleSetNode = domDoc.getElementsByTagName("ruleset");
+        if (ruleSetNode.getLength() > 0) {
+            Log.d("CommunicationDiversion", "Got ruleset");
+            Element nruleSetElement = (Element) ruleSetNode.item(0);
+            mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId, nruleSetElement);
+            if (mNetwork != null) {
+                mRuleSet.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mRuleSet.setContext(mContext);
+            }
+
+            if (mEtag != null) {
+                mRuleSet.setEtag(mEtag);
+            }
+        } else {
+            ruleSetNode = domDoc.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "ruleset");
+            if (ruleSetNode.getLength() > 0) {
+                Log.d("CommunicationDiversion", "Got ruleset");
+                Element nruleSetElement = (Element) ruleSetNode.item(0);
+                mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                        nruleSetElement);
+                if (mNetwork != null) {
+                    mRuleSet.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mRuleSet.setContext(mContext);
+                }
+
+                if (mEtag != null) {
+                    mRuleSet.setEtag(mEtag);
+                }
+            } else {
+                ruleSetNode = domDoc.getElementsByTagName("cp:ruleset");
+                if (ruleSetNode.getLength() > 0) {
+                    Log.d("CommunicationDiversion", "Got ruleset");
+                    Element nruleSetElement = (Element) ruleSetNode.item(0);
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                            nruleSetElement);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                } else {
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                }
+            }
+        }
+    }
+
+    public int getNoReplyTimer() {
+        return mNoReplyTimer.getValue();
+    }
+
+    /**
+     * Set noreply timer.
+     *
+     * @param   timerValue  time value in second
+     * @throws  XcapException if XCAP error
+     */
+    public void setNoReplyTimer(int timerValue) throws XcapException {
+        mNoReplyTimer.setValue(timerValue);
+        String noReplyTimerXml = mNoReplyTimer.toXmlString();
+        mNoReplyTimer.setContent(noReplyTimerXml);
+        if (mNoReplyTimer.getEtag() != null) {
+            this.mEtag = mNoReplyTimer.getEtag();
+        }
+    }
+
+    /**
+    * Get rule set.
+    *
+    * @return Ruleset
+    */
+    @Override
+    public RuleSet getRuleSet() {
+        return mRuleSet;
+    }
+
+    /**
+     * Save ruleset to server.
+     *
+     * @throws  XcapException if XCAP error
+     */
+    @Override
+    public void saveRuleSet() throws XcapException {
+        String ruleXml = mRuleSet.toXmlString();
+        mRuleSet.setContent(ruleXml);
+        if (mRuleSet.getEtag() != null) {
+            this.mEtag = mRuleSet.getEtag();
+        }
+    }
+
+    /**
+     * Create ruleset.
+     *
+     * @return  ruleset
+     */
+    @Override
+    public RuleSet createNewRuleSet() {
+        mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+        if (mNetwork != null) {
+            mRuleSet.setNetwork(mNetwork);
+        }
+        if (mEtag != null) {
+            mRuleSet.setEtag(mEtag);
+        }
+        return mRuleSet;
+    }
+
+    /**
+     * Save rule to server.
+     *
+     * @param ruleId rule to be saved by the id
+     * @throws  XcapException if XCAP error
+     */
+    @Override
+    public void saveRule(String ruleId) throws XcapException {
+        if (ruleId != null && !ruleId.isEmpty()) {
+            LinkedList<Rule> rules =  (LinkedList<Rule>) mRuleSet.getRules();
+            for (Rule rule : rules) {
+                if (ruleId.equals(rule.mId)) {
+                    String ruleXml = rule.toXmlString();
+                    rule.setContent(ruleXml);
+                    if (rule.getEtag() != null) {
+                        this.mEtag = rule.getEtag();
+                    }
+                    break;
+                }
+            }
+        } else {
+            Log.d("saveRule", "ruleId is null");
+        }
+    }
+
+    /**
+     * NoReplyTimer class.
+     *
+     */
+    public class NoReplyTimer extends XcapElement {
+
+        public static final String NODE_NAME = "NoReplyTimer";
+        public int mValue;
+
+        /**
+         * Constructor without initial time value.
+         *
+         * @param cdUri       XCAP document URI
+         * @param parentUri   XCAP root directory URI
+         * @param intendedId  X-3GPP-Intended-Id
+         */
+        public NoReplyTimer(XcapUri cdUri, String parentUri, String intendedId) {
+            super(cdUri, parentUri, intendedId);
+        }
+
+        /**
+         * Constructor with initial time value.
+         *
+         * @param cdUri       XCAP document URI
+         * @param parentUri   XCAP root directory URI
+         * @param intendedId  X-3GPP-Intended-Id
+         * @param initValue   time value
+         */
+        public NoReplyTimer(XcapUri cdUri, String parentUri, String intendedId, int initValue) {
+            super(cdUri, parentUri, intendedId);
+            mValue = initValue;
+        }
+
+        @Override
+        protected String getNodeName() {
+            return NODE_NAME;
+        }
+
+        public int getValue() {
+            return mValue;
+        }
+
+        public void setValue(int value) {
+            mValue = value;
+        }
+
+        /**
+         * Convert to XML string.
+         *
+         * @return XML string
+         */
+        public String toXmlString() {
+            return "<NoReplyTimer>" + String.valueOf(mValue)
+                    + "</NoReplyTimer>";
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/CommunicationWaiting.java b/packages/simservs/src/com/mediatek/simservs/client/CommunicationWaiting.java
new file mode 100644
index 0000000..e8da86e
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/CommunicationWaiting.java
@@ -0,0 +1,42 @@
+
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Communication Waiting class.
+ *
+ */
+public class CommunicationWaiting extends SimservType {
+
+    public static final String NODE_NAME = "communication-waiting";
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public CommunicationWaiting(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        // No content need to be parsed for this service
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/DefaultBehaviour.java b/packages/simservs/src/com/mediatek/simservs/client/DefaultBehaviour.java
new file mode 100644
index 0000000..8b723b0
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/DefaultBehaviour.java
@@ -0,0 +1,93 @@
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
+/**
+ * Default Behaviour class.
+ *
+ */
+public class DefaultBehaviour extends XcapElement {
+
+    public static final String NODE_NAME = "default-behaviour";
+
+    public static final String DEFAULT_BEHAVIOUR_PRESENTATION_RESTRICTED =
+            "presentation-restricted";
+    public static final String DEFAULT_BEHAVIOUR_PRESENTATION_NOT_RESTRICTED =
+            "presentation-not-restricted";
+
+    public boolean mPresentationRestricted;
+
+    /**
+     * Constructor.
+     *
+     * @param cdUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public DefaultBehaviour(XcapUri cdUri, String parentUri, String intendedId) {
+        super(cdUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    XML element
+     */
+    public DefaultBehaviour(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        String content = domElement.getTextContent();
+        mPresentationRestricted = content.equals(DEFAULT_BEHAVIOUR_PRESENTATION_RESTRICTED);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Convert to XML string.
+     *
+     * @return  XML string
+     */
+    public String toXmlString() {
+        if (mPresentationRestricted) {
+            return "<default-behaviour>" + DEFAULT_BEHAVIOUR_PRESENTATION_RESTRICTED
+                    + "</default-behaviour>";
+        } else {
+            return "<default-behaviour>" + DEFAULT_BEHAVIOUR_PRESENTATION_NOT_RESTRICTED
+                    + "</default-behaviour>";
+        }
+    }
+
+    /**
+     * Convert to XML element.
+     *
+     * @param   document    DOM document
+     * @return  XML element
+     */
+    public Element toXmlElement(Document document) {
+        Element defaultElement = (Element) document.createElement(NODE_NAME);
+        if (mPresentationRestricted) {
+            defaultElement.setTextContent(DEFAULT_BEHAVIOUR_PRESENTATION_RESTRICTED);
+        } else {
+            defaultElement.setTextContent(DEFAULT_BEHAVIOUR_PRESENTATION_NOT_RESTRICTED);
+        }
+        return defaultElement;
+    }
+
+    public boolean isPresentationRestricted() {
+        return mPresentationRestricted;
+    }
+
+    public void setPresentationRestricted(boolean presentationRestricted) {
+        mPresentationRestricted = presentationRestricted;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/IncomingCommunicationBarring.java b/packages/simservs/src/com/mediatek/simservs/client/IncomingCommunicationBarring.java
new file mode 100644
index 0000000..6cda67b
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/IncomingCommunicationBarring.java
@@ -0,0 +1,177 @@
+package com.mediatek.simservs.client;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.RuleType;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import java.util.LinkedList;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Incoming Communication Barring class.
+ *
+ */
+public class IncomingCommunicationBarring extends SimservType implements RuleType {
+
+    public static final String NODE_NAME = "incoming-communication-barring";
+
+    RuleSet mRuleSet;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public IncomingCommunicationBarring(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList ruleSetNode = domDoc.getElementsByTagName("ruleset");
+        if (ruleSetNode.getLength() > 0) {
+            Log.d("IncomingCommunicationBarring", "Got ruleset");
+            Element nruleSetElement = (Element) ruleSetNode.item(0);
+            mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId, nruleSetElement);
+            if (mNetwork != null) {
+                mRuleSet.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mRuleSet.setContext(mContext);
+            }
+
+            if (mEtag != null) {
+                mRuleSet.setEtag(mEtag);
+            }
+        } else {
+            ruleSetNode = domDoc.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "ruleset");
+            if (ruleSetNode.getLength() > 0) {
+                Log.d("IncomingCommunicationBarring", "Got ruleset");
+                Element nruleSetElement = (Element) ruleSetNode.item(0);
+                mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                        nruleSetElement);
+                if (mNetwork != null) {
+                    mRuleSet.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mRuleSet.setContext(mContext);
+                }
+
+                if (mEtag != null) {
+                    mRuleSet.setEtag(mEtag);
+                }
+            } else {
+                ruleSetNode = domDoc.getElementsByTagName("cp:ruleset");
+                if (ruleSetNode.getLength() > 0) {
+                    Log.d("IncomingCommunicationBarring", "Got cp:ruleset");
+                    Element nruleSetElement = (Element) ruleSetNode.item(0);
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                            nruleSetElement);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                } else {
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Get ruleset.
+     *
+     * @return ruleset
+     */
+    @Override
+    public RuleSet getRuleSet() {
+        return mRuleSet;
+    }
+
+    /**
+     * Save ruleset configuration to server.
+     *
+     * @throws XcapException    if XCAP error
+     */
+    @Override
+    public void saveRuleSet() throws XcapException {
+        String ruleXml = mRuleSet.toXmlString();
+        mRuleSet.setContent(ruleXml);
+    }
+
+    /**
+     * Create ruleset.
+     *
+     * @return new ruleset
+     */
+    @Override
+    public RuleSet createNewRuleSet() {
+        mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+        if (mNetwork != null) {
+            mRuleSet.setNetwork(mNetwork);
+        }
+        if (mEtag != null) {
+            mRuleSet.setEtag(mEtag);
+        }
+        return mRuleSet;
+    }
+
+    /**
+     * Save rule to server.
+     *
+     * @param ruleId rule to be saved by the id
+     * @throws  XcapException if XCAP error
+     */
+    @Override
+    public void saveRule(String ruleId) throws XcapException {
+        if (ruleId != null && !ruleId.isEmpty()) {
+            LinkedList<Rule> rules =  (LinkedList<Rule>) mRuleSet.getRules();
+            for (Rule rule : rules) {
+                if (ruleId.equals(rule.mId)) {
+                    String ruleXml = rule.toXmlString();
+                    rule.setContent(ruleXml);
+                }
+            }
+        } else {
+            Log.d("saveRule", "ruleId is null");
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentation.java b/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentation.java
new file mode 100644
index 0000000..904cde9
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentation.java
@@ -0,0 +1,42 @@
+
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Originating Identity Presentation class.
+ */
+public class OriginatingIdentityPresentation extends SimservType {
+
+    public static final String NODE_NAME = "originating-identity-presentation";
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public OriginatingIdentityPresentation(XcapUri documentUri, String parentUri,
+            String intendedId) throws XcapException,
+            ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        // No content need to be parsed for this service
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentationRestriction.java b/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentationRestriction.java
new file mode 100644
index 0000000..7492a31
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/OriginatingIdentityPresentationRestriction.java
@@ -0,0 +1,154 @@
+
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+
+/**
+ * Originating Identity Presentation Restriction class.
+ */
+public class OriginatingIdentityPresentationRestriction extends SimservType {
+
+    public static final String NODE_NAME = "originating-identity-presentation-restriction";
+    public DefaultBehaviour mDefaultBehaviour;
+    public boolean mContainDefaultBehaviour = false;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param xui               X-3GPP-Intended-Id
+     * @throws  Exception       if error
+     */
+    public OriginatingIdentityPresentationRestriction(XcapUri documentUri, String parentUri,
+            String xui) throws Exception {
+        super(documentUri, parentUri, xui);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList defaultBehaviour = domDoc.getElementsByTagName(DefaultBehaviour.NODE_NAME);
+        if (defaultBehaviour.getLength() > 0) {
+            mContainDefaultBehaviour = true;
+            Element defaultBehaviourElement = (Element) defaultBehaviour.item(0);
+            mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId,
+                    defaultBehaviourElement);
+
+            if (mNetwork != null) {
+                mDefaultBehaviour.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mDefaultBehaviour.setContext(mContext);
+            }
+        } else {
+            defaultBehaviour = domDoc.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    DefaultBehaviour.NODE_NAME);
+            if (defaultBehaviour.getLength() > 0) {
+                mContainDefaultBehaviour = true;
+                Element defaultBehaviourElement = (Element) defaultBehaviour.item(0);
+                mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId,
+                        defaultBehaviourElement);
+
+                if (mNetwork != null) {
+                    mDefaultBehaviour.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mDefaultBehaviour.setContext(mContext);
+                }
+            } else {
+                mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId);
+
+                if (mNetwork != null) {
+                    mDefaultBehaviour.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mDefaultBehaviour.setContext(mContext);
+                }
+            }
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Save configuration to server.
+     *
+     * @throws XcapException    if XCAP error
+     */
+    public void saveConfiguration() throws XcapException {
+        String serviceXml = toXmlString();
+        setContent(serviceXml);
+        mContainDefaultBehaviour = true;
+    }
+
+    /**
+     * Convert DOM to XML string.
+     *
+     * @return XML string
+     */
+    public String toXmlString() {
+        Element root = null;
+        String xmlString = null;
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document document = builder.newDocument();
+            root = (Element) document.createElement(NODE_NAME);
+            document.appendChild(root);
+            Element defaultElement = mDefaultBehaviour.toXmlElement(document);
+            root.appendChild(defaultElement);
+            xmlString = domToXmlText(root);
+        } catch (ParserConfigurationException pce) {
+            // Parser with specified options can't be built
+            pce.printStackTrace();
+        } catch (TransformerConfigurationException e) {
+            e.printStackTrace();
+        } catch (TransformerException e) {
+            e.printStackTrace();
+        }
+        return xmlString;
+    }
+
+    public boolean isContainDefaultBehaviour() {
+        return mContainDefaultBehaviour;
+    }
+
+    public boolean isDefaultPresentationRestricted() {
+        return mDefaultBehaviour.isPresentationRestricted();
+    }
+
+    /**
+     * set Default Presentation Restricted value.
+     *
+     * @param presentationRestricted default restricted value
+     * @throws XcapException if XCAP error
+     */
+    public void setDefaultPresentationRestricted(boolean presentationRestricted) throws
+            XcapException {
+        mDefaultBehaviour.setPresentationRestricted(presentationRestricted);
+
+        if (isDefaultPresentationRestricted()) {
+            String defaultBehaviourXml = mDefaultBehaviour.toXmlString();
+            mDefaultBehaviour.setContent(defaultBehaviourXml);
+        } else {
+            saveConfiguration();
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/OutgoingCommunicationBarring.java b/packages/simservs/src/com/mediatek/simservs/client/OutgoingCommunicationBarring.java
new file mode 100644
index 0000000..0781bb2
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/OutgoingCommunicationBarring.java
@@ -0,0 +1,178 @@
+package com.mediatek.simservs.client;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.RuleType;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import java.util.LinkedList;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Outgoing Communication Barring class.
+ */
+public class OutgoingCommunicationBarring extends SimservType implements RuleType {
+
+    public static final String NODE_NAME = "outgoing-communication-barring";
+
+    RuleSet mRuleSet;
+
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public OutgoingCommunicationBarring(XcapUri documentUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList ruleSetNode = domDoc.getElementsByTagName("ruleset");
+        if (ruleSetNode.getLength() > 0) {
+            Log.d("OutgoingCommunicationBarring", "Got ruleset");
+            Element nruleSetElement = (Element) ruleSetNode.item(0);
+            mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId, nruleSetElement);
+            if (mNetwork != null) {
+                mRuleSet.setNetwork(mNetwork);
+            }
+
+            if (mContext != null) {
+                mRuleSet.setContext(mContext);
+            }
+
+            if (mEtag != null) {
+                mRuleSet.setEtag(mEtag);
+            }
+        } else {
+            ruleSetNode = domDoc.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "ruleset");
+            if (ruleSetNode.getLength() > 0) {
+                Log.d("OutgoingCommunicationBarring", "Got ruleset");
+                Element nruleSetElement = (Element) ruleSetNode.item(0);
+                mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                        nruleSetElement);
+                if (mNetwork != null) {
+                    mRuleSet.setNetwork(mNetwork);
+                }
+
+                if (mContext != null) {
+                    mRuleSet.setContext(mContext);
+                }
+
+                if (mEtag != null) {
+                    mRuleSet.setEtag(mEtag);
+                }
+            } else {
+                ruleSetNode = domDoc.getElementsByTagName("cp:ruleset");
+                if (ruleSetNode.getLength() > 0) {
+                    Log.d("OutgoingCommunicationBarring", "Got cp:ruleset");
+                    Element nruleSetElement = (Element) ruleSetNode.item(0);
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId,
+                            nruleSetElement);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                } else {
+                    mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+                    if (mNetwork != null) {
+                        mRuleSet.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        mRuleSet.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        mRuleSet.setEtag(mEtag);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Get ruleset.
+     *
+     * @return ruleset
+     */
+    @Override
+    public RuleSet getRuleSet() {
+        return mRuleSet;
+    }
+
+    /**
+     * Save ruleset to configuration on server.
+     *
+     * @throws XcapException if error
+     */
+    @Override
+    public void saveRuleSet() throws XcapException {
+        String ruleXml = mRuleSet.toXmlString();
+        mRuleSet.setContent(ruleXml);
+    }
+
+    /**
+     * Save ruleset to configuration on server.
+     *
+     * @return ruleset
+     */
+    @Override
+    public RuleSet createNewRuleSet() {
+        mRuleSet = new RuleSet(mXcapUri, NODE_NAME, mIntendedId);
+        if (mNetwork != null) {
+            mRuleSet.setNetwork(mNetwork);
+        }
+        if (mEtag != null) {
+            mRuleSet.setEtag(mEtag);
+        }
+        return mRuleSet;
+    }
+
+    /**
+     * Save rule to server.
+     *
+     * @param ruleId rule to be saved by the id
+     * @throws  XcapException if XCAP error
+     */
+    @Override
+    public void saveRule(String ruleId) throws XcapException {
+        if (ruleId != null && !ruleId.isEmpty()) {
+            LinkedList<Rule> rules =  (LinkedList<Rule>) mRuleSet.getRules();
+            for (Rule rule : rules) {
+                if (ruleId.equals(rule.mId)) {
+                    String ruleXml = rule.toXmlString();
+                    rule.setContent(ruleXml);
+                }
+            }
+        } else {
+            Log.d("saveRule", "ruleId is null");
+        }
+    }
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/SimServs.java b/packages/simservs/src/com/mediatek/simservs/client/SimServs.java
new file mode 100644
index 0000000..44925fd
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/SimServs.java
@@ -0,0 +1,904 @@
+
+package com.mediatek.simservs.client;
+
+import android.content.Context;
+import android.net.Network;
+import android.os.SystemProperties;
+import android.util.Log;
+
+import com.mediatek.simservs.capability.BarringServiceCapability;
+import com.mediatek.simservs.capability.DiversionServiceCapability;
+import com.mediatek.xcap.client.XcapDebugParam;
+import com.mediatek.xcap.client.uri.XcapUri;
+import com.mediatek.xcap.client.uri.XcapUri.XcapDocumentSelector;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * Simservs class.
+ */
+public class SimServs {
+    public static boolean sDebug = false;
+    public static final String TAG = "SimServs";
+
+    public static final int OPERATOR_DEFAULT = 0;
+    public static final int OPERATOR_OP01 = OPERATOR_DEFAULT + 1;
+    public static final int OPERATOR_OP07 = OPERATOR_DEFAULT + 2;
+
+    public static final boolean LIB_CONFIG_MULTIPLE_RULE_CONDITIONS = true;
+
+    public static final int CARDTYPE_UNSPECIFIED = 0;
+    public static final int CARDTYPE_USIM = 1;
+    public static final int CARDTYPE_ISIM = 2;
+
+    public static final String SIMSERVS_FILENAME = "simservs.xml";
+    public static final String AUID_SIMSERVS = "simservs.ngn.etsi.org";
+
+    public static SimServs sInstance = null;
+    private int mCardType = CARDTYPE_UNSPECIFIED;
+    private static String sXcapRoot = null;
+    private static String sXui = null;
+    private String mIntendedId = null;
+    private String mImsi = null;
+    private String mMnc = null;
+    private String mMcc = null;
+    private String mImpi = null;
+    private String mImpu = null;
+    private String mUsername = null;
+    private String mPassword = null;
+    public XcapDocumentSelector mDocumentSelector;
+    public URI mDocumentUri;
+    public XcapUri mXcapUri;
+    private static XcapDebugParam sXcapDebugParam;
+    private Context mContext;
+    /**
+     * Constructor.
+     *
+     */
+    public SimServs() {
+        String debugProperty = SystemProperties.get("mediatek.simserv.debug", "0");
+        if (debugProperty.equals("1")) {
+            sDebug = true;
+            Log.d(TAG, "sDebug enabled.");
+        }
+    }
+
+    /**
+     * Get SimServs instance.
+     *
+     * @return Simservs instance
+     */
+    static public SimServs getInstance() {
+        if (sInstance == null) {
+            sInstance = new SimServs();
+        }
+
+        initializeDebugParam();
+        return sInstance;
+    }
+
+    /**
+     * Get XcapDebugParam.
+     *
+     * @return XcapDebugParam
+     */
+    public XcapDebugParam getXcapDebugParam() {
+        return sXcapDebugParam;
+    }
+
+    /**
+     * Set XCAP root URL.
+     *
+     * @param xcapRoot XCAP root directory URI
+     */
+    public void setXcapRoot(String xcapRoot) {
+        sXcapRoot = xcapRoot;
+        try {
+            buildDocumentUri();
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+            sXcapRoot = null;
+        }
+    }
+
+    /**
+     * Set XCAP root URL by IMPI.
+     *
+     * @param impi IMPI
+     */
+    public void setXcapRootByImpi(String impi) {
+        mCardType = CARDTYPE_ISIM;
+        mImpi = impi;
+        try {
+            buildRootUri();
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Set XCAP root URL by PLMN.
+     *
+     * @param mcc MCC
+     * @param mnc MNC
+     */
+    public void setXcapRootByMccMnc(String mcc, String mnc) {
+        mCardType = CARDTYPE_USIM;
+        mMcc = mcc;
+        mMnc = mnc;
+        try {
+            buildRootUri();
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public void setXui(String xui) {
+        sXui = xui;
+    }
+
+    /**
+     * Set XUI by IMPU.
+     *
+     * @param impu IMPU
+     */
+    public void setXuiByImpu(String impu) {
+        mCardType = CARDTYPE_ISIM;
+        mImpu = impu;
+        sXui = impu;
+    }
+
+    /**
+     * Set XUI by IMSI and PLMN.
+     *
+     * @param imsi IMSI
+     * @param mcc  MCC
+     * @param mnc  MNC
+     */
+    public void setXuiByImsiMccMnc(String imsi, String mcc, String mnc) {
+        mCardType = CARDTYPE_USIM;
+        mImsi = imsi;
+        mMcc = mcc;
+        mMnc = mnc;
+
+        sXui = String.format("sip:%s@ims.mnc%03d.mcc%03d.3gppnetwork.org", imsi,
+                             Integer.parseInt(mnc), Integer.parseInt(mcc));
+    }
+
+    public void setIntendedId(String intendedId) {
+        mIntendedId = intendedId;
+    }
+
+    public void setHttpCredential(String username, String password){
+        // TODO: remove in the future
+    }
+
+    /**
+     * Set to use HTTP protocol scheme.
+     *
+     * @param value true/false
+     */
+    public void setUseHttpProtocolScheme(boolean value) {
+        if (value) {
+            System.setProperty("xcap.protocol", "http");
+        } else {
+            System.setProperty("xcap.protocol", "https");
+        }
+    }
+
+    /**
+     * Set content-type while updating XML element.
+     *
+     * In 3GPP spec, "application/xcap-el+xml" is used.
+     * Som operator will have it's own specific content-type,
+     * ex: "application/vnd.etsi.simservs+xml"
+     *
+     * @param specdefined true to use "application/xcap-el+xml", false to use assigned type.
+     * @param type content-type
+     */
+    public void setElementUpdateContentType(boolean specdefined, String type) {
+        if (specdefined) {
+            System.setProperty("xcap.putelcontenttype", "application/xcap-el+xml");
+        } else {
+            System.setProperty("xcap.putelcontenttype", type);
+        }
+    }
+
+    /**
+     * Set to handle HTTP 409 error message content.
+     *
+     * @param value true/false
+     */
+    public void setHandleError409(boolean value) {
+        if (value) {
+            System.setProperty("xcap.handl409", "true");
+        } else {
+            System.setProperty("xcap.handl409", "false");
+        }
+    }
+
+    /**
+     * Set to fill complete ForwardTo elements according to 3GPP TS 24.604
+     *
+     * Usually only <target>, phone number,  will be used in <forward-to> element,
+     * Some operaters require to fill complete elements in <forward-to>.
+     *
+     * @param value true/false
+     */
+    public void setFillCompleteForwardTo(boolean value) {
+        if (value) {
+            System.setProperty("xcap.completeforwardto", "true");
+        } else {
+            System.setProperty("xcap.completeforwardto", "false");
+        }
+    }
+
+    /**
+     * Set to add namespace prefix "ss:".
+     * as namespace prefix for http://uri.etsi.org/ngn/params/xml/simservs/xcap
+     *
+     * @param value true/false
+     */
+    public void setXcapNSPrefixSS(boolean value) {
+        if (value) {
+            System.setProperty("xcap.ns.ss", "true");
+        } else {
+            System.setProperty("xcap.ns.ss", "false");
+        }
+    }
+
+    public String getXcapRoot() {
+        return sXcapRoot;
+    }
+
+    public String getXui() {
+        return sXui;
+    }
+
+    public String getIntendedId() {
+        return mIntendedId;
+    }
+
+    /**
+     * Set context.
+     *
+     * @param ctxt context to set
+     */
+    public void setContext(Context ctxt) {
+        mContext = ctxt;
+    }
+
+    /**
+     * Configure operator-specific requirement parameters.
+     *
+     * @param operator operator choice
+     */
+    public void setOperator(int operator) {
+        switch(operator) {
+            case OPERATOR_OP01:
+                System.setProperty("xcap.op", "01");
+                System.setProperty("xcap.protocol", "http");
+                System.setProperty("xcap.putelcontenttype", "application/vnd.etsi.simservs+xml");
+                System.setProperty("xcap.handl409", "false");
+                break;
+            case OPERATOR_OP07:
+                System.setProperty("xcap.op", "07");
+                System.setProperty("xcap.protocol", "https");
+                System.setProperty("xcap.putelcontenttype", "application/xcap-el+xml");
+                System.setProperty("xcap.handl409", "true");
+                break;
+            case OPERATOR_DEFAULT:
+            default:
+                System.setProperty("xcap.op", "00");
+                System.setProperty("xcap.protocol", "https");
+                System.setProperty("xcap.putelcontenttype", "application/xcap-el+xml");
+                System.setProperty("xcap.handl409", "false");
+                break;
+        }
+    }
+
+    /**
+     * Initialization debug utility.
+     */
+    static private void initializeDebugParam() {
+        sXcapDebugParam = XcapDebugParam.getInstance();
+        sXcapDebugParam.load();
+        sXcapRoot = null;
+        sXui = null;
+
+        String xcapRoot = sXcapDebugParam.getXcapRoot();
+        //systemproperty ex: http://xcap.ims.msg.t-mobile.com:8090/
+
+        if (xcapRoot != null && !xcapRoot.isEmpty()) {
+            sXcapRoot = xcapRoot;
+        }
+
+        String xui = sXcapDebugParam.getXcapXui();
+
+        if (xui != null && !xui.isEmpty()) {
+            sXui = xui;
+        }
+    }
+
+    /**
+     * Get domain from IMPI.
+     */
+    private String getImpiDomain() {
+        if (mImpi != null && !mImpi.isEmpty() && mImpi.contains("@")) {
+            String[] temp;
+            String delimiter = "@";
+            temp = mImpi.split(delimiter);
+            return temp[1];
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Build the XCAP root URI according to TS 23.003 13.9.
+     *
+     * @throws URISyntaxException
+     */
+    private void buildRootUri() throws URISyntaxException {
+        StringBuilder xcapRoot = new StringBuilder();
+        Log.d("Simservs", "xcap.protocol=" + System.getProperty("xcap.protocol"));
+
+        String protocol = System.getProperty("xcap.protocol", "https");
+
+        if (mCardType == CARDTYPE_USIM) {
+            xcapRoot.append(protocol + "://xcap.ims.mnc")
+                .append(mMnc)
+                .append(".mcc")
+                .append(mMcc)
+                .append(".pub.3gppnetwork.org");
+        } else if (mCardType == CARDTYPE_ISIM) {
+            if (mImpi != null && mImpi.endsWith("3gppnetwork.org")) {
+                String domain = getImpiDomain();
+                xcapRoot.append(protocol + "://xcap.");
+                xcapRoot.append(domain.substring(0, domain.indexOf(".3gppnetwork.org")));
+                if (mImpi.contains(".pub")) {
+                    xcapRoot.append(".3gppnetwork.org");
+                } else {
+                    xcapRoot.append(".pub.3gppnetwork.org");
+                }
+            } else {
+                String domain = getImpiDomain();
+                if (domain == null) {
+                    return;
+                }
+                xcapRoot.append(protocol + "://xcap.")
+                        .append(domain);
+            }
+        } else {
+            return;
+        }
+
+        xcapRoot.append("/");
+        sXcapRoot = xcapRoot.toString();
+        buildDocumentUri();
+    }
+
+    /**
+     * Build document URI.
+     *
+     * @throws URISyntaxException if URI syntax error
+     */
+    public void buildDocumentUri() throws URISyntaxException {
+        String xcapDocumentName = sXcapDebugParam.getXcapDocumentName();
+        mDocumentSelector = new XcapDocumentSelector(
+                AUID_SIMSERVS, sXui, (xcapDocumentName != null && !xcapDocumentName.isEmpty()) ?
+                xcapDocumentName : SIMSERVS_FILENAME);
+        Log.d(TAG, "document selector is " + mDocumentSelector.toString());
+        //[Fix bug by mtk01411 2013-1003]mXcapUri is member of class SimServs
+        //XcapUri mXcapUri = new XcapUri(); //Only new instance for local variable mXcapUri
+        //instead of class member mXcapUri
+        mXcapUri = new XcapUri();
+        Log.d(TAG, "buildDocumentUri():Create instance for mXcapUri");
+        mXcapUri.setXcapRoot(sXcapRoot).setDocumentSelector(mDocumentSelector);
+
+        mDocumentUri = mXcapUri.toURI();
+    }
+
+    public String getDocumentUri() {
+        return mDocumentUri.toString();
+    }
+
+    /**
+     * Get a CommunicationWaiting instance.
+     *
+     * @param  syncInstance not use
+     * @return CommunicationWaiting instance
+     * @throws Exception if error
+     */
+    public CommunicationWaiting getCommunicationWaiting(boolean syncInstance) throws Exception {
+        CommunicationWaiting cw = new CommunicationWaiting(mXcapUri, null, mIntendedId);
+        if (mContext != null) {
+            cw.setContext(mContext);
+        }
+
+        cw.loadConfiguration();
+        return cw;
+    }
+
+    /**
+     * Get a CommunicationWaiting instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return CommunicationWaiting instance
+     * @throws Exception if error
+     */
+    public CommunicationWaiting getCommunicationWaiting(boolean syncInstance, Network network)
+            throws Exception {
+        CommunicationWaiting cw = new CommunicationWaiting(mXcapUri, null, mIntendedId);
+        if (network != null) {
+            cw.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            cw.setContext(mContext);
+        }
+
+        cw.loadConfiguration();
+        return cw;
+    }
+
+    /**
+     * Get a CommunicationWaiting instance.
+     * For test purpose.
+     *
+     * @param documentUri       XCAP document URI
+     * @return CommunicationWaiting instance
+     * @throws Exception if error
+     */
+    public CommunicationWaiting getCommunicationWaiting(XcapUri documentUri) throws Exception {
+        return new CommunicationWaiting(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentation instance.
+     *
+     * @param  syncInstance not use
+     * @return OriginatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentation getOriginatingIdentityPresentation(boolean syncInstance)
+            throws Exception {
+        OriginatingIdentityPresentation oip = new OriginatingIdentityPresentation(mXcapUri, null,
+                mIntendedId);
+        if (mContext != null) {
+            oip.setContext(mContext);
+        }
+
+        oip.loadConfiguration();
+        return oip;
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentation instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return OriginatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentation getOriginatingIdentityPresentation(boolean syncInstance,
+            Network network) throws Exception {
+        OriginatingIdentityPresentation oip = new OriginatingIdentityPresentation(mXcapUri, null,
+                mIntendedId);
+        if (network != null) {
+            oip.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            oip.setContext(mContext);
+        }
+
+        oip.loadConfiguration();
+        return oip;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentation instance.
+     *
+     * @param  syncInstance not use
+     * @return TerminatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentation getTerminatingIdentityPresentation(boolean syncInstance)
+            throws Exception {
+        TerminatingIdentityPresentation tip = new TerminatingIdentityPresentation(mXcapUri, null,
+                mIntendedId);
+
+        if (mContext != null) {
+            tip.setContext(mContext);
+        }
+
+        tip.loadConfiguration();
+        return tip;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentation instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return TerminatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentation getTerminatingIdentityPresentation(boolean syncInstance,
+            Network network) throws Exception {
+        TerminatingIdentityPresentation tip = new TerminatingIdentityPresentation(mXcapUri, null,
+                mIntendedId);
+        if (network != null) {
+            tip.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            tip.setContext(mContext);
+        }
+
+        tip.loadConfiguration();
+        return tip;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentation instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     *
+     * @return OriginatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentation getOriginatingIdentityPresentation(
+            XcapUri documentUri) throws Exception {
+        return new OriginatingIdentityPresentation(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentation instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return TerminatingIdentityPresentation instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentation getTerminatingIdentityPresentation(
+            XcapUri documentUri) throws Exception {
+        return new TerminatingIdentityPresentation(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentationRestriction instance.
+     *
+     * @param  syncInstance not use
+     * @return OriginatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentationRestriction getOriginatingIdentityPresentationRestriction(
+            boolean syncInstance) throws Exception {
+        OriginatingIdentityPresentationRestriction oip =
+                new OriginatingIdentityPresentationRestriction(mXcapUri, null, mIntendedId);
+        if (mContext != null) {
+            oip.setContext(mContext);
+        }
+
+        oip.loadConfiguration();
+        return oip;
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentationRestriction instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return OriginatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentationRestriction getOriginatingIdentityPresentationRestriction(
+            boolean syncInstance, Network network) throws Exception {
+        OriginatingIdentityPresentationRestriction oipr =
+                new OriginatingIdentityPresentationRestriction(mXcapUri, null, mIntendedId);
+        if (network != null) {
+            oipr.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            oipr.setContext(mContext);
+        }
+
+        oipr.loadConfiguration();
+        return oipr;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentationRestriction instance.
+     *
+     * @param  syncInstance not use
+     * @return TerminatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentationRestriction getTerminatingIdentityPresentationRestriction(
+            boolean syncInstance) throws Exception {
+        TerminatingIdentityPresentationRestriction tipr =
+                new TerminatingIdentityPresentationRestriction(mXcapUri, null, mIntendedId);
+
+        if (mContext != null) {
+            tipr.setContext(mContext);
+        }
+
+        tipr.loadConfiguration();
+        return tipr;
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentationRestriction instance.
+     *
+     * @param  syncInstance not use
+     * @param network dedicated network
+     * @return TerminatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentationRestriction getTerminatingIdentityPresentationRestriction(
+            boolean syncInstance, Network network) throws Exception {
+        TerminatingIdentityPresentationRestriction tipr =
+                new TerminatingIdentityPresentationRestriction(mXcapUri, null, mIntendedId);
+        if (network != null) {
+            tipr.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            tipr.setContext(mContext);
+        }
+
+        tipr.loadConfiguration();
+        return tipr;
+    }
+
+    /**
+     * Get a OriginatingIdentityPresentationRestriction instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return OriginatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public OriginatingIdentityPresentationRestriction getOriginatingIdentityPresentationRestriction(
+            XcapUri documentUri) throws Exception {
+        return new OriginatingIdentityPresentationRestriction(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a TerminatingIdentityPresentationRestriction instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return TerminatingIdentityPresentationRestriction instance
+     * @throws Exception if error
+     */
+    public TerminatingIdentityPresentationRestriction getTerminatingIdentityPresentationRestriction(
+            XcapUri documentUri) throws Exception {
+        return new TerminatingIdentityPresentationRestriction(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a CommunicationDiversion instance.
+     *
+     * @param syncInstance not use
+     * @return CommunicationDiversion instance
+     * @throws Exception if error
+     */
+    public CommunicationDiversion getCommunicationDiversion(boolean syncInstance) throws
+            Exception {
+        CommunicationDiversion cd = new CommunicationDiversion(mXcapUri, null, mIntendedId);
+
+        if (mContext != null) {
+            cd.setContext(mContext);
+        }
+
+        cd.loadConfiguration();
+        return cd;
+    }
+
+    /**
+     * Get a CommunicationDiversion instance with specific network.
+     *
+     * @param syncInstance not use
+     * @param network dedicated network
+     * @return CommunicationDiversion instance
+     * @throws Exception if error
+     */
+    public CommunicationDiversion getCommunicationDiversion(boolean syncInstance,
+            Network network) throws Exception {
+        CommunicationDiversion cd = new CommunicationDiversion(mXcapUri, null, mIntendedId);
+        if (network != null) {
+            cd.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            cd.setContext(mContext);
+        }
+        cd.loadConfiguration();
+        return cd;
+    }
+
+    /**
+     * Get a CommunicationDiversion instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return CommunicationDiversion instance
+     * @throws Exception if error
+     */
+    public CommunicationDiversion getCommunicationDiversion(
+            XcapUri documentUri) throws Exception {
+        return new CommunicationDiversion(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a IncomingCommunicationBarring instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return IncomingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public IncomingCommunicationBarring getIncomingCommunicationBarring(
+            XcapUri documentUri) throws Exception {
+        return new IncomingCommunicationBarring(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a IncomingCommunicationBarring instance.
+     *
+     * @param syncInstance not use
+     * @return IncomingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public IncomingCommunicationBarring getIncomingCommunicationBarring(boolean syncInstance) throws
+            Exception {
+        IncomingCommunicationBarring icb = new IncomingCommunicationBarring(mXcapUri, null,
+                mIntendedId);
+
+        if (mContext != null) {
+            icb.setContext(mContext);
+        }
+
+        icb.loadConfiguration();
+        return icb;
+    }
+
+    /**
+     * Get a IncomingCommunicationBarring instance.
+     *
+     * @param syncInstance not use
+     * @param network dedicated network
+     * @return IncomingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public IncomingCommunicationBarring getIncomingCommunicationBarring(
+            boolean syncInstance, Network network) throws Exception {
+        IncomingCommunicationBarring icb = new IncomingCommunicationBarring(mXcapUri, null,
+                mIntendedId);
+        if (network != null) {
+            icb.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            icb.setContext(mContext);
+        }
+
+        icb.loadConfiguration();
+        return icb;
+    }
+
+    /**
+     * Get a OutgoingCommunicationBarring instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return OutgoingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public OutgoingCommunicationBarring getOutgoingCommunicationBarring(
+            XcapUri documentUri) throws Exception {
+        return new OutgoingCommunicationBarring(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a OutgoingCommunicationBarring instance.
+     *
+     * @param syncInstance not use
+     * @return OutgoingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public OutgoingCommunicationBarring getOutgoingCommunicationBarring(boolean syncInstance) throws
+            Exception {
+        OutgoingCommunicationBarring ocb = new OutgoingCommunicationBarring(mXcapUri, null,
+                mIntendedId);
+
+        if (mContext != null) {
+            ocb.setContext(mContext);
+        }
+
+        ocb.loadConfiguration();
+        return ocb;
+    }
+
+    /**
+     * Get a OutgoingCommunicationBarring instance.
+     *
+     * @param syncInstance not use
+     * @param network dedicated network
+     * @return OutgoingCommunicationBarring instance
+     * @throws Exception if error
+     */
+    public OutgoingCommunicationBarring getOutgoingCommunicationBarring(
+            boolean syncInstance, Network network) throws Exception {
+        OutgoingCommunicationBarring ocb = new OutgoingCommunicationBarring(mXcapUri, null,
+                mIntendedId);
+        if (network != null) {
+            ocb.setNetwork(network);
+        }
+
+        if (mContext != null) {
+            ocb.setContext(mContext);
+        }
+
+        ocb.loadConfiguration();
+        return ocb;
+    }
+
+    /**
+     * Get a DiversionServiceCapability instance.
+     *
+     * @param syncInstance not use
+     * @return DiversionServiceCapability instance
+     * @throws Exception if error
+     */
+    public DiversionServiceCapability getDiversionServiceCapability(boolean syncInstance) throws
+            Exception {
+        return new DiversionServiceCapability(mXcapUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a DiversionServiceCapability instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return DiversionServiceCapability instance
+     * @throws Exception if error
+     */
+    public DiversionServiceCapability getDiversionServiceCapability(
+            XcapUri documentUri) throws Exception {
+        return new DiversionServiceCapability(documentUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a DiversionServiceCapability instance.
+     *
+     * @param syncInstance not use
+     * @return BarringServiceCapability instance
+     * @throws Exception if error
+     */
+    public BarringServiceCapability getBarringServiceCapability(boolean syncInstance) throws
+            Exception {
+        return new BarringServiceCapability(mXcapUri, null, mIntendedId);
+    }
+
+    /**
+     * Get a BarringServiceCapability instance.
+     * For test purpose.
+     *
+     * @param documentUri   XCAP document URI
+     * @return BarringServiceCapability instance
+     * @throws Exception if error
+     */
+    public BarringServiceCapability getBarringServiceCapability(
+            XcapUri documentUri) throws Exception {
+        return new BarringServiceCapability(documentUri, null, mIntendedId);
+    }
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/SimservType.java b/packages/simservs/src/com/mediatek/simservs/client/SimservType.java
new file mode 100644
index 0000000..2f86dca
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/SimservType.java
@@ -0,0 +1,212 @@
+package com.mediatek.simservs.client;
+
+import android.util.Log;
+
+import com.mediatek.simservs.xcap.InquireType;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.XcapDebugParam;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.IOException;
+import java.io.StringReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * SimservType (SS type) abstract class.
+ */
+public abstract class SimservType extends InquireType {
+    //[MMTelSS] Add by mtk01411 for testing/debuging
+    public static final String TAG = "SimservType";
+    static final String ATT_ACTIVE = "active";
+
+    public boolean mActived = false;
+    String mSsTc;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public SimservType(XcapUri xcapUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(xcapUri, parentUri, intendedId);
+        Log.d(TAG, "Xcap debug params: \n" + mDebugParams.toString());
+    }
+
+    /**
+     * Sync latest version with NAF server.
+     *
+     * @throws Exception if error
+     */
+    public void refresh() throws Exception {
+        this.loadConfiguration();
+    }
+
+    /**
+     * Is E-Tag supported.
+     *
+     * @return true/false
+     */
+    public boolean isSupportEtag() {
+        return mIsSupportEtag;
+    }
+
+    /**
+     * Retrieve configuration.
+     *
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    //[Revise this API for UT by mtk01411]
+    protected void loadConfiguration() throws XcapException,
+            ParserConfigurationException {
+        String xmlContent = "";
+        String nodeName = getNodeName();
+        Log.d(TAG, "loadConfiguration():nodeName=" + nodeName);
+
+        if (XcapDebugParam.getInstance().getEnablePredefinedSimservQueryResult()) {
+            //Use different XML strings for UT purpose
+            xmlContent = readXmlFromFile("/data/ss.xml");
+
+            //Compare if the nodeName is same with tested xml node name
+            if (xmlContent.contains(nodeName) == false) {
+                //Can't query anything - not same query target
+                Log.d(TAG, "loadConfiguration():fail to get tested xml for nodeName=" + nodeName);
+                return;
+            } else {
+                Log.d(TAG, "loadConfiguration():get tested xml for nodeName=" + nodeName);
+            }
+
+        } else {
+            //Get string from remote XCAP server
+            xmlContent = getContent();
+        }
+        if (SimServs.sDebug) {
+            Log.v(TAG, "xmlContent=" + xmlContent);
+        }
+
+        if (xmlContent != null) {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            factory.setNamespaceAware(true);
+            DocumentBuilder db = factory.newDocumentBuilder();
+            InputSource is = new InputSource();
+            is.setCharacterStream(new StringReader(xmlContent));
+            Document doc;
+            try {
+                doc = db.parse(is);
+            } catch (SAXException e) {
+                factory.setNamespaceAware(false);
+                db = factory.newDocumentBuilder();
+                is = new InputSource();
+                is.setCharacterStream(new StringReader(xmlContent));
+                try {
+                    doc = db.parse(is);
+                } catch (SAXException err) {
+                    err.printStackTrace();
+                    // Throws a server error
+                    throw new XcapException(500);
+                } catch (IOException err) {
+                    err.printStackTrace();
+                    // Throws a server error
+                    throw new XcapException(500);
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+                // Throws a server error
+                throw new XcapException(500);
+            }
+            NodeList currentNode = doc.getElementsByTagName(getNodeName());
+            if (SimServs.sDebug) {
+                Log.v(TAG, "getNodeName()=" + getNodeName());
+            }
+
+            if (currentNode.getLength() > 0) {
+                Element activeElement = (Element) currentNode.item(0);
+                NamedNodeMap map = activeElement.getAttributes();
+                if (map.getLength() > 0) {
+                    for (int i = 0; i < map.getLength(); i++) {
+                        Node node = map.item(i);
+                        if (node.getNodeName().equals(ATT_ACTIVE)) {
+                            mActived = node.getNodeValue().endsWith(TRUE);
+                            break;
+                        }
+                    }
+                }
+            } else {
+                currentNode = doc.getElementsByTagNameNS(XCAP_NAMESPACE, getNodeName());
+                if (currentNode.getLength() > 0) {
+                    Element activeElement = (Element) currentNode.item(0);
+                    NamedNodeMap map = activeElement.getAttributes();
+                    if (map.getLength() > 0) {
+                        for (int i = 0; i < map.getLength(); i++) {
+                            Node node = map.item(i);
+                            if (node.getNodeName().equals(ATT_ACTIVE)) {
+                                mActived = node.getNodeValue().endsWith(TRUE);
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (SimServs.sDebug) {
+                Log.v(TAG, "xmldoc=" + doc.toString());
+            }
+
+            initServiceInstance(doc);
+        }
+    }
+
+    public boolean isActive() {
+        return mActived;
+    }
+
+    /**
+     * Set active value.
+     *
+     * @param active            active value
+     * @throws XcapException    if XCAP error
+     */
+    public void setActive(boolean active) throws XcapException {
+        mActived = active;
+        String xml = null;
+        String useXcapNs = System.getProperty("xcap.ns.ss", "false");
+
+        if ("true".equals(useXcapNs)) {
+            if (mActived) {
+                xml = "<ss:" + this.getNodeName() + " active=\"true\"/>";
+            } else {
+                xml = "<ss:" + this.getNodeName() + " active=\"false\"/>";
+            }
+            this.setContent(xml);
+        } else {
+            if (mActived) {
+                setByAttrName(ATT_ACTIVE, TRUE);
+            } else {
+                setByAttrName(ATT_ACTIVE, FALSE);
+            }
+        }
+    }
+
+    /**
+     * Instantiate from XML text.
+     *
+     * @param domDoc XML document
+     */
+    public abstract void initServiceInstance(Document domDoc);
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentation.java b/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentation.java
new file mode 100644
index 0000000..1d0652b
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentation.java
@@ -0,0 +1,41 @@
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * Spheret class.
+ */
+public class TerminatingIdentityPresentation extends SimservType {
+
+    public static final String NODE_NAME = "terminating-identity-presentation";
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public TerminatingIdentityPresentation(XcapUri documentUri, String parentUri,
+            String intendedId) throws XcapException,
+            ParserConfigurationException {
+        super(documentUri, parentUri, intendedId);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        // No content need to be parsed for this service
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentationRestriction.java b/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentationRestriction.java
new file mode 100644
index 0000000..e4b1138
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/TerminatingIdentityPresentationRestriction.java
@@ -0,0 +1,129 @@
+package com.mediatek.simservs.client;
+
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+
+/**
+ * Terminating Identity Presentation Restriction class.
+ */
+public class TerminatingIdentityPresentationRestriction extends SimservType {
+
+    public static final String NODE_NAME = "terminating-identity-presentation-restriction";
+    public DefaultBehaviour mDefaultBehaviour;
+    public boolean mContainDefaultBehaviour = false;
+
+    /**
+     * Constructor.
+     *
+     * @param documentUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param xui           X-3GPP-Intended-Id
+     * @throws Exception    if error
+     */
+    public TerminatingIdentityPresentationRestriction(XcapUri documentUri, String parentUri,
+            String xui) throws Exception {
+        super(documentUri, parentUri, xui);
+    }
+
+    @Override
+    public void initServiceInstance(Document domDoc) {
+        NodeList defaultBehaviour = domDoc.getElementsByTagName(DefaultBehaviour.NODE_NAME);
+        if (defaultBehaviour.getLength() > 0) {
+            mContainDefaultBehaviour = true;
+            Element defaultBehaviourElement = (Element) defaultBehaviour.item(0);
+            mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId,
+                    defaultBehaviourElement);
+        } else {
+            defaultBehaviour = domDoc.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    DefaultBehaviour.NODE_NAME);
+            if (defaultBehaviour.getLength() > 0) {
+                mContainDefaultBehaviour = true;
+                Element defaultBehaviourElement = (Element) defaultBehaviour.item(0);
+                mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId,
+                        defaultBehaviourElement);
+            } else {
+                mDefaultBehaviour = new DefaultBehaviour(mXcapUri, NODE_NAME, mIntendedId);
+            }
+        }
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    /**
+     * Save configuration on server.
+     *
+     * @throws XcapException    if XCAP error
+     */
+    public void saveConfiguration() throws XcapException {
+        String serviceXml = toXmlString();
+        setContent(serviceXml);
+        mContainDefaultBehaviour = true;
+    }
+
+    /**
+     * Convert to XML string.
+     *
+     * @return XML string
+     */
+    public String toXmlString() {
+        Element root = null;
+        String xmlString = null;
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document document = builder.newDocument();
+            root = (Element) document.createElement(NODE_NAME);
+            document.appendChild(root);
+            Element defaultElement = mDefaultBehaviour.toXmlElement(document);
+            root.appendChild(defaultElement);
+            xmlString = domToXmlText(root);
+        } catch (ParserConfigurationException pce) {
+            // Parser with specified options can't be built
+            pce.printStackTrace();
+        } catch (TransformerConfigurationException e) {
+            e.printStackTrace();
+        } catch (TransformerException e) {
+            e.printStackTrace();
+        }
+        return xmlString;
+    }
+
+    public boolean isContainDefaultBehaviour() {
+        return mContainDefaultBehaviour;
+    }
+
+    public boolean isDefaultPresentationRestricted() {
+        return mDefaultBehaviour.isPresentationRestricted();
+    }
+
+    /**
+     * set Default Presentation Restricted value.
+     *
+     * @param presentationRestricted retriction value
+     * @throws XcapException if XCAP error
+     */
+    public void setDefaultPresentationRestricted(boolean presentationRestricted) throws
+            XcapException {
+        mDefaultBehaviour.setPresentationRestricted(presentationRestricted);
+
+        if (isDefaultPresentationRestricted()) {
+            String defaultBehaviourXml = mDefaultBehaviour.toXmlString();
+            mDefaultBehaviour.setContent(defaultBehaviourXml);
+        } else {
+            saveConfiguration();
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Actions.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Actions.java
new file mode 100644
index 0000000..420e838
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Actions.java
@@ -0,0 +1,155 @@
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * Actions class.
+ *
+ */
+public class Actions extends XcapElement implements ConfigureType {
+
+    public static final String NODE_NAME = "cp:actions";
+
+    static final String TAG_ALLOW = "allow";
+    static final String TAG_FORWARD_TO = "forward-to";
+
+    public boolean mAllow;
+    public ForwardTo mForwardTo;
+
+    /**
+     * Constructor without XML element.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Actions(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor with XML element.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM XML element
+     */
+    public Actions(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        NodeList actionNode = domElement.getElementsByTagName(TAG_ALLOW);
+        if (actionNode.getLength() > 0) {
+            Element allowElement = (Element) actionNode.item(0);
+            String allowed = allowElement.getTextContent();
+            mAllow = allowed.equals("true");
+        } else {
+            actionNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_ALLOW);
+            if (actionNode.getLength() > 0) {
+                Element allowElement = (Element) actionNode.item(0);
+                String allowed = allowElement.getTextContent();
+                mAllow = allowed.equals("true");
+            } else {
+                actionNode = domElement.getElementsByTagName(XCAP_ALIAS + ":" + TAG_ALLOW);
+                if (actionNode.getLength() > 0) {
+                    Element allowElement = (Element) actionNode.item(0);
+                    String allowed = allowElement.getTextContent();
+                    mAllow = allowed.equals("true");
+                }
+            }
+        }
+
+        actionNode = domElement.getElementsByTagName(TAG_FORWARD_TO);
+        if (actionNode.getLength() > 0) {
+            mForwardTo = new ForwardTo(mXcapUri, NODE_NAME, mIntendedId,
+                    domElement);
+        } else {
+            actionNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_FORWARD_TO);
+            if (actionNode.getLength() > 0) {
+                mForwardTo = new ForwardTo(mXcapUri, NODE_NAME, mIntendedId,
+                        domElement);
+            } else {
+                actionNode = domElement.getElementsByTagName(XCAP_ALIAS + ":" + TAG_FORWARD_TO);
+                if (actionNode.getLength() > 0) {
+                    mForwardTo = new ForwardTo(mXcapUri, NODE_NAME, mIntendedId,
+                            domElement);
+                } else {
+                    mForwardTo = new ForwardTo(mXcapUri, NODE_NAME, mIntendedId);
+                }
+            }
+        }
+    }
+
+    /**
+     * Convert to XML element.
+     *
+     * @param document  dom document
+     * @return XML format element
+     */
+    public Element toXmlElement(Document document) {
+        Element actionsElement = (Element) document.createElement(NODE_NAME);
+
+        if (mForwardTo != null) {
+            Element forwardToElement = mForwardTo.toXmlElement(document);
+            actionsElement.appendChild(forwardToElement);
+        } else {
+            String useXcapNs = System.getProperty("xcap.ns.ss", "false");
+
+            if ("true".equals(useXcapNs)) {
+                Element allowElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_ALLOW);
+                allowElement.setTextContent(mAllow ? "true" : "false");
+                actionsElement.appendChild(allowElement);
+            } else {
+                Element allowElement = (Element) document.createElement(TAG_ALLOW);
+                allowElement.setTextContent(mAllow ? "true" : "false");
+                actionsElement.appendChild(allowElement);
+            }
+        }
+        return actionsElement;
+    }
+
+    public void setAllow(boolean allow) {
+        mAllow = allow;
+    }
+
+    public boolean isAllow() {
+        return mAllow;
+    }
+
+    /**
+     * Set ForwardTo value.
+     *
+     * @param target        forward number
+     * @param notifyCaller  whether to notify caller
+     */
+    public void setFowardTo(String target, boolean notifyCaller) {
+        if (mForwardTo == null) {
+            mForwardTo = new ForwardTo(mXcapUri, mParentUri, mIntendedId);
+        }
+        mForwardTo.setTarget(target);
+        mForwardTo.setNotifyCaller(notifyCaller);
+    }
+
+    public ForwardTo getFowardTo() {
+        return mForwardTo;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Conditions.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Conditions.java
new file mode 100644
index 0000000..242bb27
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Conditions.java
@@ -0,0 +1,733 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * Condition class.
+ *
+ */
+public class Conditions extends XcapElement implements ConfigureType {
+    public static final String NODE_NAME = "cp:conditions";
+
+    static final String TAG_BUSY = "busy";
+    static final String TAG_NO_ANSWER = "no-answer";
+    static final String TAG_NOT_REACHABLE = "not-reachable";
+    static final String TAG_NOT_REGISTERED = "not-registered";
+    static final String TAG_ROAMING = "roaming";
+    static final String TAG_RULE_DEACTIVATED = "rule-deactivated";
+    static final String TAG_INTERNATIONAL = "international";
+    static final String TAG_INTERNATIONAL_EXHC = "international-exHC";
+    static final String TAG_COMMUNICATION_DIVERTED = "communication-diverted";
+    static final String TAG_PRESENCE_STATUS = "presence-status";
+    static final String TAG_MEDIA = "media";
+    static final String TAG_ANONYMOUS = "anonymous";
+    static final String TAG_TIME = "time";
+
+    public boolean mComprehendBusy = false;
+    public boolean mComprehendNoAnswer = false;
+    public boolean mComprehendNotReachable = false;
+    public boolean mComprehendNotRegistered = false;
+    public boolean mComprehendRoaming = false;
+    public boolean mComprehendRuleDeactivated = false;
+    public boolean mComprehendInternational = false;
+    public boolean mComprehendInternationalexHc = false;
+    public boolean mComprehendCommunicationDiverted = false;
+    public boolean mComprehendPresenceStatus = false;
+    public boolean mComprehendAnonymous = false;
+    public String  mComprehendTime;
+
+    public List<String> mMedias;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Conditions(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructor with XML element.
+     *
+     * @param xcapUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM element
+     */
+    public Conditions(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        String conditionsPrefix = XCAP_ALIAS + ":";
+        // TODO Auto-generated method stub
+        NodeList conditionsNode = domElement.getElementsByTagName(TAG_BUSY);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendBusy = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_BUSY);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendBusy = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_BUSY);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendBusy = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_NO_ANSWER);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendNoAnswer = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_NO_ANSWER);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendNoAnswer = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_NO_ANSWER);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendNoAnswer = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_NOT_REACHABLE);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendNotReachable = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_NOT_REACHABLE);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendNotReachable = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_NOT_REACHABLE);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendNotReachable = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_NOT_REGISTERED);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendNotRegistered = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_NOT_REGISTERED);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendNotRegistered = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_NOT_REGISTERED);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendNotRegistered = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_ROAMING);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendRoaming = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_ROAMING);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendRoaming = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_ROAMING);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendRoaming = true;
+                }
+            }
+        }
+
+
+        conditionsNode = domElement.getElementsByTagName(TAG_RULE_DEACTIVATED);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendRuleDeactivated = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_RULE_DEACTIVATED);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendRuleDeactivated = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_RULE_DEACTIVATED);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendRuleDeactivated = true;
+                }
+            }
+        }
+
+
+        conditionsNode = domElement.getElementsByTagName(TAG_INTERNATIONAL);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendInternational = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_INTERNATIONAL);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendInternational = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_INTERNATIONAL);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendInternational = true;
+                }
+            }
+        }
+
+
+        conditionsNode = domElement.getElementsByTagName(TAG_INTERNATIONAL_EXHC);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendInternationalexHc = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_INTERNATIONAL_EXHC);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendInternationalexHc = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_INTERNATIONAL_EXHC);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendInternationalexHc = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_COMMUNICATION_DIVERTED);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendCommunicationDiverted = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_COMMUNICATION_DIVERTED);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendCommunicationDiverted = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_COMMUNICATION_DIVERTED);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendCommunicationDiverted = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_PRESENCE_STATUS);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendPresenceStatus = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_PRESENCE_STATUS);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendPresenceStatus = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(
+                        conditionsPrefix + TAG_PRESENCE_STATUS);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendPresenceStatus = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_MEDIA);
+        mMedias = new LinkedList<String>();
+        if (conditionsNode.getLength() > 0) {
+            for (int i = 0; i < conditionsNode.getLength(); i++) {
+                Element mediaElement = (Element) conditionsNode.item(i);
+                mMedias.add(mediaElement.getTextContent());
+            }
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_MEDIA);
+            if (conditionsNode.getLength() > 0) {
+                for (int i = 0; i < conditionsNode.getLength(); i++) {
+                    Element mediaElement = (Element) conditionsNode.item(i);
+                    mMedias.add(mediaElement.getTextContent());
+                }
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_MEDIA);
+                if (conditionsNode.getLength() > 0) {
+                    for (int i = 0; i < conditionsNode.getLength(); i++) {
+                        Element mediaElement = (Element) conditionsNode.item(i);
+                        mMedias.add(mediaElement.getTextContent());
+                    }
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_ANONYMOUS);
+        if (conditionsNode.getLength() > 0) {
+            mComprehendAnonymous = true;
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_ANONYMOUS);
+            if (conditionsNode.getLength() > 0) {
+                mComprehendAnonymous = true;
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_ANONYMOUS);
+                if (conditionsNode.getLength() > 0) {
+                    mComprehendAnonymous = true;
+                }
+            }
+        }
+
+        conditionsNode = domElement.getElementsByTagName(TAG_TIME);
+        if (conditionsNode.getLength() > 0) {
+            Element timeElement = (Element) conditionsNode.item(0);
+            mComprehendTime = timeElement.getTextContent();
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_TIME);
+            if (conditionsNode.getLength() > 0) {
+                Element timeElement = (Element) conditionsNode.item(0);
+                mComprehendTime = timeElement.getTextContent();
+            } else {
+                conditionsNode = domElement.getElementsByTagName(conditionsPrefix + TAG_TIME);
+                if (conditionsNode.getLength() > 0) {
+                    Element timeElement = (Element) conditionsNode.item(0);
+                    mComprehendTime = timeElement.getTextContent();
+                }
+            }
+        }
+
+    }
+
+    /**
+     * Convert to XML.
+     *
+     * @param   document DOM document
+     * @return  XML element
+     */
+    public Element toXmlElement(Document document) {
+        String useXcapNs = System.getProperty("xcap.ns.ss", "false");
+
+        if ("true".equals(useXcapNs)) {
+            Element conditionsElement = (Element) document.createElement(NODE_NAME);
+
+            if (comprehendBusy()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_BUSY);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNoAnswer()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NO_ANSWER);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNotReachable()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOT_REACHABLE);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNotRegistered()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOT_REGISTERED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendRoaming()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_ROAMING);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendRuleDeactivated()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_RULE_DEACTIVATED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendInternational()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_INTERNATIONAL);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendInternationalExHc()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_INTERNATIONAL_EXHC);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendCommunicationDiverted()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_COMMUNICATION_DIVERTED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendPresenceStatus()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_PRESENCE_STATUS);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (mMedias != null) {
+                if (mMedias.size() > 0) {
+                    Iterator<String> it = mMedias.iterator();
+                    while (it.hasNext()) {
+                        Element ruleElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                                "ss:" + TAG_MEDIA);
+                        ruleElement.setTextContent(it.next());
+                        conditionsElement.appendChild(ruleElement);
+                    }
+                }
+            }
+
+            if (comprehendAnonymous()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_ANONYMOUS);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendTime() != null && !comprehendTime().isEmpty()) {
+                Element conditionElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_TIME);
+                conditionElement.setTextContent(mComprehendTime);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            return conditionsElement;
+        } else {
+            Element conditionsElement = (Element) document.createElement(NODE_NAME);
+
+            if (comprehendBusy()) {
+                Element conditionElement = (Element) document.createElement(TAG_BUSY);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNoAnswer()) {
+                Element conditionElement = (Element) document.createElement(TAG_NO_ANSWER);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNotReachable()) {
+                Element conditionElement = (Element) document.createElement(TAG_NOT_REACHABLE);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendNotRegistered()) {
+                Element conditionElement = (Element) document.createElement(TAG_NOT_REGISTERED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendRoaming()) {
+                Element conditionElement = (Element) document.createElement(TAG_ROAMING);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendRuleDeactivated()) {
+                Element conditionElement = (Element) document.createElement(TAG_RULE_DEACTIVATED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendInternational()) {
+                Element conditionElement = (Element) document.createElement(TAG_INTERNATIONAL);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendInternationalExHc()) {
+                Element conditionElement = (Element) document.createElement(TAG_INTERNATIONAL_EXHC);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendCommunicationDiverted()) {
+                Element conditionElement =
+                        (Element) document.createElement(TAG_COMMUNICATION_DIVERTED);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendPresenceStatus()) {
+                Element conditionElement = (Element) document.createElement(TAG_PRESENCE_STATUS);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (mMedias != null) {
+                if (mMedias.size() > 0) {
+                    Iterator<String> it = mMedias.iterator();
+                    while (it.hasNext()) {
+                        Element ruleElement = (Element) document.createElement(TAG_MEDIA);
+                        ruleElement.setTextContent(it.next());
+                        conditionsElement.appendChild(ruleElement);
+                    }
+                }
+            }
+
+            if (comprehendAnonymous()) {
+                Element conditionElement = (Element) document.createElement(TAG_ANONYMOUS);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            if (comprehendTime() != null && !comprehendTime().isEmpty()) {
+                Element conditionElement = (Element) document.createElement(TAG_TIME);
+                conditionElement.setTextContent(mComprehendTime);
+                conditionsElement.appendChild(conditionElement);
+            }
+
+            return conditionsElement;
+        }
+    }
+
+    /**
+     * Turn on Busy.
+     *
+     */
+    public void addBusy() {
+        mComprehendBusy = true;
+    }
+
+    /**
+     * Turn on NoAnswer.
+     *
+     */
+    public void addNoAnswer() {
+        mComprehendNoAnswer = true;
+    }
+
+    /**
+     * Turn on NotReachable.
+     *
+     */
+    public void addNotReachable() {
+        mComprehendNotReachable = true;
+    }
+
+    /**
+     * Turn on NotRegistered.
+     *
+     */
+    public void addNotRegistered() {
+        mComprehendNotRegistered = true;
+    }
+
+    /**
+     * Turn on Roaming.
+     *
+     */
+    public void addRoaming() {
+        mComprehendRoaming = true;
+    }
+
+    /**
+     * Turn on RuleDeactivated.
+     *
+     */
+    public void addRuleDeactivated() {
+        mComprehendRuleDeactivated = true;
+    }
+
+    /**
+     * Turn on International.
+     *
+     */
+    public void addInternational() {
+        mComprehendInternational = true;
+    }
+
+    /**
+     * Turn on InternationalExHc.
+     *
+     */
+    public void addInternationalExHc() {
+        mComprehendInternationalexHc = true;
+    }
+
+    /**
+     * Turn on CommunicationDiverted.
+     *
+     */
+    public void addCommunicationDiverted() {
+        mComprehendCommunicationDiverted = true;
+    }
+
+    /**
+     * Turn on PresenceStatus.
+     *
+     */
+    public void addPresenceStatus() {
+        mComprehendPresenceStatus = true;
+    }
+
+    /**
+     * Turn on Anonymous.
+     *
+     */
+    public void addAnonymous() {
+        mComprehendAnonymous = true;
+    }
+
+    /**
+     * Get Busy value.
+     *
+     * @return value
+     */
+    public boolean comprehendBusy() {
+        return mComprehendBusy;
+    }
+
+    /**
+     * Get NoAnswer value.
+     *
+     * @return value
+     */
+    public boolean comprehendNoAnswer() {
+        return mComprehendNoAnswer;
+    }
+
+    /**
+     * Get NotReachable value.
+     *
+     * @return value
+     */
+    public boolean comprehendNotReachable() {
+        return mComprehendNotReachable;
+    }
+
+    /**
+     * Get NotRegistered value.
+     *
+     * @return value
+     */
+    public boolean comprehendNotRegistered() {
+        return mComprehendNotRegistered;
+    }
+
+    /**
+     * Get Romaing value.
+     *
+     * @return value
+     */
+    public boolean comprehendRoaming() {
+        return mComprehendRoaming;
+    }
+
+    /**
+     * Get RuleDeactivated value.
+     *
+     * @return value
+     */
+    public boolean comprehendRuleDeactivated() {
+        return mComprehendRuleDeactivated;
+    }
+
+    /**
+     * Get International value.
+     *
+     * @return value
+     */
+    public boolean comprehendInternational() {
+        return mComprehendInternational;
+    }
+
+    /**
+     * Get InternationalExHc value.
+     *
+     * @return value
+     */
+    public boolean comprehendInternationalExHc() {
+        return mComprehendInternationalexHc;
+    }
+
+    /**
+     * Get Communication Diverted value.
+     *
+     * @return value
+     */
+    public boolean comprehendCommunicationDiverted() {
+        return mComprehendCommunicationDiverted;
+    }
+
+    /**
+     * Get PresenceStatus value.
+     *
+     * @return value
+     */
+    public boolean comprehendPresenceStatus() {
+        return mComprehendPresenceStatus;
+    }
+
+    /**
+     * Get Anonymous value.
+     *
+     * @return value
+     */
+    public boolean comprehendAnonymous() {
+        return mComprehendAnonymous;
+    }
+
+    /**
+     * Add Time value.
+     *
+     * @param   time   time value
+     */
+    public void addTime(String time) {
+        mComprehendTime = time;
+    }
+
+    /**
+     * Get Time value.
+     *
+     * @return value
+     */
+    public String comprehendTime() {
+        return mComprehendTime;
+    }
+
+    /**
+     * Add Media value.
+     *
+     * @param   media   media value
+     */
+    public void addMedia(String media) {
+        if (mMedias == null) {
+            mMedias = new LinkedList<String>();
+        }
+        mMedias.add(media);
+    }
+
+    public List<String> getMedias() {
+        return mMedias;
+    }
+
+    /**
+     * Reset condition value.
+     *
+     */
+    public void clearConditions() {
+        mComprehendBusy = false;
+        mComprehendNoAnswer = false;
+        mComprehendNotReachable = false;
+        mComprehendNotRegistered = false;
+        mComprehendRoaming = false;
+        mComprehendRuleDeactivated = false;
+        mComprehendInternational = false;
+        mComprehendCommunicationDiverted = false;
+        mComprehendPresenceStatus = false;
+        if (mMedias == null) {
+            mMedias = new LinkedList<String>();
+        }
+
+        mMedias.clear();
+        mComprehendAnonymous = false;
+        mComprehendTime = null;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/ForwardTo.java b/packages/simservs/src/com/mediatek/simservs/client/policy/ForwardTo.java
new file mode 100644
index 0000000..297fbd7
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/ForwardTo.java
@@ -0,0 +1,401 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * ForwardTo class.
+ *
+ */
+public class ForwardTo extends XcapElement implements ConfigureType {
+    public static final String NODE_NAME = "forward-to";
+
+    static final String TAG_TARGET = "target";
+    static final String TAG_NOTIFY_CALLER = "notify-caller";
+    static final String TAG_REVEAL_IDENTITY_TO_CALLER = "reveal-identity-to-caller";
+    static final String TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER =
+            "reveal-served-user-identity-to-caller";
+    static final String TAG_NOTIFY_SERVED_USER = "notify-served-user";
+    static final String TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL =
+            "notify-served-user-on-outbound-call";
+    static final String TAG_REVEAL_IDENTITY_TO_TARGET = "reveal-identity-to-target";
+
+    public String mTarget; //minOccurs=1 maxOccurs=1
+    public boolean mNotifyCaller = true; //minOccurs=0
+    public boolean mRevealIdentityToCaller = true; //minOccurs=0
+    public boolean mRevealServedUserIdentityToCaller = true; //minOccurs=0
+    public boolean mNotifyServedUser = false; //minOccurs=0
+    public boolean mNotifyServedUserOnOutboundCall = false; //minOccurs=0
+    public boolean mRevealIdentityToTarget = true; //minOccurs=0
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public ForwardTo(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+        // TODO Auto-generated constructor stub
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri   XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM element
+     */
+    public ForwardTo(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        // TODO Auto-generated constructor stub
+
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        NodeList forwardToNode = domElement.getElementsByTagName(TAG_TARGET);
+        if (forwardToNode.getLength() > 0) {
+            Element targetElement = (Element) forwardToNode.item(0);
+            mTarget = targetElement.getTextContent();
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_TARGET);
+            if (forwardToNode.getLength() > 0) {
+                Element targetElement = (Element) forwardToNode.item(0);
+                mTarget = targetElement.getTextContent();
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_TARGET);
+                if (forwardToNode.getLength() > 0) {
+                    Element targetElement = (Element) forwardToNode.item(0);
+                    mTarget = targetElement.getTextContent();
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_NOTIFY_CALLER);
+        if (forwardToNode.getLength() > 0) {
+            Element notifyCallerElement = (Element) forwardToNode.item(0);
+            String notifyCaller = notifyCallerElement.getTextContent();
+            mNotifyCaller = notifyCaller.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE, TAG_NOTIFY_CALLER);
+            if (forwardToNode.getLength() > 0) {
+                Element notifyCallerElement = (Element) forwardToNode.item(0);
+                String notifyCaller = notifyCallerElement.getTextContent();
+                mNotifyCaller = notifyCaller.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_NOTIFY_CALLER);
+                if (forwardToNode.getLength() > 0) {
+                    Element notifyCallerElement = (Element) forwardToNode.item(0);
+                    String notifyCaller = notifyCallerElement.getTextContent();
+                    mNotifyCaller = notifyCaller.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_REVEAL_IDENTITY_TO_CALLER);
+        if (forwardToNode.getLength() > 0) {
+            Element revealCallerElement = (Element) forwardToNode.item(0);
+            String revealCaller = revealCallerElement.getTextContent();
+            mRevealIdentityToCaller = revealCaller.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_REVEAL_IDENTITY_TO_CALLER);
+            if (forwardToNode.getLength() > 0) {
+                Element revealCallerElement = (Element) forwardToNode.item(0);
+                String revealCaller = revealCallerElement.getTextContent();
+                mRevealIdentityToCaller = revealCaller.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_REVEAL_IDENTITY_TO_CALLER);
+                if (forwardToNode.getLength() > 0) {
+                    Element revealCallerElement = (Element) forwardToNode.item(0);
+                    String revealCaller = revealCallerElement.getTextContent();
+                    mRevealIdentityToCaller = revealCaller.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_REVEAL_IDENTITY_TO_TARGET);
+        if (forwardToNode.getLength() > 0) {
+            Element revealTargetElement = (Element) forwardToNode.item(0);
+            String revealTarget = revealTargetElement.getTextContent();
+            mRevealIdentityToTarget = revealTarget.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_REVEAL_IDENTITY_TO_TARGET);
+            if (forwardToNode.getLength() > 0) {
+                Element revealTargetElement = (Element) forwardToNode.item(0);
+                String revealTarget = revealTargetElement.getTextContent();
+                mRevealIdentityToTarget = revealTarget.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_REVEAL_IDENTITY_TO_TARGET);
+                if (forwardToNode.getLength() > 0) {
+                    Element revealTargetElement = (Element) forwardToNode.item(0);
+                    String revealTarget = revealTargetElement.getTextContent();
+                    mRevealIdentityToTarget = revealTarget.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+        if (forwardToNode.getLength() > 0) {
+            Element element = (Element) forwardToNode.item(0);
+            String str = element.getTextContent();
+            mRevealServedUserIdentityToCaller = str.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+            if (forwardToNode.getLength() > 0) {
+                Element element = (Element) forwardToNode.item(0);
+                String str = element.getTextContent();
+                mRevealServedUserIdentityToCaller = str.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+                if (forwardToNode.getLength() > 0) {
+                    Element element = (Element) forwardToNode.item(0);
+                    String str = element.getTextContent();
+                    mRevealServedUserIdentityToCaller = str.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_NOTIFY_SERVED_USER);
+        if (forwardToNode.getLength() > 0) {
+            Element element = (Element) forwardToNode.item(0);
+            String str = element.getTextContent();
+            mNotifyServedUser = str.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_NOTIFY_SERVED_USER);
+            if (forwardToNode.getLength() > 0) {
+                Element element = (Element) forwardToNode.item(0);
+                String str = element.getTextContent();
+                mNotifyServedUser = str.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_NOTIFY_SERVED_USER);
+                if (forwardToNode.getLength() > 0) {
+                    Element element = (Element) forwardToNode.item(0);
+                    String str = element.getTextContent();
+                    mNotifyServedUser = str.equals("true");
+                }
+            }
+        }
+
+        forwardToNode = domElement.getElementsByTagName(TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+        if (forwardToNode.getLength() > 0) {
+            Element element = (Element) forwardToNode.item(0);
+            String str = element.getTextContent();
+            mNotifyServedUserOnOutboundCall = str.equals("true");
+        } else {
+            forwardToNode = domElement.getElementsByTagNameNS(XCAP_NAMESPACE,
+                    TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+            if (forwardToNode.getLength() > 0) {
+                Element element = (Element) forwardToNode.item(0);
+                String str = element.getTextContent();
+                mNotifyServedUserOnOutboundCall = str.equals("true");
+            } else {
+                forwardToNode = domElement.getElementsByTagName(
+                        XCAP_ALIAS + ":" + TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+                if (forwardToNode.getLength() > 0) {
+                    Element element = (Element) forwardToNode.item(0);
+                    String str = element.getTextContent();
+                    mNotifyServedUserOnOutboundCall = str.equals("true");
+                }
+            }
+        }
+    }
+
+    /**
+     * Convert to XML element.
+     *
+     * @param document DOM document
+     * @return XML element
+     */
+    public Element toXmlElement(Document document) {
+
+        String useXcapNs = System.getProperty("xcap.ns.ss", "false");
+
+        if ("true".equals(useXcapNs)) {
+            Element forwardElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                    "ss:" + NODE_NAME);
+
+            Element allowElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                    "ss:" + TAG_TARGET);
+            allowElement.setTextContent(mTarget);
+            forwardElement.appendChild(allowElement);
+
+            String completeForwardTo = System.getProperty("xcap.completeforwardto",
+                    "false");
+
+            if ("true".equals(completeForwardTo)) {
+                Element notifyCallerElement = (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOTIFY_CALLER);
+                notifyCallerElement.setTextContent(mNotifyCaller ? "true" : "false");
+                forwardElement.appendChild(notifyCallerElement);
+
+                Element revealIdentityToCallerElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_REVEAL_IDENTITY_TO_CALLER);
+                revealIdentityToCallerElement.setTextContent(
+                            mRevealIdentityToCaller ? "true" : "false");
+                forwardElement.appendChild(revealIdentityToCallerElement);
+
+                Element revealServedUserIdentityToCallerElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+                revealServedUserIdentityToCallerElement.setTextContent(
+                            mRevealServedUserIdentityToCaller ? "true" : "false");
+                forwardElement.appendChild(revealServedUserIdentityToCallerElement);
+
+                Element notifyServedUserElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOTIFY_SERVED_USER);
+                notifyServedUserElement.setTextContent(mNotifyServedUser ? "true" : "false");
+                forwardElement.appendChild(notifyServedUserElement);
+
+                Element notifyServedUserOnOutboundCallElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+                notifyServedUserOnOutboundCallElement.setTextContent(
+                        mNotifyServedUserOnOutboundCall ? "true" : "false");
+                forwardElement.appendChild(notifyServedUserOnOutboundCallElement);
+
+                Element revealIdentityToTargetElement =
+                        (Element) document.createElementNS(XCAP_NAMESPACE,
+                        "ss:" + TAG_REVEAL_IDENTITY_TO_TARGET);
+                revealIdentityToTargetElement.setTextContent(
+                        mRevealIdentityToTarget ? "true" : "false");
+                forwardElement.appendChild(revealIdentityToTargetElement);
+            }
+
+            return forwardElement;
+        } else {
+            Element forwardElement = (Element) document.createElement(NODE_NAME);
+
+            Element allowElement = (Element) document.createElement(TAG_TARGET);
+            allowElement.setTextContent(mTarget);
+            forwardElement.appendChild(allowElement);
+
+            String completeForwardTo = System.getProperty("xcap.completeforwardto",
+                    "false");
+
+            if ("true".equals(completeForwardTo)) {
+                Element notifyCallerElement = (Element) document.createElement(TAG_NOTIFY_CALLER);
+                notifyCallerElement.setTextContent(mNotifyCaller ? "true" : "false");
+                forwardElement.appendChild(notifyCallerElement);
+
+                Element revealIdentityToCallerElement =
+                        (Element) document.createElement(TAG_REVEAL_IDENTITY_TO_CALLER);
+                revealIdentityToCallerElement.setTextContent(
+                        mRevealIdentityToCaller ? "true" : "false");
+                forwardElement.appendChild(revealIdentityToCallerElement);
+
+                Element revealServedUserIdentityToCallerElement =
+                        (Element) document.createElement(TAG_REVEAL_SERVED_USER_IDENTITY_TO_CALLER);
+                revealServedUserIdentityToCallerElement.setTextContent(
+                        mRevealServedUserIdentityToCaller ? "true" : "false");
+                forwardElement.appendChild(revealServedUserIdentityToCallerElement);
+
+                Element notifyServedUserElement =
+                        (Element) document.createElement(TAG_NOTIFY_SERVED_USER);
+                notifyServedUserElement.setTextContent(mNotifyServedUser ? "true" : "false");
+                forwardElement.appendChild(notifyServedUserElement);
+
+                Element notifyServedUserOnOutboundCallElement =
+                        (Element) document.createElement(TAG_NOTIFY_SERVED_USER_ON_OUTBOUND_CALL);
+                notifyServedUserOnOutboundCallElement.setTextContent(
+                        mNotifyServedUserOnOutboundCall ? "true" : "false");
+                forwardElement.appendChild(notifyServedUserOnOutboundCallElement);
+
+                Element revealIdentityToTargetElement =
+                        (Element) document.createElement(TAG_REVEAL_IDENTITY_TO_TARGET);
+                revealIdentityToTargetElement.setTextContent(
+                        mRevealIdentityToTarget ? "true" : "false");
+                forwardElement.appendChild(revealIdentityToTargetElement);
+            }
+
+            return forwardElement;
+        }
+
+
+    }
+
+    public void setTarget(String target) {
+        mTarget = target;
+    }
+
+    public void setNotifyCaller(boolean notifyCaller) {
+        mNotifyCaller = notifyCaller;
+    }
+
+    public void setRevealIdentityToCaller(boolean revealIdToCaller) {
+        mRevealIdentityToCaller = revealIdToCaller;
+    }
+
+    public void setRevealServedUserIdentityToCaller(boolean revealIdToCaller) {
+        mRevealServedUserIdentityToCaller = revealIdToCaller;
+    }
+
+    public void setNotifyServedUser(boolean notifyToServedUser) {
+        mNotifyServedUser = notifyToServedUser;
+    }
+
+    public void setNotifyServedUserOnOutboundCall(boolean notifyToServedUser) {
+        mNotifyServedUserOnOutboundCall = notifyToServedUser;
+    }
+
+    public void setRevealIdentityToTarget(boolean revealIdToTarget) {
+        mRevealIdentityToTarget = revealIdToTarget;
+    }
+
+    public String getTarget() {
+        return mTarget;
+    }
+
+    public boolean isNotifyCaller() {
+        return mNotifyCaller;
+    }
+
+    public boolean isRevealIdentityToCaller() {
+        return mRevealIdentityToCaller;
+    }
+
+    public boolean isRevealServedUserIdentityToCaller() {
+        return mRevealServedUserIdentityToCaller;
+    }
+
+    public boolean isNotifyServedUse() {
+        return mNotifyServedUser;
+    }
+
+    public boolean isNotifyServedUserOnOutboundCall() {
+        return mNotifyServedUserOnOutboundCall;
+    }
+
+    public boolean isRevealIdentityToTarget() {
+        return mRevealIdentityToTarget;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Rule.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Rule.java
new file mode 100644
index 0000000..3a53b34
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Rule.java
@@ -0,0 +1,221 @@
+
+package com.mediatek.simservs.client.policy;
+
+import android.util.Log;
+
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.simservs.xcap.XcapException;
+
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.net.URISyntaxException;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+
+/**
+ * Rule class.
+ */
+public class Rule extends XcapElement implements ConfigureType {
+    public static final String NODE_NAME = "cp:rule";
+    public static final String NODE_XML_NAMESPACE =
+            "?xmlns(" + COMMON_POLICY_ALIAS + "=" + COMMON_POLICY_NAMESPACE + ")";
+
+    public String mId = "none";
+    public Conditions mConditions;
+    public Actions mActions;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     */
+    public Rule(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Constructor with XML element.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM element
+     */
+    public Rule(XcapUri xcapUri, String parentUri, String intendedId,
+            Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+        mId = domElement.getAttribute("id");
+        NodeList conditionsNode = domElement.getElementsByTagName("conditions");
+        if (conditionsNode.getLength() > 0) {
+            mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId,
+                    (Element) conditionsNode.item(0));
+        } else {
+            conditionsNode = domElement.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE,
+                    "conditions");
+            if (conditionsNode.getLength() > 0) {
+                mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId,
+                        (Element) conditionsNode.item(0));
+            } else {
+                conditionsNode = domElement.getElementsByTagName("cp:conditions");
+                if (conditionsNode.getLength() > 0) {
+                    mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId,
+                            (Element) conditionsNode.item(0));
+                } else {
+                    mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId);
+                }
+            }
+        }
+
+        NodeList actionsNode = domElement.getElementsByTagName("actions");
+        if (actionsNode.getLength() > 0) {
+            mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId,
+                    (Element) actionsNode.item(0));
+        } else {
+            actionsNode = domElement.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "actions");
+            if (actionsNode.getLength() > 0) {
+                mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId,
+                        (Element) actionsNode.item(0));
+            } else {
+                actionsNode = domElement.getElementsByTagName("cp:actions");
+                if (actionsNode.getLength() > 0) {
+                    mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId,
+                            (Element) actionsNode.item(0));
+                } else {
+                    mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId);
+                }
+            }
+        }
+    }
+
+    /**
+     * Convert to XML element.
+     *
+     * @param  document DOM document
+     * @return DOM element
+     * @throws TransformerException if conversion error
+     */
+    public Element toXmlElement(Document document) throws TransformerException {
+        Element ruleElement = (Element) document.createElement(NODE_NAME);
+        ruleElement.setAttribute("id", mId);
+
+        if (mConditions != null) {
+            Element conditionsElement = mConditions.toXmlElement(document);
+            ruleElement.appendChild(conditionsElement);
+        }
+
+        if (mActions != null) {
+            Element actionsElement = mActions.toXmlElement(document);
+            ruleElement.appendChild(actionsElement);
+        }
+        return ruleElement;
+    }
+
+    /**
+     * Create actions.
+     *
+     * @return actions
+     */
+    public Actions createActions() {
+        if (mActions == null) {
+            mActions = new Actions(mXcapUri, NODE_NAME, mIntendedId);
+        }
+        return mActions;
+    }
+
+    /**
+     * Create conditions.
+     *
+     * @return conditions
+     */
+    public Conditions createConditions() {
+        if (mConditions == null) {
+            mConditions = new Conditions(mXcapUri, NODE_NAME, mIntendedId);
+        }
+        return mConditions;
+    }
+
+    public void setId(String id) {
+        mId = id;
+    }
+
+    public Conditions getConditions() {
+        return mConditions;
+    }
+
+    public Actions getActions() {
+        return mActions;
+    }
+
+    /**
+     * Sets the content of the current node.
+     *
+     * @param  xml XML string
+     * @throws XcapException if XCAP error
+     */
+    @Override
+    public void setContent(String xml) throws XcapException {
+        try {
+            mNodeUri = getNodeUri().toString();
+
+            if (getNodeName().equals(Rule.NODE_NAME)) {
+                //add rule id selector
+                mNodeUri += "%5b@id=%22" + mId.replaceAll(" ", "%20") +
+                        "%22%5d" + NODE_XML_NAMESPACE;
+            }
+            Log.d("Rule", "setContent etag=" + mEtag);
+            saveContent(xml);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Convert rule to XML string.
+     *
+     * @return  XML string
+     */
+    public String toXmlString() {
+        Element root = null;
+        String xmlString = null;
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document document = builder.newDocument();
+            root = (Element) this.toXmlElement(document);
+            document.appendChild(root);
+            xmlString = domToXmlText(root);
+        } catch (ParserConfigurationException pce) {
+            // Parser with specified options can't be built
+            pce.printStackTrace();
+        } catch (TransformerConfigurationException e) {
+            e.printStackTrace();
+        } catch (TransformerException e) {
+            e.printStackTrace();
+        }
+        return xmlString;
+    }
+
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/RuleSet.java b/packages/simservs/src/com/mediatek/simservs/client/policy/RuleSet.java
new file mode 100644
index 0000000..1b4dc19
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/RuleSet.java
@@ -0,0 +1,392 @@
+
+package com.mediatek.simservs.client.policy;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.SimServs;
+import com.mediatek.simservs.xcap.ConfigureType;
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.TransformerConfigurationException;
+import javax.xml.transform.TransformerException;
+
+/**
+ * Rule class.
+ */
+public class RuleSet extends XcapElement implements ConfigureType {
+
+    public static final String NODE_NAME = COMMON_POLICY_ALIAS + ":ruleset";
+    public static final String NODE_NAME_WITH_NAMESPACE = NODE_NAME +
+            "?xmlns(" + COMMON_POLICY_ALIAS + "=" + COMMON_POLICY_NAMESPACE + ")";
+    public List<Rule> mRules;
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public RuleSet(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+        mRules = new LinkedList<Rule>();
+    }
+
+    /**
+     * Constructor with XML element.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     * @param domElement    DOM element
+     */
+    public RuleSet(XcapUri xcapUri, String parentUri, String intendedId, Element domElement) {
+        super(xcapUri, parentUri, intendedId);
+        instantiateFromXmlNode(domElement);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME_WITH_NAMESPACE;
+    }
+
+    @Override
+    public void instantiateFromXmlNode(Node domNode) {
+        if (SimServs.LIB_CONFIG_MULTIPLE_RULE_CONDITIONS) {
+            Element domElement = (Element) domNode;
+            NodeList domNodes = domElement.getElementsByTagName("rule");
+            mRules = new LinkedList<Rule>();
+            if (domNodes.getLength() > 0) {
+                Log.d("RuleSet", "Got rule");
+                for (int i = 0; i < domNodes.getLength(); i++) {
+                    Element element = (Element) domNodes.item(i);
+                    Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                            element);
+                    if (mNetwork != null) {
+                        aRule.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        aRule.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        aRule.setEtag(mEtag);
+                    }
+
+                    mRules.add(aRule);
+                }
+            }
+
+            domNodes = domElement.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "rule");
+            if (domNodes.getLength() > 0) {
+                Log.d("RuleSet", "Got rule");
+                for (int i = 0; i < domNodes.getLength(); i++) {
+                    Element element = (Element) domNodes.item(i);
+                    Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                            element);
+                    if (mNetwork != null) {
+                        aRule.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        aRule.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        aRule.setEtag(mEtag);
+                    }
+
+                    mRules.add(aRule);
+                }
+            } else {
+                domNodes = domElement.getElementsByTagName("cp:rule");
+                if (domNodes.getLength() > 0) {
+                    Log.d("RuleSet", "Got cp:rule");
+                    for (int i = 0; i < domNodes.getLength(); i++) {
+                        Element element = (Element) domNodes.item(i);
+                        Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME,
+                                mIntendedId, element);
+                        if (mNetwork != null) {
+                            aRule.setNetwork(mNetwork);
+                        }
+
+                        if (mContext != null) {
+                            aRule.setContext(mContext);
+                        }
+
+                        if (mEtag != null) {
+                            aRule.setEtag(mEtag);
+                        }
+
+                        mRules.add(aRule);
+                    }
+                }
+            }
+
+            Log.d("RuleSet", "rules size:" + mRules.size());
+        } else {
+            // Unfold the conditions to more rules if multiple conditions exists
+            Element domElement = (Element) domNode;
+            NodeList domNodes = domElement.getElementsByTagName("rule");
+            mRules = new LinkedList<Rule>();
+            if (domNodes.getLength() > 0) {
+                Log.d("RuleSet", "Got rule");
+                for (int i = 0; i < domNodes.getLength(); i++) {
+                    Element element = (Element) domNodes.item(i);
+                    Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                            element);
+                    if (mNetwork != null) {
+                        aRule.setNetwork(mNetwork);
+                    }
+
+                    if (mContext != null) {
+                        aRule.setContext(mContext);
+                    }
+
+                    if (mEtag != null) {
+                        aRule.setEtag(mEtag);
+                    }
+
+                    Conditions conditions = aRule.getConditions();
+                    if (conditions != null) {
+                        List<String> medias = aRule.getConditions().getMedias();
+                        // Unfolding multiple medias
+                        if (medias != null && medias.size() > 0) {
+                            Iterator<String> it = medias.iterator();
+                            while (it.hasNext()) {
+                                unfoldRules(aRule, element, it.next());
+                            }
+                        } else {
+                            unfoldRules(aRule, element, null);
+                        }
+                    } else {
+                        mRules.add(aRule);
+                    }
+                }
+            } else {
+                domNodes = domElement.getElementsByTagNameNS(COMMON_POLICY_NAMESPACE, "rule");
+                if (domNodes.getLength() > 0) {
+                    Log.d("RuleSet", "Got rule");
+                    for (int i = 0; i < domNodes.getLength(); i++) {
+                        Element element = (Element) domNodes.item(i);
+                        Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                                element);
+                        if (mNetwork != null) {
+                            aRule.setNetwork(mNetwork);
+                        }
+
+                        if (mContext != null) {
+                            aRule.setContext(mContext);
+                        }
+                        if (mEtag != null) {
+                            aRule.setEtag(mEtag);
+                        }
+                        Conditions conditions = aRule.getConditions();
+                        if (conditions != null) {
+                            List<String> medias = aRule.getConditions().getMedias();
+                            // Unfolding multiple medias
+                            if (medias != null && medias.size() > 0) {
+                                Iterator<String> it = medias.iterator();
+                                while (it.hasNext()) {
+                                    unfoldRules(aRule, element, it.next());
+                                }
+                            } else {
+                                unfoldRules(aRule, element, null);
+                            }
+                        } else {
+                            mRules.add(aRule);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private void unfoldRules(Rule aRule, Element element, String media) {
+        if (aRule.getConditions().comprehendBusy()) {
+            Rule ruleBusy = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleBusy.setNetwork(mNetwork);
+            }
+            ruleBusy.getConditions().clearConditions();
+            ruleBusy.getConditions().addBusy();
+            if (media != null) {
+                ruleBusy.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleBusy);
+        }
+        if (aRule.getConditions().comprehendNotReachable()) {
+            Rule ruleNotReachable = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleNotReachable.setNetwork(mNetwork);
+            }
+            ruleNotReachable.getConditions().clearConditions();
+            ruleNotReachable.getConditions().addNotReachable();
+            if (media != null) {
+                ruleNotReachable.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleNotReachable);
+        }
+        if (aRule.getConditions().comprehendInternational()) {
+            Rule ruleInternational = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleInternational.setNetwork(mNetwork);
+            }
+            ruleInternational.getConditions().clearConditions();
+            ruleInternational.getConditions().addInternational();
+            if (media != null) {
+                ruleInternational.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleInternational);
+        }
+        if (aRule.getConditions().comprehendInternationalExHc()) {
+            Rule ruleInternationalExHc = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME,
+                    mIntendedId, element);
+            if (mNetwork != null) {
+                ruleInternationalExHc.setNetwork(mNetwork);
+            }
+            ruleInternationalExHc.getConditions().clearConditions();
+            ruleInternationalExHc.getConditions().addInternational();
+            if (media != null) {
+                ruleInternationalExHc.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleInternationalExHc);
+        }
+
+        if (aRule.getConditions().comprehendNoAnswer()) {
+            Rule ruleNoAnswer = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleNoAnswer.setNetwork(mNetwork);
+            }
+            ruleNoAnswer.getConditions().clearConditions();
+            ruleNoAnswer.getConditions().addNoAnswer();
+            if (media != null) {
+                ruleNoAnswer.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleNoAnswer);
+        }
+        if (aRule.getConditions().comprehendRoaming()) {
+            Rule ruleRoaming = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId,
+                    element);
+            if (mNetwork != null) {
+                ruleRoaming.setNetwork(mNetwork);
+            }
+            ruleRoaming.getConditions().clearConditions();
+            ruleRoaming.getConditions().addRoaming();
+            if (media != null) {
+                ruleRoaming.getConditions().addMedia(media);
+            }
+
+            mRules.add(ruleRoaming);
+        }
+    }
+
+    public List<Rule> getRules() {
+        return mRules;
+    }
+
+    /**
+     * Create rule.
+     *
+     * @param   id rule ID
+     * @return  new rule
+     */
+    public Rule createNewRule(String id) {
+        if (mRules == null) {
+            mRules = new LinkedList<Rule>();
+        }
+        Rule aRule = new Rule(mXcapUri, mParentUri + "/" + NODE_NAME, mIntendedId);
+        if (mNetwork != null) {
+            aRule.setNetwork(mNetwork);
+        }
+        if (mEtag != null) {
+            aRule.setEtag(mEtag);
+        }
+        aRule.setId(id);
+        mRules.add(aRule);
+        return aRule;
+    }
+
+    /**
+     * Empty rules.
+     */
+    public void clearRules() {
+        if (mRules == null) {
+            mRules = new LinkedList<Rule>();
+        }
+        mRules.clear();
+    }
+
+    /**
+     * Convert ruleset to XML string.
+     *
+     * @return  XML string
+     */
+    public String toXmlString() {
+        Element root = null;
+        String xmlString = null;
+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+        try {
+            DocumentBuilder builder = factory.newDocumentBuilder();
+            Document document = builder.newDocument();
+            root = (Element) document.createElement(NODE_NAME);
+            document.appendChild(root);
+            //Add by mtk01411: 2014-0128 to avoid Null Pointer Exception
+            if (mRules != null) {
+                Iterator<Rule> it = mRules.iterator();
+                while (it.hasNext()) {
+                    Rule rule = (Rule) it.next();
+                    Element ruleElement = rule.toXmlElement(document);
+                    root.appendChild(ruleElement);
+                }
+            }
+            xmlString = domToXmlText(root);
+        } catch (ParserConfigurationException pce) {
+            // Parser with specified options can't be built
+            pce.printStackTrace();
+        } catch (TransformerConfigurationException e) {
+            e.printStackTrace();
+        } catch (TransformerException e) {
+            e.printStackTrace();
+        }
+        return xmlString;
+    }
+
+    /**
+     * Set ETag value.
+     *
+     * @param etag value
+     */
+    @Override
+    public void setEtag(String etag) {
+        mEtag = etag;
+
+        for (Rule rule : mRules) {
+            Log.d("RuleSet", "rule:" + rule.mId + ", set etag:" + etag);
+            rule.setEtag(etag);
+        }
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Sphere.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Sphere.java
new file mode 100644
index 0000000..ce4146e
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Sphere.java
@@ -0,0 +1,29 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Spheret class.
+ */
+public class Sphere extends XcapElement {
+
+    public static final String NODE_NAME = "sphere";
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Sphere(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Transformations.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Transformations.java
new file mode 100644
index 0000000..3135baf
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Transformations.java
@@ -0,0 +1,29 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Transformations class.
+ */
+public class Transformations extends XcapElement {
+
+    public static final String NODE_NAME = "transformations";
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Transformations(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Until.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Until.java
new file mode 100644
index 0000000..674878a
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Until.java
@@ -0,0 +1,29 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Until class.
+ */
+public class Until extends XcapElement {
+
+    public static final String NODE_NAME = "until";
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Until(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/client/policy/Validity.java b/packages/simservs/src/com/mediatek/simservs/client/policy/Validity.java
new file mode 100644
index 0000000..2afd5e1
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/client/policy/Validity.java
@@ -0,0 +1,29 @@
+
+package com.mediatek.simservs.client.policy;
+
+import com.mediatek.simservs.xcap.XcapElement;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+/**
+ * Validity class.
+ */
+public class Validity extends XcapElement {
+
+    public static final String NODE_NAME = "validity";
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public Validity(XcapUri xcapUri, String parentUri, String intendedId) {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    @Override
+    protected String getNodeName() {
+        return NODE_NAME;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/Attributable.java b/packages/simservs/src/com/mediatek/simservs/xcap/Attributable.java
new file mode 100644
index 0000000..1deddd1
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/Attributable.java
@@ -0,0 +1,33 @@
+package com.mediatek.simservs.xcap;
+
+/**
+ * Attributable interface.
+ *
+ */
+public interface Attributable {
+    /**
+     * Get specific attribute by name.
+     *
+     * @param attribute attribute name
+     * @return  attribute value
+     * @throws  XcapException   if XCAP error
+     */
+    public String getByAttrName(String attribute) throws XcapException;
+
+    /**
+     * Set specific attribute by name.
+     *
+     * @param attrName     attribute name
+     * @param attrValue     attribute value
+     * @throws  XcapException   if XCAP error
+     */
+    public void setByAttrName(String attrName, String attrValue) throws XcapException;
+
+    /**
+     * Delete specific attribute by name.
+     *
+     * @param attribute     attribute name
+     * @throws  XcapException   if XCAP error
+     */
+    public void deleteByAttrName(String attribute) throws XcapException;
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/ConfigureType.java b/packages/simservs/src/com/mediatek/simservs/xcap/ConfigureType.java
new file mode 100644
index 0000000..2946251
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/ConfigureType.java
@@ -0,0 +1,17 @@
+package com.mediatek.simservs.xcap;
+
+import org.w3c.dom.Node;
+
+/**
+ * Configure Type interface.
+ *
+ */
+public interface ConfigureType {
+
+    /**
+     * Instanciate from XML.
+     *
+     * @param domNode   DOM node
+     */
+    public void instantiateFromXmlNode(Node domNode);
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/InquireType.java b/packages/simservs/src/com/mediatek/simservs/xcap/InquireType.java
new file mode 100644
index 0000000..bef68f2
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/InquireType.java
@@ -0,0 +1,144 @@
+package com.mediatek.simservs.xcap;
+
+import android.util.Log;
+
+import com.mediatek.xcap.client.XcapClient;
+import com.mediatek.xcap.client.XcapDebugParam;
+import com.mediatek.xcap.client.uri.XcapUri;
+
+import com.android.okhttp.Headers;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * InquireType abstract class.
+ *
+ */
+public abstract class InquireType extends XcapElement {
+
+    /**
+     * Constructor.
+     *
+     * @param xcapUri           XCAP document URI
+     * @param parentUri         XCAP root directory URI
+     * @param intendedId        X-3GPP-Intended-Id
+     * @throws XcapException    if XCAP error
+     * @throws ParserConfigurationException if parser configuration error
+     */
+    public InquireType(XcapUri xcapUri, String parentUri, String intendedId)
+            throws XcapException, ParserConfigurationException {
+        super(xcapUri, parentUri, intendedId);
+    }
+
+    /**
+     * Gets the content of the current node through XCAP protocol.
+     *
+     * @return configuration XML
+     * @throws XcapException if XCAP error
+     */
+    public String getContent() throws XcapException {
+        XcapClient xcapClient = null;
+        HttpURLConnection conn = null;
+        String ret = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            String nodeUri = getNodeUri().toString();
+            XcapDebugParam debugParam = XcapDebugParam.getInstance();
+
+            if (debugParam.getEnableSimservQueryWhole()) {
+                nodeUri = nodeUri.substring(0, nodeUri.lastIndexOf("simservs") +
+                        "simservs".length());
+            }
+
+            URI uri = new URI(nodeUri);
+
+            if (mNetwork != null) {
+                xcapClient = new XcapClient(mNetwork);
+
+                if (xcapClient == null) {
+                    throw new XcapException(500);
+                }
+            } else {
+                xcapClient = new XcapClient();
+            }
+
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-None-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            if (mContext != null) {
+                xcapClient.setContext(mContext);
+            }
+            conn = xcapClient.get(uri, headers.build());
+
+            if (conn != null) {
+                if (conn.getResponseCode() == 200 ||
+                        conn.getResponseCode() == 304) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mIsSupportEtag = true;
+                        this.mEtag = etagValue;
+                    } else {
+                        this.mIsSupportEtag = false;
+                        this.mEtag = null;
+                    }
+
+                    InputStream is = null;
+                    try {
+                        is = conn.getInputStream();
+                        // convert stream to string
+                        ret = convertStreamToString(is);
+                    } finally {
+                        if (is != null) {
+                            is.close();
+                        }
+                    }
+                } else if (conn.getResponseCode() == 409) {
+                    InputStream is = conn.getInputStream();
+
+                    if (is != null) {
+                        if ("true".equals(
+                                System.getProperty("xcap.handl409"))) {
+                            ret = null;
+                            throw new XcapException(409,
+                                parse409ErrorMessage("phrase", is));
+                        } else {
+                            ret = null;
+                            throw new XcapException(409);
+                        }
+                    } else {
+                        ret = null;
+                        throw new XcapException(409);
+                    }
+                } else {
+                    ret = null;
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+
+        Log.d(TAG, "Response XML:");
+        Log.d(TAG, ret);
+        return ret;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/RuleType.java b/packages/simservs/src/com/mediatek/simservs/xcap/RuleType.java
new file mode 100644
index 0000000..a10b245
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/RuleType.java
@@ -0,0 +1,40 @@
+package com.mediatek.simservs.xcap;
+
+import com.mediatek.simservs.client.policy.RuleSet;
+
+
+/**
+ * Rule Type interface.
+ *
+ */
+public interface RuleType {
+
+    /**
+    * Get rule set.
+    *
+    * @return Ruleset
+    */
+    public RuleSet getRuleSet();
+
+    /**
+     * Save ruleset to server.
+     *
+     * @throws  XcapException if XCAP error
+     */
+    public void saveRuleSet() throws XcapException;
+
+    /**
+     * Create ruleset.
+     *
+     * @return  ruleset
+     */
+    public RuleSet createNewRuleSet();
+
+    /**
+     * Save rule to server.
+     *
+     * @param ruleId rule to be saved by the id
+     * @throws  XcapException if XCAP error
+     */
+    public void saveRule(String ruleId) throws XcapException;
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/XcapElement.java b/packages/simservs/src/com/mediatek/simservs/xcap/XcapElement.java
new file mode 100644
index 0000000..83b7f8b
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/XcapElement.java
@@ -0,0 +1,575 @@
+package com.mediatek.simservs.xcap;
+
+import android.content.Context;
+import android.net.Network;
+import android.os.SystemProperties;
+import android.util.Log;
+
+import com.android.okhttp.Headers;
+
+import com.mediatek.simservs.client.CommunicationDiversion.NoReplyTimer;
+import com.mediatek.xcap.client.XcapClient;
+import com.mediatek.xcap.client.XcapConstants;
+import com.mediatek.xcap.client.XcapDebugParam;
+import com.mediatek.xcap.client.uri.XcapUri;
+import com.mediatek.xcap.client.uri.XcapUri.XcapNodeSelector;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.DataInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.net.HttpURLConnection;
+import java.net.Inet6Address;
+import java.net.InetAddress;
+import java.net.URI;
+import java.net.URISyntaxException;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.transform.OutputKeys;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerException;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+
+/**
+ * Validity abstract class.
+ */
+public abstract class XcapElement implements Attributable {
+    public static final String TAG = "XcapElement";
+    public static final String TRUE = "true";
+    public static final String FALSE = "false";
+
+    protected static final String AUTH_XCAP_3GPP_INTENDED = "X-3GPP-Intended-Identity";
+    protected static final String XCAP_NAMESPACE =
+            "http://uri.etsi.org/ngn/params/xml/simservs/xcap";
+    protected static final String XCAP_ALIAS = "ss";
+    protected static final String COMMON_POLICY_NAMESPACE = "urn:ietf:params:xml:ns:common-policy";
+    protected static final String COMMON_POLICY_ALIAS = "cp";
+    protected String mNodeUri = null;
+    public XcapUri mXcapUri = null;
+    public String mParentUri = null;
+    public String mIntendedId = null;
+    protected String mEtag = null;
+    protected boolean mIsSupportEtag = false;
+    public XcapDebugParam mDebugParams = XcapDebugParam.getInstance();
+    protected Network mNetwork;
+    protected Context mContext;
+
+    /**
+     * Constructs an instance without XML source.
+     *
+     * @param xcapUri       XCAP document URI
+     * @param parentUri     XCAP root directory URI
+     * @param intendedId    X-3GPP-Intended-Id
+     */
+    public XcapElement(XcapUri xcapUri, String parentUri, String intendedId) {
+        mXcapUri = xcapUri;
+        mParentUri = parentUri;
+        mIntendedId = intendedId;
+    }
+
+    /**
+     * Set dedicated network.
+     *
+     * @param network dedicated network
+     */
+    public void setNetwork(Network network) {
+        if (network != null) {
+            Log.i(TAG, "XCAP dedicated network netid:" + network);
+            mNetwork = network;
+        }
+    }
+
+    /**
+     * Set context.
+     *
+     * @param ctxt context to set
+     */
+    public void setContext(Context ctxt) {
+        if (ctxt != null) {
+            mContext = ctxt;
+        }
+    }
+
+    /**
+     * Set ETag value.
+     *
+     * @param etag value
+     */
+    public void setEtag(String etag) {
+        mEtag = etag;
+    }
+
+    /**
+     * Get ETag value.
+     *
+     * @return ETag value
+     */
+    public String getEtag() {
+        return mEtag;
+    }
+
+    /**
+     * Get node URI.
+     *
+     * @return URI
+     * @throws IllegalArgumentException if illegal argument
+     * @throws URISyntaxException if URI syntax error
+     */
+    public URI getNodeUri() throws IllegalArgumentException,
+            URISyntaxException {
+        URI elementURI;
+        XcapNodeSelector elementSelector = new XcapNodeSelector(XcapConstants.ROOT_SIMSERVS)
+                .queryByNodeName(mParentUri)
+                .queryByNodeName(getNodeName());
+
+        elementURI = mXcapUri.setNodeSelector(elementSelector).toURI();
+        return elementURI;
+    }
+
+    /**
+     * Get attribute URI .
+     *
+     * @return URI
+     * @throws IllegalArgumentException if illegal argument
+     */
+    private URI getAttributeUri(String attribute) throws IllegalArgumentException,
+            URISyntaxException {
+        URI elementURI;
+        XcapNodeSelector elementSelector = new XcapNodeSelector(XcapConstants.ROOT_SIMSERVS)
+                .queryByNodeName(mParentUri)
+                .queryByNodeName(getNodeName(), attribute);
+
+        elementURI = mXcapUri.setNodeSelector(elementSelector).toURI();
+        return elementURI;
+    }
+
+    /**
+     * Gets attribute value by attribute name.
+     *
+     * @param  attribute attribute name
+     * @return attribute value
+     * @throws XcapException if XCAP error
+     */
+    @Override
+    public String getByAttrName(String attribute) throws XcapException {
+        XcapClient xcapClient;
+
+        if (mNetwork != null) {
+            xcapClient = new XcapClient(mNetwork);
+        } else {
+            xcapClient = new XcapClient();
+        }
+
+        HttpURLConnection conn = null;
+        String ret = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-None-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            conn = xcapClient.get(getAttributeUri(attribute), headers.build());
+            if (conn != null) {
+                if (conn.getResponseCode() == 200) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mEtag = etagValue;
+                    }
+
+                    InputStream is = conn.getInputStream();
+                    // convert stream to string
+                    ret = convertStreamToString(is);
+                } else {
+                    ret = null;
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+        return ret;
+    }
+
+    /**
+     * Sets attribute value by attribute name.
+     *
+     * @param  attrName attribute name
+     * @param  attrValue attribute value
+     * @throws XcapException if XCAP error
+     */
+    @Override
+    public void setByAttrName(String attrName, String attrValue) throws XcapException {
+        XcapClient xcapClient;
+
+        if (mNetwork != null) {
+            xcapClient = new XcapClient(mNetwork);
+        } else {
+            xcapClient = new XcapClient();
+        }
+
+        HttpURLConnection conn = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            conn = xcapClient.put(getAttributeUri(attrName), "application/xcap-att+xml",
+                    attrValue, headers.build());
+            // check put response
+            if (conn != null) {
+                if (conn.getResponseCode() == 200
+                        || conn.getResponseCode() == 201) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mEtag = etagValue;
+                    }
+
+                    Log.d("info", "document created in xcap server...");
+                } else {
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+    }
+
+    /**
+     * Deletes attribute by attribute name.
+     *
+     * @param  attribute attribute name
+     * @throws XcapException if XCAP error
+     */
+    @Override
+    public void deleteByAttrName(String attribute) throws XcapException {
+        XcapClient xcapClient;
+
+        if (mNetwork != null) {
+            xcapClient = new XcapClient(mNetwork);
+        } else {
+            xcapClient = new XcapClient();
+        }
+
+        HttpURLConnection conn = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            conn = xcapClient.delete(getAttributeUri(attribute), headers.build());
+            // check put response
+            if (conn != null) {
+                if (conn.getResponseCode() == 200) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mEtag = etagValue;
+                    }
+
+                    Log.d("info", "document deleted in xcap server...");
+                } else {
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IllegalArgumentException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+    }
+
+    /**
+     * Sets the content of the current node.
+     *
+     * @param  xml XML string
+     * @throws XcapException if XCAP error
+     */
+    public void setContent(String xml) throws XcapException {
+        try {
+            mNodeUri = getNodeUri().toString();
+            saveContent(xml);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Update current node through XCAP protocol.
+     *
+     * @param  xml XML string
+     * @throws XcapException if XCAP error
+     */
+    protected void saveContent(String xml) throws XcapException {
+        XcapClient xcapClient = null;
+        HttpURLConnection conn = null;
+        Headers.Builder headers = new Headers.Builder();
+
+        try {
+            URI uri = new URI(mNodeUri);
+
+            if (mNetwork != null) {
+                xcapClient = new XcapClient(mNetwork);
+
+                if (xcapClient == null) {
+                    throw new XcapException(500);
+                }
+            } else {
+                xcapClient = new XcapClient();
+            }
+
+            if (mIntendedId != null && mEtag != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+                headers.add("If-Match", "\"" + mEtag + "\"");
+            } else if (mIntendedId != null) {
+                headers.add(AUTH_XCAP_3GPP_INTENDED, "\"" + mIntendedId + "\"");
+            }
+
+            if (mDebugParams.getEnablePredefinedSimservSetting() &&
+                    !getNodeName().equals(NoReplyTimer.NODE_NAME)) {
+                String xMl = readXmlFromFile("/data/simservs.xml");
+
+                if (xMl != null) {
+                    xml = xMl;
+                }
+            }
+
+            String putElementMime = null;
+
+            if (mDebugParams.getXcapPutElementMime() != null &&
+                    !mDebugParams.getXcapPutElementMime().isEmpty()) {
+                putElementMime = mDebugParams.getXcapPutElementMime();
+            } else {
+                putElementMime = System.getProperty("xcap.putelcontenttype",
+                        "application/xcap-el+xml");
+            }
+
+            conn = xcapClient.put(uri, putElementMime, xml, headers.build());
+            // check put response
+            if (conn != null) {
+                if (conn.getResponseCode() == 200
+                        || conn.getResponseCode() == 201) {
+                    String etagValue = conn.getHeaderField("ETag");
+
+                    if (etagValue != null) {
+                        this.mEtag = etagValue;
+                    }
+
+                    Log.d("info", "document created in xcap server...");
+                } else if (conn.getResponseCode() == 409) {
+                    InputStream is = conn.getInputStream();
+
+                    if (is != null) {
+                        if ("true".equals(System.getProperty("xcap.handl409"))) {
+                            throw new XcapException(409, parse409ErrorMessage("phrase", is));
+                        } else {
+                            throw new XcapException(409);
+                        }
+                    } else {
+                        throw new XcapException(409);
+                    }
+                } else {
+                    throw new XcapException(conn.getResponseCode());
+                }
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(e);
+        } catch (URISyntaxException e) {
+            e.printStackTrace();
+        } finally {
+            xcapClient.shutdown();
+        }
+    }
+
+    /**
+     * Not supported.
+     *
+     * @return content type
+     */
+    public String getContentType() {
+        return null;
+    }
+
+    /**
+     * Gets the URI of the current node.
+     *
+     * @return URI
+     */
+    public String getUri() {
+        StringBuilder pathUri = new StringBuilder();
+
+        if (mParentUri != null) {
+            pathUri.append(mParentUri)
+                    .append("\\")
+                    .append(getNodeName());
+            return pathUri.toString();
+        } else {
+            return getNodeName();
+        }
+    }
+
+    /**
+     * Not supported.
+     *
+     * @return null
+     */
+    public XcapElement getParent() {
+        return null;
+    }
+
+    /**
+     * Not supported.
+     *
+     * @return null
+     */
+    public String getNodeSelector() {
+        return null;
+    }
+
+
+    /**
+     * Transfer the DOM object to XML string.
+     *
+     * @param  element DOM element
+     * @return XML string
+     * @throws TransformerException if tranformation error
+     */
+    public String domToXmlText(Element element) throws TransformerException {
+        TransformerFactory transFactory = TransformerFactory.newInstance();
+        Transformer transformer = transFactory.newTransformer();
+        StringWriter buffer = new StringWriter();
+        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
+        transformer.transform(new DOMSource(element),
+                new StreamResult(buffer));
+        return buffer.toString();
+    }
+
+    /**
+     * Transfer input stream to string.
+     *
+     * @param  inputStream input stream
+     * @return string
+     * @throws IOException if I/O error
+     */
+    public String convertStreamToString(InputStream inputStream) throws IOException {
+        BufferedReader r = new BufferedReader(new InputStreamReader(inputStream));
+        StringBuilder total = new StringBuilder();
+        String line;
+        while ((line = r.readLine()) != null) {
+            total.append(line);
+        }
+        return total.toString();
+    }
+
+    protected abstract String getNodeName();
+
+    protected String readXmlFromFile(String file) {
+        String text = "";
+
+        try {
+            FileInputStream fis = new FileInputStream(file);
+            BufferedInputStream bis = new BufferedInputStream(fis);
+            DataInputStream dis = new DataInputStream(fis);
+
+            String buf;
+            while ((buf = dis.readLine()) != null) {
+                Log.d(TAG, "Read:" + buf);
+                text += buf;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return text;
+    }
+
+    /**
+     * Parse HTTP 409 error message.
+     *
+     * @param  xmlErrorTag HTTP 409 specific error message XML tag
+     * @param  inputStream HTTP 409 content
+     * @return string
+     */
+    protected String parse409ErrorMessage(String xmlErrorTag, InputStream content)
+            throws XcapException {
+        try {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            factory.setNamespaceAware(false);
+            DocumentBuilder db = factory.newDocumentBuilder();
+            InputSource is = new InputSource();
+            is.setCharacterStream(new StringReader(convertStreamToString(content)));
+            Document doc;
+            doc = db.parse(is);
+
+            NodeList currentNode = doc.getElementsByTagName(xmlErrorTag);
+
+            if (currentNode.getLength() > 0) {
+                Element activeElement = (Element) currentNode.item(0);
+                String textContent = activeElement.getTextContent();
+                Log.d(TAG, "parse409ErrorMessage:[" + textContent + "]");
+                return textContent;
+            }
+        } catch (ParserConfigurationException e) {
+            e.printStackTrace();
+            throw new XcapException(500);
+        } catch (IOException e) {
+            e.printStackTrace();
+            throw new XcapException(500);
+        } catch (SAXException e) {
+            e.printStackTrace();
+            throw new XcapException(500);
+        }
+
+        return null;
+    }
+}
diff --git a/packages/simservs/src/com/mediatek/simservs/xcap/XcapException.java b/packages/simservs/src/com/mediatek/simservs/xcap/XcapException.java
new file mode 100644
index 0000000..02246fe
--- /dev/null
+++ b/packages/simservs/src/com/mediatek/simservs/xcap/XcapException.java
@@ -0,0 +1,79 @@
+
+package com.mediatek.simservs.xcap;
+
+import java.io.IOException;
+
+/**
+ * XCAP Exception class.
+ */
+public class XcapException extends Exception {
+
+    private static final long serialVersionUID = 1L;
+
+    public static final int NO_EXCEPTION = 0;
+    public static final int CONNECTION_POOL_TIMEOUT_EXCEPTION = 1;
+    public static final int CONNECT_TIMEOUT_EXCEPTION = 2;
+    public static final int NO_HTTP_RESPONSE_EXCEPTION = 3;
+    public static final int HTTP_RECOVERABL_EEXCEPTION = 4;
+    public static final int MALFORMED_CHALLENGE_EXCEPTION = 5;
+    public static final int AUTH_CHALLENGE_EXCEPTION = 6;
+    public static final int CREDENTIALS_NOT_AVAILABLE_EXCEPTION = 7;
+    public static final int INVALID_CREDENTIALS_EXCEPTION = 8;
+    public static final int AUTHENTICATION_EXCEPTION = 9;
+    public static final int MALFORMED_COOKIE_EXCEPTION = 10;
+    public static final int REDIRECT_EXCEPTION = 11;
+    public static final int URI_EXCEPTION = 12;
+    public static final int PROTOCOL_EXCEPTION = 13;
+    public static final int HTTP_EXCEPTION = 14;
+
+    private int mHttpErrorCode = 0;
+    private int mExceptionCode = NO_EXCEPTION;
+    private boolean mIsConnectionError = false;
+    private String mXcapErrorMessage;
+
+    /**
+     * Constructs an instance with error code.
+     *
+     * @param httpErrorCode XCAP error code
+     */
+    public XcapException(int httpErrorCode) {
+        mHttpErrorCode = httpErrorCode;
+    }
+
+    /**
+     * Constructs an instance with error code and message.
+     *
+     * @param httpErrorCode XCAP error code
+     * @param xcapErrorMessage XCAP error message
+     */
+    public XcapException(int httpErrorCode, String xcapErrorMessage) {
+        mHttpErrorCode = httpErrorCode;
+        mXcapErrorMessage = xcapErrorMessage;
+    }
+
+    /**
+     * Constructs an instance with IO exception.
+     *
+     * @param httpException I/O error exception
+     */
+    public XcapException(IOException httpException) {
+        if ("GBA Authentication hit HTTP 403 Forbidden".equals(httpException.getMessage())) {
+            mHttpErrorCode = 403;
+            return;
+        }
+
+        mIsConnectionError = true;
+    }
+
+    public boolean isConnectionError() {
+        return mIsConnectionError;
+    }
+
+    public int getHttpErrorCode() {
+        return mHttpErrorCode;
+    }
+
+    public int getExceptionCodeCode() {
+        return mExceptionCode;
+    }
+}
diff --git a/packages/simservs/test/SimservsTest.java b/packages/simservs/test/SimservsTest.java
new file mode 100644
index 0000000..fdedad4
--- /dev/null
+++ b/packages/simservs/test/SimservsTest.java
@@ -0,0 +1,565 @@
+
+package com.mediatek.simservs.test;
+
+import android.util.Log;
+
+import com.mediatek.simservs.client.CommunicationDiversion;
+import com.mediatek.simservs.client.CommunicationWaiting;
+import com.mediatek.simservs.client.IncomingCommunicationBarring;
+import com.mediatek.simservs.client.OriginatingIdentityPresentation;
+import com.mediatek.simservs.client.OriginatingIdentityPresentationRestriction;
+import com.mediatek.simservs.client.OutgoingCommunicationBarring;
+import com.mediatek.simservs.client.SimServs;
+import com.mediatek.simservs.client.policy.Actions;
+import com.mediatek.simservs.client.policy.Conditions;
+import com.mediatek.simservs.client.policy.Rule;
+import com.mediatek.simservs.client.policy.RuleSet;
+import com.mediatek.simservs.xcap.XcapException;
+import com.mediatek.xcap.client.XcapClient;
+import com.mediatek.xcap.client.XcapConstants;
+import com.mediatek.xcap.client.uri.XcapUri;
+import com.mediatek.xcap.client.uri.XcapUri.XcapDocumentSelector;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.List;
+
+/**
+ * Simservs test class.
+ */
+public class SimservsTest {
+
+    static final private String TAG = "SimservsTest";
+
+    static final private String INITIAL_DOC =
+            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
+            "    <resource-lists xmlns=\"urn:ietf:params:xml:ns:resource-lists\">\r\n" +
+            "        <communication-waiting active=\"true\"/>\r\n" +
+            "        <originating-identity-presentation active=\"true\"/>\r\n" +
+            "        <originating-identity-presentation-restriction active=\"true\"/>\r\n" +
+            "        <outgoing-communication-barring active=\"true\">\r\n" +
+            "             <ruleset>\r\n" +
+            "                  <rule id=\"AO\">\r\n" +
+            "                       <actions>\r\n" +
+            "                            <allow>false</allow>\r\n" +
+            "                       </actions>\r\n" +
+            "                  </rule>\r\n" +
+            "             </ruleset>\r\n" +
+            "        </outgoing-communication-barring>\r\n" +
+            "        <incoming-communication-barring active=\"true\">\r\n" +
+            "             <ruleset>\r\n" +
+            "                  <rule id=\"IR\">\r\n" +
+            "                       <conditions>\r\n" +
+            "                            <roaming/>\r\n" +
+            "                            <media>audio</media>\r\n" +
+            "                       </conditions>\r\n" +
+            "                       <actions>\r\n" +
+            "                            <allow>false</allow>\r\n" +
+            "                       </actions>\r\n" +
+            "                  </rule>\r\n" +
+            "             </ruleset>\r\n" +
+            "        </incoming-communication-barring>\r\n" +
+            "        <communication-diversion active=\"true\">\r\n" +
+            "            <NoReplyTimer>1000</NoReplyTimer>\r\n" +
+            "            <ruleset>\r\n" +
+            "                <rule id=\"CFB\">\r\n" +
+            "                    <conditions>\r\n" +
+            "                        <busy/>\r\n" +
+            "                        <media>audio</media>\r\n" +
+            "                    </conditions>\r\n" +
+            "                    <actions>\r\n" +
+            "                        <forward-to>\r\n" +
+            "                            <target>\"+886988555222\"</target>\r\n" +
+            "                            <notify-caller>true</notify-caller>\r\n" +
+            "                        </forward-to>\r\n" +
+            "                    </actions>\r\n" +
+            "                </rule>\r\n" +
+            "                <rule id=\"CFNRc\">\r\n" +
+            "                    <conditions>\r\n" +
+            "                        <not-reachable/>\r\n" +
+            "                        <media>audio</media>\r\n" +
+            "                    </conditions>\r\n" +
+            "                    <actions>\r\n" +
+            "                        <forward-to>\r\n" +
+            "                            <target>\"+886988555222\"</target>\r\n" +
+            "                            <notify-caller>true</notify-caller>\r\n" +
+            "                        </forward-to>\r\n" +
+            "                    </actions>\r\n" +
+            "                </rule>\r\n" +
+            "            </ruleset>\r\n" +
+            "        </communication-diversion>\r\n" +
+            "        <communication-diversion-serv-cap active=\"true\">\r\n" +
+            "          <serv-cap-conditions>\r\n" +
+            "             <serv-cap-external-list provisioned=\"false\">\r\n" +
+            "               </serv-cap-external-list>\r\n" +
+            "             <serv-cap-identity provisioned=\"true\"></serv-cap-identity>\r\n" +
+            "             <serv-cap-media>\r\n" +
+            "                <media>audio</media>\r\n" +
+            "                <media>video</media>\r\n" +
+            "              </serv-cap-media>\r\n" +
+            "             <serv-cap-presence-status provisioned=\"false\">\r\n" +
+            "               </serv-cap-presence-status>\r\n" +
+            "             <serv-cap-validity provisioned=\"false\"></serv-cap-validity>\r\n" +
+            "          </serv-cap-conditions>\r\n" +
+            "          <serv-cap-actions>\r\n" +
+            "               <serv-cap-target>\r\n" +
+            "                  <telephony-type/>\r\n" +
+            "               </serv-cap-target>\r\n" +
+            "               <serv-cap-notify-served-user-on-outbound-call provisioned=\"false\">" +
+            "                 </serv-cap-notify-served-user-on-outbound-call>\r\n" +
+            "              <serv-cap-reveal-identity-to-caller provisioned=\"false\">\r\n" +
+            "                </serv-cap-reveal-identity-to-caller>\r\n" +
+            "              <serv-cap-reveal-served-user-identity-to-caller provisioned=\"false\">" +
+            "                </serv-cap-reveal-served-user-identity-to-caller>\r\n" +
+            "              <serv-cap-reveal-identity-to-target provisioned=\"false\">\r\n" +
+            "                </serv-cap-reveal-identity-to-target>\r\n" +
+            "          </serv-cap-actions>\r\n" +
+            "        </communication-diversion-serv-cap>\r\n" +
+            "        <communication-barring-serv-cap active=\"true\">\r\n" +
+            "            <serv-cap-conditions>\r\n" +
+            "                <serv-cap-communication-diverted provisioned=\"false\">\r\n" +
+            "                   </serv-cap-communication-diverted>\r\n" +
+            "                <serv-cap-external-list provisioned=\"false\">" +
+            "                   </serv-cap-external-list>\r\n" +
+            "                <serv-cap-identity provisioned=\"false\"></serv-cap-identity>\r\n" +
+            "                <serv-cap-media>\r\n" +
+            "                    <media>audio</media>\r\n" +
+            "                    <media>video</media>\r\n" +
+            "                </serv-cap-media>\r\n" +
+            "                <serv-cap-other-identity provisioned=\"false\">" +
+            "                   </serv-cap-other-identity>\r\n" +
+            "                <serv-cap-presence-status provisioned=\"false\">" +
+            "                   </serv-cap-presence-status>\r\n" +
+            "                <serv-cap-roaming provisioned=\"true\"></serv-cap-roaming>\r\n" +
+            "                <serv-cap-rule-deactivated provisioned=\"false\">" +
+            "                   </serv-cap-rule-deactivated>\r\n" +
+            "                <serv-cap-request-name provisioned=\"false\">" +
+            "                   </serv-cap-request-name>\r\n" +
+            "                <serv-cap-validity provisioned=\"false\"></serv-cap-validity>\r\n" +
+            "            </serv-cap-conditions>\r\n" +
+            "        </communication-barring-serv-cap>\r\n" +
+            "    </resource-lists>\r\n";
+
+    static final private String XCAP_ROOT = "http://192.168.1.2:8080/";
+    static final private String TEST_USER = "sip:user@anritsu-cscf.com";
+    static final private String TEST_DOC = "simservs";
+
+    /**
+     * Fetch document of supplementary service configuration.
+     *
+     * @param ra XcapClient instance
+     * @param documentURI document location URI
+     */
+    private static void getDoc(XcapClient ra,
+            URI documentURI) throws IOException {
+
+        HttpResponse response;
+        response = ra.get(documentURI, null);
+
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "response 200, response = " + response.toString());
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+    }
+
+    /**
+     * Configure supplementary service.
+     *
+     * @param ra XcapClient instance
+     * @param documentURI document location URI
+     */
+    private static void putDoc(XcapClient ra,
+            URI uri) throws IOException {
+        URI documentURI = uri;
+        HttpResponse response;
+
+        // put the document and get sync response
+        response = ra.put(documentURI, "application/resource-lists+xml", INITIAL_DOC);
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200
+                    || response.getStatusLine().getStatusCode() == 201) {
+                Log.d("info", "document created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create document in xcap server...");
+        }
+
+    }
+
+    /**
+     * Remove configuration of supplementary service.
+     *
+     * @param ra XcapClient instance
+     * @param documentURI document location URI
+     */
+    private static void deleteDoc(XcapClient ra,
+            URI uri) throws IOException {
+        URI documentURI = uri;
+        HttpResponse response;
+
+        response = ra.delete(documentURI);
+
+        // check get response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "document retreived in xcap server and content is the expected...");
+                Log.d("info", "sync test suceed :)");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+    }
+
+    /**
+     * Test suite.
+     *
+     * @throws URISyntaxException if URI syntax error
+     * @throws IOException        if I/O error
+     */
+    static public void syncTest() throws URISyntaxException, IOException {
+        String documentUri = null;
+        SimServs simservs = SimServs.getInstance();
+
+        simservs.setXui("user@chinaTel.com");
+        simservs.setIntendedId("user@chinaTel.com");
+
+        simservs.setXuiByImsiMccMnc("234150999999999", "234", "15");
+        String xui = simservs.getXui();
+        if (xui == null) {
+            Exception e = new Exception("XUI test fail");
+            e.printStackTrace();
+            throw e;
+        }
+
+        simservs.setXcapRootByImpi("user@chinaTel.com");
+        documentUri = simservs.getDocumentUri();
+
+        simservs.setXcapRootByImpi("2341509999999999@ims.mnc466.mcc97.3gppnetwork.org");
+        documentUri = simservs.getDocumentUri();
+
+        simservs.setXcapRootByMccMnc("466", "97");
+        documentUri = simservs.getDocumentUri();
+
+        XcapClient ra = new XcapClient();
+
+        XcapDocumentSelector documentSelector = new XcapDocumentSelector(
+                XcapConstants.AUID_RESOURCE_LISTS, TEST_USER, TEST_DOC);
+        Log.d(TAG, "document selector is " + documentSelector.toString());
+        XcapUri xcapUri = new XcapUri();
+        xcapUri.setXcapRoot(XCAP_ROOT).setDocumentSelector(documentSelector);
+
+        // ====================================
+
+        try {
+            CommunicationWaiting cw = simservs.getCommunicationWaiting(xcapUri, TEST_USER,
+                    "password");
+            CommunicationDiversion cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            IncomingCommunicationBarring icb = simservs.getIncomingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            OutgoingCommunicationBarring ocb = simservs.getOutgoingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            OriginatingIdentityPresentation oip = simservs.getOriginatingIdentityPresentation(
+                    xcapUri, TEST_USER, "password");
+            OriginatingIdentityPresentationRestriction oir = simservs
+                    .getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                            "password");
+
+            // ====================================
+            // De-active test
+            cw.setActive(false);
+            cw = simservs.getCommunicationWaiting(xcapUri, TEST_USER,
+                    "password");
+            if (cw.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            cd.setActive(false);
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            if (cd.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            icb.setActive(false);
+            icb = simservs.getIncomingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            if (icb.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            ocb.setActive(false);
+            ocb = simservs.getOutgoingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            if (ocb.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            oip.setActive(false);
+            oip = simservs.getOriginatingIdentityPresentation(
+                    xcapUri, TEST_USER, "password");
+            if (oip.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            oir.setActive(false);
+            oir = simservs.getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                    "password");
+            if (oir.isActive()) {
+                throw new Exception("UT De-active test fail");
+            }
+
+            // ====================================
+            // Active test
+            cw.setActive(true);
+            cw = simservs.getCommunicationWaiting(xcapUri, TEST_USER,
+                    "password");
+            if (!cw.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            cd.setActive(true);
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            if (!cd.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            icb.setActive(true);
+            icb = simservs.getIncomingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            if (!icb.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            ocb.setActive(true);
+            ocb = simservs.getOutgoingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            if (!ocb.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            oip.setActive(true);
+            oip = simservs.getOriginatingIdentityPresentation(
+                    xcapUri, TEST_USER, "password");
+            if (!oip.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            oir.setActive(true);
+            oir = simservs.getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                    "password");
+            if (!oir.isActive()) {
+                throw new Exception("UT Active test fail");
+            }
+
+            // ====================================
+            // OIR default-behaviour test
+            oir.setDefaultPresentationRestricted(false);
+            oir = simservs
+                    .getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                            "password");
+            if (oir.isDefaultPresentationRestricted()) {
+                throw new Exception("UT default-behaviour test fail");
+            }
+
+            oir.setDefaultPresentationRestricted(true);
+            oir = simservs
+                    .getOriginatingIdentityPresentationRestriction(xcapUri, TEST_USER,
+                            "password");
+            if (!oir.isDefaultPresentationRestricted()) {
+                throw new Exception("UT default-behaviour test fail");
+            }
+
+            // ====================================
+            // CD NoReplyTimer test
+            int cdNoReplayTimer = cd.getNoReplyTimer();
+            cd.setNoReplyTimer(555);
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            if (cd.getNoReplyTimer() != 555) {
+                throw new Exception("UT CD NoReplyTimer test fail");
+
+            }
+
+            cd.setNoReplyTimer(cdNoReplayTimer);
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            if (cd.getNoReplyTimer() != cdNoReplayTimer) {
+                throw new Exception("UT CD NoReplyTimer test fail");
+            }
+
+            // ====================================
+            // Clear ruleset test
+            RuleSet ruleSet = cd.getRuleSet();
+            ruleSet.clearRules();
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() > 0) {
+                throw new Exception("UT CD Clear ruleset test fail");
+            }
+
+            // ====================================
+            // Add a rule test
+            Rule rule = ruleSet.createNewRule("Add a rule test");
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT CD create rule test fail");
+            }
+
+            // ====================================
+            // Add a condition within a rule test
+            rule = ruleSet.getRules().get(0);
+            Conditions conditions = rule.createConditions();
+            conditions.addRoaming();
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT Add a condition on a rule test fail");
+            } else {
+                rule = ruleSet.getRules().get(0);
+                if (!rule.getConditions().comprehendRoaming()) {
+                    throw new Exception("UT Add a condition on a rule test fail");
+                }
+            }
+
+            // ====================================
+            // Add a media within a condition test
+            rule = ruleSet.getRules().get(0);
+            conditions = rule.getConditions();
+            conditions.addMedia("audio");
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT Add a condition media within a rule test fail");
+            } else {
+                rule = ruleSet.getRules().get(0);
+                List<String> medias = rule.getConditions().getMedias();
+                if (!medias.get(0).equals("audio")) {
+                    throw new Exception("UT Add a condition media within a rule test fail");
+                }
+            }
+
+            // ====================================
+            // Unfold multiple conditions test
+            if (!simservs.LIB_CONFIG_MULTIPLE_RULE_CONDITIONS) {
+                rule = ruleSet.getRules().get(0);
+                conditions = rule.getConditions();
+                conditions.addBusy();
+                conditions.addMedia("video");
+                cd.saveRuleSet();
+
+                cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                        "password");
+                ruleSet = cd.getRuleSet();
+                if (ruleSet.getRules().size() < 4) {
+                    throw new Exception("UT Unfold multiple conditions test fail");
+                }
+                // Save to server and check again
+                cd.saveRuleSet();
+
+                cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                        "password");
+                ruleSet = cd.getRuleSet();
+                if (ruleSet.getRules().size() < 4) {
+                    throw new Exception("UT Unfold multiple conditions test fail");
+                }
+            }
+            // ====================================
+            // CD Target modify test
+            ruleSet = cd.getRuleSet();
+            ruleSet.clearRules();
+            rule = ruleSet.createNewRule("CD Target modify test");
+            rule.createConditions().addBusy();
+            Actions actions = rule.createActions();
+            actions.setFowardTo("0912364587", true);
+            cd.saveRuleSet();
+
+            cd = simservs.getCommunicationDiversion(xcapUri, TEST_USER,
+                    "password");
+            ruleSet = cd.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT CD Target modify test fail");
+            } else {
+                rule = ruleSet.getRules().get(0);
+                if (!rule.getConditions().comprehendBusy()) {
+                    throw new Exception("UT CD Target modify test fail");
+                } else {
+                    if (!rule.getActions().getFowardTo().getTarget().endsWith("0912364587")) {
+                        throw new Exception("UT CD Target modify test fail");
+                    }
+                    if (!rule.getActions().getFowardTo().isNotifyCaller()) {
+                        throw new Exception("UT CD Target modify test fail");
+                    }
+                }
+            }
+            // ====================================
+            // CB Action allow test
+            ruleSet = icb.getRuleSet();
+            ruleSet.clearRules();
+
+            rule = ruleSet.createNewRule("CB Action allow test");
+            rule.createConditions().addInternational();
+            actions = rule.createActions();
+            actions.setAllow(true);
+            icb.saveRuleSet();
+
+            icb = simservs.getIncomingCommunicationBarring(xcapUri,
+                    TEST_USER, "password");
+            ruleSet = icb.getRuleSet();
+            if (ruleSet.getRules().size() == 0) {
+                throw new Exception("UT CB Action allow test fail");
+            } else {
+                rule = ruleSet.getRules().get(0);
+                if (!rule.getConditions().comprehendInternational()) {
+                    throw new Exception("UT CB Action allow test fail");
+                } else {
+                    if (!rule.getActions().isAllow()) {
+                        throw new Exception("UT CB Action allow test fail");
+                    }
+                }
+            }
+            // ====================================
+        } catch (XcapException e) {
+            int httpErrorCode = -1;
+            int exceptionCodeCode = -1;
+            if (e.isConnectionError()) {
+                exceptionCodeCode = e.getExceptionCodeCode();
+                Log.e("Simservs", "httpErrorCode=" + httpErrorCode);
+            } else {
+                httpErrorCode = e.getHttpErrorCode();
+                Log.e("Simservs", "exceptionCodeCode=" + exceptionCodeCode);
+            }
+            e.printStackTrace();
+        }
+
+        /** Delete a XML document **/
+        // deleteDoc(ra, xcapUri.toURI(), credentials);
+        // ====================================
+        ra.shutdown();
+    }
+}
diff --git a/packages/xcap/Android.mk b/packages/xcap/Android.mk
new file mode 100644
index 0000000..91f314c
--- /dev/null
+++ b/packages/xcap/Android.mk
@@ -0,0 +1,16 @@
+LOCAL_PATH := $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_JAVA_LIBRARIES := okhttp
+
+# Include all the java files.
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+
+LOCAL_MODULE_TAGS := optional
+
+# The name of the jar file to create.
+LOCAL_MODULE := xcap
+
+# Build a static jar file.
+include $(BUILD_STATIC_JAVA_LIBRARY)
+
diff --git a/packages/xcap/NOTICE b/packages/xcap/NOTICE
new file mode 100644
index 0000000..fa27076
--- /dev/null
+++ b/packages/xcap/NOTICE
@@ -0,0 +1,15 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
\ No newline at end of file
diff --git a/packages/xcap/README b/packages/xcap/README
new file mode 100644
index 0000000..bee265b
--- /dev/null
+++ b/packages/xcap/README
@@ -0,0 +1,19 @@
+MTK XCAP library, for any feature that uses XCAP protocol.
+
+This library is pre-built by MediaTek internal.
+
+
+WHAT IT DOES?
+=============
+Simservs module will depend on xcap to communicate with XCAP server.
+
+HOW IT WAS BUILT?
+==================
+All source/dependency modules of this module are already put in
+'vendor/mediatek/proprietary/protect/external/xcap' folder.
+
+HOW TO USE IT?
+==============
+Provide api for any feature module that runs on XCAP protocol.
+
+All the source code of this library were written by MediaTek co..
diff --git a/packages/xcap/src/com/mediatek/xcap/XcapClient.java b/packages/xcap/src/com/mediatek/xcap/XcapClient.java
new file mode 100644
index 0000000..d2a43e3
--- /dev/null
+++ b/packages/xcap/src/com/mediatek/xcap/XcapClient.java
@@ -0,0 +1,492 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.client;
+
+import android.content.Context;
+import android.net.Network;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Log;
+
+import com.android.okhttp.Headers;
+
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.ProtocolException;
+import java.net.Socket;
+import java.net.URI;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.UnrecoverableKeyException;
+import java.security.cert.CertificateException;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+/**
+ * XcapClient class.
+ */
+public class XcapClient {
+    private static final String TAG = "XcapClient";
+
+    private HttpURLConnection mConnection = null;
+
+    private String mUserAgent;
+
+    // Default connection and socket timeout of 60 seconds. Tweak to taste.
+    private static final int SOCKET_OPERATION_TIMEOUT = 30 * 1000;
+    private static final int MAX_SOCKET_CONNECTION = 30;
+
+    private XcapDebugParam mDebugParam = XcapDebugParam.getInstance();
+    private Network mNetwork;
+    private Context mContext;
+
+    private TrustManager[] mTrustAllCerts = new TrustManager[] {new X509TrustManager() {
+        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+                return null;
+        }
+
+        public void checkClientTrusted(java.security.cert.X509Certificate[] certs,
+                String authType) {
+        }
+
+        public void checkServerTrusted(java.security.cert.X509Certificate[] certs,
+                String authType) {
+        }
+    } };
+
+    public static final String METHOD_PUT = "PUT";
+    public static final String METHOD_GET = "GET";
+    public static final String METHOD_DELETE = "DELETE";
+
+    /**
+     * Constructor.
+     *
+     */
+    public XcapClient() {
+        composeUserAgent();
+        initialize();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param userAgent XCAP client User Agent
+     */
+    public XcapClient(String userAgent) {
+        mUserAgent = userAgent;
+        initialize();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param network dedicated network
+     */
+    public XcapClient(Network network) {
+        composeUserAgent();
+
+        if (network != null) {
+            mNetwork = network;
+        }
+
+        initialize();
+    }
+
+    /**
+     * Constructor.
+     *
+     * @param userAgent XCAP client User Agent
+     * @param network dedicated network
+     */
+    public XcapClient(String userAgent, Network network) {
+        mUserAgent = userAgent;
+
+        if (network != null) {
+            mNetwork = network;
+        }
+
+        initialize();
+    }
+
+    /**
+     * Set context.
+     *
+     * @param ctxt context to set
+     */
+    public void setContext(Context ctxt) {
+        mContext = ctxt;
+    }
+
+    private void composeUserAgent() {
+        boolean isGbaEnabled = false;
+        IBinder b = ServiceManager.getService("GbaService");
+        if (b != null) {
+            Log.i(TAG , "GbaService Enabled");
+            isGbaEnabled = true;
+        }
+
+        if (mDebugParam.getXcapUserAgent() != null && !mDebugParam.getXcapUserAgent().isEmpty()) {
+            mUserAgent = mDebugParam.getXcapUserAgent();
+        } else {
+            mUserAgent = "XCAP Client" + (isGbaEnabled ? " 3gpp-gba" : "");
+        }
+    }
+
+    private void initialize() {
+
+    }
+
+    /**
+     * Shutdown connection.
+     */
+    public void shutdown() {
+        if (mConnection != null) {
+            mConnection.disconnect();
+        }
+    }
+
+    private void addExtraHeaders(HttpURLConnection connection, Headers rawHeaders) {
+        Set<String> names = rawHeaders.names();
+        for (String name : names) {
+            List<String> values = rawHeaders.values(name);
+            for (String value : values) {
+                if (!name.isEmpty() && !value.isEmpty()) {
+                    // Add the header if the param is valid
+                    connection.setRequestProperty(name, value);
+                    break;
+                }
+            }
+        }
+    }
+
+    private void logRequestHeaders(HttpURLConnection connection) {
+        Map<String, List<String>> headerFields = connection.getRequestProperties();
+
+        Log.d(TAG, "Request Headers:");
+
+        for (Map.Entry<String, List<String>> entry : headerFields.entrySet()) {
+            final String key = entry.getKey();
+            final List<String> values = entry.getValue();
+            if (values != null) {
+                for (String value : values) {
+                    Log.d(TAG, key + ": " + value);
+                }
+            }
+        }
+    }
+
+    private void logResponseHeaders(HttpURLConnection connection) {
+        Map<String, List<String>> headerFields = connection.getHeaderFields();
+
+        Log.d(TAG, "Response Headers:");
+
+        for (Map.Entry<String, List<String>> entry : headerFields.entrySet()) {
+            final String key = entry.getKey();
+            final List<String> values = entry.getValue();
+            if (values != null) {
+                for (String value : values) {
+                    Log.d(TAG, key + ": " + value);
+                }
+            }
+        }
+    }
+
+    private HttpURLConnection execute(URL url, String method, byte[] xml,
+            Headers additionalRequestHeaders) throws IOException {
+        int tryCount = 3;
+        boolean success = false;
+        //OkHttp usage
+        mConnection = null;
+
+        boolean isTrustAll = mDebugParam.getEnableXcapTrustAll();
+
+        if (isTrustAll) {
+            // Install the all-trusting trust manager
+            try {
+                SSLContext sc = SSLContext.getInstance("SSL");
+                sc.init(null, mTrustAllCerts, new java.security.SecureRandom());
+                HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
+            } catch (GeneralSecurityException se) {
+                se.printStackTrace();
+            }
+
+            // Create all-trusting host name verifier
+            HostnameVerifier allHostsValid = new HostnameVerifier() {
+                public boolean verify(String hostname, SSLSession session) {
+                    return true;
+                }
+            };
+
+            // Install the all-trusting host verifier
+            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
+        }
+
+        while (tryCount > 0 && !success) {
+            try {
+                Log.d(TAG, method + " :" + url.toString());
+
+                if (mNetwork != null) {
+                    mConnection = (HttpURLConnection) mNetwork.openConnection(url);
+                } else {
+                    mConnection = (HttpURLConnection) url.openConnection();
+                }
+                mConnection.setDoInput(true);
+                mConnection.setConnectTimeout(SOCKET_OPERATION_TIMEOUT);
+                mConnection.setReadTimeout(SOCKET_OPERATION_TIMEOUT);
+                // xen0n: AOSP doesn't have setWriteTimeout
+                // mConnection.setWriteTimeout(SOCKET_OPERATION_TIMEOUT);
+                // Header: User-Agent
+                mConnection.setRequestProperty("User-Agent", mUserAgent);
+                addExtraHeaders(mConnection, additionalRequestHeaders);
+                // Different stuff for GET and POST
+                if (METHOD_PUT.equals(method)) {
+                    mConnection.setDoOutput(true);
+                    mConnection.setRequestMethod(METHOD_PUT);
+                    if (Log.isLoggable(TAG, Log.DEBUG)) {
+                        logRequestHeaders(mConnection);
+                    }
+                    // Sending request body
+                    final OutputStream out =
+                            new BufferedOutputStream(mConnection.getOutputStream());
+                    out.write(xml);
+                    out.flush();
+                    out.close();
+                } else if (METHOD_GET.equals(method)) {
+                    mConnection.setRequestMethod(METHOD_GET);
+                    if (Log.isLoggable(TAG, Log.DEBUG)) {
+                        logRequestHeaders(mConnection);
+                    }
+                }
+
+
+                // Get response
+                final int responseCode = mConnection.getResponseCode();
+                final String responseMessage = mConnection.getResponseMessage();
+                Log.d(TAG, "HTTP: " + responseCode + " " + responseMessage);
+                if (Log.isLoggable(TAG, Log.DEBUG)) {
+                    logResponseHeaders(mConnection);
+                }
+
+                if (responseCode == 200 || responseCode == 403  || responseCode == 304 ||
+                        responseCode == 412) {
+                    success = true;
+                    break;
+                } else if (responseCode == 409) {
+                    if ("true".equals(System.getProperty("xcap.handl409"))) {
+                        success = true;
+                        break;
+                    } else {
+                        Log.d(TAG, "HTTP status code is not 200 or 403");
+                    }
+                } else {
+                    Log.d(TAG, "HTTP status code is not 200 or 403 or 409");
+                }
+            } catch (MalformedURLException e) {
+                e.printStackTrace();
+                throw e;
+            } catch (ProtocolException e) {
+                e.printStackTrace();
+                throw e;
+            } catch (IOException e) {
+                e.printStackTrace();
+                Log.d(TAG, "gba.auth:" + System.getProperty("gba.auth"));
+                if ("403".equals(System.getProperty("gba.auth"))) {
+                    success = true;
+                    System.setProperty("gba.auth", "");
+                    throw new IOException("GBA Authentication hit HTTP 403 Forbidden");
+                } else {
+                    throw e;
+                }
+            } finally {
+                if (!success) {
+                    try {
+                        tryCount--;
+                        if (tryCount > 0) {
+                            Thread.sleep(5 * 1000);
+                            Log.d(TAG, "retry once");
+                        }
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+
+        return mConnection;
+        //OkHttp usage end
+    }
+
+    /**
+     * HTTP GET.
+     *
+     * @param  uri document URI
+     * @param  additionalRequestHeaders HTTP headers
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection get(URI uri, Headers additionalRequestHeaders) throws IOException {
+        return execute(uri.toURL(), METHOD_GET, null, additionalRequestHeaders);
+    }
+
+    /**
+     * HTTP PUT.
+     *
+     * @param  uri document URI
+     * @param  mimetype MIME TYPE
+     * @param  content content to upload
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection put(URI uri, String mimetype, String content) throws IOException {
+        Log.d(TAG, "PUT: " + content);
+        return put(uri, mimetype, content.getBytes("UTF-8"), null, null, null);
+
+    }
+
+    /**
+     * HTTP PUT.
+     *
+     * @param  uri document URI
+     * @param  mimetype MIME TYPE
+     * @param  content content to upload
+     * @param  additionalRequestHeaders HTTP headers
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection put(URI uri, String mimetype, String content,
+            Headers additionalRequestHeaders) throws IOException {
+        Log.d(TAG, "PUT: " + content);
+        return put(uri, mimetype, content.getBytes("UTF-8"), additionalRequestHeaders, null, null);
+
+    }
+
+    /**
+     * HTTP PUT.
+     *
+     * @param  uri document URI
+     * @param  mimetype MIME TYPE
+     * @param  content content to upload in string format
+     * @param  additionalRequestHeaders HTTP headers
+     * @param  eTag E-TAG
+     * @param  condition use with E-TAG
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection put(URI uri, String mimetype, String content,
+            Headers additionalRequestHeaders, String eTag, String condition) throws IOException {
+        Log.d(TAG, "PUT: " + content);
+        return put(uri, mimetype, content.getBytes("UTF-8"), additionalRequestHeaders, eTag,
+                condition);
+
+    }
+
+    /**
+     * HTTP PUT.
+     *
+     * @param  uri document URI
+     * @param  mimetype MIME TYPE
+     * @param  content content to upload in byte array format
+     * @param  additionalRequestHeaders HTTP headers
+     * @param  eTag E-TAG
+     * @param  condition use with E-TAG
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection put(URI uri, String mimetype, byte[] content,
+            Headers additionalRequestHeaders, String eTag, String condition) throws IOException {
+        Headers.Builder headers = additionalRequestHeaders.newBuilder();
+        headers.add(XcapConstants.HDR_KEY_CONTENT_TYPE, mimetype);
+        return execute(uri.toURL(), METHOD_PUT, content, headers.build());
+    }
+
+    /**
+     * HTTP DELETE.
+     *
+     * @param  uri document URI
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection delete(URI uri) throws IOException {
+        return delete(uri, null, null, null);
+    }
+
+    /**
+     * HTTP DELETE.
+     *
+     * @param  uri document URI
+     * @param  additionalRequestHeaders HTTP headers
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection delete(URI uri, Headers additionalRequestHeaders) throws IOException {
+        return delete(uri, additionalRequestHeaders, null, null);
+    }
+
+    /**
+     * HTTP DELETE.
+     *
+     * @param  uri document URI
+     * @param  additionalRequestHeaders HTTP headers
+     * @param  eTag E-TAG
+     * @param  condition use with E-TAG
+     * @return HTTP response
+     * @throws IOException if I/O error
+     */
+    public HttpURLConnection delete(URI uri, Headers additionalRequestHeaders, String eTag,
+            String condition) throws IOException {
+        return execute(uri.toURL(), METHOD_DELETE, null, additionalRequestHeaders);
+    }
+}
diff --git a/packages/xcap/src/com/mediatek/xcap/XcapConstants.java b/packages/xcap/src/com/mediatek/xcap/XcapConstants.java
new file mode 100644
index 0000000..a17053e
--- /dev/null
+++ b/packages/xcap/src/com/mediatek/xcap/XcapConstants.java
@@ -0,0 +1,82 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.client;
+
+/**
+ * XcapConstants class.
+ */
+public class XcapConstants {
+
+    /**
+     * Method enumeration.
+     */
+    public enum Method {
+        GET,
+        PUT,
+        DELETE
+    }
+
+    // KEY: HTTP Header ==> HDR_KEY
+    public static final String HDR_KEY_ALLOW = "Allow";
+    public static final String HDR_KEY_CONTENT_TYPE = "Content-Type";
+    public static final String HDR_KEY_CONTENT_LENGTH = "Content-Length";
+    public static final String HDR_KEY_ETAG = "ETag";
+    public static final String HDR_KEY_IF_MATCH = "If-Match";
+    public static final String HDR_KEY_IF_NONE_MATCH = "If-None-Match";
+    public static final String HDR_KEY_HOST = "Host";
+    public static final String HDR_KEY_AUTHORIZATION = "Authorization";
+    public static final String HDR_KEY_WWW_AUTHENTICATE = "WWW-Authenticate";
+    public static final String HDR_KEY_X_3GPP_ASSERTED_IDENTITY = "X-3GPP-Asserted-Identity";
+    public static final String HDR_KEY_X_XCAP_ASSERTED_IDENTITY = "X-XCAP-Asserted-Identity";
+
+    public static final String AUID_GROUP_USAGE_LIST = "org.openmobilealliance.group-usage-list";
+    public static final String AUID_GROUPS = "org.openmobilealliance.groups";
+    public static final String AUID_OMA_SEARCH = "org.openmobilealliance.search";
+    public static final String AUID_PRES_RULES = "org.openmobilealliance.pres-rules";
+    public static final String AUID_RESOURCE_LISTS = "resource-lists";
+    public static final String AUID_XCAP_CAPS = "xcap-caps";
+    public static final String AUID_XCAP_DIRECTORY = "org.openmobilealliance.xcap-directory";
+    public static final String AUID_USER_PROFILE = "org.openmobilealliance.user-profile";
+
+    public static final String ROOT_SIMSERVS = "simservs";
+
+    // Value: HTTP Header value ==> HDR_VALUE
+
+}
diff --git a/packages/xcap/src/com/mediatek/xcap/XcapDebugParam.java b/packages/xcap/src/com/mediatek/xcap/XcapDebugParam.java
new file mode 100644
index 0000000..f355230
--- /dev/null
+++ b/packages/xcap/src/com/mediatek/xcap/XcapDebugParam.java
@@ -0,0 +1,371 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.client;
+
+import android.os.SystemProperties;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+import org.xml.sax.SAXException;
+
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.StringReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+/**
+ * XCAP debug configuration class.
+ */
+public class XcapDebugParam {
+    private static final String TAG_ROOT = "DebugParam";
+    private static final String TAG_XCAP_ROOT = "XcapRoot";
+    private static final String TAG_XCAP_USER_AGENT = "XcapUserAgent";
+    private static final String TAG_XCAP_XUI = "XcapXui";
+    private static final String TAG_XCAP_HTTP_DIGEST_USERNAME = "HttpDigestUsername";
+    private static final String TAG_XCAP_HTTP_DIGEST_PASSWORD = "HttpDigestPassword";
+    private static final String TAG_XCAP_ENABLE_PREDEFINED_SIMSERV_QUERY_RESULT =
+            "EnablePredefinedSimservQueryResult";
+    private static final String TAG_XCAP_ENABLE_PREDEFINED_SIMSERV_SETTING =
+            "EnablePredefinedSimservSetting";
+    private static final String TAG_XCAP_ENABLE_SIMSERV_QUERY_WHOLE = "EnableSimservQueryWhole";
+    private static final String TAG_XCAP_ENABLE_HTTP_LOG = "EnableHttpLog";
+    private static final String TAG_XCAP_ENABLE_TRUST_ALL = "EnableXcapTrustAll";
+    private static final String TAG_XCAP_DOCUMENT_NAME = "XcapDocumentName";
+    private static final String TAG_XCAP_PUT_ELEMENT_MIME = "XcapPutElementMime";
+    private static final String TAG_GBA_BSF_SERVER_URL = "BsfServerUrl";
+    private static final String TAG_ENABLE_GBA_TRUST_ALL = "EnableGbaTrustAll";
+    private static final String TAG_ENABLE_GBA_FORCE_RUN = "EnableGbaForceRun";
+
+    private static XcapDebugParam sInstance;
+
+    //XCAP
+    private String mXcapRoot;
+    private String mXcapUserAgent;
+    private String mXcapXui;
+    private String mHttpDigestUsername;
+    private String mHttpDigestPassword;
+    //if enable, push xml file to /data/ss.xml
+    private boolean mEnablePredefinedSimservQueryResult = false;
+    //if enable, push xml file /data/simservs.xml
+    private boolean mEnablePredefinedSimservSetting = false;
+    private boolean mEnableSimservQueryWhole = false;
+    private boolean mEnableHttpLog = false;
+    private boolean mEnableXcapTrustAll = false;
+    private String mXcapDocumentName;
+    private String mXcapPutElementMime;
+
+    /**
+     * Singleton.
+     *
+     * @return XcapDebugParam instance
+     */
+    public static XcapDebugParam getInstance() {
+        if (sInstance == null) {
+            sInstance = new XcapDebugParam();
+        }
+        return sInstance;
+    }
+
+
+    /**
+     * Load debug configuration.
+     */
+    public void load() {
+        String xmlContent = readXmlFromFile("/data/misc/xcapconfig.xml");
+        if (xmlContent == null) {
+            return;
+        }
+
+        try {
+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
+            DocumentBuilder db = factory.newDocumentBuilder();
+            InputSource is = new InputSource();
+            is.setCharacterStream(new StringReader(xmlContent));
+            Document doc;
+            doc = db.parse(is);
+
+            NodeList debugParamNode = doc.getElementsByTagName(TAG_ROOT);
+            if (debugParamNode.getLength() > 0) {
+                instantiateFromXmlNode(debugParamNode.item(0));
+            }
+        } catch (SAXException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (ParserConfigurationException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Read XML file.
+     *
+     * @param file XML file path
+     * @return String content of XML
+     */
+    public String readXmlFromFile(String file) {
+        String text = "";
+
+        try {
+            FileInputStream fis = new FileInputStream(file);
+            DataInputStream dis = new DataInputStream(fis);
+
+            String buf;
+            while ((buf = dis.readLine()) != null) {
+                text += buf;
+            }
+            fis.close();
+        } catch (IOException e) {
+            reset();
+            return null;
+        }
+
+        return text;
+    }
+
+    private void reset() {
+        mXcapRoot = null;
+        mXcapUserAgent = null;
+        mXcapXui = null;
+        mHttpDigestUsername = null;
+        mHttpDigestPassword = null;
+        mEnablePredefinedSimservQueryResult = false;
+        mEnablePredefinedSimservSetting = false;
+        mEnableSimservQueryWhole = false;
+        mEnableHttpLog = false;
+        mEnableXcapTrustAll = false;
+        mXcapDocumentName = "simservs.xml";
+        mXcapPutElementMime = null;
+    }
+
+    private void instantiateFromXmlNode(Node domNode) {
+        Element domElement = (Element) domNode;
+
+        NodeList node = domElement.getElementsByTagName(TAG_XCAP_ROOT);
+        if (node.getLength() > 0) {
+            mXcapRoot = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_USER_AGENT);
+        if (node.getLength() > 0) {
+            mXcapUserAgent = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_XUI);
+        if (node.getLength() > 0) {
+            mXcapXui = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_HTTP_DIGEST_USERNAME);
+        if (node.getLength() > 0) {
+            mHttpDigestUsername = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_HTTP_DIGEST_PASSWORD);
+        if (node.getLength() > 0) {
+            mHttpDigestPassword = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_PREDEFINED_SIMSERV_QUERY_RESULT);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnablePredefinedSimservQueryResult = true;
+            } else {
+                mEnablePredefinedSimservQueryResult = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_PREDEFINED_SIMSERV_SETTING);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnablePredefinedSimservSetting = true;
+            } else {
+                mEnablePredefinedSimservSetting = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_SIMSERV_QUERY_WHOLE);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnableSimservQueryWhole = true;
+            } else {
+                mEnableSimservQueryWhole = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_HTTP_LOG);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnableHttpLog = true;
+            } else {
+                mEnableHttpLog = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_ENABLE_TRUST_ALL);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                mEnableXcapTrustAll = true;
+            } else {
+                mEnableXcapTrustAll = false;
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_DOCUMENT_NAME);
+        if (node.getLength() > 0) {
+            mXcapDocumentName = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_XCAP_PUT_ELEMENT_MIME);
+        if (node.getLength() > 0) {
+            mXcapPutElementMime = ((Element) node.item(0)).getTextContent();
+        }
+
+        node = domElement.getElementsByTagName(TAG_GBA_BSF_SERVER_URL);
+        if (node.getLength() > 0) {
+            String gbaBsfServerUrl = ((Element) node.item(0)).getTextContent();
+            SystemProperties.set("persist.gba.bsf.url", gbaBsfServerUrl);
+        }
+
+        node = domElement.getElementsByTagName(TAG_ENABLE_GBA_TRUST_ALL);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                SystemProperties.set("persist.gba.trustall", str);
+            } else if ("false".equalsIgnoreCase(str)) {
+                SystemProperties.set("persist.gba.trustall", str);
+            }
+        }
+
+        node = domElement.getElementsByTagName(TAG_ENABLE_GBA_FORCE_RUN);
+        if (node.getLength() > 0) {
+            String str = ((Element) node.item(0)).getTextContent();
+            if ("true".equalsIgnoreCase(str)) {
+                SystemProperties.set("gba.run", str);
+            } else if ("false".equalsIgnoreCase(str)) {
+                SystemProperties.set("gba.run", str);
+            }
+        }
+    }
+
+    public String getXcapRoot() {
+        return mXcapRoot;
+    }
+
+    public String getXcapUserAgent() {
+        return mXcapUserAgent;
+    }
+
+    public String getXcapXui() {
+        return mXcapXui;
+    }
+
+    public String getHttpDigestUsername() {
+        return mHttpDigestUsername;
+    }
+
+    public String getHttpDigestPassword() {
+        return mHttpDigestPassword;
+    }
+
+    public boolean getEnablePredefinedSimservQueryResult() {
+        return mEnablePredefinedSimservQueryResult;
+    }
+
+    public boolean getEnablePredefinedSimservSetting() {
+        return mEnablePredefinedSimservSetting;
+    }
+
+    public boolean getEnableSimservQueryWhole() {
+        return mEnableSimservQueryWhole;
+    }
+
+    public boolean getEnableHttpLog() {
+        return mEnableHttpLog;
+    }
+
+    public boolean getEnableXcapTrustAll() {
+        return mEnableXcapTrustAll;
+    }
+
+    public String getXcapDocumentName() {
+        return mXcapDocumentName;
+    }
+
+    public String getXcapPutElementMime() {
+        return mXcapPutElementMime;
+    }
+
+    /**
+     * Print info.
+     *
+     * @return String type of info
+     */
+    public String toString() {
+        return "mXcapRoot: " + mXcapRoot + "\n" +
+                "mXcapUserAgent: " + mXcapUserAgent + "\n" +
+                "mXcapXui: " + mXcapXui + "\n" +
+                "mHttpDigestUsername: " + mHttpDigestUsername + "\n" +
+                "mHttpDigestPassword: " + mHttpDigestPassword + "\n" +
+                "mEnablePredefinedSimservQueryResult: " +
+                mEnablePredefinedSimservQueryResult + "\n" +
+                "mEnablePredefinedSimservSetting: " +
+                mEnablePredefinedSimservSetting + "\n" +
+                "mEnableSimservQueryWhole: " + mEnableSimservQueryWhole + "\n" +
+                "mEnableHttpLog: " + mEnableHttpLog + "\n" +
+                "mEnableXcapTrustAll: " + mEnableXcapTrustAll + "\n" +
+                "mXcapDocumentName: " + mXcapDocumentName + "\n" +
+                "mXcapPutElementMime: " + mXcapPutElementMime + "\n";
+    }
+}
+
diff --git a/packages/xcap/src/com/mediatek/xcap/uri/XcapUri.java b/packages/xcap/src/com/mediatek/xcap/uri/XcapUri.java
new file mode 100644
index 0000000..32b7ef6
--- /dev/null
+++ b/packages/xcap/src/com/mediatek/xcap/uri/XcapUri.java
@@ -0,0 +1,418 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.client.uri;
+
+import android.os.SystemProperties;
+
+import java.net.URLEncoder;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.charset.Charset;
+
+/**
+ * XcapUri class.
+ */
+public class XcapUri {
+
+    private static final String RESOURCE_SELECTOR_SEPARATOR = "/~~/";
+    private static final char PATH_SEPARATOR = '/';
+
+    private String mXcapRoot = null;
+    private String mDocumentSelector = null;
+    private String mNodeSelector = null;
+
+    // Based on the Concept of XPath
+    // Example: XCAP root / Document Selector / Node Selector
+    // Node Selector
+    // ~~/resource-lists/list%5b@name=%22l1%22%5d
+
+    /**
+     * Constructor.
+     *
+     */
+    public XcapUri() {
+
+    }
+
+    public String getXcapRoot() {
+        return mXcapRoot;
+    }
+
+    /**
+     * set Xcap Root.
+     *
+     * @param xcapRoot XCAP root URI
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setXcapRoot(String xcapRoot) throws IllegalArgumentException {
+        if (xcapRoot.charAt(xcapRoot.length() - 1) != '/') {
+            throw new IllegalArgumentException("xcap root must end with /");
+        }
+        mXcapRoot = xcapRoot;
+        return this;
+    }
+
+    public String getDocumentSelector() {
+        return mDocumentSelector;
+    }
+
+    /**
+     * set document selector.
+     *
+     * @param documentSelector XCAP document selector
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setDocumentSelector(XcapDocumentSelector documentSelector)
+            throws IllegalArgumentException {
+        setDocumentSelector(documentSelector.toString());
+        return this;
+    }
+
+    /**
+     * set document selector.
+     *
+     * @param documentSelector string document selector
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setDocumentSelector(String documentSelector)
+            throws IllegalArgumentException {
+        if (documentSelector.charAt(0) == '/') {
+            throw new IllegalArgumentException("document selector must not start with /");
+        }
+        mDocumentSelector = documentSelector;
+        return this;
+    }
+
+    public String getNodeSelector() {
+        return mNodeSelector;
+    }
+
+    /**
+     * set node selector.
+     *
+     * @param nodeSelector XCAP node selector
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setNodeSelector(XcapNodeSelector nodeSelector)
+            throws IllegalArgumentException {
+        setNodeSelector(nodeSelector.toString());
+        return this;
+    }
+
+    /**
+     * set node selector.
+     *
+     * @param nodeSelector string node selector
+     * @return XcapUri
+     * @throws IllegalArgumentException if illegal argument error
+     */
+    public XcapUri setNodeSelector(String nodeSelector)
+            throws IllegalArgumentException {
+        if (mDocumentSelector.charAt(0) == '/') {
+            throw new IllegalArgumentException("document selector must not start with /");
+        }
+        mNodeSelector = nodeSelector;
+        return this;
+    }
+
+    /**
+     * Convert to URI.
+     *
+     * @return URI
+     * @throws URISyntaxException if URI syntax error
+     */
+    public URI toURI() throws URISyntaxException {
+        final StringBuilder sb = new StringBuilder(mXcapRoot);
+        if ("true".equals(SystemProperties.get("persist.mtk.xcap.rawurl"))) {
+            sb.append(mDocumentSelector);
+            if (mNodeSelector != null) {
+                sb.append(RESOURCE_SELECTOR_SEPARATOR).append(mNodeSelector);
+            }
+        } else {
+            sb.append(mDocumentSelector.replaceAll("\\+", "%2B"));
+            if (mNodeSelector != null) {
+                sb.append(RESOURCE_SELECTOR_SEPARATOR).append(
+                        mNodeSelector.replaceAll("\\+", "%2B"));
+            }
+        }
+
+        return new URI(sb.toString());
+    }
+
+    /**
+     * XcapDocumentSelector class.
+     *
+     */
+    static public class XcapDocumentSelector {
+
+        private static final String XCAP_USER_PATH = "users";
+        private static final String XCAP_GLOBAL_PATH = "global";
+
+        private StringBuilder mDocumentSelector = new StringBuilder();
+        private String mAuid = null;
+        private String mXui = null;
+        private String mDocumentName = null;
+
+        /**
+         * Make XCAP document path.
+         *
+         * @param newSegment segment
+         * @return XcapDocumentSelector
+         */
+        public XcapDocumentSelector queryPath(String newSegment) {
+            if (mDocumentSelector.length() != 0) {
+                mDocumentSelector.append(PATH_SEPARATOR);
+            }
+            mDocumentSelector.append(newSegment);
+            return this;
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param auid application ID
+         * @param xui  XUI
+         * @param documentName document name
+         */
+        public XcapDocumentSelector(String auid, String xui, String documentName) {
+            mAuid = auid;
+            mXui = xui;
+            mDocumentName = documentName;
+
+            this.queryPath(auid).queryPath(XCAP_USER_PATH).queryPath(xui).queryPath(documentName);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param auid application ID
+         * @param documentName document name
+         */
+        public XcapDocumentSelector(String auid, String documentName) {
+            StringBuilder documentSelector = new StringBuilder();
+
+            mAuid = auid;
+            mDocumentName = documentName;
+
+            this.queryPath(auid).queryPath(XCAP_GLOBAL_PATH).queryPath(documentName);
+        }
+
+        /**
+         * Convert to string.
+         *
+         * @return string
+         */
+        public String toString() {
+            return mDocumentSelector.toString();
+        }
+    }
+
+    /**
+     * XcapNodeSelector class.
+     *
+     */
+    static public class XcapNodeSelector {
+        private final StringBuilder mNodeSelector = new StringBuilder();
+
+        /**
+         * Make node path.
+         *
+         * @param elementName XML element name
+         * @return XcapNodeSelector instance
+         */
+        // Select by Element Name
+        public XcapNodeSelector queryByNodeName(String elementName) {
+            if (elementName == null) {
+                return this;
+            }
+
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName);
+            return this;
+        }
+
+        /**
+         * Make attribute path.
+         *
+         * @param attrName XML attribute name
+         * @return XcapNodeSelector instance
+         */
+        // Select by Attribute Name
+        public XcapNodeSelector queryByAttrName(String attrName) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append("@").append(attrName);
+            return this;
+        }
+
+        /**
+         * Make element path with attribute.
+         *
+         * @param elementName XML element name
+         * @param attrName    XML attribute name
+         * @return XcapNodeSelector instance
+         */
+        // Select by Element Name with Attribute
+        public XcapNodeSelector queryByNodeName(String elementName, String attrName) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName);
+            queryByAttrName(attrName);
+            return this;
+        }
+
+        /**
+         * Make element path with attribute name and value.
+         *
+         * @param elementName XML element name
+         * @param attrName    XML attribute name
+         * @param attrValue   XML attribute value
+         * @return XcapNodeSelector instance
+         */
+        // Select by Attribute Name/Value
+        public XcapNodeSelector queryByNodeName(String elementName, String attrName,
+                String attrValue) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName).append("[@").append(attrName).append("=\"")
+                    .append(attrValue).append("\"]");
+            return this;
+        }
+
+        /**
+         * Make path by node name.
+         *
+         * @param elementName XML element name
+         * @param pos         position offset
+         * @return XcapNodeSelector instance
+         */
+        // Positional Selectors
+        public XcapNodeSelector queryByNodeName(String elementName, int pos) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName).append("[").append(pos).append("]");
+            return this;
+        }
+
+        /**
+         * Make path by node name.
+         *
+         * @param elementName XML element name
+         * @param pos         position offset
+         * @param attrName    XML attribute name
+         * @param attrValue   XML attribute value
+         * @return XcapNodeSelector instance
+         */
+        // Positional Selectors
+        public XcapNodeSelector queryByNodeNameWithPos(String elementName, int pos,
+                String attrName, String attrValue) {
+            if (mNodeSelector.length() != 0) {
+                mNodeSelector.append(PATH_SEPARATOR);
+            }
+            mNodeSelector.append(elementName).append("[").append(pos).append("]").append("[@")
+                    .append(attrName).append("=\"").append(attrValue).append("\"]");
+            return this;
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param elementName XML element name
+         */
+        public XcapNodeSelector(String elementName) {
+            queryByNodeName(elementName);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param elementName XML element name
+         * @param attrName    XML attribute name
+         */
+        public XcapNodeSelector(String elementName, String attrName) {
+            queryByNodeName(elementName, attrName);
+        }
+
+        /**
+         * Constructor.
+         *
+         * @param elementName XML element name
+         * @param attrName    XML attribute name
+         * @param attrValue   XML attribute value
+         */
+        public XcapNodeSelector(String elementName, String attrName, String attrValue) {
+            queryByNodeName(elementName, attrName, attrValue);
+        }
+
+        /**
+         * Convert to string.
+         *
+         * @return string
+         */
+        public String toString() {
+            return mNodeSelector.toString();
+        }
+    }
+
+    /**
+     * Encode path in UTF-8.
+     *
+     * @param path path input
+     * @return path in UTF-8
+     * @throws NullPointerException if null error
+     */
+    public static String encodePath(String path) throws NullPointerException {
+        if (path == null) {
+            throw new NullPointerException("string to encode is null");
+        }
+        return new String(URLEncoder.encode(path));
+    }
+}
diff --git a/packages/xcap/test/XcapTester.java b/packages/xcap/test/XcapTester.java
new file mode 100644
index 0000000..37e954a
--- /dev/null
+++ b/packages/xcap/test/XcapTester.java
@@ -0,0 +1,290 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ *
+ */
+
+package com.mediatek.xcap.test;
+
+import android.util.Log;
+
+import com.mediatek.xcap.client.XcapClient;
+import com.mediatek.xcap.client.XcapConstants;
+import com.mediatek.xcap.client.uri.XcapUri;
+import com.mediatek.xcap.client.uri.XcapUri.XcapDocumentSelector;
+import com.mediatek.xcap.client.uri.XcapUri.XcapNodeSelector;
+
+import org.apache.http.HttpResponse;
+import org.apache.http.auth.UsernamePasswordCredentials;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+
+/**
+ * XcapTester class.
+ */
+public class XcapTester {
+    static final private String INITIAL_DOCUMENT =
+            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n" +
+                    "    <resource-lists xmlns=\"urn:ietf:params:xml:ns:resource-lists\">\r\n" +
+                    "        <list name=\"friends\">\r\n" +
+                    "        </list>\r\n" +
+                    "    </resource-lists>\r\n";
+
+    static final private String XCAP_ROOT = "http://172.23.4.42:80/xcap-root/";
+    static final private String TEST_USER = "xcapTest@example.com";
+    static final private String TEST_DOC = "testDoc";
+
+    static final private String TAG = "XcapTester";
+
+    private static void getDoc(XcapClient ra,
+            URI documentURI,
+            UsernamePasswordCredentials credentials) throws IOException {
+
+        HttpResponse response;
+        response = ra.get(documentURI, null);
+
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "response 200, response = " + response.toString());
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+    }
+
+    /**
+     * Test suite.
+     *
+     * @throws IOException if I/O error
+     * @throws URISyntaxException if URI syntax error
+     */
+    static public void syncTest() throws IOException, URISyntaxException {
+
+        /** Put a XML document **/
+        XcapClient ra = new XcapClient();
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials("userName",
+                "password");
+
+        XcapDocumentSelector documentSelector = new XcapDocumentSelector(
+                XcapConstants.AUID_RESOURCE_LISTS, TEST_USER, TEST_DOC);
+        Log.d(TAG, "document selector is " + documentSelector.toString());
+        XcapUri xcapUri = new XcapUri();
+        xcapUri.setXcapRoot(XCAP_ROOT).setDocumentSelector(documentSelector);
+
+        URI documentURI = xcapUri.toURI();
+        HttpResponse response;
+
+        // put the document and get sync response
+        response = ra.put(documentURI, "application/resource-lists+xml", INITIAL_DOCUMENT);
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200
+                    || response.getStatusLine().getStatusCode() == 201) {
+                Log.d("info", "document created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create document in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Get an element node **/
+        XcapNodeSelector elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends");
+        URI elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+
+        // get the document and check content is ok
+        response = ra.get(elementURI, null);
+
+        // check get response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "document retreived in xcap server and content is the expected...");
+                Log.d("info", "sync test suceed :)");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+        // ====================================
+        /** Append an element **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeName("entry");
+
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+        String newFriend = "            <entry uri=\"sip:Seraph@example.com\">\r\n" +
+                "                <display-name>Seraph Huang</display-name>\r\n" +
+                "            </entry>\r\n";
+        response = ra.put(elementURI, "application/xcap-el+xml", newFriend);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 201) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Insert an element by position indiction **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeNameWithPos("entry", 1, "uri", "sip:Johnny@example.com");
+
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+        String newFriend1 = "            <entry uri=\"sip:Johnny@example.com\">\r\n" +
+                "                <display-name>Johnny Shih</display-name>\r\n" +
+                "            </entry>\r\n";
+        response = ra.put(elementURI, "application/xcap-el+xml", newFriend1);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 201) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Modify a node attribute **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeName("entry", 1);
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+        String newFriend2 = "            <entry uri=\"sip:Johnny1@example.com\">\r\n" +
+                "                <display-name>Johnny Shih</display-name>\r\n" +
+                "            </entry>\r\n";
+        response = ra.put(elementURI, "application/xcap-el+xml", newFriend2);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Fetch an attribute **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeName("entry", 1)
+                .queryByAttrName("uri");
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+
+        response = ra.get(elementURI, null);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Delete an element **/
+        elementSelector = new XcapNodeSelector(XcapConstants.AUID_RESOURCE_LISTS)
+                .queryByNodeName("list", "name", "friends")
+                .queryByNodeNameWithPos("entry", 1, "uri", "sip:Johnny1@example.com");
+
+        elementURI = xcapUri.setNodeSelector(elementSelector).toURI();
+        response = ra.delete(elementURI);
+
+        // check put response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "element created in xcap server...");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to create element in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        /** Delete document **/
+        response = ra.delete(documentURI);
+
+        // check get response
+        if (response != null) {
+            if (response.getStatusLine().getStatusCode() == 200) {
+                Log.d("info", "document retreived in xcap server and content is the expected...");
+                Log.d("info", "sync test suceed :)");
+            } else {
+                Log.d("server", "bad response from xcap server: " + response.toString());
+            }
+        } else {
+            Log.d("server", "unable to retreive document in xcap server...");
+        }
+        // ====================================
+        // get the document and check content is ok
+        getDoc(ra, documentURI, credentials);
+        // ====================================
+        ra.shutdown();
+    }
+}
diff --git a/src/java/com/android/ims/ImsManager.java b/src/java/com/android/ims/ImsManager.java
index 707d91a..826aeb2 100644
--- a/src/java/com/android/ims/ImsManager.java
+++ b/src/java/com/android/ims/ImsManager.java
@@ -44,8 +44,20 @@ import com.android.ims.internal.IImsUt;
 import com.android.ims.internal.ImsCallSession;
 import com.android.ims.internal.IImsConfig;
 
+import com.android.internal.telephony.PhoneConstants;
 import com.android.internal.telephony.TelephonyProperties;
 
+import com.mediatek.ims.WfcReasonInfo;
+
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.capability.CapabilityService;
+import org.gsma.joyn.chat.ChatService;
+import org.gsma.joyn.contacts.ContactsService;
+import org.gsma.joyn.ft.FileTransferService;
+import org.gsma.joyn.gsh.GeolocSharingService;
+import org.gsma.joyn.ish.ImageSharingService;
+import org.gsma.joyn.vsh.VideoSharingService;
+
 import java.util.HashMap;
 
 /**
@@ -74,7 +86,7 @@ public class ImsManager {
      * Internal use only.
      * @hide
      */
-    private static final String IMS_SERVICE = "ims";
+    public /* MTK */ static final String IMS_SERVICE = "ims";
 
     /**
      * The result code to be sent back with the incoming call {@link PendingIntent}.
@@ -677,6 +689,8 @@ public class ImsManager {
         mContext = context;
         mPhoneId = phoneId;
         createImsService(true);
+        // MTK
+        createTerminalApiServices();
     }
 
     /*
@@ -722,6 +736,8 @@ public class ImsManager {
             ImsConnectionStateListener listener) throws ImsException {
         checkAndThrowExceptionIfServiceUnavailable();
 
+        if (DBG) log("ImsManager: open");  // MTK
+
         if (incomingCallPendingIntent == null) {
             throw new NullPointerException("incomingCallPendingIntent can't be null");
         }
@@ -760,6 +776,8 @@ public class ImsManager {
     public void close(int serviceId) throws ImsException {
         checkAndThrowExceptionIfServiceUnavailable();
 
+        if (DBG) log("ImsManager: close");  // MTK
+
         try {
             mImsService.close(serviceId);
         } catch (RemoteException e) {
@@ -909,6 +927,7 @@ public class ImsManager {
         boolean isConferenceUri = profile.getCallExtraBoolean(
                 TelephonyProperties.EXTRAS_IS_CONFERENCE_URI, false);
         if (!isConferenceUri && (callees != null) && (callees.length == 1)) {
+            // MTK TODO: !profile.getCallExtraBoolean(ImsCallProfile.EXTRA_CONFERENCE)
             call.start(session, callees[0]);
         } else {
             call.start(session, callees);
@@ -1097,6 +1116,8 @@ public class ImsManager {
             IBinder binder = ServiceManager.checkService(getImsServiceName(mPhoneId));
 
             if (binder == null) {
+                if (DBG) log("ImsManager: createImsService binder is null");  // MTK
+
                 return;
             }
         }
@@ -1111,6 +1132,8 @@ public class ImsManager {
         }
 
         mImsService = IImsService.Stub.asInterface(b);
+
+        if (DBG) log("ImsManager: mImsService = " + mImsService);  // MTK
     }
 
     /**
@@ -1423,4 +1446,315 @@ public class ImsManager {
         ImsManager.updateImsServiceConfig(context,
                 SubscriptionManager.getDefaultVoicePhoneId(), true);
     }
+
+    // MTK
+
+    /// M: IMS VoLTE refactoring. @{
+    /**
+     * Key to retrieve the sequence number from an incoming call intent.
+     * @see #open(PendingIntent, ImsConnectionStateListener)
+     * @hide
+     */
+    public static final String EXTRA_SEQ_NUM = "android:imsSeqNum";
+
+    /*
+     * Key to retrieve the sequence number from an incoming call intent.
+     * @see #open(PendingIntent, ImsConnectionStateListener)
+     * @hide
+     */
+    public static final String EXTRA_DIAL_STRING = "android:imsDialString";
+    /// @}
+
+    /// M: ALPS02261962. For IMS registration state and capability informaion. @{
+    public static final String ACTION_IMS_STATE_CHANGED =
+            "com.android.ims.IMS_STATE_CHANGED";
+    /// @}
+
+    /**
+     * Action for the incoming call indication intent for the Phone app.
+     * Internal use only.
+     * @hide
+     */
+    public static final String ACTION_IMS_INCOMING_CALL_INDICATION =
+            "com.android.ims.IMS_INCOMING_CALL_INDICATION";
+
+    /* M WFC */
+    public static final String EXTRA_IMS_REG_STATE_KEY = "android:regState";
+    public static final String EXTRA_IMS_ENABLE_CAP_KEY = "android:enablecap";
+    public static final String EXTRA_IMS_DISABLE_CAP_KEY = "android:disablecap";
+    public static final String EXTRA_IMS_REG_ERROR_KEY = "android:regError";
+
+    // RCS Terminal API Services
+    private CapabilityService mCapabilitiesApi;
+    private ChatService mChatApi;
+    private ContactsService mContactsApi;
+    private FileTransferService mFileTransferApi;
+    private GeolocSharingService mGeolocSharingApi;
+    private VideoSharingService mVideoSharingApi;
+    private ImageSharingService mImageSharingApi;
+
+    private void createTerminalApiServices()
+    {
+        Rlog.d(TAG, "createTerminalApiServices entry");
+        mCapabilitiesApi = new CapabilityService(mContext,
+                new MyServiceListener());
+        mCapabilitiesApi.connect();
+        mChatApi = new ChatService(mContext,
+                new MyServiceListener());
+        mChatApi.connect();
+        mContactsApi = new ContactsService(mContext,
+                new MyServiceListener());
+        mContactsApi.connect();
+        mFileTransferApi = new FileTransferService(mContext,
+                new MyServiceListener());
+        mFileTransferApi.connect();
+        mGeolocSharingApi = new GeolocSharingService(mContext,
+                new MyServiceListener());
+        mGeolocSharingApi.connect();
+        mImageSharingApi = new ImageSharingService(mContext,
+                new MyServiceListener());
+        mImageSharingApi.connect();
+        mVideoSharingApi = new VideoSharingService(mContext,
+                new MyServiceListener());
+        mVideoSharingApi.connect();
+    }
+
+    /**
+     * Returns a Capabilities Service Terminal API to client.
+     */
+    public CapabilityService getCapabilitiesService() {
+        return mCapabilitiesApi;
+    }
+
+    /**
+     * Returns a Chat Service Terminal API to client.
+     */
+    public ChatService getChatService() {
+        return mChatApi;
+    }
+
+    /**
+     * Returns a File Sharing Terminal API to client.
+     */
+    public FileTransferService getFileTransferService() {
+        return mFileTransferApi;
+    }
+
+    /**
+     * Returns a Contacts Service Terminal API to client.
+     */
+    public ContactsService getContactsService() {
+        return mContactsApi;
+    }
+
+    /**
+     * Returns a Geoloc Sharing Terminal API to client.
+     */
+    public GeolocSharingService getGeolocSharingService() {
+        return mGeolocSharingApi;
+    }
+
+    /**
+     * Returns a Image Sharing Terminal API to client.
+     */
+    public ImageSharingService getImageSharingService() {
+        return mImageSharingApi;
+    }
+
+    /**
+     * Returns a Video Sharing Terminal API to client.
+     */
+    public VideoSharingService getVideoSharingService() {
+        return mVideoSharingApi;
+    }
+
+    /**
+     * MyServiceListener listen to connect/disconnect service events.
+     */
+    public class MyServiceListener implements JoynServiceListener {
+
+        /**
+         * On service connected.
+         */
+        @Override
+        public void onServiceConnected() {
+            Rlog.d(TAG, "onServiceConnected entry ");
+        }
+
+        /**
+         * On service disconnected.
+         *
+         * @param error the error
+         */
+        @Override
+        public void onServiceDisconnected(int error) {
+            Rlog.d(TAG, "onServiceDisconnected entry " + error);
+        }
+
+    }
+
+    /**
+     * Gets the sequence number from the specified incoming call broadcast intent.
+     *
+     * @param incomingCallIntent the incoming call broadcast intent
+     * @return the sequence number or null if the intent does not contain it
+     * @hide
+     */
+    private static int getSeqNum(Intent incomingCallIntent) {
+        if (incomingCallIntent == null) {
+            return (-1);
+        }
+
+        return incomingCallIntent.getIntExtra(EXTRA_SEQ_NUM, -1);
+    }
+
+    /**
+     * To Allow or refuse incoming call indication to send to App.
+     *
+     * @param serviceId a service id which is obtained from {@link ImsManager#open}
+     * @param incomingCallIndication the incoming call broadcast intent.
+     * @param isAllow to indication to allow or refuse the incoming call indication.
+     * @throws ImsException if set call indication results in an error.
+     * @hide
+     */
+    public void setCallIndication(int serviceId, Intent incomingCallIndication,
+            boolean isAllow) throws ImsException {
+        if (DBG) {
+            log("setCallIndication :: serviceId=" + serviceId
+                    + ", incomingCallIndication=" + incomingCallIndication);
+        }
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        if (incomingCallIndication == null) {
+            throw new ImsException("Can't retrieve session with null intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        int incomingServiceId = getServiceId(incomingCallIndication);
+
+        if (serviceId != incomingServiceId) {
+            throw new ImsException("Service id is mismatched in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        String callId = getCallId(incomingCallIndication);
+
+        if (callId == null) {
+            throw new ImsException("Call ID missing in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        int seqNum = getSeqNum(incomingCallIndication);
+
+        if (seqNum == -1) {
+            throw new ImsException("seqNum missing in the incoming call intent",
+                    ImsReasonInfo.CODE_LOCAL_ILLEGAL_ARGUMENT);
+        }
+
+        try {
+            mImsService.setCallIndication(callId, seqNum, isAllow);
+        } catch (RemoteException e) {
+            throw new ImsException("setCallIndication()", e,
+                    ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+     * To get IMS state.
+     *
+     * @return ims state - disabled, enabling, enable, disabling.
+     * @throws ImsException if getting the ims status result in an error.
+     * @hide
+     */
+    public int getImsState() throws ImsException {
+        int imsState = PhoneConstants.IMS_STATE_DISABLED;
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            imsState = mImsService.getImsState();
+        } catch (RemoteException e) {
+            throw new ImsException("getImsState()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+        return imsState;
+    }
+
+    /**
+    * To get IMS registration status.
+    *
+    * @return true if ims is registered or false if ims is unregistered.
+    * @throws ImsException if getting the ims registration result in an error.
+    * @hide
+    */
+    public boolean getImsRegInfo() throws ImsException {
+        boolean isImsReg = false;
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            isImsReg = mImsService.getImsRegInfo(mPhoneId);
+        } catch (RemoteException e) {
+            throw new ImsException("getImsRegInfo", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+        return isImsReg;
+    }
+
+    /**
+    * To get IMS registration extension information.
+    *
+    * @return a string which is converted from the value of ims feature capability.
+    * @throws ImsException if getting the ims extension information result in an error.
+    * @hide
+    */
+    public String getImsExtInfo() throws ImsException {
+        String imsExtInfo = "0";
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            imsExtInfo = mImsService.getImsExtInfo();
+        } catch (RemoteException e) {
+            throw new ImsException("getImsExtInfo()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+        return imsExtInfo;
+    }
+
+    /**
+    * To hangup all calls.
+    * @throws ImsException if getting the ims status result in an error.
+    * @hide
+    */
+    public void hangupAllCall() throws ImsException {
+
+        checkAndThrowExceptionIfServiceUnavailable();
+
+        try {
+            mImsService.hangupAllCall();
+        } catch (RemoteException e) {
+            throw new ImsException("hangupAll()", e, ImsReasonInfo.CODE_LOCAL_IMS_SERVICE_DOWN);
+        }
+    }
+
+    /**
+    * To get WFC stat.
+    *
+    * @return a value for wfc status.
+    * @throws ImsException if getting the ims status result in an error.
+    * @hide
+    */
+    public int getWfcStatusCode() /*throws RemoteException*/ {
+        /*if (mImsNotificationController == null) {
+            throw new RemoteException ("getWfcStatusCode:ImsNotificationController not ready");
+            }
+            return mImsNotificationController.getRegistrationStatus(); */
+        if (mImsService == null) {
+            return WfcReasonInfo.CODE_WFC_DEFAULT;
+        }
+        try {
+            return mImsService.getRegistrationStatus();
+        } catch (RemoteException e) {
+            return WfcReasonInfo.CODE_WFC_DEFAULT;
+        }
+    }
 }
diff --git a/src/java/com/android/ims/ImsServiceBase.java b/src/java/com/android/ims/ImsServiceBase.java
index 0fdde8e..0dd6851 100644
--- a/src/java/com/android/ims/ImsServiceBase.java
+++ b/src/java/com/android/ims/ImsServiceBase.java
@@ -110,6 +110,38 @@ public abstract class ImsServiceBase {
         public void setUiTTYMode(int serviceId, int uiTtyMode, Message onComplete) {
             onSetUiTTYMode(serviceId, uiTtyMode, onComplete);
         }
+
+        // xen0n
+
+        @Override
+        public void setCallIndication(String callId, int seqNum, boolean isAllow) {
+            onSetCallIndication(callId, seqNum, isAllow);
+        }
+
+        @Override
+        public int getImsState() {
+            return onGetImsState();
+        }
+
+        @Override
+        public boolean getImsRegInfo(int phoneId) {
+            return onGetImsRegInfo(phoneId);
+        }
+
+        @Override
+        public String getImsExtInfo() {
+            return onGetImsExtInfo();
+        }
+
+        @Override
+        public void hangupAllCall() {
+            onHangupAllCall();
+        }
+
+        @Override
+        public int getRegistrationStatus() {
+            return onGetRegistrationStatus();
+        }
     }
 
     private ImsServiceBinder mBinder;
@@ -197,5 +229,39 @@ public abstract class ImsServiceBase {
     protected void onSetUiTTYMode(int serviceId, int uiTtyMode, Message onComplete) {
         // no-op
     }
+
+    // xen0n
+
+    protected void onSetCallIndication(String callId, int seqNum, boolean isAllow) {
+        // no-op
+    }
+
+    protected int onGetImsState() {
+        // no-op
+
+        return 0;  // DUMMY VALUE
+    }
+
+    protected boolean onGetImsRegInfo(int phoneId) {
+        // no-op
+
+        return false;  // DUMMY VALUE
+    }
+
+    protected String onGetImsExtInfo() {
+        // no-op
+
+        return "";  // DUMMY VALUE
+    }
+
+    protected void onHangupAllCall() {
+        // no-op
+    }
+
+    protected int onGetRegistrationStatus() {
+        // no-op
+
+        return 0;  // DUMMY VALUE
+    }
 }
 
diff --git a/src/java/com/android/ims/ImsUt.java b/src/java/com/android/ims/ImsUt.java
index ccf4c76..058a9a6 100644
--- a/src/java/com/android/ims/ImsUt.java
+++ b/src/java/com/android/ims/ImsUt.java
@@ -28,6 +28,9 @@ import android.telephony.Rlog;
 import com.android.ims.internal.IImsUt;
 import com.android.ims.internal.IImsUtListener;
 
+/// M: SS OP01 Ut
+import java.util.Arrays;
+
 /**
  * Provides APIs for the supplementary service settings using IMS (Ut interface).
  * It is created from 3GPP TS 24.623 (XCAP(XML Configuration Access Protocol)
@@ -681,5 +684,87 @@ public class ImsUt implements ImsUtInterface {
                 mPendingCmds.remove(key);
             }
         }
+
+        // MTK
+
+        /// M: SS OP01 Ut @{
+        /**
+         * Notifies the status of the call forwarding in a time slot supplementary service.
+         */
+        @Override
+        public void utConfigurationCallForwardInTimeSlotQueried(IImsUt ut,
+                int id, ImsCallForwardInfoEx[] cfInfo) {
+            Integer key = Integer.valueOf(id);
+
+            synchronized (mLockObj) {
+                sendSuccessReport(mPendingCmds.get(key), cfInfo);
+                mPendingCmds.remove(key);
+            }
+        }
+        /// @}
+    }
+
+    // MTK
+
+    /// M: SS OP01 Ut @{
+    /**
+     * Retrieves the configuration of the call forward in a time slot.
+     * The return value of ((AsyncResult)result.obj) is an array of {@link ImsCallForwardInfoEx}.
+     */
+    @Override
+    public void queryCallForwardInTimeSlot(int condition, Message result) {
+        if (DBG) {
+            log("queryCallForwardInTimeSlot :: Ut = " + miUt + ", condition = " + condition);
+        }
+
+        synchronized (mLockObj) {
+            try {
+                int id = miUt.queryCallForwardInTimeSlot(condition);
+
+                if (id < 0) {
+                    sendFailureReport(result,
+                            new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
+                    return;
+                }
+
+                mPendingCmds.put(Integer.valueOf(id), result);
+            } catch (RemoteException e) {
+                sendFailureReport(result,
+                        new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
+            }
+        }
+    }
+
+    /**
+     * Modifies the configuration of the call forward in a time slot.
+     */
+    @Override
+    public void updateCallForwardInTimeSlot(int action, int condition, String number,
+            int timeSeconds, long[] timeSlot, Message result) {
+        if (DBG) {
+            log("updateCallForwardInTimeSlot :: Ut = " + miUt + ", action = " + action
+                    + ", condition = " + condition + ", number = " + number
+                    + ", timeSeconds = " + timeSeconds
+                    + ", timeSlot = " + Arrays.toString(timeSlot));
+        }
+
+        synchronized (mLockObj) {
+            try {
+                int id = miUt.updateCallForwardInTimeSlot(action,
+                        condition, number, timeSeconds, timeSlot);
+
+                if (id < 0) {
+                    sendFailureReport(result,
+                            new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
+                    return;
+                }
+
+                mPendingCmds.put(Integer.valueOf(id), result);
+            } catch (RemoteException e) {
+                sendFailureReport(result,
+                        new ImsReasonInfo(ImsReasonInfo.CODE_UT_SERVICE_UNAVAILABLE, 0));
+            }
+        }
     }
+    /// @}
 }
diff --git a/src/java/com/android/ims/ImsUtInterface.java b/src/java/com/android/ims/ImsUtInterface.java
index 327f476..1b37546 100644
--- a/src/java/com/android/ims/ImsUtInterface.java
+++ b/src/java/com/android/ims/ImsUtInterface.java
@@ -183,4 +183,20 @@ public interface ImsUtInterface {
      * Updates the configuration of the COLP supplementary service.
      */
     public void updateCOLP(boolean enable, Message result);
+
+    // MTK
+
+    /// M: SS OP01 Ut @{
+    /**
+     * Retrieves the configuration of the call forward in a time slot.
+     * The return value of ((AsyncResult)result.obj) is an array of {@link ImsCallForwardInfoEx}.
+     */
+    public void queryCallForwardInTimeSlot(int condition, Message result);
+
+    /**
+     * Modifies the configuration of the call forward in a time slot.
+     */
+    public void updateCallForwardInTimeSlot(int action, int condition, String number,
+            int timeSeconds, long[] timeSlot, Message result);
+    /// @}
 }
diff --git a/src/java/com/android/ims/internal/ImsCallSession.java b/src/java/com/android/ims/internal/ImsCallSession.java
index d8614e3..f462a71 100644
--- a/src/java/com/android/ims/internal/ImsCallSession.java
+++ b/src/java/com/android/ims/internal/ImsCallSession.java
@@ -17,6 +17,7 @@
 package com.android.ims.internal;
 
 import android.os.Message;
+import android.os.Messenger;
 import android.os.RemoteException;
 import android.telecom.Connection;
 
@@ -402,6 +403,21 @@ public class ImsCallSession {
         public void callSessionSuppServiceReceived(ImsCallSession session,
                 ImsSuppServiceNotification suppServiceInfo) {
         }
+
+        // MTK
+
+        /// M: ALPS02256671. For PAU information changed. @{
+        /**
+         * Notifies of a change to the PAU information.
+         *
+         * @param session The call session.
+         * @param profile The call profile.
+         * @hide
+         */
+        public void callSessionPauInfoChanged(ImsCallSession session, ImsCallProfile profile) {
+            // no-op
+        }
+        /// @}
     }
 
     private final IImsCallSession miSession;
@@ -871,7 +887,17 @@ public class ImsCallSession {
         }
 
         try {
+            // MTK
+            /// M: ALPS02321477 @{
+            /// Google issue. Original sendDtmf could not pass Message.target to another process,
+            /// because Message.writeToParcel didn't write target. Workaround this issue by adding
+            /// a new API which passes target by Messenger.
+            if (result != null && result.getTarget() != null) {
+                Messenger target = new Messenger(result.getTarget());
+                miSession.sendDtmfbyTarget(c, result, target);
+            } else {
             miSession.sendDtmf(c, result);
+            }  // MTK
         } catch (RemoteException e) {
         }
     }
@@ -1265,6 +1291,23 @@ public class ImsCallSession {
             }
         }
 
+        // MTK
+
+        /// M: ALPS02256671. For PAU information changed. @{
+        /**
+         * Notifies of a change to the PAU information.
+         *
+         * @param session The call session.
+         * @param profile The call profile.
+         * @hide
+         */
+        public void callSessionPauInfoChanged(IImsCallSession session, ImsCallProfile profile) {
+            if (mListener != null) {
+                mListener.callSessionPauInfoChanged(ImsCallSession.this, profile);
+            }
+        }
+        /// @}
+
     }
 
     /**
@@ -1285,4 +1328,26 @@ public class ImsCallSession {
         sb.append("]");
         return sb.toString();
     }
+
+    // MTK
+
+    /// M: For one-key conference MT displayed as incoming conference call. @{
+    /**
+     * Determines if the incoming session is multiparty.
+     *
+     * @return {@code True} if the incoming session is multiparty.
+     * @hide
+     */
+    public boolean isIncomingCallMultiparty() {
+        if (mClosed) {
+            return false;
+        }
+
+        try {
+            return miSession.isIncomingCallMultiparty();
+        } catch (RemoteException e) {
+            return false;
+        }
+    }
+    /// @}
 }
diff --git a/src/java/com/android/ims/internal/ImsVideoCallProvider.java b/src/java/com/android/ims/internal/ImsVideoCallProvider.java
index 7050631..b0bdd92 100644
--- a/src/java/com/android/ims/internal/ImsVideoCallProvider.java
+++ b/src/java/com/android/ims/internal/ImsVideoCallProvider.java
@@ -94,6 +94,12 @@ public abstract class ImsVideoCallProvider {
                 case MSG_SET_PAUSE_IMAGE:
                     onSetPauseImage((Uri) msg.obj);
                     break;
+                // MTK
+                /* M: ViLTE part start */
+                case MSG_SET_UI_MODE:
+                    onSetUIMode((int) msg.obj);
+                    break;
+                /* M: ViLTE part end */
                 default:
                     break;
             }
@@ -151,6 +157,14 @@ public abstract class ImsVideoCallProvider {
         public void setPauseImage(Uri uri) {
             mProviderHandler.obtainMessage(MSG_SET_PAUSE_IMAGE, uri).sendToTarget();
         }
+
+        // MTK
+
+        /* M: ViLTE part start */
+        public void setUIMode(int mode) {
+            mProviderHandler.obtainMessage(MSG_SET_UI_MODE, mode).sendToTarget();
+        }
+        /* M: ViLTE part end */
     }
 
     public ImsVideoCallProvider() {
@@ -265,4 +279,16 @@ public abstract class ImsVideoCallProvider {
             }
         }
     }
+
+    // MTK
+
+    /* M: ViLTE part start */
+    private static final int MSG_MTK_BASE = 100;
+    private static final int MSG_SET_UI_MODE = MSG_MTK_BASE;
+    /* M: ViLTE part end */
+
+    /* M: ViLTE part start */
+    /** @see Connection.VideoProvider#onSetUIMode */
+    public abstract void onSetUIMode(int mode);
+    /* M: ViLTE part end */
 }
diff --git a/src/java/com/android/ims/internal/ImsVideoCallProviderWrapper.java b/src/java/com/android/ims/internal/ImsVideoCallProviderWrapper.java
index 57f74fa..9b277a1 100644
--- a/src/java/com/android/ims/internal/ImsVideoCallProviderWrapper.java
+++ b/src/java/com/android/ims/internal/ImsVideoCallProviderWrapper.java
@@ -108,6 +108,20 @@ public class ImsVideoCallProviderWrapper extends Connection.VideoProvider {
             mHandler.obtainMessage(MSG_CHANGE_CAMERA_CAPABILITIES,
                     cameraCapabilities).sendToTarget();
         }
+
+        // MTK
+
+        /* M: ViLTE part start */
+        /* Different from AOSP, additional parameter "rotation" is added. */
+        @Override
+        public void changePeerDimensionsWithAngle(int width, int height, int rotation) {
+            SomeArgs args = SomeArgs.obtain();
+            args.arg1 = width;
+            args.arg2 = height;
+            args.arg3 = rotation;
+            mHandler.obtainMessage(MSG_CHANGE_PEER_DIMENSIONS_WITH_ANGLE, args).sendToTarget();
+        }
+        /* M: ViLTE part end */
     }
 
     /** Default handler used to consolidate binder method calls onto a single thread. */
@@ -153,6 +167,22 @@ public class ImsVideoCallProviderWrapper extends Connection.VideoProvider {
                 case MSG_CHANGE_VIDEO_QUALITY:
                     changeVideoQuality(msg.arg1);
                     break;
+                // MTK
+                /* M: ViLTE part start */
+                /* Different from AOSP, additional parameter "rotation" is added. */
+                case MSG_CHANGE_PEER_DIMENSIONS_WITH_ANGLE:
+                    args = (SomeArgs) msg.obj;
+                    try {
+                        int width = (int) args.arg1;
+                        int height = (int) args.arg2;
+                        int rotation = (int) args.arg3;
+                        // MTK TODO: wow this is wonderfully-hidden intrusive modification...
+                        // changePeerDimensionsWithAngle(width, height, rotation);
+                    } finally {
+                        args.recycle();
+                    }
+                    break;
+                /* M: ViLTE part end */
                 default:
                     break;
             }
@@ -253,4 +283,24 @@ public class ImsVideoCallProviderWrapper extends Connection.VideoProvider {
         } catch (RemoteException e) {
         }
     }
+
+    // MTK
+
+    private static final int MSG_MTK_BASE = 100;
+    private static final int MSG_CHANGE_PEER_DIMENSIONS_WITH_ANGLE = MSG_MTK_BASE;
+
+    /* M: ViLTE part start */
+    /** @inheritDoc */
+    public void onSetUIMode(int mode) {
+        try {
+            mVideoCallProvider.setUIMode(mode);
+        } catch (RemoteException e) {
+        }
+    }
+
+    public IImsVideoCallProvider getProvider() {
+        return mVideoCallProvider;
+    }
+    /* M: ViLTE part end */
+
 }
diff --git a/src/java/com/mediatek/ims/ImsNotificationController.java b/src/java/com/mediatek/ims/ImsNotificationController.java
new file mode 100644
index 0000000..dc76649
--- /dev/null
+++ b/src/java/com/mediatek/ims/ImsNotificationController.java
@@ -0,0 +1,446 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.ims;
+
+import android.app.KeyguardManager;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.database.ContentObserver;
+import android.net.ConnectivityManager;
+import android.net.NetworkInfo;
+import android.net.NetworkInfo.DetailedState;
+import android.net.Uri;
+import android.net.wifi.WifiManager;
+import android.os.Handler;
+import android.provider.Settings;
+import android.telephony.ServiceState;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import com.android.ims.ImsConfig;
+import com.android.ims.ImsManager;
+import com.android.internal.telephony.PhoneConstants;
+import com.android.internal.telephony.RILConstants;
+
+// import com.mediatek.common.MPlugin;
+// import com.mediatek.common.wfc.IImsNotificationControllerExt;
+
+/** Class to show WFC related notifications like registration & WFC call.
+ */
+public class ImsNotificationController {
+
+    BroadcastReceiver mBr = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            // TODO Auto-generated method stub
+            if (DBG) Log.d(TAG, "Intent action:" + intent.getAction());
+
+            /* Restore screen lock state, even if intent received may not provide its effect */
+            if (intent.getAction().equals(Intent.ACTION_SCREEN_OFF)) {
+                mIsScreenLock = true;
+                handleScreenOff();
+            } else {
+                mIsScreenLock = mKeyguardManager.isKeyguardLocked();
+            }
+            if (DBG) Log.d(TAG, "on receive:screen lock:" + mIsScreenLock);
+
+            /* ALPS02260621: Need to save phone_type as there is no provision of getting it
+                     * without having phone object.
+                     */
+            if (intent.getAction().equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED)) {
+                String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+                int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY,
+                        RILConstants.NO_PHONE);
+                if (phoneType == RILConstants.IMS_PHONE) {
+                    if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                            || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                        mPhoneType = RILConstants.IMS_PHONE;
+                    } else {
+                        mPhoneType = RILConstants.NO_PHONE;
+                    }
+                }
+            }
+            if (DBG) {
+                Log.d(TAG, "mPhoneType:" + mPhoneType);
+            }
+
+            if (Settings.Global.getInt(context.getContentResolver(),
+                    Settings.Global.WFC_IMS_ENABLED,
+                    ImsConfig.FeatureValueConstants.OFF)
+                    == ImsConfig.FeatureValueConstants.OFF
+                    || !isWifiEnabled() || !isWifiConnected()) {
+                if (DBG) Log.d(TAG, "WFC off or Wifi off or not connected, return");
+                removeWfcNotification();
+                return;
+            }
+
+            if (intent.getAction().equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+                handleImsStateChange(intent);
+            } else if (intent.getAction().equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED)) {
+                handleCallIntent(intent);
+            } else if (intent.getAction().equals(ImsManager.ACTION_IMS_SERVICE_DOWN)) {
+                removeWfcNotification();
+            } else if (intent.getAction().equals(Intent.ACTION_SCREEN_ON)) {
+                handleScreenOn();
+            } else if (intent.getAction().equals(Intent.ACTION_USER_PRESENT)) {
+                handleScreenUnlock();
+            }
+        }
+    };
+
+    private static final boolean DBG = true;
+    private static final String TAG = "ImsNotificationController";
+    private static final String ACTION_LAUNCH_WFC_SETTINGS
+            = "android.settings.WIFI_CALLING_SETTINGS";
+
+    /**
+    * Wfc registration notification ID. This is
+     * the ID of the Notification given to the NotificationManager.
+     * Note: Id should be unique within APP.
+     */
+    private static final int WFC_NOTIFICATION = 0x10;
+
+    // MTK TODO
+    private static final int WFC_REGISTERED_ICON =
+            0;  //com.mediatek.internal.R.drawable.wfc_notify_registration_success;
+    private static final int WFC_CALL_ICON =
+            0;  //com.mediatek.internal.R.drawable.wfc_notify_ongoing_call;
+
+    private static final int WFC_REGISTERED_TITLE =
+            0;  //com.mediatek.internal.R.string.success_notification_title;
+    private static final int WFC_CALL_TITLE =
+            0;  //com.mediatek.internal.R.string.ongoing_call_notification_title;
+
+    private static final int WFC_REGISTERED_SUMMARY =
+            0;  //com.mediatek.internal.R.string.success_notification_summary;
+
+    // Current WFC state.
+    // Can be: 1) Success: WFC registered (2) DEFAULT: WFC on but not registered
+    // (3) Various error codes: defined in WfcReasonInfo
+    private int mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+
+    private boolean mWfcCapabilityPresent = false;
+    private boolean mWfcCallOngoing = false;
+    private boolean mIsScreenLock = false;
+
+    /*  Vars required for ImsNotificationController initialization */
+    private Context mContext;
+    private long mSubId;
+    private int mPhoneType = RILConstants.NO_PHONE;
+
+    private NotificationManager mNotificationManager;
+    private WifiManager mWifiManager;
+    private ConnectivityManager mConnectivityManager;
+    private KeyguardManager mKeyguardManager;
+    private ContentObserver mWfcSwitchContentObserver;
+
+    /* IMSN Plugin */
+    // IImsNotificationControllerExt mImsnExt;
+
+    /** Constructor.
+     * @param context context
+     * @param subId subId
+     */
+    public ImsNotificationController(Context context, long subId) {
+        if (DBG) {
+            Log.d(TAG, "in constructor: subId:" + subId);
+        }
+        mContext = context;
+        mSubId = subId;
+        mNotificationManager =
+                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
+        mWifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        mConnectivityManager =
+                (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        mKeyguardManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
+        mIsScreenLock =  mKeyguardManager.isKeyguardLocked();
+        registerReceiver();
+        registerForWfcSwitchChange();
+
+         /* IMSN plugin part */
+        // mImsnExt = getIMSNPlugin(context);
+    }
+
+    /** Stop the Imsnotification controller.
+     */
+    public void stop() {
+        if (DBG) Log.d(TAG, "in destroy Instance");
+        unRegisterReceiver();
+        unRegisterForWfcSwitchChange();
+        /* Cancel visible notifications, if any */
+        mNotificationManager.cancelAll();
+    }
+
+    private void registerReceiver() {
+        IntentFilter filter = new IntentFilter(ImsManager.ACTION_IMS_STATE_CHANGED);
+        filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
+        filter.addAction(ImsManager.ACTION_IMS_SERVICE_DOWN);
+        filter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_SCREEN_ON);
+        filter.addAction(Intent.ACTION_USER_PRESENT);
+        mContext.registerReceiver(mBr, filter);
+    }
+
+    private void unRegisterReceiver() {
+        mContext.unregisterReceiver(mBr);
+    }
+
+    private void handleCallIntent(Intent intent) {
+        String state = intent.getStringExtra(TelephonyManager.EXTRA_STATE);
+        int phoneType = intent.getIntExtra(PhoneConstants.PHONE_TYPE_KEY, RILConstants.NO_PHONE);
+        if (DBG) Log.d(TAG, "in handleCallIntent, phone state:" + state);
+        if (DBG) Log.d(TAG, "in handleCallIntent, phone type:" + phoneType);
+        if (phoneType == RILConstants.IMS_PHONE) {
+            if (TelephonyManager.EXTRA_STATE_OFFHOOK.equals(state)
+                    || TelephonyManager.EXTRA_STATE_RINGING.equals(state)) {
+                mWfcCallOngoing = true;
+                displayWfcCallNotification();
+            } else {
+                mWfcCallOngoing = false;
+                displayWfcRegistrationNotification(false);
+            }
+        } else if (phoneType == RILConstants.GSM_PHONE && mWfcCallOngoing) {
+            mWfcCallOngoing = false;
+            displayWfcRegistrationNotification(false);
+        }
+    }
+
+    private void handleImsStateChange(Intent intent) {
+        if (intent.getAction().equals(ImsManager.ACTION_IMS_STATE_CHANGED)) {
+            mImsState = intent.getIntExtra(ImsManager.EXTRA_IMS_REG_STATE_KEY,
+                    ServiceState.STATE_OUT_OF_SERVICE);
+            if (DBG) Log.d(TAG, "in handleImsStateChange, serviceState:" + mImsState);
+            if (mImsState != ServiceState.STATE_IN_SERVICE) {
+                removeWfcNotification();
+            } else {
+                handleInStateService(intent);
+            }
+        }
+        if (DBG) Log.d(TAG, "exit handleImsStateChange, imsState:" + mImsState);
+    }
+
+    private void handleInStateService(Intent intent) {
+        if (DBG) Log.d(TAG, "in handleInStateService");
+        /*handle for registration icon*/
+        boolean[] enabledFeatures = intent
+                .getBooleanArrayExtra(ImsManager.EXTRA_IMS_ENABLE_CAP_KEY);
+        if (DBG) Log.d(TAG, "wifi capability:" + enabledFeatures[ImsConfig.FeatureConstants
+                .FEATURE_TYPE_VOICE_OVER_WIFI]);
+        if (enabledFeatures[ImsConfig.FeatureConstants.FEATURE_TYPE_VOICE_OVER_WIFI] == true) {
+            mWfcCapabilityPresent = true;
+            /* Capabilities have been change to WIFI, so set wfc status as Success.
+             * It is done to cover handover cases in which IMS_STATE_CHANGE is not
+             * received before capability_change intent
+            */
+            mImsState = WfcReasonInfo.CODE_WFC_SUCCESS;
+            /* ALPS02187200: Query phone state to check whether UE is in Call
+             * when capability change to Wifi.This case can happen during handover from
+             * LTE to Wifi when call is ongoing.
+             */
+            TelephonyManager tm = (TelephonyManager) mContext
+                    .getSystemService(Context.TELEPHONY_SERVICE);
+            // TODO: for multiSim
+            /* ALPS02260621: check phone_type before showing call icon*/
+            if ((tm.getCallState() == TelephonyManager.CALL_STATE_OFFHOOK
+                            || tm.getCallState() == TelephonyManager.CALL_STATE_RINGING)
+                        && mPhoneType == RILConstants.IMS_PHONE) {
+                mWfcCallOngoing = true;
+                displayWfcCallNotification();
+            } else {
+                displayWfcRegistrationNotification(true);
+            }
+        } else {
+            mWfcCapabilityPresent = false;
+            /* Capabilities have been change to other than WIFI, so set wfc status as OFF */
+            mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+            removeWfcNotification();
+        }
+    }
+
+
+
+    /* Listening screen off intent because no intent for screen lock present in SDK now
+     * So, treating screen Off as screen lock
+     * Remove notification, if screen off
+     */
+    private void handleScreenOff() {
+        mNotificationManager.cancel(WFC_NOTIFICATION);
+    }
+
+    /* Screen on but check if screen is locked or not. If unlocked, show notification. */
+    private void handleScreenOn() {
+        if (!mIsScreenLock) {
+            if (DBG) Log.d(TAG, "screen not locked & screen on, show notification");
+            showNotification();
+        }
+    }
+
+    /* Intent received when user unlocks. Show notification. */
+    private void handleScreenUnlock() {
+        showNotification();
+    }
+
+    private void showNotification() {
+        if (mWfcCallOngoing) {
+            displayWfcCallNotification();
+        } else if (mWfcCapabilityPresent) {
+            displayWfcRegistrationNotification(false);
+        }
+    }
+
+    private void displayWfcCallNotification() {
+        if (DBG) Log.d(TAG, "in call handling, screen lock:" + mIsScreenLock);
+        if (!mIsScreenLock && mImsState == WfcReasonInfo.CODE_WFC_SUCCESS
+                    && mWfcCapabilityPresent) {
+            // TODO: to handle fake SRVCC case(wfc registered but during call setup it goes on CS).
+            //Need RAT type of call setup
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(mContext.getResources().getString(WFC_CALL_TITLE))
+                    .setSmallIcon(WFC_CALL_ICON)
+                    .setOngoing(true)
+                    .setVisibility(Notification.VISIBILITY_SECRET)
+                    .build();
+            mNotificationManager.notify(WFC_NOTIFICATION, noti);
+            if (DBG) Log.d(TAG, "showing wfc call notification");
+        }
+    }
+
+    private void displayWfcRegistrationNotification(boolean showTicker) {
+        if (DBG) Log.d(TAG, "in registration handling, screen lock:" + mIsScreenLock);
+        if (!mIsScreenLock && mImsState == WfcReasonInfo.CODE_WFC_SUCCESS && mWfcCapabilityPresent
+            && mWfcCallOngoing == false) {
+            Notification noti = new Notification.Builder(mContext)
+                    .setContentTitle(mContext.getResources().getString(WFC_REGISTERED_TITLE))
+                    .setContentText(mContext.getResources().getString(WFC_REGISTERED_SUMMARY))
+                    .setSmallIcon(WFC_REGISTERED_ICON)
+                    .setOngoing(true)
+                    .setVisibility(Notification.VISIBILITY_SECRET)
+                    .build();
+            if (showTicker) {
+                noti.tickerText = mContext.getResources().getString(WFC_REGISTERED_TITLE);
+            }
+            Intent intent = new Intent(ACTION_LAUNCH_WFC_SETTINGS);
+            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+            /*
+            if (mImsnExt != null) {
+                intent = mImsnExt.getIntent(IImsNotificationControllerExt.REGISTRATION, intent);
+            }
+            */
+            noti.contentIntent = PendingIntent.getActivity(mContext, 0, intent, 0);
+            noti.flags |= Notification.FLAG_NO_CLEAR;
+            mNotificationManager.notify(WFC_NOTIFICATION, noti);
+            if (DBG) Log.d(TAG, "showing wfc registration notification");
+        }
+    }
+
+    private void removeWfcNotification() {
+        if (DBG) Log.d(TAG, "removing wfc notification, if any");
+        mNotificationManager.cancel(WFC_NOTIFICATION);
+        mImsState = WfcReasonInfo.CODE_WFC_DEFAULT;
+        mWfcCapabilityPresent = false;
+        mWfcCallOngoing = false;
+    }
+
+    public int getRegistrationStatus() {
+        return mImsState;
+    }
+
+    private boolean isWifiEnabled() {
+        int wifiState = mWifiManager.getWifiState();
+        if (DBG) Log.d(TAG, "wifi state:" + wifiState);
+        return (wifiState != WifiManager.WIFI_STATE_DISABLED);
+    }
+
+    private boolean isWifiConnected() {
+        NetworkInfo networkInfo = mConnectivityManager
+                .getNetworkInfo(ConnectivityManager.TYPE_WIFI);
+        if (networkInfo != null) {
+            if (DBG) Log.d(TAG, "networkInfo:" + networkInfo.isConnected());
+            if (DBG) Log.d(TAG, "networkInfo:" + networkInfo.getDetailedState());
+        }
+        return (networkInfo != null && (networkInfo.isConnected()
+                    || networkInfo.getDetailedState() == DetailedState.CAPTIVE_PORTAL_CHECK));
+    }
+
+    /* Observes WFC settings changes. Needed for cases when WFC is switch OFF but
+     * state_changes intent is received. Ex: WFC error & user switches WCF OFF.
+     */
+    private void registerForWfcSwitchChange() {
+        mWfcSwitchContentObserver = new ContentObserver(new Handler()) {
+
+            @Override
+            public void onChange(boolean selfChange) {
+                this.onChange(selfChange, Settings.Global.getUriFor(Settings
+                        .Global.WFC_IMS_ENABLED));
+            }
+
+            @Override
+            public void onChange(boolean selfChange, Uri uri) {
+                if (Settings.Global.getInt(mContext.getContentResolver(),
+                    Settings.Global.WFC_IMS_ENABLED,
+                    ImsConfig.FeatureValueConstants.OFF)
+                    == ImsConfig.FeatureValueConstants.OFF) {
+                    if (DBG) Log.d(TAG, "contentObserver:WFC OFF");
+                    removeWfcNotification();
+                }
+            }
+        };
+        mContext.getContentResolver().registerContentObserver(
+                Settings.Global.getUriFor(Settings.Global.WFC_IMS_ENABLED),
+                false, mWfcSwitchContentObserver);
+    }
+
+    private void unRegisterForWfcSwitchChange() {
+        mContext.getContentResolver().unregisterContentObserver(mWfcSwitchContentObserver);
+        mWfcSwitchContentObserver = null;
+    }
+
+    /*
+    private IImsNotificationControllerExt getIMSNPlugin(Context context) {
+        IImsNotificationControllerExt ext;
+        ext = (IImsNotificationControllerExt) MPlugin.createInstance(
+                IImsNotificationControllerExt.class.getName(), context);
+        return ext;
+    }
+    */
+}
+
diff --git a/src/java/com/mediatek/ims/WfcReasonInfo.java b/src/java/com/mediatek/ims/WfcReasonInfo.java
new file mode 100644
index 0000000..7d16148
--- /dev/null
+++ b/src/java/com/mediatek/ims/WfcReasonInfo.java
@@ -0,0 +1,233 @@
+package com.mediatek.ims;
+
+/**
+ * This class enables an application to get details on why a WFC.
+ * registration/call failed.
+ * @hide
+ */
+public class WfcReasonInfo {
+
+    /**
+     * Specific code of each types.
+     */
+    public static final int CODE_UNSPECIFIED = 999;
+
+    /* Registration Successful, No error code. */
+    public static final int CODE_WFC_SUCCESS = 99;
+
+    /* Code for WFC OFF & default errors, if any */
+    public static final int CODE_WFC_DEFAULT = 100;
+
+    /**
+     * RNS (RNS -> Connectivity Service (CS)).
+     */
+    // Wi-Fi signal lost
+    public static final int CODE_WFC_WIFI_SIGNAL_LOST = 2001;
+
+    // Unable to complete call
+    public static final int CODE_WFC_UNABLE_TO_COMPLETE_CALL = 2003;
+
+    // No available qualified mobile network
+    public static final int CODE_WFC_NO_AVAILABLE_QUALIFIED_MOBILE_NETWORK = 2004;
+
+    // Unable to complete call
+    public static final int CODE_WFC_UNABLE_TO_COMPLETE_CALL_CD = 2005;
+
+    // No RAT is available
+    public static final int CODE_WFC_RNS_ALLOWED_RADIO_DENY = 2006;
+
+    // (No LTE no Wi-fi) only 2G/3G is available
+    public static final int CODE_WFC_RNS_ALLOWED_RADIO_NONE = 2007;
+
+    /**
+     * DNS error.
+     */
+
+    // Unable to receive response to NAPTR query
+    public static final int CODE_WFC_DNS_RECV_NAPTR_QUERY_RSP_ERROR = 1201;
+
+    // Unable to receive response to SRV query
+    public static final int CODE_WFC_DNS_RECV_RSP_SRV_QUERY_ERROR = 1202;
+
+    // Unable to receive response to A query
+    public static final int CODE_WFC_DNS_RECV_RSP_QUERY_ERROR = 1203;
+
+    // ePDG Wi-Fi calling- Device is unable to resolve FQDN for the ePDG to an
+    // IP Address
+    public static final int CODE_WFC_DNS_RESOLVE_FQDN_ERROR = 1041;
+
+    /**
+     * SIM error.
+     */
+
+    // Incorrect SIM card used (ex: no UICC with GBA support being used)
+    // The error will be displayed when the SIM card inserted is not GBA capable
+    // or is not a TMO SIM card
+    public static final int CODE_WFC_INCORRECT_SIM_CARD_ERROR = 1301;
+
+    /**
+     * Connection Error (Unable to connect).
+     */
+    // Error shown when the device experiences a Null pointer Exception error
+    // or an error local to the device before registration attempts are made
+    public static final int CODE_WFC_LOCAL_OR_NULL_PTR_ERROR = 1401;
+
+    // Device is not able to connect to ePDG or experiences a Null pointer error
+    // or an error local to the device before registration attempts are made
+    public static final int CODE_WFC_EPDG_CON_OR_LOCAL_OR_NULL_PTR_ERROR = 1081;
+
+    // Device is unable to establish an IP sec tunnel with the ePDG for any
+    // reason
+    // other than timeout or certificate validation
+    public static final int CODE_WFC_EPDG_IPSEC_SETUP_ERROR = 1082;
+
+    // Device is unable to establish a TLS connection for reasons other than
+    // certificate
+    // verifications failures. This includes timeout to TCP connection
+    public static final int CODE_WFC_TLS_CONN_ERROR = 1405;
+
+    // Error 500: Internal server error
+    // Device receives a 500 error message in response to the register message
+    public static final int CODE_WFC_INTERNAL_SERVER_ERROR = 1406;
+
+    // REG99: All other failures
+    public static final int CODE_WFC_ANY_OTHER_CONN_ERROR = 1407;
+
+    /**
+     * Certificate Error (Invalid Certificate).
+     */
+
+    // Unable to validate the server certificate (this would happen if the URL
+    // for certificate revocation cannot be resolved to IP or
+    // the server cannot be reached in case of a firewall or captive portal)
+    public static final int CODE_WFC_SERVER_CERT_VALIDATION_ERROR = 1501;
+
+    // Unable to validate the server certificate for IP sec tunnel establishment
+    public static final int CODE_WFC_SERVER_IPSEC_CERT_VALIDATION_ERROR = 1101;
+
+    // The certificate during IP sec tunnel establishment is invalid:
+    // certificate is revoked or has expired
+    public static final int CODE_WFC_SERVER_IPSEC_CERT_INVALID_ERROR = 1111;
+
+    // The certificate is invalid: certificate is revoked, certificate expired,
+    public static final int CODE_WFC_SERVER_CERT_INVALID_ERROR = 1504;
+
+    /**
+     * Network returns 403 Forbidden to the Register message.
+     */
+    // Error 403: Unknown user
+    public static final int CODE_WFC_403_UNKNOWN_USER = 1601;
+
+    // Error 403: Roaming not allowed
+    public static final int CODE_WFC_403_ROAMING_NOT_ALLOWED = 1602;
+
+    // Error 403: Mismatch identities
+    public static final int CODE_WFC_403_MISMATCH_IDENTITIES = 1603;
+
+    // Error 403: authentication scheme unsupported
+    public static final int CODE_WFC_403_AUTH_SCHEME_UNSUPPORTED = 1604;
+
+    // Error 403: handset is blacklisted
+    public static final int CODE_WFC_403_HANDSET_BLACKLISTED = 1605;
+
+    /**
+     * No 911 address on file (Missing 911 address).
+     */
+
+    // Missing 911 address
+    public static final int CODE_WFC_911_MISSING = 1701;
+
+    /**
+     * Returns status code corresponding to WFC status.
+     * @param status indicate WFC status
+     * @return WFC error code
+     */
+    public static int getImsStatusCodeString(int status) {
+        // WFC status string resounce id
+        int resId = 0;
+        // MTK TODO
+        /*
+        switch (status) {
+            case WfcReasonInfo.CODE_WFC_DEFAULT:
+                resId = com.mediatek.internal.R.string.wfc_off;
+                break;
+            case WfcReasonInfo.CODE_WFC_SUCCESS:
+                resId = com.mediatek.internal.R.string.wfc_on;
+                break;
+            case WfcReasonInfo.CODE_WFC_RNS_ALLOWED_RADIO_DENY:
+                resId = com.mediatek.internal.R.string.wfc_rns_allowed_radio_deny; // TODO:
+                break;
+            case WfcReasonInfo.CODE_WFC_RNS_ALLOWED_RADIO_NONE:
+                resId = com.mediatek.internal.R.string.wfc_rns_allowed_radio_none; // TODO:
+                break;
+            case WfcReasonInfo.CODE_WFC_DNS_RECV_NAPTR_QUERY_RSP_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_dns_recv_naptr_query_rsp_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_DNS_RECV_RSP_SRV_QUERY_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_dns_recv_rsp_srv_query_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_DNS_RECV_RSP_QUERY_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_dns_recv_rsp_query_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_DNS_RESOLVE_FQDN_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_dns_resolve_fqdn_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_INCORRECT_SIM_CARD_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_incorrect_sim_card_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_LOCAL_OR_NULL_PTR_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_local_or_null_ptr_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_EPDG_CON_OR_LOCAL_OR_NULL_PTR_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_epdg_con_or_local_or_null_ptr_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_EPDG_IPSEC_SETUP_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_epdg_ipsec_setup_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_TLS_CONN_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_tls_conn_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_INTERNAL_SERVER_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_internal_server_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_SERVER_CERT_VALIDATION_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_server_cert_validation_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_SERVER_IPSEC_CERT_VALIDATION_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_server_ipsec_cert_validation_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_SERVER_IPSEC_CERT_INVALID_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_server_ipsec_cert_invalid_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_SERVER_CERT_INVALID_ERROR:
+                resId = com.mediatek.internal.R.string.wfc_server_cert_invalid_error;
+                break;
+            case WfcReasonInfo.CODE_WFC_403_UNKNOWN_USER:
+                resId = com.mediatek.internal.R.string.wfc_403_unknown_user;
+                break;
+            case WfcReasonInfo.CODE_WFC_403_ROAMING_NOT_ALLOWED:
+                resId = com.mediatek.internal.R.string.wfc_403_roaming_not_allowed;
+                break;
+            case WfcReasonInfo.CODE_WFC_403_MISMATCH_IDENTITIES:
+                resId = com.mediatek.internal.R.string.wfc_403_mismatch_identities;
+                break;
+            case WfcReasonInfo.CODE_WFC_403_AUTH_SCHEME_UNSUPPORTED:
+                resId = com.mediatek.internal.R.string.wfc_403_auth_scheme_unsupported;
+                break;
+            case WfcReasonInfo.CODE_WFC_403_HANDSET_BLACKLISTED:
+                resId = com.mediatek.internal.R.string.wfc_403_handset_blacklisted;
+                break;
+            case WfcReasonInfo.CODE_WFC_911_MISSING:
+                resId = com.mediatek.internal.R.string.wfc_911_missing;
+                break;
+            case CODE_WFC_ANY_OTHER_CONN_ERROR:
+            case CODE_UNSPECIFIED:
+            default:
+                resId = com.mediatek.internal.R.string.wfc_any_other_conn_error;
+                break;
+        }
+        */
+        return resId;
+    }
+
+}
diff --git a/src/java/org/gsma/joyn/Build.java b/src/java/org/gsma/joyn/Build.java
new file mode 100644
index 0000000..d16b065
--- /dev/null
+++ b/src/java/org/gsma/joyn/Build.java
@@ -0,0 +1,79 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+
+
+/**
+ * This class offers information related to the build version of the API
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Build {
+    /**
+     * List of version codes
+     */
+    public static class VERSION_CODES {
+        /**
+         * The original first version of joyn API
+         */
+        public final static int BASE = 1;
+
+    }
+
+    /**
+     * List of GSMA codes
+     */
+    public static class GSMA_CODES {
+        /**
+         * joyn hotfixes version
+         */
+        public final static int RCSE_HOTFIXES_1_2 = 1;
+        /**
+         * joyn Blackbird version
+         */
+        public final static int RCSE_BLACKBIRD = 2;
+
+    }
+
+    /**
+     * API release implementor name
+     */
+    public static final String API_CODENAME = "GSMA";
+
+    /**
+     * API version number
+     *
+     * @see Build.GSMA_CODES
+     */
+    public final static int GSMA_VERSION = GSMA_CODES.RCSE_BLACKBIRD;
+
+    /**
+     * GSMA version number from class Build.VERSION_CODES
+     */
+    public static final int API_VERSION = VERSION_CODES.BASE;
+
+    /**
+     * Internal number used by the underlying source control to represent this
+     * build
+     */
+    public static final int API_INCREMENTAL = 0;
+
+    private Build() {
+    }
+}
diff --git a/src/java/org/gsma/joyn/H264Config.java b/src/java/org/gsma/joyn/H264Config.java
new file mode 100644
index 0000000..3bbdf6e
--- /dev/null
+++ b/src/java/org/gsma/joyn/H264Config.java
@@ -0,0 +1,148 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
+
+/**
+ * Default H264 Settings
+ *
+ * @author hlxn7157
+ * @author Deutsche Telekom AG
+ */
+public class H264Config {
+
+    /** Constant values */
+    public static final int QCIF_WIDTH = 176;
+    public static final int QCIF_HEIGHT = 144;
+
+    public static final int CIF_WIDTH = 352;
+    public static final int CIF_HEIGHT = 288;
+
+    public static final int QVGA_WIDTH = 320;
+    public static final int QVGA_HEIGHT = 240;
+
+    public static final int VGA_WIDTH = 640;
+    public static final int VGA_HEIGHT = 480;
+
+    /**
+     * Codec name
+     */
+    public final static String CODEC_NAME = "H264";
+
+    /**
+     * Default clock rate
+     */
+    public final static int CLOCK_RATE = 90000;
+
+    /**
+     * H264 OPTIONAL payload format parameter "profile-level-id" - RFC 3984
+     */
+    public static final String CODEC_PARAM_PROFILEID = "profile-level-id";
+
+    /**
+     * H264 OPTIONAL payload format parameter "packetization-mode" - RFC 3984
+     */
+    public static final String CODEC_PARAM_PACKETIZATIONMODE = "packetization-mode";
+
+    /**
+     * H264 OPTIONAL payload format parameter "sprop-parameter-sets" - RFC 3984
+     */
+    public static final String CODEC_PARAM_SPROP_PARAMETER_SETS = "sprop-parameter-sets";
+
+    /**
+     * Default codec params
+     */
+    public final static String CODEC_PARAMS = "profile-level-id=42900b;packetization-mode=1";
+
+    /**
+     * Default video width
+     */
+    public final static int VIDEO_WIDTH = QCIF_WIDTH;
+
+    /**
+     * Default video height
+     */
+    public final static int VIDEO_HEIGHT = QCIF_HEIGHT;
+
+    /**
+     * Default video frame rate
+     */
+    public final static int FRAME_RATE = 15;
+
+    /**
+     * Default video bit rate
+     */
+    public final static int BIT_RATE = 64000;
+
+    /**
+     * Get value of packetization mode
+     *
+     * @param codecParams
+     * @return
+     */
+    public static int getCodecPacketizationMode(String codecParams) {
+        int packetization_mode = 0;
+        String valPackMode = getParameterValue(CODEC_PARAM_PACKETIZATIONMODE, codecParams);
+        if (valPackMode != null) {
+            try {
+                packetization_mode = Integer.parseInt(valPackMode);
+            } catch (Exception e) {
+            }
+        }
+        return packetization_mode;
+    }
+
+    /**
+     * Get value of profile level ID
+     *
+     * @param codecParams
+     * @return
+     */
+    public static String getCodecProfileLevelId(String codecParams) {
+        return getParameterValue(CODEC_PARAM_PROFILEID, codecParams);
+    }
+
+    /**
+     * Get parameter value from SDP parameters string with parameter-value
+     * format 'key1=value1; ... keyN=valueN'
+     *
+     * @param paramKey parameter name
+     * @param params parameters string
+     * @return if parameter exists return {@link String} with value, otherwise
+     *         return <code>null</code>
+     */
+    private static String getParameterValue(String paramKey, String params) {
+        String value = null;
+        if (params != null && params.length() > 0) {
+            try {
+                Pattern p = Pattern.compile("(?<=" + paramKey + "=).*?(?=;|$)");
+                Matcher m = p.matcher(params);
+                if (m.find()) {
+                    value = m.group(0);
+                }
+            } catch (PatternSyntaxException e) {
+                // Nothing to do
+            }
+        }
+        return value;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ICoreServiceWrapper.aidl b/src/java/org/gsma/joyn/ICoreServiceWrapper.aidl
new file mode 100644
index 0000000..c5032e0
--- /dev/null
+++ b/src/java/org/gsma/joyn/ICoreServiceWrapper.aidl
@@ -0,0 +1,73 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2011. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package org.gsma.joyn;
+
+
+/**
+ * This interface will handle remote calling about Registration status.
+  */
+interface ICoreServiceWrapper {
+    /**
+     * Get Window Binder. 
+     */
+	IBinder getChatServiceBinder();
+	
+	 /**
+     * Get Window Binder. 
+     */
+	IBinder getFileTransferServiceBinder();
+	
+	 /**
+     * Get Window Binder. 
+     */
+	IBinder getCapabilitiesServiceBinder();
+	
+	 /**
+     * Get Window Binder. 
+     */
+	IBinder getContactsServiceBinder();
+	
+	IBinder getGeolocServiceBinder();
+	
+	IBinder getVideoSharingServiceBinder();
+	
+	IBinder getImageSharingServiceBinder();
+	
+	IBinder getIPCallServiceBinder();
+	
+	IBinder getMultimediaSessionServiceBinder();
+	
+	IBinder getNetworkConnectivityApiBinder();
+}
diff --git a/src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl b/src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl
new file mode 100644
index 0000000..61763f9
--- /dev/null
+++ b/src/java/org/gsma/joyn/IJoynServiceRegistrationListener.aidl
@@ -0,0 +1,10 @@
+package org.gsma.joyn;
+
+/**
+ * Joyn service registration events listener
+ */
+interface IJoynServiceRegistrationListener {
+	void onServiceRegistered();
+	
+	void onServiceUnregistered();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/Intents.java b/src/java/org/gsma/joyn/Intents.java
new file mode 100644
index 0000000..0e784b9
--- /dev/null
+++ b/src/java/org/gsma/joyn/Intents.java
@@ -0,0 +1,143 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Intents related to joyn service activities
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Intents {
+    /**
+     * Intents for joyn client
+     */
+    public static class Client {
+        /**
+         * Intent to load the settings activity to enable or disable the client
+         */
+        public static final String ACTION_VIEW_SETTINGS = "org.gsma.joyn.action.VIEW_SETTINGS";
+
+        /**
+         * Intent to request the client status. The result is received via an Intent
+         * having the following extras:
+         * <ul>
+         * <li> {@link #EXTRA_CLIENT} containing the client package name.
+         * <li> {@link #EXTRA_STATUS} containing the boolean status of the client. True
+         *  means that the client is activated, else the client is not activated.
+         */
+        public static final String ACTION_CLIENT_GET_STATUS = ".client.action.GET_STATUS";
+
+        /**
+         * Client package name
+         */
+        public final static String EXTRA_CLIENT = "client";
+
+        /**
+         * Client status
+         */
+        public final static String EXTRA_STATUS = "status";
+
+        public final static String SERVICE_UP = "org.gsma.joyn.action.SERVICE_UP";
+
+        private Client() {
+        }
+    }
+
+    /**
+     * Intents for chat service
+     */
+    public static class Chat {
+        /**
+         * Load the chat application to view a chat conversation. This
+         * Intent takes into parameter an URI on the chat conversation
+         * (i.e. content://chats/chat_ID). If no parameter found the main
+         * entry of the chat application is displayed.
+         */
+        public static final String ACTION_VIEW_CHAT = "org.gsma.joyn.action.VIEW_CHAT";
+
+        /**
+         * Load the chat application to start a new conversation with a
+         * given contact. This Intent takes into parameter a contact URI
+         * (i.e. content://contacts/people/contact_ID). If no parameter the
+         * main entry of the chat application is displayed.
+         */
+        public static final String ACTION_INITIATE_CHAT = "org.gsma.joyn.action.INITIATE_CHAT";
+
+        /**
+         * Load the group chat application. This Intent takes into parameter an
+         * URI on the group chat conversation (i.e. content://chats/chat_ID). If
+         * no parameter found the main entry of the group chat application is displayed.
+         */
+        public static final String ACTION_VIEW_GROUP_CHAT = "org.gsma.joyn.action.VIEW_GROUP_CHAT";
+
+        /**
+         * Load the group chat application to start a new conversation with a
+         * group of contacts. This Intent takes into parameter a list of contact
+         * URIs. If no parameter the main entry of the group chat application is displayed.
+         */
+        public static final String ACTION_INITIATE_GROUP_CHAT = "org.gsma.joyn.action.INITIATE_GROUP_CHAT";
+
+        private Chat() {
+        }
+    }
+
+    /**
+     * Intents for file transfer service
+     */
+    public static class FileTransfer {
+        /**
+         * Load the file transfer application to view a file transfer. This Intent
+         * takes into parameter an URI on the file transfer (i.e. content://filetransfers/ft_ID).
+         * If no parameter found the main entry of the file transfer application is displayed.
+         */
+        public static final String ACTION_VIEW_FT = "org.gsma.joyn.action.VIEW_FT";
+
+        /**
+         * Load the file transfer application to start a new file transfer to a given
+         * contact. This Intent takes into parameter a contact URI (i.e. content://contacts/people/contact_ID).
+         * If no parameter the main entry of the file transfer application is displayed.
+         */
+        public static final String ACTION_INITIATE_FT = "org.gsma.joyn.action.INITIATE_FT";
+
+        private FileTransfer() {
+        }
+    }
+
+    /**
+     * Intents for IP call service
+     */
+    public static class IPCall {
+        /**
+         * Load the IP call application to view a call. This Intent takes into parameter an URI on
+         * the call (i.e. content://ipcalls/ipcall_ID). If no parameter found the main entry of the
+         * IP call application is displayed.
+         */
+        public static final String ACTION_VIEW_IPCALL = "org.gsma.joyn.action.VIEW_IPCALL";
+
+        /**
+         * Load the IP call application to start a new call to a given contact. This Intent takes
+         * into parameter a contact URI (i.e. content://contacts/people/contact_ID). If no parameter
+         * the main entry of the IP call application is displayed.
+         */
+        public static final String ACTION_INITIATE_IPCALL = "org.gsma.joyn.action.INITIATE_IPCALL";
+
+        private IPCall() {
+        }
+    }
+}
+
diff --git a/src/java/org/gsma/joyn/JoynContactFormatException.java b/src/java/org/gsma/joyn/JoynContactFormatException.java
new file mode 100644
index 0000000..37d8174
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynContactFormatException.java
@@ -0,0 +1,40 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn contact format exception. This exception is thrown when the
+ * contact format is not supported or not well formatted. The supported
+ * formats are:<br>
+ * - Phone number in national or international format (e.g. +33xxx).<br>
+ * - SIP address (eg. "John" <sip:+33xxx@domain.com>).<br>
+ * - SIP-URI (e.g. sip:+33xxx@domain.com).<br>
+ * - Tel-URI (eg. tel:+33xxx).
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynContactFormatException extends JoynServiceException {
+    static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor
+     */
+    public JoynContactFormatException() {
+        super("joyn contact format not supported");
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynService.java b/src/java/org/gsma/joyn/JoynService.java
new file mode 100644
index 0000000..f6da911
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynService.java
@@ -0,0 +1,245 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+import java.lang.reflect.Method;
+import java.util.List;
+
+
+import android.app.ActivityManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.os.IInterface;
+
+/**
+ * Abstract joyn service
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class JoynService {
+    /**
+     * Action to broadcast when joyn service is up.
+     */
+    public static final String ACTION_RCS_SERVICE_UP = "org.gsma.joyn.action.RCS_SERVICE_UP";
+
+    public static final String TAG = "TAPI-JoynService";
+
+    /**
+     * Service error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Service has been disabled
+         */
+        public final static int SERVICE_DISABLED = 1;
+
+        /**
+         * Service connection has been lost
+         */
+        public final static int CONNECTION_LOST = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Application context
+     */
+    protected Context ctx;
+
+    /**
+     * Service listener
+     */
+    protected JoynServiceListener serviceListener;
+
+    /**
+     * API interface
+     */
+    private IInterface api = null;
+
+    /**
+     * Service version
+     */
+    protected Integer version = null;
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public JoynService(Context ctx, JoynServiceListener listener) {
+        Logger.d(TAG, "JoynService() constructor " + ctx + " listener = " + listener);
+        this.ctx = ctx;
+        this.serviceListener = listener;
+    }
+
+    /**
+     * Call specific method on the API interface
+     *
+     * @param method Method to be called
+     * @param param Parameters of the method
+     * @param paramClass Class of the parameter passed
+     * @return Object
+     * @throws JoynServiceException
+     */
+    private Object callApiMethod(String method, Object param, Class paramClass) throws JoynServiceException {
+        if (api != null) {
+            Class c = api.getClass();
+            try {
+                if (param != null) {
+                    Method m = c.getDeclaredMethod(method, paramClass);
+                    return m.invoke(api, param);
+                } else {
+                    Method m = c.getDeclaredMethod(method, null);
+                    return m.invoke(api);
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        this.api = api;
+    }
+
+    /**
+     * Connects to the API
+     */
+    public abstract void connect();
+
+    /**
+     * Disconnects from the API
+     */
+    public abstract void disconnect();
+
+    /**
+     * Returns true if the service is connected, else returns false
+     *
+     * @return Returns true if connected else returns false
+     */
+    public boolean isServiceConnected() {
+        return (api != null);
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        Logger.d(TAG, "getServiceVersion() entry " + api);
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = (Integer) callApiMethod("getServiceVersion", null, null);
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        Logger.d(TAG, "isServiceRegistered() entry " + api);
+        if (api != null) {
+            return (Boolean) callApiMethod("isServiceRegistered", null, null);
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.d(TAG, "addServiceRegistrationListener() entry " + api);
+        if (api != null) {
+            callApiMethod("addServiceRegistrationListener", listener, IJoynServiceRegistrationListener.class);
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.d(TAG, "removeServiceRegistrationListener() entry " + api);
+        if (api != null) {
+            callApiMethod("removeServiceRegistrationListener", listener, IJoynServiceRegistrationListener.class);
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    /**
+     * MTK API
+     *
+     * @param Context
+     * @return boolean RcsCore service is started or not
+     */
+    public static boolean isServiceStarted(Context ctx) {
+        ActivityManager activityManager = (ActivityManager) ctx.getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningServiceInfo> serviceList = activityManager.getRunningServices(Integer.MAX_VALUE);
+         for (int i = 0; i < serviceList.size(); i++) {
+               ActivityManager.RunningServiceInfo serviceInfo = serviceList.get(i);
+               ComponentName serviceName = serviceInfo.service;
+               if (serviceName.getClassName().equals("com.orangelabs.rcs.service.RcsCoreService")) {
+                     if (serviceInfo.pid != 0) {
+                          return true;
+                     } else {
+                          return false;
+                     }
+               }
+         }
+         return false;
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceConfiguration.java b/src/java/org/gsma/joyn/JoynServiceConfiguration.java
new file mode 100644
index 0000000..0684045
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceConfiguration.java
@@ -0,0 +1,684 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+//import com.orangelabs.rcs.platform.AndroidFactory;
+
+import org.gsma.joyn.chat.ChatLog;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.net.Uri;
+import android.util.Log;
+
+/**
+ * joyn Service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynServiceConfiguration {
+    /**
+     * Returns True if the joyn service is activated, else returns False. The
+     * service may be activated or deactivated by the end user via the joyn
+     * settings application.
+     *
+     * @param ctx
+     *            Context
+     * @return Boolean
+     */
+    
+    /**
+     * Boolean value "true"
+     */
+    public static final String TRUE = Boolean.toString(true);
+
+    /**
+     * Boolean value "false"
+     */
+    public static final String FALSE = Boolean.toString(false);
+
+    public static boolean isServiceActivated() {
+        /*
+         * if
+         * (AndroidFactory.getApplicationContext().checkCallingOrSelfPermission
+         * (Permissions.READ_RCS_STATE) != PackageManager.PERMISSION_GRANTED) {
+         * throw new SecurityException(" Required permission READ_RCS_STATE"); }
+         */
+        /*
+         * boolean result = false; Uri databaseUri =
+         * Uri.parse("content://com.orangelabs.rcs.settings/settings");
+         * ContentResolver cr =
+         * AndroidFactory.getApplicationContext().getContentResolver(); Cursor c
+         * = cr.query(databaseUri, null, "key" + "='" + "ServiceActivated" +
+         * "'", null, null); if (c != null) { if ((c.getCount() > 0) &&
+         * c.moveToFirst()) { String value = c.getString(2); result =
+         * Boolean.parseBoolean(value); } c.close(); } return result;
+         */
+        return false;
+    }
+
+    /**
+     * Returns True if the joyn service is activated, else returns False. The
+     * service may be activated or deactivated by the end user via the joyn
+     * settings application.
+     *
+     * @param ctx
+     * @return Boolean
+     */
+    public static boolean isServiceActivated(Context ctx) {
+        boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "ServiceActivated" + "'", null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                String value = c.getString(2);
+                result = Boolean.parseBoolean(value);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+    /**
+     * Returns the display name associated to the joyn user account. The display
+     * name may be updated by the end user via the joyn settings application.
+     *
+     * @param ctx
+     *            Context
+     * @return Display name
+     */
+    public static String getUserDisplayName() {
+        // TODO: to be changed
+        /*
+         * String result = null; Uri databaseUri =
+         * Uri.parse("content://com.orangelabs.rcs.settings/settings");
+         * ContentResolver cr =
+         * AndroidFactory.getApplicationContext().getContentResolver(); Cursor c
+         * = cr.query(databaseUri, null, "key" + "='" + "ImsDisplayName" + "'",
+         * null, null); if (c != null) { if ((c.getCount() > 0) &&
+         * c.moveToFirst()) { result = c.getString(2); } c.close(); } return
+         * result;
+         */
+        return null;
+    }
+
+    /**
+     * Get the alias name
+     *
+     * @param contact no
+     * @result alias name for contact
+     */
+    public static String getAliasName(Context ctx, String Contact) {
+         Log.d("getAliasName ", Contact);
+         Uri CONTENT_URI = Uri.parse("content://com.orangelabs.rcs.chat/message");
+         ContentResolver cr = ctx.getContentResolver();
+        String aliasName = "";
+        Cursor cursor = cr.query(CONTENT_URI,
+                new String[] {
+                ChatLog.Message.DISPLAY_NAME,
+                },
+                "(" + ChatLog.Message.CONTACT_NUMBER + "='" + Contact + "' "+
+                "AND " +ChatLog.Message.DISPLAY_NAME + " <> '' "+")",
+                null,
+                ChatLog.GroupChat.TIMESTAMP + " DESC");
+        if (cursor.moveToFirst()) {
+            String status = cursor.getString(0);
+            aliasName = status;
+        }
+        cursor.close();
+        return aliasName;
+    }
+
+    /**
+     * Profile Auth
+     *
+     * @param ctx
+     * @return Boolean
+     */
+    public boolean getProfileAuth(Context ctx) {
+
+     // TODO: to be changed
+        boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "profileAuth"
+                + "'", null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                String value = c.getString(2);
+                result = Boolean.parseBoolean(value);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+
+
+    /**
+     * NAB Authentication
+     *
+     * @param ctx
+     * @return Auth Type
+     */
+    public boolean getNABAuth(Context ctx) {
+        boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "nabAuth" + "'",
+                null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                String value = c.getString(2);
+                result = Boolean.parseBoolean(value);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+    /**
+     * Public Account Auth
+     *
+     * @param ctx
+     * @return Boolean Auth Type
+     */
+     public boolean getPublicAccountAUTH(Context ctx) {
+         boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+         ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "publicAccountAuth" + "'", null, null);
+         if (c != null) {
+             if ((c.getCount() > 0) && c.moveToFirst()) {
+                 String value = c.getString(2);
+                 result = Boolean.parseBoolean(value);
+             }
+             c.close();
+         }
+         return result;
+     }
+
+   /**
+    * SSo Auth
+    *
+     * @param ctx
+     * @return Boolean Auth type
+    */
+    public boolean getSSOAuth(Context ctx) {
+        boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "ssoAuth" + "'",
+                null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                String value = c.getString(2);
+                result = Boolean.parseBoolean(value);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+   /**
+    * Profile Address
+    *
+     * @param ctx
+     * @return String address
+    */
+    public String getProfileAddress(Context ctx) {
+        String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "profileAddress"
+                + "'", null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                result = c.getString(2);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+
+   /**
+    * Profile Port
+    *
+     * @param ctx
+     * @return String port
+    */
+    public String getProfileAddressPort(Context ctx) {
+        String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+        ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "profileAddressPort" + "'", null, null);
+        if (c != null) {
+            if ((c.getCount() > 0) && c.moveToFirst()) {
+                result = c.getString(2);
+            }
+            c.close();
+        }
+        return result;
+    }
+
+    /**
+     * Profile Address Type
+     *
+     * @param ctx
+     * @return String Address
+     */
+     public String getProfileAddressType(Context ctx) {
+         String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+         ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "ProfileAddressType" + "'", null, null);
+         if (c != null) {
+             if ((c.getCount() > 0) && c.moveToFirst()) {
+                 result = c.getString(2);
+             }
+             c.close();
+         }
+         return result;
+     }
+
+
+     /**
+      * Profile Address
+      *
+     * @param ctx
+     * @return String address
+      */
+      public String getNABAddress(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "nabAddress"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+
+     /**
+     * NAB Address Port
+      *
+     * @param ctx
+     * @return String port
+      */
+      public String getNABAddressPort(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "nabAddressPort"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+     /**
+     * NAB Address Type
+      *
+     * @param ctx
+     * @return String Address
+      */
+      public String getNABAddressType(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "nabAddressType"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+     /**
+      * Public Address
+      *
+     * @param ctx
+     * @return String address
+      */
+      public String getPublicAccountAddress(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "publicAccountAddress" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+
+     /**
+     * Public Account Port
+      *
+     * @param ctx
+     * @return String port
+      */
+      public String getPublicAccountAddressPort(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "publicAccountAddressPort" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+     /**
+     * Public Account Address Type
+      *
+     * @param ctx
+     * @return String Address
+      */
+      public String getPublicAccountAddressType(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "publicAccountAddressType" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+     /**
+      * SSo Address
+      *
+     * @param ctx
+      * @return address
+      */
+      public String getSSOAddress(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "SSOAddress"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+
+    /**
+     * SSO Port
+     *
+     * @param ctx
+     * @return port
+     */
+      public String getSSOAddressPort(Context ctx) {
+          String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "SSOAddressPort"
+                + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  result = c.getString(2);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+    /**
+     * Address Type
+     *
+     * @param ctx
+     * @return Address
+     */
+     public String getSSOAddressType(Context ctx) {
+         String result = null;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+         ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='" + "SSOAddressType"
+                + "'", null, null);
+         if (c != null) {
+             if ((c.getCount() > 0) && c.moveToFirst()) {
+                 result = c.getString(2);
+             }
+             c.close();
+         }
+         return result;
+     }
+
+    /**
+     * Public Uri set by stack
+     *
+     * @param ctx
+     * @return String
+     */
+     public String getPublicUri(Context ctx) {
+         String result = "";
+         Uri databaseUri = Uri.parse("content://com.orangelabs.rcs.settings/settings");
+         ContentResolver cr = ctx.getContentResolver();
+         Cursor c = cr.query(databaseUri, null,
+                 "key" + "='" + "publicUri" + "'", null, null);
+         if (c != null) {
+             if ((c.getCount() > 0) && c.moveToFirst()) {
+                 result = c.getString(2);
+             }
+             c.close();
+         }
+
+         return result;
+     }
+
+     /**
+      * Configuration
+      * 
+     * @param ctx
+      * @return Configuration State
+      */
+      public boolean getConfigurationState(Context ctx) {
+          boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "configurationState" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  String value = c.getString(2);
+                  result = Boolean.parseBoolean(value);
+              }
+              c.close();
+          }
+          return result;
+      }
+
+
+
+      /**
+       * Service Activation State
+       *
+     * @param ctx
+     * @return String Service State
+       */
+       public static boolean getServiceState(Context ctx) {
+           boolean result = false;
+        Uri databaseUri = Uri
+                .parse("content://com.orangelabs.rcs.settings/settings");
+           ContentResolver cr = ctx.getContentResolver();
+        Cursor c = cr.query(databaseUri, null, "key" + "='"
+                + "ServiceActivated" + "'", null, null);
+           if (c != null) {
+               if ((c.getCount() > 0) && c.moveToFirst()) {
+                   String value = c.getString(2);
+                   result = Boolean.parseBoolean(value);
+               }
+               c.close();
+           }
+           return result;
+       }
+
+       /**
+        * Set the root directory for files
+        *
+        *  @param path Directory path
+        */
+       public void setFileRootDirectory(String path, Context ctx) {
+           Uri databaseUri = Uri
+           .parse("content://com.orangelabs.rcs.settings/settings");
+           if (ctx != null) {
+               ContentResolver cr = ctx.getContentResolver();
+               ContentValues values = new ContentValues();
+               values.put("value", path);
+               String where = "key" + "='" + "DirectoryPathFiles" + "'";
+              // long startTime = System.currentTimeMillis();
+               cr.update(databaseUri, values, where, null);
+           }
+       }
+
+       /** Set the root directory for Photo
+       *
+       *  @param path Directory path
+       */
+      public void setPhotoRootDirectory(String path, Context ctx) {
+          Uri databaseUri = Uri
+          .parse("content://com.orangelabs.rcs.settings/settings");
+          if (ctx != null) {
+              ContentResolver cr = ctx.getContentResolver();
+              ContentValues values = new ContentValues();
+              values.put("value", path);
+              String where = "key" + "='" + "DirectoryPathPhotos" + "'";
+             // long startTime = System.currentTimeMillis();
+              cr.update(databaseUri, values, where, null);
+          }
+      }
+
+      /** Set the root directory for Videos
+       *
+       *  @param path Directory path
+       */
+      public void setVideoRootDirectory(String path, Context ctx) {
+          Uri databaseUri = Uri
+          .parse("content://com.orangelabs.rcs.settings/settings");
+          if (ctx != null) {
+              ContentResolver cr = ctx.getContentResolver();
+              ContentValues values = new ContentValues();
+              values.put("value", path);
+              String where = "key" + "='" + "DirectoryPathVideos" + "'";
+             // long startTime = System.currentTimeMillis();
+              cr.update(databaseUri, values, where, null);
+          }
+      }
+      
+      /** Set the root directory for Photo
+      *
+      *  @param path Directory path
+      */
+      public static void setServicePermissionState(boolean state, Context ctx) {
+          String stringState = "";
+          if(state) {
+              stringState = TRUE;
+          } else {
+              stringState = FALSE;
+          }
+          Uri databaseUri = Uri
+          .parse("content://com.orangelabs.rcs.settings/settings");
+          if (ctx != null) {
+          ContentResolver cr = ctx.getContentResolver();
+          ContentValues values = new ContentValues();
+              values.put("value", stringState);
+              String where = "key" + "='" + "servicePermitted" + "'";
+              // long startTime = System.currentTimeMillis();
+              cr.update(databaseUri, values, where, null);
+          }
+      }
+      
+      /**
+       * Returns True if the App Permission is granted .
+       *
+       * @param ctx
+       * @return Boolean
+       */
+      public static boolean isServicePermission(Context ctx) {
+          boolean result = false;
+          Uri databaseUri = Uri
+                  .parse("content://com.orangelabs.rcs.settings/settings");
+          ContentResolver cr = ctx.getContentResolver();
+          Cursor c = cr.query(databaseUri, null, "key" + "='"
+                  + "servicePermitted" + "'", null, null);
+          if (c != null) {
+              if ((c.getCount() > 0) && c.moveToFirst()) {
+                  String value = c.getString(2);
+                  result = Boolean.parseBoolean(value);
+              }
+              c.close();
+          }
+          return result;
+      }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceException.java b/src/java/org/gsma/joyn/JoynServiceException.java
new file mode 100644
index 0000000..6677dd4
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceException.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn service exception
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynServiceException extends java.lang.Exception {
+    static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor
+     *
+     * @param error Error message
+     */
+    public JoynServiceException(String error) {
+        super(error);
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceListener.java b/src/java/org/gsma/joyn/JoynServiceListener.java
new file mode 100644
index 0000000..607aa08
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceListener.java
@@ -0,0 +1,41 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn service event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public interface JoynServiceListener {
+    /**
+     * Callback called when service is connected. This method is called when the
+     * service is well connected to the RCS service (binding procedure successfull):
+     * this means the methods of the API may be used.
+     */
+    public void onServiceConnected();
+
+    /**
+     * Callback called when service has been disconnected. This method is called when
+     * the service is disconnected from the RCS service (e.g. service deactivated).
+     *
+     * @param error Error
+     * @see JoynService.Error
+     */
+    public void onServiceDisconnected(int error);
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceNotAvailableException.java b/src/java/org/gsma/joyn/JoynServiceNotAvailableException.java
new file mode 100644
index 0000000..91599bf
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceNotAvailableException.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn service not available exception
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynServiceNotAvailableException extends JoynServiceException {
+    static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor
+     */
+    public JoynServiceNotAvailableException() {
+        super("joyn service not available");
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceNotRegisteredException.java b/src/java/org/gsma/joyn/JoynServiceNotRegisteredException.java
new file mode 100644
index 0000000..174f876
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceNotRegisteredException.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ * Joyn service not registered exception
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynServiceNotRegisteredException extends JoynServiceException {
+    static final long serialVersionUID = 1L;
+
+    /**
+     * Constructor
+     */
+    public JoynServiceNotRegisteredException() {
+        super("joyn service not registered");
+    }
+}
diff --git a/src/java/org/gsma/joyn/JoynServiceRegistrationListener.java b/src/java/org/gsma/joyn/JoynServiceRegistrationListener.java
new file mode 100644
index 0000000..e668766
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynServiceRegistrationListener.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+
+/**
+ * Service registration events listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class JoynServiceRegistrationListener extends IJoynServiceRegistrationListener.Stub {
+    /**
+     * Callback called when service is registered to the network platform
+     */
+    public abstract void onServiceRegistered();
+
+    /**
+     * Callback called when service is unregistered from the network platform
+     */
+    public abstract void onServiceUnregistered();
+}
diff --git a/src/java/org/gsma/joyn/JoynUtils.java b/src/java/org/gsma/joyn/JoynUtils.java
new file mode 100644
index 0000000..8622125
--- /dev/null
+++ b/src/java/org/gsma/joyn/JoynUtils.java
@@ -0,0 +1,86 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+import java.util.List;
+
+
+import android.app.Activity;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+
+/**
+ * Utility functions which permit to detect other joyn client installed on a
+ * device
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynUtils {
+    /**
+     * Returns the list of joyn clients installed on the device. An application
+     * is identified as a joyn client by including an intent filter with the
+     * ACTION_CLIENT_SETTINGS action in the Manifest.xml of the application.
+     *
+     * @param context Application context
+     * @return List of application info
+     */
+
+    public static final String TAG = "TAPI-JoynUtils";
+
+    public static List<ResolveInfo> getJoynClients(Context context) {
+        Logger.d(TAG, "getJoynClients() entry " + context);
+        Intent intent = new Intent(Intents.Client.ACTION_VIEW_SETTINGS);
+        List<ResolveInfo> list = context.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
+        Logger.d(TAG, "getJoynClients() exit " + list);
+        return list;
+    }
+
+    /**
+     * Is a particular joyn client activated. The result is returned
+     * asynchronously via a broadcast receiver.
+     *
+     * @param context Application context
+     * @param appInfo Application info
+     * @param receiverResult Broadcast receiver result
+     */
+    public static void isJoynClientActivated(Context context, ResolveInfo appInfo, BroadcastReceiver receiverResult) {
+        Logger.d(TAG, "isJoynClientActivated() entry " + context);
+        Intent broadcastIntent = new Intent(appInfo.activityInfo.packageName
+                + Intents.Client.ACTION_CLIENT_GET_STATUS);
+        context.sendOrderedBroadcast(broadcastIntent, null, receiverResult, null, Activity.RESULT_OK, null, null);
+    }
+
+    /**
+     * Load the settings activity of a particular joyn client to enable or
+     * disable the client
+     *
+     * @param context Application context
+     * @param appInfo Application info
+     */
+    public static void loadJoynClientSettings(Context context, ResolveInfo appInfo) {
+        Logger.d(TAG, "loadJoynClientSettings() entry " + context);
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.setComponent(new ComponentName(appInfo.activityInfo.packageName, appInfo.activityInfo.name));
+        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
+        context.startActivity(intent);
+    }
+}
diff --git a/src/java/org/gsma/joyn/Logger.java b/src/java/org/gsma/joyn/Logger.java
new file mode 100644
index 0000000..c644f50
--- /dev/null
+++ b/src/java/org/gsma/joyn/Logger.java
@@ -0,0 +1,209 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2011. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package org.gsma.joyn;
+
+import android.app.Activity;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.content.SharedPreferences.Editor;
+import android.util.Log;
+
+
+//This is a common logger for MTK RCS-e solution.
+public final class Logger {
+    public static final String TAG = "[RCSe]";
+
+    private Logger() {
+    }; // Static common use class should not be instantiated.
+
+    private static final boolean XLOG_ENABLED = true;
+    private static boolean sIsLogEnabled = true;
+    // This is used for test codes
+    public static final boolean IS_DEBUG = true;
+    public static final String RCS_PREFS_IS_INTEGRATION_MODE = "IS_INTEGRATION_MODE";
+
+    // This is used for launch mode or integration mode
+    private static boolean sIsIntegrationMode;
+
+    /**
+     * Get sIsIntegrationMode.
+     *
+     * @return sIsIntegrationMode
+     */
+    public static boolean getIsIntegrationMode() {
+        return true;
+        //return sIsIntegrationMode;
+    }
+
+    /**
+     * Set sIsIntegrationMode.
+     *
+     * @param boolean isIntegrationMode.
+     */
+    public static void setIsIntegrationMode(boolean isIntegrationMode) {
+        sIsIntegrationMode = isIntegrationMode;
+    }
+
+    /**
+     * initialize sIsIntegrationMode.
+     *
+     * @param Context context.
+     */
+    public static void initialize(Context context) {
+        if (context != null) {
+            v(TAG, "initialize(), context is not null");
+            SharedPreferences preferences =
+                    context.getSharedPreferences(RCS_PREFS_IS_INTEGRATION_MODE, Activity.MODE_PRIVATE);
+            if (preferences.contains(RCS_PREFS_IS_INTEGRATION_MODE)) {
+                sIsIntegrationMode = preferences.getBoolean(RCS_PREFS_IS_INTEGRATION_MODE, false);
+            } else {
+                sIsIntegrationMode = false;
+                Editor editor = preferences.edit();
+                editor.putBoolean(RCS_PREFS_IS_INTEGRATION_MODE, false);
+                editor.commit();
+            }
+        } else {
+            sIsIntegrationMode = false;
+        }
+        v(TAG, "initialize(), sIsIntegrationMode = " + sIsIntegrationMode);
+    }
+
+    /**
+     * Run-time set whether need to enable the RCS-e log in this process.
+     *
+     * @param isLogEnable Enable/disable the RCS-e log.
+     */
+    public static void setLogEnabled(boolean isLogEnable) {
+        sIsLogEnabled = isLogEnable;
+        sIsLogEnabled = true;
+    }
+
+    /**
+     * Send a verbose log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void v(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.v(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.v(TAG, getCombinedMessage(tag, message));
+            }
+        }
+
+    }
+
+    /**
+     * Send a debug log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void d(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.d(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.d(TAG, getCombinedMessage(tag, message));
+            }
+        }
+    }
+
+    /**
+     * Send an information log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void i(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.i(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.i(TAG, getCombinedMessage(tag, message));
+            }
+        }
+    }
+
+    /**
+     * Send a warning log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void w(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.w(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.w(TAG, getCombinedMessage(tag, message));
+            }
+        }
+    }
+
+    /**
+     * Send a error log message.
+     *
+     * @param tag Normally it's the class name who call this method.
+     * @param message The message you want to send.
+     */
+    public static void e(String tag, String message) {
+        if (true) {
+            if (XLOG_ENABLED) {
+                Log.e(TAG, getCombinedMessage(tag, message));
+            } else {
+                Log.e(TAG, getCombinedMessage(tag, message));
+            }
+        }
+    }
+
+    private static String getCombinedMessage(String tag, String message) {
+        if (null != tag) {
+            StringBuilder builder = new StringBuilder();
+            builder.append("[");
+            builder.append(tag);
+            builder.append("]: ");
+            builder.append(message);
+            return builder.toString();
+        } else {
+            return message;
+        }
+
+    }
+}
diff --git a/src/java/org/gsma/joyn/Permissions.java b/src/java/org/gsma/joyn/Permissions.java
new file mode 100644
index 0000000..df15d55
--- /dev/null
+++ b/src/java/org/gsma/joyn/Permissions.java
@@ -0,0 +1,133 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn;
+
+/**
+ *
+ *
+ * @author MTK
+ */
+public class Permissions {
+
+    /**
+     * This is a new permission that governs access to the
+     * chat API, and is required both to receive and to send over an RCS
+     * chat session
+     */
+    public final static String RCS_USE_CHAT = "org.gsma.joyn.RCS_USE_CHAT";
+
+    /**
+     * This is a new permission that that is required by a
+     * client in order to read the chat history from the content provider
+     */
+    public final static String RCS_READ_CHAT = "org.gsma.joyn.RCS_READ_CHAT";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to handle the receipt of a file transferred from a remote
+     * party
+     */
+    public final static String RCS_FILETRANSFER_RECEIVE = "org.gsma.joyn.RCS_FILETRANSFER_RECEIVE";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to initiate the transfer of a file transferred to a remote
+     * party
+     */
+    public final static String RCS_FILETRANSFER_SEND = "org.gsma.joyn.RCS_FILETRANSFER_SEND";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to read the file transfer history from the content provider
+     */
+    public final static String RCS_FILETRANSFER_READ = "org.gsma.joyn.RCS_FILETRANSFER_READ";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to handle the receipt of a image shared by a remote
+     */
+    public final static String RCS_IMAGESHARE_RECEIVE = "org.gsma.joyn.RCS_IMAGESHARE_RECEIVE";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to initiate the sharing of an image with a remote party
+     */
+    public final static String RCS_IMAGESHARE_SEND = "org.gsma.joyn.RCS_IMAGESHARE_SEND";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to read the image share history from the content provider
+     */
+    public final static String RCS_IMAGESHARE_READ = "org.gsma.joyn.RCS_FILETRANSFER_READ";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to receipt of a video shared by a remote party
+     */
+    public final static String RCS_VIDEOSHARE_RECEIVE = "org.gsma.joyn.RCS_VIDEOSHARE_RECEIVE";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to initiate the sharing of an video with a remote party
+     */
+    public final static String RCS_VIDEOSHARE_SEND = "org.gsma.joyn.RCS_VIDEOSHARE_SEND";
+
+    /**
+     * This is a new permission that is
+     * required by a client in order to read the video share history from the content provider
+     */
+    public final static String RCS_VIDEOSHARE_READ = "org.gsma.joyn.RCS_VIDEOSHARE_READ";
+
+    /**
+     * This is a new permission this is a new permission that governs
+     * access to capability information
+     */
+    public final static String RCS_READ_CAPABILITIES = "org.gsma.joyn.RCS_READ_CAPABILITIES";
+
+    /**
+     * This is a new permission that governs access to the IP Call API, and is required to initiate,
+     * receive and to manage RCS IP Call sessions.
+     */
+    public final static String RCS_USE_IPCALL = "org.gsma.joyn.RCS_USE_IPCALL";
+
+    /**
+     * This is a new permission that that is required by client in order to read the IP Call
+     * history from the content provider..
+     */
+    public final static String RCS_READ_IPCALL = "org.gsma.joyn.RCS_READ_IPCALL";
+
+    /**
+     * this is a new permission that is required to
+     * send Geolocation data over an RCS chat session
+     */
+    public final static String RCS_LOCATION_SEND = "org.gsma.joyn.RCS_LOCATION_SEND";
+
+    /**
+     * This is a new permission that that is required by client in order to read the using the
+     * capabilities service, since use of the API implicitly reveals information about
+     * past and current contacts for the device.
+     */
+    public final static String ANDROID_READ_CONTACTS = "android.permission.READ_CONTACTS";
+
+    /**
+     * This is a new permission that that is required by client analogous to READ_PHONE_STATE,
+     * covering general access to the RCS stack state.
+     */
+    public final static String READ_RCS_STATE = "org.gsma.joyn.READ_RCS_STATE";
+
+}
diff --git a/src/java/org/gsma/joyn/capability/Capabilities.aidl b/src/java/org/gsma/joyn/capability/Capabilities.aidl
new file mode 100644
index 0000000..df47aa0
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/Capabilities.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.capability;
+
+/**
+ * Capabilities object
+ */
+parcelable Capabilities;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/capability/Capabilities.java b/src/java/org/gsma/joyn/capability/Capabilities.java
new file mode 100644
index 0000000..c1dff37
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/Capabilities.java
@@ -0,0 +1,405 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.capability;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Capabilities of a contact. This class encapsulates the different capabilities
+ * which may be supported by the local user or a remote contact.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Capabilities implements Parcelable {
+    /**
+     * Image sharing support
+     */
+    private boolean imageSharing = false;
+
+    public static final String TAG = "Capabilities";
+
+    public void setImageSharingSupport(boolean imageSharing) {
+        Logger.i(TAG, "setImageSharingSupport entry" + imageSharing);
+        this.imageSharing = imageSharing;
+    }
+
+    /**
+     * Video sharing support
+     */
+    private boolean videoSharing = false;
+
+    public void setVideoSharingSupport(boolean videoSharing) {
+        Logger.i(TAG, "setVideoSharingSupport entry" + videoSharing);
+        this.videoSharing = videoSharing;
+    }
+
+    /**
+     * IM session support
+     */
+    private boolean imSession = false;
+
+    /**
+     * File transfer support
+     */
+    private boolean fileTransfer = false;
+
+    /**
+     * Geolocation push support
+     */
+    private boolean geolocPush = false;
+
+    /**
+     * IP voice call support
+     */
+    private boolean ipVoiceCall = false;
+
+    /**
+     * IP video call support
+     */
+    private boolean ipVideoCall = false;
+
+    /**
+     * List of supported extensions
+     */
+    private Set<String> extensions = new HashSet<String>();
+
+    /**
+     * Automata flag
+     */
+    private boolean automata = false;
+
+    /**
+     * Automata flag
+     */
+    private boolean fileTransferHttpSupported = false;
+
+    /**
+     * Automata flag
+     */
+    private boolean rcsContact = false;
+
+    private boolean burnAfterRead = false;
+
+    /**
+     * Integrated Mode of this contact
+     */
+    private boolean integratedMessagingMode = false;
+
+    public void setIntegratedMessagingMode(boolean integratedMessagingMode) {
+        Logger.i(TAG, "setIntegratedMessagingMode entry" + integratedMessagingMode);
+        this.integratedMessagingMode = integratedMessagingMode;
+    }
+
+    public boolean isIntegratedMessagingMode() {
+        Logger.i(TAG, "isIntegratedMessagingMode entry" + integratedMessagingMode);
+        return integratedMessagingMode;
+    }
+
+    /**
+     * Cs Video support
+     */
+    private boolean csVideoSupported = false;
+
+    public boolean isCsVideoSupported() {
+        return csVideoSupported;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param imageSharing Image sharing support
+     * @param videoSharing Video sharing support
+     * @param imSession IM/Chat support
+     * @param fileTransfer File transfer support
+     * @param geolocPush Geolocation push support
+     * @param ipVoiceCall IP voice call support
+     * @param ipVideoCall IP video call support
+     * @param extensions Set of supported extensions
+     * @param automata Automata flag
+     * @hide
+     */
+    public Capabilities(boolean imageSharing, boolean videoSharing, boolean imSession,
+            boolean fileTransfer, boolean geolocPush,
+            boolean ipVoiceCall, boolean ipVideoCall,
+            Set<String> extensions, boolean automata, boolean fileTransferHttpSupport, boolean rcsContact, boolean integratedMessagingMode, boolean csVideoSupported,
+            boolean isBurnAfterRead
+            ) {
+        Logger.i(TAG, "Capabilities entry , values are " + "Imagesharing-" + imageSharing + "videosharing-" + videoSharing + "imSession-" + imSession +
+                "filetransfer-" + fileTransfer + "geolocPush-" + geolocPush + "ipVoicecall-" + ipVoiceCall + "ipVideoCall-" + ipVideoCall +
+                "extensions-" + extensions + "automata-" + automata + "fileTransferHttpSupport-" + "rcsContact-" + rcsContact +
+                "integratedMessagingMode-" + integratedMessagingMode + "csVideoSupported-" + csVideoSupported);
+        this.imageSharing = imageSharing;
+        this.videoSharing = videoSharing;
+        this.imSession = imSession;
+        this.fileTransfer = fileTransfer;
+        this.geolocPush = geolocPush;
+        this.ipVoiceCall = ipVoiceCall;
+        this.ipVideoCall = ipVideoCall;
+        this.extensions = extensions;
+        this.automata = automata;
+        this.fileTransferHttpSupported = fileTransferHttpSupport;
+        this.rcsContact = rcsContact;
+        this.integratedMessagingMode = integratedMessagingMode;
+        this.csVideoSupported = csVideoSupported;
+        this.burnAfterRead = isBurnAfterRead;
+    }
+
+    public Capabilities(boolean imageSharing, boolean videoSharing, boolean imSession,
+            boolean fileTransfer, boolean geolocPush,
+            boolean ipVoiceCall, boolean ipVideoCall,
+            Set<String> extensions, boolean automata, boolean fileTransferHttpSupport, boolean rcsContact, boolean integratedMessagingMode, boolean csVideoSupported) {
+        Logger.i(TAG, "Capabilities entry , values are " + "Imagesharing-" + imageSharing + "videosharing-" + videoSharing + "imSession-" + imSession +
+                "filetransfer-" + fileTransfer + "geolocPush-" + geolocPush + "ipVoicecall-" + ipVoiceCall + "ipVideoCall-" + ipVideoCall +
+                "extensions-" + extensions + "automata-" + automata + "fileTransferHttpSupport-" + "rcsContact-" + rcsContact +
+                "integratedMessagingMode-" + integratedMessagingMode + "csVideoSupported-" + csVideoSupported);
+        this.imageSharing = imageSharing;
+        this.videoSharing = videoSharing;
+        this.imSession = imSession;
+        this.fileTransfer = fileTransfer;
+        this.geolocPush = geolocPush;
+        this.ipVoiceCall = ipVoiceCall;
+        this.ipVideoCall = ipVideoCall;
+        this.extensions = extensions;
+        this.automata = automata;
+        this.fileTransferHttpSupported = fileTransferHttpSupport;
+        this.rcsContact = rcsContact;
+        this.integratedMessagingMode = integratedMessagingMode;
+        this.csVideoSupported = csVideoSupported;
+
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public Capabilities(Parcel source) {
+        this.imageSharing = source.readInt() != 0;
+        this.videoSharing = source.readInt() != 0;
+        this.imSession = source.readInt() != 0;
+        this.fileTransfer = source.readInt() != 0;
+        List<String> exts = new ArrayList<String>();
+        source.readStringList(exts);
+        this.extensions = new HashSet<String>(exts);
+        this.geolocPush = source.readInt() != 0;
+        this.ipVoiceCall = source.readInt() != 0;
+        this.ipVideoCall = source.readInt() != 0;
+        this.automata = source.readInt() != 0;
+        this.fileTransferHttpSupported = source.readInt() != 0;
+        this.rcsContact = source.readInt() != 0;
+        this.integratedMessagingMode = source.readInt() != 0;
+        this.csVideoSupported = source.readInt() != 0;
+        this.burnAfterRead = source.readInt() != 0;
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(imageSharing ? 1 : 0);
+        dest.writeInt(videoSharing ? 1 : 0);
+        dest.writeInt(imSession ? 1 : 0);
+        dest.writeInt(fileTransfer ? 1 : 0);
+        if (extensions != null) {
+            List<String> exts = new ArrayList<String>();
+            exts.addAll(extensions);
+            dest.writeStringList(exts);
+        }
+        dest.writeInt(geolocPush ? 1 : 0);
+        dest.writeInt(ipVoiceCall ? 1 : 0);
+        dest.writeInt(ipVideoCall ? 1 : 0);
+        dest.writeInt(automata ? 1 : 0);
+        dest.writeInt(fileTransferHttpSupported ? 1 : 0);
+        dest.writeInt(rcsContact ? 1 : 0);
+        dest.writeInt(integratedMessagingMode ? 1 : 0);
+        dest.writeInt(csVideoSupported ? 1 : 0);
+        dest.writeInt(burnAfterRead ? 1 : 0);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<Capabilities> CREATOR
+            = new Parcelable.Creator<Capabilities>() {
+        public Capabilities createFromParcel(Parcel source) {
+            return new Capabilities(source);
+        }
+
+        public Capabilities[] newArray(int size) {
+            return new Capabilities[size];
+        }
+    };
+
+    /**
+     * Is image sharing supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isImageSharingSupported() {
+        Logger.i(TAG, "isImageSharingSupported value " + imageSharing);
+        return imageSharing;
+    }
+
+    /**
+     * Is video sharing supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isVideoSharingSupported() {
+        Logger.i(TAG, "isVideoSharingSupported value " + videoSharing);
+        return videoSharing;
+    }
+
+    /**
+     * Is IM session supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isImSessionSupported() {
+        Logger.i(TAG, "isImSessionSupported value " + imSession);
+        return imSession;
+    }
+
+    /**
+     * Is file transfer supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isFileTransferSupported() {
+        Logger.i(TAG, "isFileTransferSupported value " + fileTransfer);
+        return fileTransfer;
+    }
+
+
+    /**
+     * Is geolocation push supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isGeolocPushSupported() {
+        Logger.i(TAG, "isGeolocPushSupported value " + geolocPush);
+        return geolocPush;
+    }
+
+    /**
+     * Is IP voice call supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isIPVoiceCallSupported() {
+        Logger.i(TAG, "isIPVoiceCallSupported value " + ipVoiceCall);
+        return ipVoiceCall;
+    }
+
+    /**
+     * Is IP video call supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isIPVideoCallSupported() {
+        Logger.i(TAG, "isIPVideoCallSupported value " + ipVideoCall);
+        return ipVideoCall;
+    }
+
+    /**
+     * Is extension supported
+     *
+     * @param tag Feature tag
+     * @return Returns true if supported else returns false
+     */
+    public boolean isExtensionSupported(String tag) {
+        Logger.i(TAG, "isExtensionSupported value " + extensions.contains(tag));
+        return extensions.contains(tag);
+    }
+
+    /**
+     * Get list of supported extensions
+     *
+     * @return List of feature tags
+     */
+    public Set<String> getSupportedExtensions() {
+        Logger.i(TAG, "getSupportedExtensions value " + extensions);
+        return extensions;
+    }
+
+    /**
+     * Is automata
+     *
+     * @return Returns true if it's an automata else returns false
+     */
+    public boolean isAutomata() {
+        Logger.i(TAG, "isAutomata value" + automata);
+        return automata;
+    }
+
+    /**
+     * If FT HTTP Supported
+     *
+     * @return Returns true if it's supported
+     */
+    public boolean isFileTransferHttpSupported() {
+        Logger.i(TAG, "isFileTransferHttpSupported value" + fileTransferHttpSupported);
+        return fileTransferHttpSupported;
+    }
+
+    /**
+     * Is contact RCSe supported
+     *
+     * @return Returns true if it's rcs contact
+     */
+    public boolean isSupportedRcseContact() {
+        Logger.i(TAG, "isSupportedRcseContact value" + rcsContact);
+        return rcsContact;
+    }
+
+    /**
+     * BURN AFTER READING
+     *
+     */
+
+    public boolean isBurnAfterRead() {
+        return burnAfterRead;
+    }
+}
diff --git a/src/java/org/gsma/joyn/capability/CapabilitiesListener.java b/src/java/org/gsma/joyn/capability/CapabilitiesListener.java
new file mode 100644
index 0000000..5135caf
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/CapabilitiesListener.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.capability;
+
+
+/**
+ * New capabilities event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class CapabilitiesListener extends ICapabilitiesListener.Stub {
+    /**
+     * Callback called when new capabilities are received for a given contact
+     *
+     * @param contact Contact
+     * @param capabilities Received capabilities
+     */
+    public abstract void onCapabilitiesReceived(String contact, Capabilities capabilities);
+}
diff --git a/src/java/org/gsma/joyn/capability/CapabilitiesLog.java b/src/java/org/gsma/joyn/capability/CapabilitiesLog.java
new file mode 100644
index 0000000..cb4d8a8
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/CapabilitiesLog.java
@@ -0,0 +1,109 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.capability;
+
+import android.net.Uri;
+
+/**
+ * Content provider for last received capabilities
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class CapabilitiesLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.capabilities/capabilities");
+
+    /**
+     * Capability is not supported
+     */
+    public static final int NOT_SUPPORTED = 0;
+
+    /**
+     * Capability is supported
+     */
+    public static final int SUPPORTED = 1;
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the MSISDN of the contact associated to the capabilities.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the image share capability.
+     * @see CapabilitiesLog.Support
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_IMAGE_SHARE = "capability_image_share";
+
+    /**
+     * The name of the column containing the video share capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_VIDEO_SHARE = "capability_video_share";
+
+    /**
+     * The name of the column containing the file transfer capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_FILE_TRANSFER = "capability_file_transfer";
+
+    /**
+     * The name of the column containing the chat/IM session capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_IM_SESSION = "capability_im_session";
+
+    /**
+     * The name of the column containing the geoloc push capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_GEOLOC_PUSH = "capability_geoloc_push";
+
+    /**
+     * The name of the column containing the IP voice call capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_IP_VOICE_CALL = "capability_ip_voice_call";
+
+    /**
+     * The name of the column containing the IP video call capability.
+     * <P>Type: INTEGER</P>
+     */
+    public static final String CAPABILITY_IP_VIDEO_CALL = "capability_ip_video_call";
+
+    /**
+     * The name of the column containing the RCS extensions. List of features tags
+     * semicolon separated (e.g. <TAG1>;<TAG2>;TAGn).
+     * <P>Type: TEXT</P>
+     */
+    public static final String CAPABILITY_EXTENSIONS = "capability_extensions";
+
+
+    public static final String CAPABILITY_BURN_AFTER_READING = "burn_after_reading";
+
+
+}
diff --git a/src/java/org/gsma/joyn/capability/CapabilityService.java b/src/java/org/gsma/joyn/capability/CapabilityService.java
new file mode 100644
index 0000000..c871492
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/CapabilityService.java
@@ -0,0 +1,452 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.capability;
+
+import java.util.Iterator;
+import java.util.Set;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+
+
+import org.gsma.joyn.Logger;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+
+/**
+ * Capability service offers the main entry point to read capabilities
+ * of remote contacts, to initiate capability discovery and to receive
+ * capabilities updates. Several applications may connect/disconnect
+ * to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class CapabilityService extends JoynService {
+    /**
+     * Intent broadcasted to discover extensions
+     *
+     * @see CapabilityService.EXTENSION_MIME_TYPE
+     */
+    public final static String INTENT_EXTENSIONS = "org.gsma.joyn.capability.EXTENSION";
+
+    /**
+     * Extension MIME type
+     */
+    public final static String EXTENSION_MIME_TYPE = "org.gsma.joyn";
+
+    /**
+     * API
+     */
+    private ICapabilityService api = null;
+
+    public static final String TAG = "CapabilityService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public CapabilityService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_READ_CAPABILITIES) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_READ_CAPABILITIES");
+        }*/
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.ANDROID_READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission ANDROID_READ_CONTACTS");
+        }*/
+        Logger.i(TAG, "connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        intent.setAction(ICapabilityService.class.getName());
+        ctx.bindService(intent, apiConnection, 0);
+
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+        Logger.i(TAG, "setApi entry" + api);
+        this.api = (ICapabilityService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry");
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getCapabilitiesServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(ICapabilityService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected entry");
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the capabilities supported by the local end user. The supported
+     * capabilities are fixed by the MNO and read during the provisioning.
+     *
+     * @return Capabilities
+     * @throws JoynServiceException
+     */
+    public Capabilities getMyCapabilities() throws JoynServiceException {
+        Logger.i(TAG, "getMyCapabilities entry");
+        if (api != null) {
+            try {
+                return api.getMyCapabilities();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the capabilities of a given contact from the local database. This
+     * method doesnt request any network update to the remote contact. The parameter
+     * contact supports the following formats: MSISDN in national or international
+     * format, SIP address, SIP-URI or Tel-URI. If the format of the contact is not
+     * supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @return Capabilities
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public Capabilities getContactCapabilities(String contact) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "getContactCapabilities entry" + contact);
+        if (api != null) {
+            try {
+                return api.getContactCapabilities(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Requests capabilities to a remote contact. This method initiates in background
+     * a new capability request to the remote contact by sending a SIP OPTIONS. The
+     * result of the capability request is sent asynchronously via callback method of
+     * the capabilities listener. A capability refresh is only sent if the timestamp
+     * associated to the capability has expired (the expiration value is fixed via MNO
+     * provisioning). The parameter contact supports the following formats: MSISDN in
+     * national or international format, SIP address, SIP-URI or Tel-URI. If the format
+     * of the contact is not supported an exception is thrown. The result of the
+     * capability refresh request is provided to all the clients that have registered
+     * the listener for this event.
+     *
+     * @param contact Contact
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public void requestContactCapabilities(String contact) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "requestContactCapabilities entry" + contact);
+        if (api != null) {
+            try {
+                api.requestContactCapabilities(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Requests capabilities for a group of remote contacts. This method initiates
+     * in background new capability requests to the remote contact by sending a
+     * SIP OPTIONS. The result of the capability request is sent asynchronously via
+     * callback method of the capabilities listener. A capability refresh is only
+     * sent if the timestamp associated to the capability has expired (the expiration
+     * value is fixed via MNO provisioning). The parameter contact supports the
+     * following formats: MSISDN in national or international format, SIP address,
+     * SIP-URI or Tel-URI. If the format of the contact is not supported an exception
+     * is thrown. The result of the capability refresh request is provided to all the
+     * clients that have registered the listener for this event.
+     *
+     * @param contacts List of contacts
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public void requestContactCapabilities(Set<String> contacts) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "requestContactCapabilities entry" + contacts);
+        Iterator<String> values = contacts.iterator();
+        while (values.hasNext()) {
+            requestContactCapabilities(values.next());
+        }
+    }
+
+    /**
+     * Requests capabilities for all contacts existing in the local address book. This
+     * method initiates in background new capability requests for each contact of the
+     * address book by sending SIP OPTIONS. The result of a capability request is sent
+     * asynchronously via callback method of the capabilities listener. A capability
+     * refresh is only sent if the timestamp associated to the capability has expired
+     * (the expiration value is fixed via MNO provisioning). The result of the capability
+     * refresh request is provided to all the clients that have registered the listener
+     * for this event.
+     *
+     * @param contacts List of contacts
+     * @throws JoynServiceException
+     */
+    public void requestAllContactsCapabilities() throws JoynServiceException {
+        Logger.i(TAG, "requestAllContactsCapabilities entry");
+        if (api != null) {
+            try {
+                api.requestAllContactsCapabilities();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        Logger.i(TAG, "getServiceVersion entry");
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            Logger.i(TAG, "getServiceVersion is" + version);
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        Logger.i(TAG, "isServiceRegistered entry");
+        if (api != null) {
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            Logger.i(TAG, "isServiceRegistered" + serviceStatus);
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a capabilities listener on any contact
+     *
+     * @param listener Capabilities listener
+     * @throws JoynServiceException
+     */
+    public void addCapabilitiesListener(CapabilitiesListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addCapabilitiesListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addCapabilitiesListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a capabilities listener
+     *
+     * @param listener Capabilities listener
+     * @throws JoynServiceException
+     */
+    public void removeCapabilitiesListener(CapabilitiesListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeCapabilitiesListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeCapabilitiesListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a capabilities listener on a list of contacts
+     *
+     * @param contacts Set of contacts
+     * @param listener Capabilities listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public void addCapabilitiesListener(Set<String> contacts, CapabilitiesListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "addCapabilitiesListener entry" + contacts + listener);
+        if (api != null) {
+            try {
+                Iterator<String> list = contacts.iterator();
+                while (list.hasNext()) {
+                    String contact = list.next();
+                    api.addContactCapabilitiesListener(contact, listener);
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a capabilities listener on a list of contacts
+     *
+     * @param contacts Set of contacts
+     * @param listener Capabilities listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public void removeCapabilitiesListener(Set<String> contacts, CapabilitiesListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "removeCapabilitiesListener entry" + contacts + listener);
+        if (api != null) {
+            try {
+                Iterator<String> list = contacts.iterator();
+                while (list.hasNext()) {
+                    String contact = list.next();
+                    api.removeContactCapabilitiesListener(contact, listener);
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl b/src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl
new file mode 100644
index 0000000..7dbcfa1
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/ICapabilitiesListener.aidl
@@ -0,0 +1,10 @@
+package org.gsma.joyn.capability;
+
+import org.gsma.joyn.capability.Capabilities;
+
+/**
+ * Callback method for new capabilities
+ */
+interface ICapabilitiesListener {
+	void onCapabilitiesReceived(in String contact, in Capabilities capabilities);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/capability/ICapabilityService.aidl b/src/java/org/gsma/joyn/capability/ICapabilityService.aidl
new file mode 100644
index 0000000..ca140f3
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/ICapabilityService.aidl
@@ -0,0 +1,34 @@
+package org.gsma.joyn.capability;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.capability.Capabilities;
+import org.gsma.joyn.capability.ICapabilitiesListener;
+
+/**
+ * Capability service API
+ */
+interface ICapabilityService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	Capabilities getMyCapabilities();
+
+	Capabilities getContactCapabilities(in String contact);
+
+	void requestContactCapabilities(in String contact);
+
+	void requestAllContactsCapabilities();
+
+	void addCapabilitiesListener(in ICapabilitiesListener listener);
+
+	void removeCapabilitiesListener(in ICapabilitiesListener listener);
+
+	void addContactCapabilitiesListener(in String contact, in ICapabilitiesListener listener);
+
+	void removeContactCapabilitiesListener(in String contact, in ICapabilitiesListener listener);
+	
+	int getServiceVersion();
+}
diff --git a/src/java/org/gsma/joyn/capability/package-info.java b/src/java/org/gsma/joyn/capability/package-info.java
new file mode 100644
index 0000000..6cc2258
--- /dev/null
+++ b/src/java/org/gsma/joyn/capability/package-info.java
@@ -0,0 +1,20 @@
+/**
+ * This API permits to discover capabilities supported by remote contacts.
+ * <p>
+ * This API allows for querying the capabilities of a user or users and checking
+ * for changes in their capabilities:<br>
+ * - Read the supported capabilities locally by the user on its device.<br>
+ * - Retrieve all capabilities of a user.<br>
+ * - Checking a specific capability of a user.<br>
+ * - Registering for changes to a user/users capabilities.<br>
+ * - Unregistering for changes to a user/users capabilities.<br>
+ * - Define scheme for registering new service capabilities based on manifest defined
+ *  feature tags. This API may be accessible by any application (third party, MNO, OEM).
+ *  The RCS extensions are controlled internally by the RCS service.
+ * <p>
+ * For example, this API may be used:<br>
+ * - To request capability update for a user when opening its contact card in the address book.<br>
+ * - To synchronize capabilities of all the contacts from the RCS account management menu.<br>
+ * - To receive supported capabilities when a CS call is established.<br>
+ */
+package org.gsma.joyn.capability;
diff --git a/src/java/org/gsma/joyn/chat/Chat.java b/src/java/org/gsma/joyn/chat/Chat.java
new file mode 100644
index 0000000..d24be2c
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/Chat.java
@@ -0,0 +1,482 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+
+import org.gsma.joyn.JoynServiceException;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * Chat
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Chat {
+
+    /**
+     * Direction of the group chat
+     */
+    public static class MessageState {
+        /**
+         * Message being sent
+         */
+        public static final int SENDING = 0;
+
+        /**
+         * Message sent
+         */
+        public static final int SENT = 1;
+
+        /**
+         * Message delivered to remote
+         */
+        public static final int DELIVERED = 2;
+
+        /**
+         * Message sending failed
+         */
+        public static final int FAILED = 3;
+    }
+
+    /**
+     * Direction of the group chat
+     */
+    public static class ErrorCodes {
+        /**
+         * Message being sent
+         */
+        public static final int TIMEOUT = 1;
+
+        /**
+         * Message sent
+         */
+        public static final int UNKNOWN = 2;
+
+        /**
+         * Message delivered to remote
+         */
+        public static final int INTERNAL_EROR = 3;
+
+        /**
+         * Message sending failed
+         */
+        public static final int OUT_OF_SIZE = 4;
+    }
+
+    /**
+     * Chat interface
+     */
+    protected IChat chatInf;
+
+    public static final String TAG = "TAPI-Chat";
+
+    /**
+     * Constructor
+     *
+     * @param chatIntf Chat interface
+     */
+    Chat(IChat chatIntf) {
+        this.chatInf = chatIntf;
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact entry");
+        try {
+            return chatInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a chat message
+     *
+     * @param message Message
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendMessage(String message) throws JoynServiceException {
+        Logger.i(TAG, "ABC sendMessage entry " + message);
+        try {
+            return chatInf.sendMessage(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a geoloc message
+     *
+     * @param geoloc Geoloc info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendGeoloc(Geoloc geoloc) throws JoynServiceException {
+
+        Logger.i(TAG, "sendGeoloc entry " + geoloc);
+        try {
+            return chatInf.sendGeoloc(geoloc);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a large mode message
+     *
+     * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+   public String sendMessageByLargeMode(String message) throws JoynServiceException {
+
+        Logger.i(TAG, "sendMessageByLargeMode entry " + message);
+        try {
+            return chatInf.sendMessageByLargeMode(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+  /**
+    * Sends a cloud large mode message
+    *
+    * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+    */
+  public String sendCloudMessageByLargeMode(String message) throws JoynServiceException {
+
+    Logger.i(TAG, "sendCloudMessageByLargeMode entry " + message);
+        try {
+            return chatInf.sendCloudMessageByLargeMode(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+   }
+
+  /**
+     * Sends a pager mode message
+     *
+     * @param messageId Message id
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+  public void sendSpamMessageByPagerMode(String contact, String messageId)  throws JoynServiceException {
+
+        Logger.i(TAG, "sendSpamMessageByPagerMode entry " + messageId);
+        try {
+            chatInf.sendSpamMessageByPagerMode(contact, messageId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+   /**
+    * Sends a pager mode message for spam report
+    *
+     * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+   public String sendMessageByPagerMode(String message) throws JoynServiceException {
+
+        Logger.i(TAG, "sendMessageByPagerMode entry " + message);
+        try {
+            return chatInf.sendMessageByPagerMode(message, false, false, false, false, null);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+   /**
+    * Sends a pager mode message
+    *
+    * @param message Message info
+    * @return Unique message ID or null in case of error
+    * @throws JoynServiceException
+    */
+  public String sendOnetoMultiMessageByPagerMode(String message, HashSet<String> participants) throws JoynServiceException {
+
+       Logger.i(TAG, "sendMessageByPagerMode entry " + message);
+       try {
+           return chatInf.sendMessageByPagerMode(message, false, false, true, false, new ArrayList<String>(participants));
+       } catch (Exception e) {
+           throw new JoynServiceException(e.getMessage());
+       }
+   }
+
+  /**
+    * Sends a pager mode emoticon message
+    * 
+    * @param message Message info
+    * @return Unique message ID or null in case of error
+    * @throws JoynServiceException
+    */
+  public String sendOnetoMultiEmoticonsMessageByPagerMode(String message, HashSet<String> participants) throws JoynServiceException {
+       
+       Logger.i(TAG, "sendOnetoMultiEmoticonsMessageByPagerMode entry " + message + "Participants: " + participants);
+       try {
+           return chatInf.sendOnetoMultiEmoticonsMessage(message,new ArrayList<String>(participants));
+       } catch(Exception e) {
+           throw new JoynServiceException(e.getMessage());
+       }       
+   }
+   
+   
+  /**
+   * Sends a pager mode message
+   *
+   * @param message Message info
+   * @return Unique message ID or null in case of error
+   * @throws JoynServiceException
+   */
+ public String sendOnetoMultiMessage(String message, HashSet<String> participants) throws JoynServiceException {
+
+      try {
+          return chatInf.sendOnetoMultiMessage(message, new ArrayList<String>(participants));
+      } catch (Exception e) {
+          throw new JoynServiceException(e.getMessage());
+      }
+  }
+
+
+ /**
+  * Sends a pager mode message
+  *
+  * @param message Message info
+  * @return Unique message ID or null in case of error
+  * @throws JoynServiceException
+  */
+public String sendEmoticonShopMessage(String message) throws JoynServiceException {
+
+     try {
+         return chatInf.sendEmoticonShopMessage(message);
+     } catch (Exception e) {
+         throw new JoynServiceException(e.getMessage());
+     }
+ }
+
+public String sendCloudMessage(String message) throws JoynServiceException {
+
+     try {
+         return chatInf.sendCloudMessage(message);
+     } catch (Exception e) {
+         throw new JoynServiceException(e.getMessage());
+     }
+ }
+
+
+
+
+  public String sendBurnMessage(String message)throws JoynServiceException {
+      Logger.i(TAG, "sendBurnMessage entry " + message);
+        try {
+        //  return chatInf.sendGeoloc(geoloc);
+        return null;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+  }
+
+
+
+  public String sendPagerModeBurnMessage(String message)throws JoynServiceException {
+      Logger.i(TAG, "sendPagerModeBurnMessage entry " + message);
+        try {
+            return chatInf.sendPagerModeBurnMessage(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+  }
+
+  /**
+   * Sends a burn message by large message mode
+   *
+   * @param message Message info
+   * @return Unique message ID or null in case of error
+   * @throws JoynServiceException
+   */
+  public String sendLargeModeBurnMessage(String message)throws JoynServiceException {
+      Logger.i(TAG, "sendLargeModeBurnMessage entry " + message);
+        try {
+        return chatInf.sendLargeModeBurnMessage(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+  }
+
+    /**
+     * Sends a displayed delivery report for a given message ID
+     *
+     * @param msgId Message ID
+     * @throws JoynServiceException
+     */
+    public void sendDisplayedDeliveryReport(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "sendDisplayedDeliveryReport entry " + msgId);
+        try {
+            chatInf.sendDisplayedDeliveryReport(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a burn report for a given burn message ID
+     *
+     * @param msgId Message ID
+     * @throws JoynServiceException
+     */
+    public void sendBurnDeliveryReport(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "sendBurnDeliveryReport entry " + msgId);
+        try {
+            chatInf.sendBurnDeliveryReport(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends an Is-composing event. The status is set to true when
+     * typing a message, else it is set to false.
+     *
+     * @param status Is-composing status
+     * @throws JoynServiceException
+     */
+    public void sendIsComposingEvent(boolean status) throws JoynServiceException {
+        Logger.i(TAG, "sendIsComposingEvent entry " + status);
+        try {
+            chatInf.sendIsComposingEvent(status);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     *
+     * @param msgId message Id of message
+     * @return state of the message
+     * @throws JoynServiceException
+     */
+    public int resendMessage(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "resendMessage msgId " + msgId);
+        try {
+            return chatInf.resendMessage(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     *
+     * @param msgId message Id of message
+     * @throws JoynServiceException
+     */
+    public int reSendMultiMessageByPagerMode(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "reSendMultiMessageByPagerMode msgId " + msgId);
+        try {
+            return chatInf.reSendMultiMessageByPagerMode(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     *
+     * @param msgId message Id of message
+     * @return state of the message
+     * @throws JoynServiceException
+     */
+    public int getState(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "getState MessageId= " + msgId);
+        try {
+            return 0;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on chat events
+     *
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(ChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener entry " + listener);
+        try {
+            chatInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener on chat events
+     *
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(ChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener entry " + listener);
+        try {
+            chatInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on spam events
+     *
+     * @param listener Spam event listener
+     * @throws JoynServiceException
+     */
+    public void addSpamReportListener(SpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addSpamReportListener entry " + listener);
+        try {
+            chatInf.addSpamReportListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener on spam events
+     *
+     * @param listener Spam event listener
+     * @throws JoynServiceException
+     */
+    public void removeSpamReportListener(SpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeSpamReportListener entry " + listener);
+        try {
+            chatInf.removeSpamReportListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatIntent.java b/src/java/org/gsma/joyn/chat/ChatIntent.java
new file mode 100644
index 0000000..ae74d4c
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatIntent.java
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+/**
+ * Intent for chat conversation
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatIntent {
+    /**
+     * Broadcast action: a new chat message has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the remote contact
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_MESSAGE} containing the chat message (parcelable object).
+     * </ul>
+     */
+    public final static String ACTION_NEW_CHAT = "org.gsma.joyn.chat.action.NEW_CHAT";
+
+     /**
+     * Broadcast action: a delivery status of a chat message has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the remote contact
+     * <li> {msgId} containing the message id of the message.
+     * <li> {status} containing the delivery status of chat message.
+     * </ul>
+     */
+    public final static String ACTION_DELIVERY_STATUS = "org.gsma.joyn.chat.action.DELIEVRY_STATUS";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CLOUD_MESSAGE = "cloudMessage";
+
+    /**
+     * Display name of the contact sending the invitation (extracted from the SIP address)
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Received message
+     *
+     * @see ChatMessage
+     * @see GeolocMessage
+     */
+    public final static String EXTRA_MESSAGE = "firstMessage";
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatListener.java b/src/java/org/gsma/joyn/chat/ChatListener.java
new file mode 100644
index 0000000..a2e34e9
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatListener.java
@@ -0,0 +1,111 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+
+/**
+ * Chat event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class ChatListener extends IChatListener.Stub {
+    /**
+     * Callback called when a new message has been received
+     *
+     * @param message Chat message
+     * @see ChatMessage
+     */
+    public abstract void onNewMessage(ChatMessage message);
+
+    /**
+     * Callback called when a new geoloc has been received
+     *
+     * @param message Geoloc message
+     */
+    public abstract void onNewGeoloc(GeolocMessage message);
+
+    /**
+     * Callback called when a message has been delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageDelivered(String msgId);
+
+    /**
+     * Callback called when a message has been displayed by the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageDisplayed(String msgId);
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageFailed(String msgId);
+
+    /**
+     * Callback called when an Is-composing event has been received. If the
+     * remote is typing a message the status is set to true, else it is false.
+     *
+     * @param status Is-composing status
+     */
+    public abstract void onComposingEvent(boolean status);
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public void onReportFailedMessage(String msgId, int errtype, String statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has been sent to the remote
+     *
+     * @param msgId Message ID
+     */
+    public void onReportSentMessage(String msgId) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public void onReportDeliveredMessage(String msgId) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a new burn message has been received
+     *
+     * @param message Chat message
+     * @see ChatMessage
+     */
+    public void onNewBurnMessageArrived(ChatMessage msg) {
+        // default implementation for TAPI extension
+    }
+
+    //message callback when a new burn file transfer arrives
+    //public abstract void onNewBurnFileTransfer(
+    //          String transferId,Boolean isGroup,String chatSessionId,String ChatId);
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatLog.java b/src/java/org/gsma/joyn/chat/ChatLog.java
new file mode 100644
index 0000000..6dc01ae
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatLog.java
@@ -0,0 +1,702 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.io.ByteArrayInputStream;
+import java.io.ObjectInputStream;
+
+import android.net.Uri;
+
+/**
+ * Content provider for chat history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatLog {
+    /**
+     * Group chat
+     */
+    public static class GroupChat {
+        /**
+         * Content provider URI for chat conversations
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/chat");
+
+        /**
+         * The name of the column containing the unique ID for a row.
+         * <P>Type: primary key</P>
+         */
+        public static final String ID = "_id";
+
+        /**
+         * The name of the column containing the unique ID of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CHAT_ID = "chat_id";
+
+        /**
+         * The name of the column containing the state of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.State
+         */
+        public static final String STATE = "state";
+
+        /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String SUBJECT = "subject";
+
+
+        /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PARTICIPANTS_LIST = "participants";
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String DIRECTION = "direction";
+
+        /**
+         * The name of the column containing the time when group chat is created.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP = "timestamp";
+
+
+        /*
+         * M: CPM related changes
+         */
+        /**
+         * The name of the column containing the conversation ID.(in case of CPM only its added)
+         * <P>Type: TEXT</P>
+         */
+        public static final String CONVERSATION_ID = "conversation_id";
+
+        /*
+         *@: ENDS
+         */
+        /**
+         * CMCC changes
+         */
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String CHAIRMAN = "chairman";
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String NICKNAME = "nickname";
+
+        public static final String ISBLOCKED = "isBlocked";
+
+    }
+
+    /**
+     * Chat message from a single chat or group chat
+     */
+    public static class Message {
+        /**
+         * Content provider URI for chat messages
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/message");
+
+        /**
+         * Content provider URI for chat messages of a given conversation. In case of single chat
+         * the conversation is identified by the contact phone number. In case of group chat the
+         * the conversation is identified by the unique chat ID.
+         */
+        public static final Uri CONTENT_CHAT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/message/#");
+
+        /**
+         * The name of the column containing the unique ID for a row.
+         * <P>Type: primary key</P>
+         */
+        public static final String ID = "_id";
+
+        /**
+         * The name of the column containing the chat ID.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CHAT_ID = "chat_id";
+
+        /**
+         * The name of the column containing the message ID.
+         * <P>Type: TEXT</P>
+         */
+        public static final String MESSAGE_ID = "msg_id";
+
+        /**
+         * The name of the column containing the message status.
+         * <P>Type: INTEGER</P>
+         */
+        public static final String MESSAGE_STATUS = "status";
+
+        /**
+         * The name of the column containing the message direction.
+         * <P>Type: INTEGER</P>
+         */
+        public static final String DIRECTION = "direction";
+
+        /**
+         * The name of the column containing the type of message.
+         * <P>Type: INTEGER</P>
+         * @see ChatLog.Message.Type
+         */
+        public static final String MESSAGE_TYPE = "msg_type";
+
+        /**
+         * The name of the column containing the identity of the sender of the message.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CONTACT_NUMBER = "sender";
+
+
+        /**
+         * The name of the column containing the message body.
+         * <P>Type: BLOB</P>
+         */
+        public static final String BODY = "body";
+
+        /**
+         * The name of the column containing the time when message is created.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP = "timestamp";
+
+        /**
+         * The name of the column containing the time when message is sent. If 0 means not sent.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP_SENT = "timestamp_sent";
+
+        /**
+         * The name of the column containing the time when message is delivered. If 0 means not delivered.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP_DELIVERED = "timestamp_delivered";
+
+        /**
+         * The name of the column containing the time when message is displayed. If 0 means not displayed.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP_DISPLAYED = "timestamp_displayed";
+
+        /**
+         * The name of the column containing the MIME-TYPE of the message body.
+         * <P>Type: TEXT</P>
+         */
+        public static final String MIME_TYPE = "mime_type";
+
+
+        /** M:for adding alias or display name
+         * The name of the column containing the display name user. in case of O2O only in SYSTEM_MSG this value will be set.
+         * in case of GROUP CHAT, it will be set for all messages
+         * <P>Type: TEXT</P>
+         */
+        public static final String DISPLAY_NAME = "display_name";
+        /**@*/
+
+        /*
+         * M: CPM related changes
+         */
+        /**
+         * The name of the column containing the conversation ID.(in case of CPM only its added)
+         * <P>Type: TEXT</P>
+         */
+        public static final String CONVERSATION_ID = "conversation_id";
+
+        /*
+         *@: ENDS
+         */
+
+
+        /**
+         * Type of the message
+         */
+        public static class Type {
+            /**
+             * Content message
+             */
+            public static final int CONTENT = 0;
+
+            /**
+             * System message
+             */
+            public static final int SYSTEM = 1;
+
+            /**
+             * Spam message
+             */
+            public static final int SPAM = 2;
+
+            /**
+             * burn message
+             */
+            public static final int BURN = 3;
+
+            /**
+             * burn message
+             */
+            public static final int PUBLIC = 4;
+
+            /**
+             * CLOUD message
+             */
+            public static final int CLOUD = 5;
+
+            /**
+             * CLOUD message
+             */
+            public static final int EMOTICON = 6;
+
+        }
+
+        /**
+         * Direction of the message
+         */
+        public static class Direction {
+            /**
+             * Incoming message
+             */
+            public static final int INCOMING = 0;
+
+            /**
+             * Outgoing message
+             */
+            public static final int OUTGOING = 1;
+
+            /**
+             * Irrelevant or not applicable (e.g. for a system message)
+             */
+            public static final int IRRELEVANT = 2;
+        }
+
+        /**
+         * Status of the message
+         */
+        public static class Status {
+            /**
+             * Status of a content message
+             */
+            public static class Content {
+                /**
+                 * The message has been delivered, but we don't know if the message
+                 * has been read by the remote
+                 */
+                public static final int UNREAD = 0;
+
+                /**
+                 * The message has been delivered and a displayed delivery report is
+                 * requested, but we don't know if the message has been read by the remote
+                 */
+                public static final int UNREAD_REPORT = 1;
+
+                /**
+                 * The message has been read by the remote (i.e. displayed)
+                 */
+                public static final int READ = 2;
+
+                /**
+                 * The message is in progress of sending
+                 */
+                public static final int SENDING = 3;
+
+                /**
+                 * The message has been sent
+                 */
+                public static final int SENT = 4;
+
+                /**
+                 * The message is failed to be sent
+                 */
+                public static final int FAILED = 5;
+
+                /**
+                 * The message is queued to be sent by joyn service when possible
+                 */
+                public static final int TO_SEND = 6;
+
+                /**
+                 * The message is a spam message
+                 */
+                public static final int BLOCKED = 7;
+            }
+
+            /**
+             * Status of the system message
+             */
+            public static class System {
+                /**
+                 * Invitation of a participant is pending
+                 */
+                public static final int PENDING = 0;
+
+                /**
+                 * Invitation accepted by a participant
+                 */
+                public static final int ACCEPTED = 1;
+
+                /**
+                 * Invitation declined by a participant
+                 */
+                public static final int DECLINED = 2;
+
+                /**
+                 * Invitation of a participant has failed
+                 */
+                public static final int FAILED = 3;
+
+                /**
+                 * Participant has joined the group chat
+                 */
+                public static final int JOINED = 4;
+
+                /**
+                 * Participant has left the group chat (i.e. departed)
+                 */
+                public static final int GONE = 5;
+
+                /**
+                 * Participant has been disconnected from the group chat (i.e. booted)
+                 */
+                public static final int DISCONNECTED = 6;
+
+                /**
+                 * Participant is busy
+                 */
+                public static final int BUSY = 7;
+            }
+        }
+    }
+
+    /**
+     * Chat message from a single chat or group chat
+     */
+    public static class MultiMessage {
+        /**
+         * Content provider URI for chat messages
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/multimessage");
+
+        /**
+         * Content provider URI for chat messages of a given conversation. In case of single chat
+         * the conversation is identified by the contact phone number. In case of group chat the
+         * the conversation is identified by the unique chat ID.
+         */
+        public static final Uri CONTENT_CHAT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/multimessage/#");
+
+
+        /**
+         * The name of the column containing the unique ID for a row.
+         * <P>Type: primary key</P>
+         */
+        public static final String ID = "_id";
+
+        /**
+         * The name of the column containing the unique ID of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String CHAT_ID = "chat_id";
+
+        public static final String MESSAGE_ID = "msg_id";
+        /**
+         * The name of the column containing the state of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.State
+         */
+        public static final String STATE = "state";
+
+        /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String SUBJECT = "subject";
+
+
+        /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PARTICIPANTS_LIST = "participants";
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String DIRECTION = "direction";
+
+        /**
+         * The name of the column containing the time when group chat is created.
+         * <P>Type: LONG</P>
+         */
+        public static final String TIMESTAMP = "timestamp";
+
+        /*
+         *@: ENDS
+         */
+
+
+        /**
+         * Type of the message
+         */
+        public static class Type {
+            /**
+             * Content message
+             */
+            public static final int CONTENT = 0;
+
+            /**
+             * System message
+             */
+            public static final int SYSTEM = 1;
+
+            /**
+             * Spam message
+             */
+            public static final int SPAM = 2;
+        }
+
+        /**
+         * Direction of the message
+         */
+        public static class Direction {
+            /**
+             * Incoming message
+             */
+            public static final int INCOMING = 0;
+
+            /**
+             * Outgoing message
+             */
+            public static final int OUTGOING = 1;
+
+            /**
+             * Irrelevant or not applicable (e.g. for a system message)
+             */
+            public static final int IRRELEVANT = 2;
+        }
+
+        /**
+         * Status of the message
+         */
+        public static class Status {
+            /**
+             * Status of a content message
+             */
+            public static class Content {
+                /**
+                 * The message has been delivered, but we don't know if the message
+                 * has been read by the remote
+                 */
+                public static final int UNREAD = 0;
+
+                /**
+                 * The message has been delivered and a displayed delivery report is
+                 * requested, but we don't know if the message has been read by the remote
+                 */
+                public static final int UNREAD_REPORT = 1;
+
+                /**
+                 * The message has been read by the remote (i.e. displayed)
+                 */
+                public static final int READ = 2;
+
+                /**
+                 * The message is in progress of sending
+                 */
+                public static final int SENDING = 3;
+
+                /**
+                 * The message has been sent
+                 */
+                public static final int SENT = 4;
+
+                /**
+                 * The message is failed to be sent
+                 */
+                public static final int FAILED = 5;
+
+                /**
+                 * The message is queued to be sent by joyn service when possible
+                 */
+                public static final int TO_SEND = 6;
+
+                /**
+                 * The message is a spam message
+                 */
+                public static final int BLOCKED = 7;
+            }
+
+            /**
+             * Status of the system message
+             */
+            public static class System {
+                /**
+                 * Invitation of a participant is pending
+                 */
+                public static final int PENDING = 0;
+
+                /**
+                 * Invitation accepted by a participant
+                 */
+                public static final int ACCEPTED = 1;
+
+                /**
+                 * Invitation declined by a participant
+                 */
+                public static final int DECLINED = 2;
+
+                /**
+                 * Invitation of a participant has failed
+                 */
+                public static final int FAILED = 3;
+
+                /**
+                 * Participant has joined the group chat
+                 */
+                public static final int JOINED = 4;
+
+                /**
+                 * Participant has left the group chat (i.e. departed)
+                 */
+                public static final int GONE = 5;
+
+                /**
+                 * Participant has been disconnected from the group chat (i.e. booted)
+                 */
+                public static final int DISCONNECTED = 6;
+
+                /**
+                 * Participant is busy
+                 */
+                public static final int BUSY = 7;
+            }
+        }
+    }
+
+
+    public static class GroupChatMember {
+        /**
+         * Content provider URI for chat conversations
+         */
+        public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.chat/groupmember");
+
+
+        /**
+         *
+         * <P>Type: TEXT</P>
+         */
+        public static final String ID = "_id";
+
+
+        /**
+         *
+         * <P>Type: TEXT</P>
+         */
+        public static final String CHAT_ID = "CHAT_ID";
+
+
+        /**
+         *
+         * <P>Type: TEXT</P>
+         */
+        public static final String GROUP_MEMBER_NAME = "MEMBER_NAME";
+
+        /**
+         * .
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String GROUP_MEMBER_PORTRAIT = "PORTRAIT";
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String GROUP_MEMBER_NUMBER = "CONTACT_NUMBER";
+
+
+        /**
+         * The name of the column containing the direction of the group chat.
+         * <P>Type: INTEGER</P>
+         * @see GroupChat.Direction
+         */
+        public static final String GROUP_MEMBER_TYPE = "CONTACT_ETYPE";
+
+
+
+        /*
+         * M: CPM related changes
+         */
+        /**
+         * The name of the column containing the conversation ID.(in case of CPM only its added)
+         * <P>Type: TEXT</P>
+         */
+        public static final String CONVERSATION_ID = "conversation_id";
+
+        /*
+         *@: ENDS
+         */
+    }
+
+    /**
+     * Get plain text message from a BLOB
+     *
+     * @param content BLOB content
+     * @return Text message or null in case of error
+     */
+    public static String getTextFromBlob(byte[] content) {
+        try {
+            return new String(content);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    /**
+     * Get geoloc object from a BLOB
+     *
+     * @param content BLOB content
+     * @return Geoloc object or null in case of error
+     * @see Geoloc
+     */
+    public static Geoloc getGeolocFromBlob(byte[] content) {
+        try {
+            ByteArrayInputStream bis = new ByteArrayInputStream(content);
+            ObjectInputStream is = new ObjectInputStream(bis);
+            Geoloc geoloc = (Geoloc) is.readObject();
+            is.close();
+            return geoloc;
+        } catch (Exception e) {
+            return null;
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatMessage.aidl b/src/java/org/gsma/joyn/chat/ChatMessage.aidl
new file mode 100644
index 0000000..5fd54a4
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatMessage.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Chat message object
+ */
+parcelable ChatMessage;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/ChatMessage.java b/src/java/org/gsma/joyn/chat/ChatMessage.java
new file mode 100644
index 0000000..085fcd0
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatMessage.java
@@ -0,0 +1,275 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.Date;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Chat message
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatMessage implements Parcelable {
+    /**
+     * MIME type
+     */
+    public final static String MIME_TYPE = "text/plain";
+
+    public static final String TAG = "TAPI-ChatMessage";
+    /**
+     * Unique message Id
+     */
+    private String id;
+
+    /**
+     * Contact who has sent the message
+     */
+    private String contact;
+
+    /**
+     * Message content
+     */
+    private String message;
+
+    /**
+     * Receipt date of the message
+     */
+    private Date receiptAt;
+
+    /**
+     * Display Name
+     */
+    private String displayName;
+
+    /**
+     * Flag indicating is a displayed report is requested
+     */
+    private boolean displayedReportRequested = false;
+
+
+    /**
+     * burn message
+     */
+    private boolean isBurnMessage = false;
+
+    private boolean isPublicMessage = false;
+
+    private boolean isCloudMessage = false;
+
+    private boolean isEmoticonMessage = false;
+
+
+    /**
+     * Constructor for outgoing message
+     *
+     * @param messageId Message Id
+     * @param contact Contact
+     * @param message Message content
+     * @param receiptAt Receipt date
+     * @param displayedReportRequested Flag indicating if a displayed report is requested
+     * @hide
+     */
+    public ChatMessage(String messageId, String remote, String message, Date receiptAt, boolean displayedReportRequested, String displayName) {
+        Logger.i(TAG, "ChatMessage entry" + "messageId=" + messageId + " remote=" + remote + " message=" + message +
+                " receiptAt=" + receiptAt + " displayedReportRequested=" + displayedReportRequested);
+        Logger.i(TAG, "ABCG ChatMessage entry" + "displayname=" + displayName);
+        this.id = messageId;
+        this.contact = remote;
+        this.message = message;
+        this.displayedReportRequested = displayedReportRequested;
+        this.receiptAt = receiptAt;
+        this.displayName = displayName;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public ChatMessage(Parcel source) {
+        this.id = source.readString();
+        this.contact = source.readString();
+        this.message = source.readString();
+        this.receiptAt = new Date(source.readLong());
+        this.displayedReportRequested = source.readInt() != 0;
+        this.displayName = source.readString();
+        this.isBurnMessage = source.readByte() != 0;
+        this.isPublicMessage = source.readByte() != 0;
+        this.isCloudMessage = source.readByte() != 0;
+        this.isEmoticonMessage = source.readByte() != 0;
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(id);
+        dest.writeString(contact);
+        dest.writeString(message);
+        dest.writeLong(receiptAt.getTime());
+        dest.writeInt(displayedReportRequested ? 1 : 0);
+        dest.writeString(displayName);
+        dest.writeByte((byte) (isBurnMessage ? 1 : 0));
+        dest.writeByte((byte) (isPublicMessage ? 1 : 0));
+        dest.writeByte((byte) (isCloudMessage ? 1 : 0));
+        dest.writeByte((byte) (isEmoticonMessage ? 1 : 0));
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<ChatMessage> CREATOR
+            = new Parcelable.Creator<ChatMessage>() {
+        public ChatMessage createFromParcel(Parcel source) {
+            return new ChatMessage(source);
+        }
+
+        public ChatMessage[] newArray(int size) {
+            return new ChatMessage[size];
+        }
+    };
+
+    /**
+     * Returns the message ID
+     *
+     * @return ID
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * Returns the contact
+     *
+     * @return Contact
+     */
+    public String getContact() {
+        return contact;
+    }
+
+    /**
+     * Returns the message content
+     *
+     * @return String
+     */
+    public String getMessage() {
+        return message;
+    }
+
+    /**
+     * Returns the display name
+     *
+     * @return String
+     */
+    public String getDisplayName() {
+        return displayName;
+    }
+
+    /**
+     * Returns the receipt date of chat message
+     *
+     * @return Date
+     */
+    public Date getReceiptDate() {
+        return receiptAt;
+    }
+
+    /**
+     * Is displayed delivery report requested
+     *
+     * @return Returns true if requested else returns false
+     */
+    public boolean isDisplayedReportRequested() {
+        return displayedReportRequested;
+    }
+
+    /**
+     * Is the chat message of burn type
+     *
+     * @return Returns true if chat message is of burn type else returns false
+     */
+    public boolean isBurnMessage() {
+        return isBurnMessage;
+    }
+
+     /**
+     * Set the message type of chat message as burn message
+     *
+     * @param burnFlag Flag indicating whether message is burn message type
+     */
+    public void setBurnMessage(boolean burnFlag) {
+        isBurnMessage = burnFlag;
+    }
+
+    public boolean isCloudMessage() {
+        return isCloudMessage;
+    }
+
+    public void setCloudMessage(boolean burnFlag) {
+        isCloudMessage = burnFlag;
+    }
+
+    public boolean isEmoticonMessage() {
+        return isEmoticonMessage;
+    }
+
+    public void setEmoticonMessage(boolean burnFlag) {
+        isEmoticonMessage = burnFlag;
+    }
+
+    /**
+     * Is the chat message of public chat type
+     *
+     * @return Returns true if chat message is of public chat type else returns false
+     */
+    public boolean isPublicMessage() {
+        return isPublicMessage;
+    }
+
+    /**
+     * Set the message type of chat message as public chat
+     *
+     * @param publicFlag Flag indicating whether message is public chat type
+     */
+    public void setPublicMessage(boolean publicFlag) {
+        isPublicMessage = publicFlag;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatService.java b/src/java/org/gsma/joyn/chat/ChatService.java
new file mode 100644
index 0000000..07877ac
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatService.java
@@ -0,0 +1,843 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+import org.gsma.joyn.Logger;
+//import com.orangelabs.rcs.service.api.ChatServiceImpl;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+
+/**
+ * Chat service offers the main entry point to initiate chat 1-1 ang group
+ * conversations with contacts. Several applications may connect/disconnect
+ * to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatService extends JoynService {
+    /**
+     * API
+     */
+    private IChatService api = null;
+
+    public static final String TAG = "TAPI-ChatService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public ChatService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    @Override
+    public void connect() {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_USE_CHAT) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_USE_CHAT");
+        }*/
+        Logger.i(TAG, "connected() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        boolean connected = ctx.bindService(intent, apiConnection, 0);
+        Logger.i(TAG, "connect() exit status" + connected);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    @Override
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    @Override
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+        Logger.i(TAG, "setApi entry" + api);
+        this.api = (IChatService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry" + service);
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getChatServiceBinder();
+            } catch (RemoteException e1) {
+
+                e1.printStackTrace();
+            }
+            setApi(IChatService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            setApi(null);
+            Logger.i(TAG, "onServiceDisconnected entry");
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of the chat service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public ChatServiceConfiguration getConfiguration() throws JoynServiceException {
+        if (api != null) {
+            try {
+                Logger.i(TAG, "getConfiguration entry");
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    @Override
+    public int getServiceVersion() throws JoynServiceException {
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                    Logger.i(TAG, "getServiceVersion entry " + version);
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    @Override
+    public boolean isServiceRegistered() throws JoynServiceException {
+        Logger.i(TAG, "isServiceRegistered entry ");
+        if (api != null) {
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+                Logger.i(TAG, "isServiceRegistered entry " + serviceStatus);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public void initiateSpamReport(String contact, String messageId) throws JoynServiceException {
+        Logger.i(TAG, "initiateSpamReport entry " + contact + ":" + messageId);
+        if (api != null) {
+            try {
+                api.initiateSpamReport(contact, messageId);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    @Override
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Adds a spam listener.
+     *
+     * @param listener Spam Report listener
+     * @throws JoynServiceException
+     */
+    public void addSpamReportListener(SpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addSpamReportListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addSpamReportListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Removes a spam listener
+     *
+     * @param listener Spam Report listener
+     * @throws JoynServiceException
+     */
+    public void removeSpamReportListener(SpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeSpamReportListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeSpamReportListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    @Override
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Open a single chat with a given contact and returns a Chat instance.
+     * The parameter contact supports the following formats: MSISDN in national
+     * or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @param contact Contact
+     * @param listener Chat event listener
+     * @return Chat or null
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public Chat openSingleChat(String contact, ChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "openSingleChat entry " + contact);
+        if (api != null) {
+            try {
+                IChat chatIntf = api.openSingleChat(contact, listener);
+                if (chatIntf != null) {
+                    return new Chat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Open a 1-Multi chat with a list of contscs and returns a Chat instance.
+     * The  contact supports the following formats: MSISDN in national
+     * or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @param participants list of Contacts
+     * @param listener Chat event listener
+     * @return Chat or null
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public Chat openMultiChat(List<String> participants, ChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            try {
+                IChat chatIntf = api.openMultiChat(participants, listener);
+                if (chatIntf != null) {
+                    return new Chat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+
+    /**
+     * Open a public account chat with a given contact and returns a Chat instance.
+     * The parameter contact supports the following formats: MSISDN in national
+     * or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @param contact Contact
+     * @param listener Chat Event listener
+     * @return Chat or null
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public PublicAccountChat initPublicAccountChat(String contact, ChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "initPublicAccountChat entry " + contact);
+        if (api != null) {
+            try {
+                IChat chatIntf = api.initPublicAccountChat(contact, listener);
+                if (chatIntf != null) {
+                    return new PublicAccountChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates a group chat with a group of contact and returns a GroupChat
+     * instance. The subject is optional and may be null.
+     *
+     * @param contact List of contacts
+     * @param subject Subject
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public GroupChat initiateGroupChat(Set<String> contacts, String subject, GroupChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "initiateGroupChat entry= " + contacts + " subject =" + subject);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.initiateGroupChat(new ArrayList<String>(contacts), subject, listener);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Sends a message to list of participants
+     *
+     * @param participants List of contacts
+     * @param message Message to be sent
+     * @param listener Group Chat event listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public String sendOne2MultiMessageLargeMode(String message, Set<String> participants,  GroupChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "sendOne2MultiMessage entry= " + participants + " subject =" + message);
+        if (api != null) {
+            try {
+                return api.sendOne2MultiMessage(new ArrayList<String>(participants), message, listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates a group chat with a group of contact and returns a GroupChat
+     * instance. The subject is optional and may be null.
+     *
+     * @param contact List of contacts
+     * @param subject Subject
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public int resendOne2MultiMessage(String msgId, GroupChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "resendOne2MultiMessage entry= " + msgId);
+        if (api != null) {
+            try {
+                return api.resendOne2MultiMessage(msgId, listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates a group chat with a group of contact and returns a GroupChat
+     * instance. The subject is optional and may be null.
+     *
+     * @param contact List of contacts
+     * @param subject Subject
+     * @param listener Chat event listener
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public String sendOne2MultiCloudMessageLargeMode(String message, Set<String> participants,  GroupChatListener listener) throws JoynServiceException, JoynContactFormatException {
+        Logger.i(TAG, "sendOne2MultiCloudMessageLarge entry= " + participants + " subject =" + message);
+        if (api != null) {
+            try {
+                return api.sendOne2MultiCloudMessageLargeMode(new ArrayList<String>(participants), message, listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    /**
+     * Rejoins an existing group chat from its unique chat ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat
+     * @throws JoynServiceException
+     */
+    public GroupChat rejoinGroupChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "rejoinGroupChat entry= " + chatId);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.rejoinGroupChat(chatId);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Rejoins an existing group chat from its unique chat ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat
+     * @throws JoynServiceException
+     */
+    public GroupChat rejoinGroupChatId(String chatId, String rejoinId) throws JoynServiceException {
+        Logger.i(TAG, "rejoinGroupChat entry= " + chatId + "; rejoin id: " + rejoinId);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.rejoinGroupChatId(chatId, rejoinId);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Restarts a previous group chat from its unique chat ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat
+     * @throws JoynServiceException
+     */
+    public GroupChat restartGroupChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "restartGroupChat entry= " + chatId);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.restartGroupChat(chatId);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Restarts a previous group chat from its unique chat ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat
+     * @throws JoynServiceException
+     */
+    public void syncAllGroupChats(GroupChatSyncingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "syncAllGroupChats ");
+        if (api != null) {
+            try {
+                api.syncAllGroupChats(listener);
+            } catch(Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * sync the group info from server use group chat id
+     *
+     * @param chatId Chat ID
+     * @throws JoynServiceException
+     */
+    public void syncGroupChat(String chatId, GroupChatSyncingListener listener)
+            throws JoynServiceException {
+        Logger.i(TAG, "sync group info: " + chatId);
+        if (api != null) {
+            try {
+                api.syncGroupChat(chatId, listener);
+            } catch(Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of single chats in progress
+     *
+     * @return List of chats
+     * @throws JoynServiceException
+     */
+    public Set<Chat> getChats() throws JoynServiceException {
+        Logger.i(TAG, "getChats entry ");
+        if (api != null) {
+            try {
+                Set<Chat> result = new HashSet<Chat>();
+                List<IBinder> chatList = api.getChats();
+                for (IBinder binder : chatList) {
+                    Chat chat = new Chat(IChat.Stub.asInterface(binder));
+                    result.add(chat);
+                }
+                Logger.i(TAG, "getChats returning with  " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a chat in progress with a given contact
+     *
+     * @param contact Contact
+     * @return Chat or null if not found
+     * @throws JoynServiceException
+     */
+    public Chat getChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "getChat entry " + chatId);
+        if (api != null) {
+            try {
+                IChat chatIntf = api.getChat(chatId);
+                if (chatIntf != null) {
+                    return new Chat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a public chat in progress for the provided chatId
+     *
+     * @param chatId Chat Id of the Public chat
+     * @throws JoynServiceException
+     */
+    public Chat getPublicAccountChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "getPublicAccountChat entry " + chatId);
+        if (api != null) {
+            try {
+                IChat chatIntf = api.getPublicAccountChat(chatId);
+                if (chatIntf != null) {
+                    return new PublicAccountChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a single chat from its invitation Intent
+     *
+     * @param intent Invitation Intent
+     * @return Chat or null if not found
+     * @throws JoynServiceException
+     */
+    public Chat getChatFor(Intent intent) throws JoynServiceException {
+        Logger.i(TAG, "getChatFor entry " + intent);
+        if (api != null) {
+            try {
+                String contact = intent.getStringExtra(ChatIntent.EXTRA_CONTACT);
+                if (contact != null) {
+                    return getChat(contact);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of group chats in progress
+     *
+     * @return List of group chat
+     * @throws JoynServiceException
+     */
+    public Set<GroupChat> getGroupChats() throws JoynServiceException {
+        Logger.i(TAG, "getGroupChats entry ");
+        if (api != null) {
+            try {
+                Set<GroupChat> result = new HashSet<GroupChat>();
+                List<IBinder> chatList = api.getGroupChats();
+                for (IBinder binder : chatList) {
+                    GroupChat chat = new GroupChat(IGroupChat.Stub.asInterface(binder));
+                    result.add(chat);
+                }
+                Logger.i(TAG, "getGroupChats returning with " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a group chat in progress from its unique ID
+     *
+     * @param chatId Chat ID
+     * @return Group chat or null if not found
+     * @throws JoynServiceException
+     */
+    public GroupChat getGroupChat(String chatId) throws JoynServiceException {
+        Logger.i(TAG, "getGroupChat entry " + chatId);
+        if (api != null) {
+            try {
+                IGroupChat chatIntf = api.getGroupChat(chatId);
+                if (chatIntf != null) {
+                    return new GroupChat(chatIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a group chat from its invitation Intent
+     *
+     * @param intent Intent invitation
+     * @return Group chat or null if not found
+     * @throws JoynServiceException
+     */
+    public GroupChat getGroupChatFor(Intent intent) throws JoynServiceException {
+        Logger.i(TAG, "getGroupChat entry " + intent);
+        if (api != null) {
+            try {
+                String chatId = intent.getStringExtra(GroupChatIntent.EXTRA_CHAT_ID);
+                if (chatId != null) {
+                    return getGroupChat(chatId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Block messages in group, stack will not notify application about
+     * any received message in this group
+     *
+     * @param chatId chatId of the group
+     * @param flag true means block the message, false means unblock it
+     * @throws JoynServiceException
+     */
+    public void blockGroupMessages(String chatId, boolean flag) throws JoynServiceException {
+        Logger.i(TAG, "blockGroupMessages() entry with chatId: " + chatId + ",flag:" + flag);
+        if (api != null) {
+            try {
+                api.blockGroupMessages(chatId, flag);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a chat invitation listener
+     *
+     * @param listener New chat listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(NewChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addEventListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a chat invitation listener
+     *
+     * @param listener New chat listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(NewChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeEventListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.aidl b/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.aidl
new file mode 100644
index 0000000..4cecc2a
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Chat configuration object
+ */
+parcelable ChatServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.java b/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.java
new file mode 100644
index 0000000..3595a4b
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ChatServiceConfiguration.java
@@ -0,0 +1,357 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Chat service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ChatServiceConfiguration {
+
+    public static final String TAG = "ChatServiceConfiguration";
+    /**
+     * Store and Forward warning
+     */
+    private boolean warnSF;
+
+    /**
+     * Chat timeout
+     */
+    private int chatTimeout;
+
+    /**
+     * Is-composing timeout
+     */
+    private int isComposingTimeout;
+
+    /**
+     * Max participants in a group chat
+     */
+    private int maxGroupChatParticipants;
+
+    /**
+     * Max length of a message in a single chat
+     */
+    private long maxMsgLengthSingleChat;
+
+    /**
+     * Max length of a message in a group chat
+     */
+    private long maxMsgLengthGroupChat;
+
+    /**
+     * Max group chat sessions
+     */
+    private int maxGroupChat;
+
+    /**
+     * SMS fallback
+     */
+    private boolean smsFallback;
+
+    /**
+     * Auto accept mode for single chat
+     */
+    private boolean autoAcceptSingleChat;
+
+    /**
+     * Auto accept mode for group chat
+     */
+    private boolean autoAcceptGroupChat;
+
+    /**
+     * Displayed delivery report
+     */
+    private boolean displayedDeliveryReport;
+
+    /**
+     * Max geoloc label length
+     */
+    private int maxGeolocLabelLength;
+
+    /**
+     * Geoloc expiraion time
+     */
+    private int geolocExpireTime;
+
+
+    /**
+     * Geoloc expiraion time
+     */
+    private boolean mIsImCapAlwaysOn;
+
+    /**
+     * Constructor
+     *
+     * @param chatSF Chat S&F
+     * @param groupChatSF Group chat S&F
+     * @param warnSF Store and Forward warning
+     * @param chatTimeout Chat timeout
+     * @param isComposingTimeout Is-composing timeout
+     * @param maxGroupChatParticipants Max participants in a group chat
+     * @param maxMsgLengthSingleChat Max length of a message in a single chat
+     * @param maxMsgLengthGroupChat Max length of a message in a group chat
+     * @param maxGroupChat Max group chats
+     * @param smsFallback SMS fallback
+     * @param autoAcceptSingleChat Auto accept mode for single chat
+     * @param autoAcceptGroupChat Auto accept mode for group chat
+     * @param displayedDeliveryReport Displayed delivery report
+     * @param maxGeolocLabelLength Max geoloc label length
+     * @param geolocExpireTime Geoloc expiration time
+     * @hide
+     */
+    public ChatServiceConfiguration(boolean warnSF, int chatTimeout, int isComposingTimeout,
+            int maxGroupChatParticipants, long maxMsgLengthSingleChat, long maxMsgLengthGroupChat,
+            int maxGroupChat, boolean smsFallback, boolean autoAcceptSingleChat, boolean autoAcceptGroupChat,
+            boolean displayedDeliveryReport, int maxGeolocLabelLength, int geolocExpireTime, boolean isImCapAlwaysOn) {
+        Logger.i(TAG, "ChatServiceConfiguration entry" + "warnSF " + warnSF + "chatTimeout " + chatTimeout + "isComposingTimeout " + isComposingTimeout +
+                "maxGroupChatParticipants" + maxGroupChatParticipants + "maxMsgLengthSingleChat " + maxMsgLengthSingleChat + "maxMsgLengthGroupChat" + maxMsgLengthGroupChat + "maxGroupChat " + maxGroupChat +
+                "smsFallback " + smsFallback + "autoAcceptSingleChat " + autoAcceptSingleChat + "autoAcceptGroupChat " + autoAcceptGroupChat + "displayedDeliveryReport " + displayedDeliveryReport +
+                "maxGeolocLabelLength " + maxGeolocLabelLength + "geolocExpireTime " + geolocExpireTime + "isImCapAlwaysOn " + isImCapAlwaysOn);
+        this.warnSF = warnSF;
+        this.chatTimeout = chatTimeout;
+        this.isComposingTimeout = isComposingTimeout;
+        this.maxGroupChatParticipants = maxGroupChatParticipants;
+        this.maxMsgLengthSingleChat = maxMsgLengthSingleChat;
+        this.maxMsgLengthGroupChat = maxMsgLengthGroupChat;
+        this.maxGroupChat = maxGroupChat;
+        this.smsFallback = smsFallback;
+        this.autoAcceptSingleChat = autoAcceptSingleChat;
+        this.autoAcceptGroupChat = autoAcceptGroupChat;
+        this.displayedDeliveryReport = displayedDeliveryReport;
+        this.maxGeolocLabelLength = maxGeolocLabelLength;
+        this.geolocExpireTime = geolocExpireTime;
+        this.mIsImCapAlwaysOn = isImCapAlwaysOn;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public ChatServiceConfiguration(Parcel source) {
+        this.chatTimeout = source.readInt();
+        this.isComposingTimeout = source.readInt();
+        this.maxGroupChatParticipants = source.readInt();
+        this.maxMsgLengthSingleChat = source.readLong();
+        this.maxMsgLengthGroupChat = source.readLong();
+        this.smsFallback = source.readInt() != 0;
+        this.autoAcceptSingleChat = source.readInt() != 0;
+        this.autoAcceptGroupChat = source.readInt() != 0;
+        this.displayedDeliveryReport = source.readInt() != 0;
+        this.warnSF = source.readInt() != 0;
+        this.maxGroupChat = source.readInt();
+        this.maxGeolocLabelLength = source.readInt();
+        this.geolocExpireTime = source.readInt();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(chatTimeout);
+        dest.writeInt(isComposingTimeout);
+        dest.writeInt(maxGroupChatParticipants);
+        dest.writeLong(maxMsgLengthSingleChat);
+        dest.writeLong(maxMsgLengthGroupChat);
+        dest.writeInt(smsFallback ? 1 : 0);
+        dest.writeInt(autoAcceptSingleChat ? 1 : 0);
+        dest.writeInt(autoAcceptGroupChat ? 1 : 0);
+        dest.writeInt(displayedDeliveryReport ? 1 : 0);
+        dest.writeInt(warnSF ? 1 : 0);
+        dest.writeInt(maxGroupChat);
+        dest.writeInt(maxGeolocLabelLength);
+        dest.writeInt(geolocExpireTime);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<ChatServiceConfiguration> CREATOR
+            = new Parcelable.Creator<ChatServiceConfiguration>() {
+        public ChatServiceConfiguration createFromParcel(Parcel source) {
+            return new ChatServiceConfiguration(source);
+        }
+
+        public ChatServiceConfiguration[] newArray(int size) {
+            return new ChatServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Does the UX should alert the user that messages are handled differently when
+     * the Store and Forward functionality is involved. It returns True if user should
+     * be informed when sending message to offline user.
+     *
+     * @return Boolean
+     */
+    public boolean isImWarnSf() {
+        return warnSF;
+    }
+
+    /**
+     * Returns the time after inactive chat session could be closed
+     *
+     * @return Timeout in seconds
+     */
+    public int getChatSessionTimeout() {
+        return chatTimeout;
+    }
+
+    /**
+     * Returns the Is-composing timeout value
+     *
+     * @return Timeout in seconds
+     */
+    public int getIsComposingTimeout() {
+        return isComposingTimeout;
+    }
+
+    /**
+     * Returns maximum number of participants in a group chat
+     *
+     * @return Number
+     */
+    public int getGroupChatMaxParticipantsNumber() {
+        return maxGroupChatParticipants;
+    }
+
+    /**
+     * Return maximum length of a single chat message
+     *
+     * @return Number of bytes
+     */
+    public long getSingleChatMessageMaxLength() {
+        return maxMsgLengthSingleChat;
+    }
+
+    /**
+     * Return maximum length of a group chat message
+     *
+     * @return Number of bytes
+     */
+    public long getGroupChatMessageMaxLength() {
+        return maxMsgLengthGroupChat;
+    }
+
+    /**
+     * Returns the max number of simultaneous group chats
+     *
+     * @return Number
+     */
+    public int getMaxGroupChats() {
+        return maxGroupChat;
+    }
+
+    /**
+     * Does the UX proposes automatically a SMS fallback in case of chat failure. It
+     * returns True if SMS fallback procedure is activated, else returns False.
+     *
+     * @return Boolean
+     */
+    public boolean isSmsFallback() {
+        return smsFallback;
+    }
+
+    /**
+     * Does auto accept mode activated for single chat
+     *
+     * @return Boolean
+     */
+    public boolean isChatAutoAcceptMode() {
+        return autoAcceptSingleChat;
+    }
+
+    /**
+     * Does auto accept mode activated for group chat
+     *
+     * @return Boolean
+     */
+    public boolean isGroupChatAutoAcceptMode() {
+        return autoAcceptGroupChat;
+    }
+
+    /**
+     * Does displayed delivery report activated on received chat messages
+     *
+     * @return Boolean
+     */
+    public boolean isDisplayedDeliveryReport() {
+        return displayedDeliveryReport;
+    }
+
+    /**
+     * Activates or deactivates the displayed delivery report on received chat messages
+     *
+     * @param state State
+     */
+    public void setDisplayedDeliveryReport(boolean state) {
+        this.displayedDeliveryReport = state;
+    }
+
+    /**
+     * Return maximum length of a geoloc label
+     *
+     * @return Number of bytes
+     */
+    public int getGeolocLabelMaxLength() {
+        return maxGeolocLabelLength;
+    }
+
+    /**
+     * Get geoloc expiration time
+     *
+     * @return Time in seconds
+     */
+    public int getGeolocExpirationTime() {
+        return geolocExpireTime;
+    }
+
+    /**
+     * Returns IM always on or not
+     *
+     * @return boolean value
+     */
+    public boolean isImCapAlwaysOn() {
+        return mIsImCapAlwaysOn;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ConferenceEventData.aidl b/src/java/org/gsma/joyn/chat/ConferenceEventData.aidl
new file mode 100644
index 0000000..33a8900
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ConferenceEventData.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Chat message object
+ */
+parcelable ConferenceEventData;
diff --git a/src/java/org/gsma/joyn/chat/ConferenceEventData.java b/src/java/org/gsma/joyn/chat/ConferenceEventData.java
new file mode 100644
index 0000000..97baeb9
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ConferenceEventData.java
@@ -0,0 +1,352 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Chat message
+ *
+ */
+public class ConferenceEventData implements Parcelable {
+    public static final String TAG = "TAPI-ConferenceEventData";
+
+    public static final class State {
+        public static final String FULL = "full";
+        public static final String PARTIAL = "partial";
+    }
+
+    private String state = "";
+
+    private String subject = "";
+
+    private String chairman = "";
+
+    private List<ConferenceUser> users;
+
+    public String getState() {
+        return state;
+    }
+
+    public void setState(String state) {
+        this.state = state;
+    }
+
+    public String getSubject() {
+        return subject;
+    }
+
+    public void setSubject(String subject) {
+        this.subject = subject;
+    }
+
+    public String getChairman() {
+        return chairman;
+    }
+
+    public void setChairman(String chairman) {
+        this.chairman = chairman;
+    }
+
+    public List<ConferenceUser> getUsers() {
+        return users;
+    }
+
+    public void setUsers(List<ConferenceUser> users) {
+        this.users = users;
+    }
+
+    public ConferenceEventData(
+            String state,
+            String subject,
+            String chairman,
+            List<ConferenceUser> users) {
+        this.state = state;
+        this.subject = subject;
+        this.chairman = chairman;
+        this.users = users;
+    }
+
+    public ConferenceEventData(Parcel source) {
+        this.state = source.readString();
+        this.subject = source.readString();
+        this.chairman = source.readString();
+
+        if (source.dataAvail() > 0) {
+            int size = source.readInt();
+            this.users = new ArrayList<ConferenceUser>(size);
+            for (int i = 0; i < size; i++ ) {
+                ConferenceUser user = (ConferenceUser)source.readParcelable(null);
+                this.users.add(user);
+            }
+        }
+    }
+
+    public ConferenceEventData() {
+    }
+
+    public void writeToParcel(Parcel dest, int arg1) {
+        dest.writeString(state);
+        dest.writeString(subject);
+        dest.writeString(chairman);
+        if (users != null) {
+            dest.writeInt(users.size());
+            for (ConferenceUser user : users) {
+                dest.writeParcelable(user, 0);
+            }
+        }
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<ConferenceEventData> CREATOR
+            = new Parcelable.Creator<ConferenceEventData>() {
+        public ConferenceEventData createFromParcel(Parcel source) {
+            return new ConferenceEventData(source);
+        }
+
+        public ConferenceEventData[] newArray(int size) {
+            return new ConferenceEventData[size];
+        }
+    };
+
+    public static class ConferenceUser implements Parcelable{
+        /**
+         * User State
+         */
+        private String state;
+
+        /**
+         * Status of the user
+         */
+        private String status;
+
+        /**
+         * disconnection method
+         */
+        private String method;
+
+        /**
+         * role of the user
+         */
+        private String role;
+
+        /**
+         * etype of the user
+         */
+        private String etype;
+
+        /**
+         * displayname of the user
+         */
+        private String displayName;
+
+        /**
+         * entity of the user
+         */
+        private String entity;
+
+
+        /**
+         * Constructor for outgoing message
+         *
+         * @param entity entity
+         * @param state state
+         * @param status status
+         * @param method method
+         * @param role role
+         * @param etype etype
+         * @param displayname displayname
+         *
+         */
+        public ConferenceUser(
+                String entity,
+                String state,
+                String status,
+                String method,
+                String role,
+                String etype,
+                String displayName) {
+            Logger.i(TAG, "ConferenceUser entry" +
+                    "entity=" + entity + " state=" + state + " status=" + status +
+                    " method=" + method + " role=" + role + " etype=" + etype +
+                    " displayName=" + displayName);
+            this.entity = entity;
+            this.state = state;
+            this.status = status;
+            this.method = method;
+            this.role = role;
+            this.etype = etype;
+            this.displayName = displayName;
+        }
+
+        /**
+         * Constructor
+         *
+         * @param source Parcelable source
+         * @hide
+         */
+        public ConferenceUser(Parcel source) {
+            this.entity = source.readString();
+            this.state = source.readString();
+            this.status = source.readString();
+            this.method = source.readString();
+            this.role = source.readString();
+            this.etype = source.readString();
+            this.displayName = source.readString();
+        }
+
+
+        /**
+         * Write parcelable object
+         *
+         * @param dest The Parcel in which the object should be written
+         * @param flags Additional flags about how the object should be written
+         * @hide
+         */
+        public void writeToParcel(Parcel dest, int flags) {
+            dest.writeString(entity);
+            dest.writeString(state);
+            dest.writeString(status);
+            dest.writeString(method);
+            dest.writeString(role);
+            dest.writeString(etype);
+            dest.writeString(displayName);
+        }
+
+        /**
+         * Parcelable creator
+         *
+         * @hide
+         */
+        public static final Parcelable.Creator<ConferenceUser> CREATOR
+            = new Parcelable.Creator<ConferenceUser>() {
+            public ConferenceUser createFromParcel(Parcel source) {
+                return new ConferenceUser(source);
+            }
+
+            public ConferenceUser[] newArray(int size) {
+                return new ConferenceUser[size];
+            }
+        };
+
+        /**
+         * Returns the role
+         *
+         * @return role
+         */
+        public String getRole() {
+            return role;
+        }
+
+        /**
+         * Returns the state
+         *
+         * @return state
+         */
+        public String getState() {
+            return state;
+        }
+
+        /**
+         * Returns the status
+         *
+         * @return status
+         */
+        public String getStatus() {
+            return status;
+        }
+
+        /**
+         * Returns the method
+         *
+         * @return method
+         */
+        public String getDisconnectMethod() {
+            return method;
+        }
+
+        /**
+         * Returns the etype
+         *
+         * @return etype
+         */
+        public String getEtype() {
+            return etype;
+        }
+
+        /**
+         * Returns the entity
+         *
+         * @return entity
+         */
+        public String getEntity() {
+            return entity;
+        }
+
+        /**
+         * Returns the display name
+         *
+         * @return displayName
+         */
+        public String getDisplayName() {
+            return displayName;
+        }
+
+        @Override
+        public int describeContents() {
+            // TODO Auto-generated method stub
+            return 0;
+        }
+
+        public static class State {
+            public final static String FULL = "full";
+            public final static String PARTIAL = "partial";
+            public final static String DELETED = "deleted";
+        }
+        public static class Status {
+            public final static String CONNECTED = "connected";
+            public final static String DISCONNECTED = "disconnected";
+            public final static String PENDING = "pending";
+        }
+        public static class Method {
+            public final static String BOOTED = "booted";
+            public final static String DEPARTED = "departed";
+        }
+        public static class Role {
+            public final static String CHAIRMAN = "chairman";
+            public final static String PARTICIPANT = "participant";
+        }
+    }
+
+    @Override
+    public int describeContents() {
+        // TODO Auto-generated method stub
+        return 0;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/ConferenceEventData/ConferenceUser.aidl b/src/java/org/gsma/joyn/chat/ConferenceEventData/ConferenceUser.aidl
new file mode 100644
index 0000000..a1d4c2e
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ConferenceEventData/ConferenceUser.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat.ConferenceEventData;
+
+/**
+ * Chat message object
+ */
+parcelable ConferenceUser;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/Geoloc.aidl b/src/java/org/gsma/joyn/chat/Geoloc.aidl
new file mode 100644
index 0000000..d5128bb
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/Geoloc.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Geoloc object
+ */
+parcelable Geoloc;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/Geoloc.java b/src/java/org/gsma/joyn/chat/Geoloc.java
new file mode 100644
index 0000000..b5e64ab
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/Geoloc.java
@@ -0,0 +1,239 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.io.Serializable;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Geolocation push info
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class Geoloc implements Parcelable, Serializable {
+    private static final long serialVersionUID = 0L;
+
+    public static final String TAG = "TAPI-Geoloc";
+    /**
+     * Label associated to the geolocation
+     */
+    private String label;
+
+    /**
+     * Latitude
+     */
+    private double latitude;
+
+    /**
+     * Longitude
+     */
+    private double longitude;
+
+    /**
+     * Expiration date of the geolocation
+     */
+    private long expiration = 0L;
+
+    /**
+     * Accuracy (in meters)
+     */
+    private float accuracy = 0.0f;
+
+    /**
+     * Constructor
+     *
+     * @param label Label
+     * @param latitude Latitude
+     * @param longitude Longitude
+     * @param expiration Expiration time
+     * @hide
+     */
+    public Geoloc(String label, double latitude, double longitude, long expiration) {
+        Logger.i(TAG, "Geoloc entry" + "label=" + label + " latitude=" + latitude + " longitude=" + longitude +
+                " expiration=" + expiration);
+        this.label = label;
+        this.latitude = latitude;
+        this.longitude = longitude;
+        this.expiration = expiration;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param label Label
+     * @param latitude Latitude
+     * @param longitude Longitude
+     * @param expiration Expiration date
+     * @param accuracy Accuracy
+     * @hide
+     */
+    public Geoloc(String label, double latitude, double longitude, long expiration, float accuracy) {
+        this(label, latitude, longitude, expiration);
+        Logger.i(TAG, "accuracy=" + accuracy);
+        this.accuracy = accuracy;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public Geoloc(Parcel source) {
+        this.label = source.readString();
+        this.latitude = source.readDouble();
+        this.longitude = source.readDouble();
+        this.expiration = source.readLong();
+        this.accuracy = source.readFloat();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(label);
+        dest.writeDouble(latitude);
+        dest.writeDouble(longitude);
+        dest.writeLong(expiration);
+        dest.writeFloat(accuracy);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<Geoloc> CREATOR = new Parcelable.Creator<Geoloc>() {
+        public Geoloc createFromParcel(Parcel source) {
+            return new Geoloc(source);
+        }
+
+        public Geoloc[] newArray(int size) {
+            return new Geoloc[size];
+        }
+    };
+
+    /**
+     * Returns the label
+     *
+     * @return Label
+     */
+    public String getLabel() {
+        return label;
+    }
+
+    /**
+     * Set the label
+     *
+     * @param label Label
+     */
+    public void setLabel(String label) {
+        this.label = label;
+    }
+
+    /**
+     * Returns the latitude
+     *
+     * @return Latitude
+     */
+    public double getLatitude() {
+        return latitude;
+    }
+
+    /**
+     * Set the latitude
+     *
+     * @param latitude Latitude
+     */
+    public void setLatitude(double latitude) {
+        this.latitude = latitude;
+    }
+
+    /**
+     * Returns the longitude
+     *
+     * @return Longitude
+     */
+    public double getLongitude() {
+        return longitude;
+    }
+
+    /**
+     * Set the longitude
+     *
+     * @param longitude Longitude
+     */
+    public void setLongitude(double longitude) {
+        this.longitude = longitude;
+    }
+
+    /**
+     * Returns the expiration date of the geolocation
+     *
+     * @return Expiration date. 0 means no expiration date has been defined.
+     */
+    public long getExpiration() {
+        return expiration;
+    }
+
+    /**
+     * Set the expiration date of the geolocation
+     *
+     * @param expiration Expiration
+     */
+    public void setExpiration(long expiration) {
+        this.expiration = expiration;
+    }
+
+    /**
+     * Returns the accuracy
+     *
+     * @return Accuracy in meters. 0 means no accuracy has been defined.
+     */
+    public float getAccuracy() {
+        return accuracy;
+    }
+
+    /**
+     * Set the accuracy
+     *
+     * @param accuracy Accuracy in meters
+     */
+    public void setAcuracy(float accuracy) {
+        this.accuracy = accuracy;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/GeolocMessage.aidl b/src/java/org/gsma/joyn/chat/GeolocMessage.aidl
new file mode 100644
index 0000000..2636449
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GeolocMessage.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.chat;
+
+/**
+ * Geoloc message object
+ */
+parcelable GeolocMessage;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/GeolocMessage.java b/src/java/org/gsma/joyn/chat/GeolocMessage.java
new file mode 100644
index 0000000..5f9bfe0
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GeolocMessage.java
@@ -0,0 +1,123 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.Date;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Geoloc push message
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GeolocMessage extends ChatMessage implements Parcelable {
+    /**
+     * MIME type
+     */
+    public final static String MIME_TYPE = "application/geoloc";
+
+    public static final String TAG = "TAPI-GeolocMessage";
+    /**
+     * Geoloc info
+     */
+    private Geoloc geoloc = null;
+
+    /**
+     * Constructor for outgoing message
+     *
+     * Constructor for outgoing message
+     *
+     * @param messageId Message Id
+     * @param contact Contact
+     * @param geoloc Geolocation info
+     * @param receiptAt Receipt date
+     * @param displayedReportRequested Flag indicating if a displayed report is requested
+     * @hide
+     */
+    public GeolocMessage(String messageId, String remote, Geoloc geoloc, Date receiptAt, boolean imdnDisplayedRequested) {
+        super(messageId, remote, null, receiptAt, imdnDisplayedRequested, null);
+        Logger.i(TAG, "GeolocMessage entry geoloc =" + geoloc);
+        this.geoloc = geoloc;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public GeolocMessage(Parcel source) {
+        super(source);
+
+        this.geoloc = new Geoloc(source);
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        super.writeToParcel(dest, flags);
+
+        geoloc.writeToParcel(dest, flags);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<GeolocMessage> CREATOR
+            = new Parcelable.Creator<GeolocMessage>() {
+        public GeolocMessage createFromParcel(Parcel source) {
+            return new GeolocMessage(source);
+        }
+
+        public GeolocMessage[] newArray(int size) {
+            return new GeolocMessage[size];
+        }
+    };
+
+    /**
+     * Get geolocation info
+     *
+     * @return Geoloc object
+     * @see Geoloc
+     */
+    public Geoloc getGeoloc() {
+        return geoloc;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/GroupChat.java b/src/java/org/gsma/joyn/chat/GroupChat.java
new file mode 100644
index 0000000..f3634c7
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GroupChat.java
@@ -0,0 +1,696 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.ft.FileTransfer;
+import org.gsma.joyn.ft.FileTransferListener;
+import org.gsma.joyn.ft.IFileTransfer;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * Group chat
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GroupChat {
+
+    public static final String TAG = "TAPI-GroupChat";
+    /**
+     * Group chat state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Chat invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Chat invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Chat is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Chat has been terminated
+         */
+        public final static int TERMINATED = 4;
+
+        /**
+         * Chat has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Chat has been closed by the user. A user which has closed a
+         * conversation voluntary can't rejoin it afterward.
+         */
+        public final static int CLOSED_BY_USER = 6;
+
+        /**
+         * Chat has failed
+         */
+        public final static int FAILED = 7;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the group chat
+     */
+    public static class Direction {
+        /**
+         * Incoming chat
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing chat
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * State of the group chat conference Notify
+     */
+    public static class ConfState {
+
+        public final static String FULL = "full";
+        public final static String PARTIAL = "partial";
+    }
+
+    /**
+     * Status of group chat addparticipants
+     */
+    public static class ParticipantStatus {
+        /**
+         * Successfuly added
+         */
+        public static final int SUCCESS = 0;
+
+        /**
+         * Nota added
+         */
+        public static final int FAIL = 1;
+    }
+
+     /**
+     * Direction of the group chat
+     */
+    public static class MessageState {
+        /**
+         * Message being sent
+         */
+        public static final int SENDING = 0;
+
+        /**
+         * Message sent
+         */
+        public static final int SENT = 1;
+
+        /**
+         * Message delivered to remote
+         */
+        public static final int DELIVERED = 2;
+
+        /**
+         * Message sending failed
+         */
+        public static final int FAILED = 3;
+    }
+
+     /**
+     * Direction of the group chat
+     */
+    public static class ErrorCodes {
+        /**
+         * Message being sent
+         */
+        public static final int TIMEOUT = 1;
+
+        /**
+         * Message sent
+         */
+        public static final int UNKNOWN = 2;
+
+        /**
+         * Message delivered to remote
+         */
+        public static final int INTERNAL_EROR = 3;
+
+        /**
+         * Message sending failed
+         */
+        public static final int OUT_OF_SIZE = 4;
+    }
+
+    /**
+     * Error codes for Failed reason
+     */
+    public static class ReasonCode {
+        /**
+         * successful
+         */
+        public static final int SUCCESSFUL = 1;
+
+        /**
+         * Unknown
+         */
+        public static final int UNKNOWN = 2;
+
+        /**
+         * internal error
+         */
+        public static final int INTERNAL_ERROR = 3;
+
+        /**
+         * Time out
+         */
+        public static final int TIME_OUT = 4;
+    }
+
+    /**
+     * Group chat error
+     */
+    public static class Error {
+        /**
+         * Group chat has failed
+         */
+        public final static int CHAT_FAILED = 0;
+
+        /**
+         * Group chat invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        /**
+         * Chat conversation not found
+         */
+        public final static int CHAT_NOT_FOUND = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Group chat interface
+     */
+    private IGroupChat chatInf;
+
+    /**
+     * Constructor
+     *
+     * @param chatIntf Group chat interface
+     */
+    GroupChat(IGroupChat chatIntf) {
+        this.chatInf = chatIntf;
+    }
+
+    /**
+     * Returns the chat ID
+     *
+     * @return Chat ID
+     * @throws JoynServiceException
+     */
+    public String getChatId() throws JoynServiceException {
+        Logger.i(TAG, "getChatId entry " + chatInf);
+        try {
+            return chatInf.getChatId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the chat ID
+     *
+     * @return Session ID
+     * @throws JoynServiceException
+     */
+    public String getChatSessionId() throws JoynServiceException {
+        Logger.i(TAG, "getChatSessionId entry " + chatInf);
+        try {
+            return chatInf.getChatSessionId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the group chat (incoming or outgoing)
+     *
+     * @return Direction
+     * @see GroupChat.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        Logger.i(TAG, "getDirection entry " + chatInf);
+        try {
+            return chatInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the group chat
+     *
+     * @return State
+     * @see GroupChat.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        Logger.i(TAG, "getState() entry " + chatInf);
+        try {
+            return chatInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the group chat
+     *
+     * @param messageId Message Id
+     * @return State
+     * @see GroupChat.State
+     * @throws JoynServiceException
+     */
+    public int getMessageState(String messageId) throws JoynServiceException {
+        Logger.i(TAG, "getState() entry " + chatInf + "Message Id = " + messageId);
+        try {
+            //return chatInf.getState();
+            return chatInf.getMessageState(messageId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact() entry " + chatInf);
+        try {
+            return chatInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the subject of the group chat
+     *
+     * @return Subject
+     * @throws JoynServiceException
+     */
+    public String getSubject() throws JoynServiceException {
+        Logger.i(TAG, "getSubject() entry " + chatInf);
+        try {
+            return chatInf.getSubject();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the list of connected participants. A participant is identified
+     * by its MSISDN in national or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @return List of participants
+     * @throws JoynServiceException
+     */
+    public Set<String> getParticipants() throws JoynServiceException {
+        Logger.i(TAG, "getParticipants() entry " + chatInf);
+        try {
+            return new HashSet<String>(chatInf.getParticipants());
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the list of connected participants. A participant is identified
+     * by its MSISDN in national or international format, SIP address, SIP-URI or Tel-URI.
+     *
+     * @return List of participants
+     * @throws JoynServiceException
+     */
+    public Set<String> getAllParticipants() throws JoynServiceException {
+        Logger.i(TAG, "getAllParticipants() entry " + chatInf);
+        try {
+            return new HashSet<String>(chatInf.getAllParticipants());
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts chat invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        Logger.i(TAG, "acceptInvitation() entry " + chatInf);
+        try {
+            chatInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects chat invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        Logger.i(TAG, "rejectInvitation() entry " + chatInf);
+        try {
+            chatInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a text message to the group
+     *
+     * @param text Message
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendMessage(String text) throws JoynServiceException {
+        Logger.i(TAG, "sendMessage() entry " + text);
+        try {
+            return chatInf.sendMessage(text);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a emoticons message to the group
+     *
+     * @param text Message
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendEmoticonsMessage(String text) throws JoynServiceException {
+        Logger.i(TAG, "sendEmoticonsMessage() entry " + text);
+        try {
+            return chatInf.sendEmoticonsMessage(text);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a geoloc message
+     *
+     * @param geoloc Geoloc info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+    public String sendGeoloc(Geoloc geoloc) throws JoynServiceException {
+        Logger.i(TAG, "sendGeoloc() entry " + geoloc);
+        try {
+            return chatInf.sendGeoloc(geoloc);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Transfers a file to participants. The parameter filename contains the complete
+     * path of the file to be transferred.
+     *
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer sendFile(String filename, String fileicon, FileTransferListener listener) throws JoynServiceException {
+        Logger.i(TAG, "sendFile() entry filename=" + filename + " fileicon=" + fileicon + " listener =" + listener);
+        try {
+            IFileTransfer ftIntf = chatInf.sendFile(filename, fileicon, listener);
+            if (ftIntf != null) {
+                return new FileTransfer(ftIntf);
+            } else {
+                return null;
+            }
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends an Is-composing event. The status is set to true when typing
+     * a message, else it is set to false.
+     *
+     * @param status Is-composing status
+     * @throws JoynServiceException
+     */
+    public void sendIsComposingEvent(boolean status) throws JoynServiceException {
+        Logger.i(TAG, "sendIsComposingEvent() entry " + status);
+        try {
+            chatInf.sendIsComposingEvent(status);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * @param msgId message Id of message
+     * @throws JoynServiceException
+     */
+    public int resendMessage(String msgId) throws JoynServiceException  {
+        Logger.i(TAG, "resendMessage msgId " + msgId);
+        try {
+            return chatInf.resendMessage(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a displayed delivery report for a given message ID
+     *
+     * @param msgId Message ID
+     * @return State of the message
+     * @throws JoynServiceException
+     */
+    public void sendDisplayedDeliveryReport(String msgId) throws JoynServiceException {
+        Logger.i(TAG, "sendDisplayedDeliveryReport() entry " + msgId);
+        try {
+            chatInf.sendDisplayedDeliveryReport(msgId);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds participants to a group chat
+     *
+     * @param participants List of participants
+     * @throws JoynServiceException
+     */
+    public void addParticipants(Set<String> participants) throws JoynServiceException {
+        Logger.i(TAG, "addParticipants() entry " + participants);
+        try {
+            chatInf.addParticipants(new ArrayList<String>(participants));
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the max number of participants in the group chat. This limit is
+     * read during the conference event subscription and overrides the provisioning
+     * parameter.
+     *
+     * @return Number
+     * @throws JoynServiceException
+     */
+    public int getMaxParticipants() throws JoynServiceException {
+        Logger.i(TAG, "getMaxParticipants() entry ");
+        try {
+            return chatInf.getMaxParticipants();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Quits a group chat conversation. The conversation will continue between
+     * other participants if there are enough participants.
+     *
+     * @throws JoynServiceException
+     */
+    public void quitConversation() throws JoynServiceException {
+        Logger.i(TAG, "quitConversation() entry ");
+        try {
+            chatInf.quitConversation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on chat events
+     *
+     * @param listener Group chat event listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(GroupChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener() entry " + listener);
+
+        try {
+            chatInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener on chat events
+     *
+     * @param listener Group chat event listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(GroupChatListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener() entry " + listener);
+        try {
+            chatInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Set the new chairman(chairman privilege).
+     *
+     * @param newChairman new chairman of the group, should be a group member
+     * @throws JoynServiceException
+     */
+    public void transferChairman(String newChairman) throws JoynServiceException {
+        Logger.i(TAG, "transferChairman() entry " + newChairman);
+        try {
+            chatInf.transferChairman(newChairman);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * modify subject of group(chairman privilege).
+     *
+     * @param newSubject new subject string
+     * @throws JoynServiceException
+     */
+    public void modifySubject(String newSubject) throws JoynServiceException {
+        Logger.i(TAG, "modifySubject() entry " + newSubject);
+        try {
+            chatInf.modifySubject(newSubject);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * modify nickname of participant.
+     *
+     * @param newNickname new nick name of participant
+     * @throws JoynServiceException
+     */
+    public void modifyMyNickName(String newNickname) throws JoynServiceException {
+        Logger.i(TAG, "modifyMyNickName() entry " + newNickname);
+        try {
+            chatInf.modifyMyNickName(newNickname);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * remove set of participants(chairman privilege).
+     *
+     * @param participants list of participants to be removed
+     * @throws JoynServiceException
+     */
+    public void removeParticipants(List<String> participants) throws JoynServiceException {
+        Logger.i(TAG, "removeParticipants() entry " + participants);
+        try {
+            chatInf.removeParticipants(participants);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * chairman abort(leave) the group, Group session will abort
+     *
+     * @throws JoynServiceException
+     */
+    public void abortConversation() throws JoynServiceException {
+        Logger.i(TAG, "abortConversation() entry ");
+        try {
+            chatInf.abortConversation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * If myself chairman of the group
+     *
+     * @return true/false
+     * @throws JoynServiceException
+     */
+    public boolean isMeChairman() throws JoynServiceException {
+        Logger.i(TAG, "isMeChairman() entry ");
+        boolean flag = false;
+        try {
+            flag = chatInf.isMeChairman();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+        return flag;
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/GroupChatIntent.java b/src/java/org/gsma/joyn/chat/GroupChatIntent.java
new file mode 100644
index 0000000..b695060
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GroupChatIntent.java
@@ -0,0 +1,74 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+/**
+ * Intent for group chat conversation
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GroupChatIntent {
+    /**
+     * Broadcast action: a new group chat invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_CHAT_ID} containing the unique ID of the chat conversation.
+     * <li> {@link #EXTRA_SUBJECT} containing the subject associated to the conversation.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.chat.action.NEW_GROUP_CHAT";
+
+    /**
+     * Broadcast action: a new group chat invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CHAT_ID} containing the unique ID of the chat conversation.
+     * <li> {sessionId} containing the session Id of the group chat.
+     * </ul>
+     */
+    public final static String ACTION_SESSION_REPLACED = "org.gsma.joyn.chat.action.REPLACED_GROUP_CHAT";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation (extracted from the SIP address)
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the chat conversation
+     */
+    public final static String EXTRA_CHAT_ID = "chatId";
+
+    /**
+     * Subject associated to the conversation (optional)
+     */
+    public final static String EXTRA_SUBJECT = "subject";
+
+    /**
+     * Session identitiy to the conversation
+     */
+    public final static String EXTRA_SESSION_IDENTITY = "sessionIdentity";
+}
diff --git a/src/java/org/gsma/joyn/chat/GroupChatListener.java b/src/java/org/gsma/joyn/chat/GroupChatListener.java
new file mode 100644
index 0000000..4908cdc
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GroupChatListener.java
@@ -0,0 +1,301 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+import java.util.List;
+import org.gsma.joyn.chat.ConferenceEventData.ConferenceUser;
+
+
+/**
+ * Group chat event listener
+
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class GroupChatListener extends IGroupChatListener.Stub {
+    /**
+     * Callback called when the session is well established and messages
+     * may be exchanged with the group of participants
+     */
+    public abstract void onSessionStarted();
+
+    /**
+     * Callback called when the session has been aborted or terminated
+     */
+    public abstract void onSessionAborted();
+
+    /**
+     * Callback called when the session has failed
+     *
+     * @param error Error
+     * @see GroupChat.Error
+     */
+    public abstract void onSessionError(int error);
+
+    /**
+     * Callback called when a new message has been received
+     *
+     * @param message New chat message
+     * @see ChatMessage
+     */
+    public abstract void onNewMessage(ChatMessage message);
+
+    /**
+     * Callback called when a new geoloc has been received
+     *
+     * @param message Geoloc message
+     * @see GeolocMessage
+     */
+    public abstract void onNewGeoloc(GeolocMessage message);
+
+    /**
+     * Callback called when a message has been delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageDelivered(String msgId);
+
+    /**
+     * Callback called when a message has been displayed by the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageDisplayed(String msgId);
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     */
+    public abstract void onReportMessageFailed(String msgId);
+
+    /**
+     * Callback called when an Is-composing event has been received. If the
+     * remote is typing a message the status is set to true, else it is false.
+     *
+     * @param contact Contact
+     * @param status Is-composing status
+     */
+    public abstract void onComposingEvent(String contact, boolean status);
+
+    /**
+     * Callback called when a new participant has joined the group chat
+     *
+     * @param contact Contact
+     * @param contactDisplayname Remote Contact display name
+     */
+    public abstract void onParticipantJoined(String contact, String contactDisplayname);
+
+    /**
+     * Callback called when a participant has left voluntary the group chat
+     *
+     * @param contact Contact
+     */
+    public abstract void onParticipantLeft(String contact);
+
+    /**
+     * Callback called when a participant is disconnected from the group chat
+     *
+     * @param contact Contact
+     */
+    public abstract void onParticipantDisconnected(String contact);
+
+    /**
+     * Callback called when the session has been aborted by chairman
+     */
+    public void onSessionAbortedbyChairman() {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has been delivered to the remote
+     *
+     * @param msgId Message ID
+     * @param contact Remote contact
+     */
+    public void onReportMessageDeliveredContact(String msgId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has been displayed by the remote
+     *
+     * @param msgId Message ID
+     * @param contact Remote contact
+     */
+    public void onReportMessageDisplayedContact(String msgId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     * @param contact Remote contact
+     */
+    public void onReportMessageFailedContact(String msgId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has failed to be delivered to the remote
+     *
+     * @param msgId Message ID
+     * @param errtype Error cause for failure
+     * @param statusCode Status code associated with failure
+     */
+    public void onReportFailedMessage(String msgId, int errtype, String statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a message has been sent to remote
+     *
+     * @param msgId Message ID
+     */
+    public void onReportSentMessage(String msgId) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when a group chat is dissolved
+     *
+     */
+    public void onGroupChatDissolved() {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called to inform the result of invite participants
+     *
+     * @param errtype Error cause for failure
+     * @param statusCode Status code associated with failure
+     */
+    public void onInviteParticipantsResult(int errType, String statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when new chairman is successfully changed by current chairman
+     * (Callback only received by chairman)
+     * @param errType errorType
+     */
+    public void onSetChairmanResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when chairman is changed by current chairman
+     * (Callback received by every user of group)
+     * @param newChairman new chairman
+     */
+    public void onChairmanChanged(String newChairman) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when subject is modified
+     * (Callback only received by chairman)
+     * @param errType errorType
+     */
+    public void onModifySubjectResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when subject is changed
+     * (Callback received by every user of group)
+     * @param newSubject new subject
+     */
+    public void onSubjectChanged(String newSubject) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when nickname is modified
+     * (callback received only by user who modified the nickname)
+     * @param errType errorType
+     */
+    public void onModifyNickNameResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when nickname is changed
+     * (callback received by every group member)
+     * @param contact contact who modified nick name
+     */
+    public void onNickNameChanged(String contact, String newNickName) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when participants are removed
+     * (Callback only received by chairman)
+     * @param errType errorType
+     * @param statusCode status Code
+     * @param participant participant removed
+     */
+    public void onRemoveParticipantResult(int errType, int statusCode, String participant) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called participant is kicked out(removed) by chairman
+     * (Callback received by removed participant)
+     * @param from who kicked out
+     */
+    public void onReportMeKickedOut(String from) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called participant is kicked out(removed) by chairman
+     * (Callback received by other than removed participants)
+     * @param contact kicked out participant
+     */
+    public void onReportParticipantKickedOut(String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called chairman has successfully aborted the group
+     * (Callback only received by chairman)
+     * @param errType errorType
+     */
+    public void onAbortConversationResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called user has left the group successfully
+     * (Callback received by user who left the group)
+     * @param errType errorType
+     */
+    public void onQuitConversationResult(int errType, int statusCode) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when SIP notify is received in group conference
+     * (Callback received for add participant, remove participant, User left, nick name change)
+     * @param confState conference state
+     */
+    public void onConferenceNotify(String confState, List<ConferenceUser> users) {
+        // default implementation for TAPI extension
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/GroupChatSyncingListener.java b/src/java/org/gsma/joyn/chat/GroupChatSyncingListener.java
new file mode 100644
index 0000000..2516e20
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/GroupChatSyncingListener.java
@@ -0,0 +1,21 @@
+package org.gsma.joyn.chat;
+
+import java.util.List;
+
+/**
+ * Group chat event listener
+ */
+public abstract class GroupChatSyncingListener extends IGroupChatSyncingListener.Stub {
+    /**
+     */
+    public abstract void onSyncStart(int goupCount);
+
+    /**
+     */
+    public abstract void onSyncInfo(String chatId, ConferenceEventData info);
+
+    /**
+     */
+    public abstract void onSyncDone(int result);
+
+}
diff --git a/src/java/org/gsma/joyn/chat/IChat.aidl b/src/java/org/gsma/joyn/chat/IChat.aidl
new file mode 100644
index 0000000..245b2c7
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IChat.aidl
@@ -0,0 +1,60 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.IChatListener;
+import org.gsma.joyn.chat.ISpamReportListener;
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Chat interface
+ */
+interface IChat {
+	String getRemoteContact();
+	
+
+	String sendMessage(in String message);
+	
+	void sendDisplayedDeliveryReport(in String msgId);
+	
+	void sendIsComposingEvent(in boolean status);
+	
+	void addEventListener(in IChatListener listener);
+	
+	void removeEventListener(in IChatListener listener);
+
+	void addSpamReportListener(in ISpamReportListener listener);
+	
+	void removeSpamReportListener(in ISpamReportListener listener);
+
+	String sendGeoloc(in Geoloc geoloc);
+	
+	int resendMessage(in String msgId);
+	
+	int reSendMultiMessageByPagerMode(in String msgId);
+	
+	String sendMessageByLargeMode(in String message);
+	
+        String sendCloudMessageByLargeMode(in String message);
+	
+	String sendPublicAccountMessageByLargeMode(in String message);
+	
+	String sendMessageByPagerMode(in String message ,in boolean isBurnMessage , in boolean isPublicMessage , in boolean isMultiMessage , in boolean isPayEmoticon,in List<String> participants);
+	
+	void sendSpamMessageByPagerMode(in String contact, in String messageId) ;
+	
+	String sendOnetoMultiMessage(in String message, in List<String> participants);
+	
+	String sendOnetoMultiEmoticonsMessage(in String message, in List<String> participants);
+		
+	//String sendOnetoMultiCloudMessage(in String message, in List<String> participants);
+	
+	String sendEmoticonShopMessage(in String message);
+	String sendCloudMessage(in String message);
+	
+	String sendPagerModeBurnMessage(in String message);
+	
+	String sendLargeModeBurnMessage(in String message);
+	
+	int getState(in String msgId);
+	
+	void sendBurnDeliveryReport(in String msgId);
+}
diff --git a/src/java/org/gsma/joyn/chat/IChatListener.aidl b/src/java/org/gsma/joyn/chat/IChatListener.aidl
new file mode 100644
index 0000000..3e6d495
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IChatListener.aidl
@@ -0,0 +1,30 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.ChatMessage;
+import org.gsma.joyn.chat.GeolocMessage;
+
+/**
+ * Chat event listener
+ */
+interface IChatListener {
+	void onNewMessage(in ChatMessage message);
+
+	void onNewGeoloc(in GeolocMessage message);
+
+	void onReportMessageDelivered(in String msgId);
+
+	void onReportMessageDisplayed(in String msgId);
+
+	void onReportMessageFailed(in String msgId);
+
+	void onComposingEvent(in boolean status);
+
+  void onReportFailedMessage(in String msgId,in int errtype,in String statusCode);
+	
+	void onReportSentMessage(in String msgId);
+	
+	void onReportDeliveredMessage(in String msgId);
+	
+	void onNewBurnMessageArrived(in ChatMessage message);
+	
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/IChatService.aidl b/src/java/org/gsma/joyn/chat/IChatService.aidl
new file mode 100644
index 0000000..188a00c
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IChatService.aidl
@@ -0,0 +1,73 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.chat.IChatListener;
+import org.gsma.joyn.chat.IChat;
+import org.gsma.joyn.chat.IGroupChatListener;
+import org.gsma.joyn.chat.IGroupChat;
+import org.gsma.joyn.chat.INewChatListener;
+import org.gsma.joyn.chat.ISpamReportListener;
+import org.gsma.joyn.chat.IGroupChatSyncingListener;
+import org.gsma.joyn.chat.ChatServiceConfiguration;
+
+/**
+ * Chat service API
+ */
+interface IChatService {
+	boolean isServiceRegistered();
+    
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	ChatServiceConfiguration getConfiguration();
+    
+	IChat openSingleChat(in String contact, in IChatListener listener);
+	
+    IChat openMultiChat(in List<String> participants, in IChatListener listener);
+
+	IChat initPublicAccountChat(in String contact, in IChatListener listener);
+
+	IGroupChat initiateGroupChat(in List<String> contacts, in String subject, in IGroupChatListener listener);
+    
+	String sendOne2MultiMessage(in List<String> contacts, in String messages, in IGroupChatListener listener);
+        
+	int resendOne2MultiMessage(in String megId, in IGroupChatListener listener);
+    
+        String sendOne2MultiCloudMessageLargeMode(in List<String> contacts, in String messages, in IGroupChatListener listener);
+    
+	IGroupChat rejoinGroupChat(in String chatId);
+    
+	IGroupChat rejoinGroupChatId(in String chatId, in String rejoinId);
+    
+	IGroupChat restartGroupChat(in String chatId);
+
+    void syncAllGroupChats(in IGroupChatSyncingListener listener);
+    void syncGroupChat(in String chatId, in IGroupChatSyncingListener listener);
+    
+	void addEventListener(in INewChatListener listener);
+    
+	void removeEventListener(in INewChatListener listener);
+    
+	void initiateSpamReport(String contact, String messageId);
+	
+	void addSpamReportListener(in ISpamReportListener listener);
+	
+	void removeSpamReportListener(in ISpamReportListener listener);
+    
+	IChat getChat(in String chatId);
+
+	IChat getPublicAccountChat(in String chatId);
+
+	List<IBinder> getChats();
+
+	List<IBinder> getGroupChats();
+    
+	IGroupChat getGroupChat(in String chatId);
+	
+	void blockGroupMessages(in String chatId, in boolean flag);
+	
+	int getServiceVersion();
+	
+	boolean isImCapAlwaysOn();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/IGroupChat.aidl b/src/java/org/gsma/joyn/chat/IGroupChat.aidl
new file mode 100644
index 0000000..ed1df5b
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IGroupChat.aidl
@@ -0,0 +1,72 @@
+package org.gsma.joyn.chat;
+
+import java.util.List;
+
+import org.gsma.joyn.chat.IGroupChatListener;
+import org.gsma.joyn.chat.Geoloc;
+import org.gsma.joyn.ft.IFileTransfer;
+import org.gsma.joyn.ft.IFileTransferListener;
+
+
+/**
+ * Group chat interface
+ */
+interface IGroupChat {
+	String getChatId();
+	
+	String getChatSessionId();
+
+	int getDirection();
+	
+	int getState();	
+
+	String getSubject();	
+
+	List<String> getParticipants();
+	
+	List<String> getAllParticipants();
+	
+	void acceptInvitation();
+	
+	void rejectInvitation();
+	
+	String sendMessage(in String text);
+
+	String sendEmoticonsMessage(in String text);
+
+	void sendIsComposingEvent(in boolean status);
+	
+	void sendDisplayedDeliveryReport(in String msgId);
+
+	void addParticipants(in List<String> participants);
+	
+	int getMaxParticipants();
+	
+	int getMessageState(in String messageId);
+	
+	int resendMessage(in String msgId);
+	
+	void quitConversation();
+	
+	void addEventListener(in IGroupChatListener listener);
+	
+	void removeEventListener(in IGroupChatListener listener);
+	
+	String getRemoteContact();
+
+	String sendGeoloc(in Geoloc geoloc);
+
+	IFileTransfer sendFile(in String filename, in String fileicon, in IFileTransferListener listener);
+	
+	void transferChairman(in String newChairman);
+	
+	void modifySubject(in String newSubject);
+	
+	void modifyMyNickName(in String newNickname);
+	
+	void removeParticipants(in List<String> participants);
+	
+	void abortConversation();
+	
+	boolean isMeChairman();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/IGroupChatListener.aidl b/src/java/org/gsma/joyn/chat/IGroupChatListener.aidl
new file mode 100644
index 0000000..3143f1e
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IGroupChatListener.aidl
@@ -0,0 +1,76 @@
+package org.gsma.joyn.chat;
+
+import java.util.List;
+
+import org.gsma.joyn.chat.ChatMessage;
+import org.gsma.joyn.chat.GeolocMessage;
+import org.gsma.joyn.chat.ConferenceEventData.ConferenceUser;
+
+/**
+ * Group chat event listener
+ */
+interface IGroupChatListener {
+	void onSessionStarted();
+	
+	void onSessionAborted();
+
+	void onSessionAbortedbyChairman();
+
+	void onSessionError(in int reason);
+		
+	void onNewMessage(in ChatMessage message);
+
+	void onNewGeoloc(in GeolocMessage message);
+
+	void onReportMessageDeliveredContact(in String msgId,in String contact);
+
+	void onReportMessageDisplayedContact(in String msgId,in String contact);
+
+	void onReportMessageFailedContact(in String msgId,in String contact);
+	
+	void onReportMessageDelivered(in String msgId);
+
+	void onReportMessageDisplayed(in String msgId);
+
+	void onReportMessageFailed(in String msgId);
+	
+	void onReportFailedMessage(in String msgId,in int errtype,in String statusCode);
+		
+	void onReportSentMessage(in String msgId);
+
+	void onGroupChatDissolved();
+	
+	void onInviteParticipantsResult(in int errType,in String statusCode);
+	
+	void onComposingEvent(in String contact, in boolean status);
+	
+	void onParticipantJoined(in String contact, in String contactDisplayname);
+	
+	void onParticipantLeft(in String contact);
+
+	void onParticipantDisconnected(in String contact);
+
+    void onSetChairmanResult(in int errType, in int statusCode);
+	
+	void onChairmanChanged(in String newChairman);
+	
+	void onModifySubjectResult(in int errType, in int statusCode);
+	
+	void onSubjectChanged(in String newSubject);
+	
+	void onModifyNickNameResult(in int errType, in int statusCode);
+    
+    void onNickNameChanged(in String contact, in String newNickName);
+	
+	void onRemoveParticipantResult(in int errType, in int statusCode, in String participant);
+	
+	void onReportMeKickedOut(in String from);
+	
+	void onReportParticipantKickedOut(in String contact);
+	
+	void onAbortConversationResult(in int errType, in int statusCode);
+	
+	void onQuitConversationResult(in int errType, in int statusCode);
+	
+	void onConferenceNotify(in String confState, in List<ConferenceUser> users);
+}
diff --git a/src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl b/src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl
new file mode 100644
index 0000000..df5e312
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IGroupChatSyncingListener.aidl
@@ -0,0 +1,12 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.ConferenceEventData;
+
+/**
+ * Conference info listener
+ */
+interface IGroupChatSyncingListener {
+    void onSyncStart(in int count);
+    void onSyncInfo(in String chatId, in ConferenceEventData info);
+    void onSyncDone(in int result);
+}
diff --git a/src/java/org/gsma/joyn/chat/INewChatListener.aidl b/src/java/org/gsma/joyn/chat/INewChatListener.aidl
new file mode 100644
index 0000000..806c284
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/INewChatListener.aidl
@@ -0,0 +1,12 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.ChatMessage;
+
+/**
+ * New chat invitation event listener
+ */
+interface INewChatListener {
+	void onNewSingleChat(in String contact, in ChatMessage message);
+	
+	void onNewGroupChat(in String chatId);
+}
diff --git a/src/java/org/gsma/joyn/chat/IPublicAccountChat.aidl b/src/java/org/gsma/joyn/chat/IPublicAccountChat.aidl
new file mode 100644
index 0000000..f4e84bc
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/IPublicAccountChat.aidl
@@ -0,0 +1,11 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.chat.IChatListener;
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Public Account Chat interface
+ */
+interface IPublicAccountChat {
+	
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/chat/ISpamReportListener.aidl b/src/java/org/gsma/joyn/chat/ISpamReportListener.aidl
new file mode 100644
index 0000000..f16abad
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/ISpamReportListener.aidl
@@ -0,0 +1,10 @@
+package org.gsma.joyn.chat;
+
+/**
+ * New chat invitation event listener
+ */
+interface ISpamReportListener {
+	void onSpamReportSuccess( String contact, String msgId);
+	
+	void onSpamReportFailed( String contact, String msgId, int errorCode);
+}
diff --git a/src/java/org/gsma/joyn/chat/NewChatListener.java b/src/java/org/gsma/joyn/chat/NewChatListener.java
new file mode 100644
index 0000000..e5eba0c
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/NewChatListener.java
@@ -0,0 +1,51 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+
+/**
+ * New chat invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewChatListener extends INewChatListener.Stub {
+    /**
+     * Callback called when a new chat invitation has been received
+     *
+     * @param contact Remote contact
+     * @param message Chat message
+     * @see ChatMessage
+     */
+    public abstract void onNewSingleChat(String contact, ChatMessage message);
+
+    /**
+     * Callback called when a new group chat invitation has been received
+     *
+     * @param chatId Chat ID
+     */
+    public abstract void onNewGroupChat(String chatId);
+
+    /**
+     * Callback called when a new public account chat invitation has been received
+     *
+     * @param chatId Chat ID
+     */
+    public void onNewPublicAccountChat(String chatId,ChatMessage message) {
+        // default implementation for TAPI extension
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/PublicAccountChat.java b/src/java/org/gsma/joyn/chat/PublicAccountChat.java
new file mode 100644
index 0000000..e8f15e8
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/PublicAccountChat.java
@@ -0,0 +1,50 @@
+package org.gsma.joyn.chat;
+
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.Logger;
+
+public class PublicAccountChat extends Chat {
+    /**
+     * Constructor
+     *
+     * @param chatIntf Chat interface
+     */
+    PublicAccountChat(IChat chatIntf) {
+        super(chatIntf);
+    }
+
+    /**
+     * Sends a large mode public account message
+     *
+     * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+   public String sendPublicAccountMessageByLargeMode(String message) throws JoynServiceException {
+
+        Logger.i(TAG, "PAM sendPublicAccountMessageByLargeMode entry " + message);
+        try {
+            return chatInf.sendPublicAccountMessageByLargeMode(message);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+  /**
+     * Sends a pager mode message
+     *
+     * @param message Message info
+     * @return Unique message ID or null in case of error
+     * @throws JoynServiceException
+     */
+   public String sendPublicAccountMessageByPagerMode(String message) throws JoynServiceException {
+
+        Logger.i(TAG, "PAM sendPublicAccountMessageByPagerMode entry " + message);
+        try {
+            String extraParams[] = {"public" };
+          return chatInf.sendMessageByPagerMode(message, false, true, false, false, null);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/chat/SpamReportListener.java b/src/java/org/gsma/joyn/chat/SpamReportListener.java
new file mode 100644
index 0000000..9372dcf
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/SpamReportListener.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.chat;
+
+
+/**
+ * New chat invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class SpamReportListener extends ISpamReportListener.Stub {
+    /**
+     * Callback called when a new chat invitation has been received
+     *
+     * @param contact Remote contact
+     * @param msgId Chat message ID
+     * @see ChatMessage
+     */
+    public abstract void onSpamReportSuccess(String contact, String msgId);
+
+    /**
+     * Callback called when a new group chat invitation has been received
+     *
+     * @param contact contact
+     * @param msgId msgId
+     * @param errorCode errorCode
+     */
+    public abstract void onSpamReportFailed(String contact, String msgId, int errorCode);
+}
diff --git a/src/java/org/gsma/joyn/chat/package-info.java b/src/java/org/gsma/joyn/chat/package-info.java
new file mode 100644
index 0000000..f5c2877
--- /dev/null
+++ b/src/java/org/gsma/joyn/chat/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * This API exposes all functionality for single chat and group chat services.
+ * <p>
+ */
+package org.gsma.joyn.chat;
diff --git a/src/java/org/gsma/joyn/contacts/ContactsProvider.java b/src/java/org/gsma/joyn/contacts/ContactsProvider.java
new file mode 100644
index 0000000..f1a96c2
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/ContactsProvider.java
@@ -0,0 +1,75 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.contacts;
+
+/**
+ * Contacts provider for joyn info integrated in the native address book
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ContactsProvider {
+    /**
+     * RCS phone number
+     */
+    public final static String MIME_TYPE_PHONE_NUMBER = "vnd.android.cursor.item/org.gsma.joyn.number";
+
+    /**
+     * Registration state
+     */
+    public final static String MIME_TYPE_REGISTRATION_STATE = "vnd.android.cursor.item/org.gsma.joyn.registration-state";
+
+    /**
+     * Image sharing capability support
+     */
+    public final static String MIME_TYPE_IMAGE_SHARING = "vnd.android.cursor.item/org.gsma.joyn.image-sharing";
+
+    /**
+     * Video sharing capability support
+     */
+    public final static String MIME_TYPE_VIDEO_SHARING = "vnd.android.cursor.item/org.gsma.joyn.video-sharing";
+
+    /**
+     * IM/Chat capability support
+     */
+    public final static String MIME_TYPE_IM_SESSION = "vnd.android.cursor.item/org.gsma.joyn.im-session";
+
+    /**
+     * File transfer capability support
+     */
+    public final static String MIME_TYPE_FILE_TRANSFER = "vnd.android.cursor.item/org.gsma.joyn.file-transfer";
+
+    /**
+     * Geolocation push capability support
+     */
+    public final static String MIME_TYPE_GEOLOC_PUSH = "vnd.android.cursor.item/org.gsma.joyn.geoloc-push";
+
+    /**
+     * IP voice call capability support
+     */
+    public final static String MIME_TYPE_IP_VOICE_CALL = "vnd.android.cursor.item/org.gsma.joyn.ip-voice-call";
+
+    /**
+     * IP video call capability support
+     */
+    public final static String MIME_TYPE_IP_VIDEO_CALL = "vnd.android.cursor.item/org.gsma.joyn.ip-video-call";
+
+    /**
+     * RCS extensions supported
+     */
+    public final static String MIME_TYPE_EXTENSIONS = "vnd.android.cursor.item/org.gsma.joyn.extensions";
+}
diff --git a/src/java/org/gsma/joyn/contacts/ContactsService.java b/src/java/org/gsma/joyn/contacts/ContactsService.java
new file mode 100644
index 0000000..f6bc54f
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/ContactsService.java
@@ -0,0 +1,447 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.contacts;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.res.AssetFileDescriptor;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Environment;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+import android.provider.ContactsContract;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+import org.gsma.joyn.Logger;
+
+/**
+ * Contacts service offers additional methods to manage RCS info in the
+ * local address book.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ContactsService extends JoynService {
+    /**
+     * API
+     */
+    private IContactsService api = null;
+    private Context mContext = null;
+    public static final String TAG = "TAPI-ContactsService";
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public ContactsService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+        mContext = ctx;
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "ContactsService connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        Logger.i(TAG, "ContactsService disconnect() entry");
+        try {
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IContactsService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry " + className);
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getContactsServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IContactsService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected entry " + className);
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the joyn contact infos from its contact ID (i.e. MSISDN)
+     *
+     * @param contactId Contact ID
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public JoynContact getJoynContact(String contactId) throws JoynServiceException {
+        Logger.i(TAG, "getJoynContact entry Id=" + contactId);
+        if (api != null) {
+            try {
+                return api.getJoynContact(contactId);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of joyn contacts
+     *
+     * @return List of contacts
+     * @throws JoynServiceException
+     */
+    public Set<JoynContact> getJoynContacts() throws JoynServiceException {
+        Logger.i(TAG, "getJoynContacts entry ");
+        if (api != null) {
+            try {
+                Set<JoynContact> result = new HashSet<JoynContact>();
+                List<JoynContact> contacts = api.getJoynContacts();
+                for (int i = 0; i < contacts.size(); i++) {
+                    JoynContact contact = contacts.get(i);
+                    result.add(contact);
+                }
+                Logger.i(TAG, "getJoynContacts returning result = " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of online contacts (i.e. registered)
+     *
+     * @return List of contacts
+     * @throws JoynServiceException
+     */
+    public Set<JoynContact> getJoynContactsOnline() throws JoynServiceException {
+        Logger.i(TAG, "getJoynContactsOnline() entry ");
+        if (api != null) {
+            try {
+                Set<JoynContact> result = new HashSet<JoynContact>();
+                result.addAll(api.getJoynContactsOnline());
+                Logger.i(TAG, "getJoynContactsOnline() returning result = " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of contacts supporting a given extension or service ID
+     *
+     * @param serviceId Service ID
+     * @return List of contacts
+     * @throws JoynServiceException
+     */
+    public Set<JoynContact> getJoynContactsSupporting(String serviceId) throws JoynServiceException {
+        Logger.i(TAG, "getJoynContactsSupporting() entry ");
+        if (api != null) {
+            try {
+                Set<JoynContact> result = new HashSet<JoynContact>();
+                result.addAll(api.getJoynContactsSupporting(serviceId));
+                Logger.i(TAG, "getJoynContactsSupporting() returning result = " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the vCard of a contact. The method returns the complete filename including the path of the visit
+     * card. The filename has the file extension .vcf and is generated from the native address book
+     * vCard URI (see Android SDK attribute ContactsContract.Contacts.CONTENT_VCARD_URI which returns
+     * the referenced contact formatted as a vCard when opened through openAssetFileDescriptor(Uri, String)).
+     *
+     * @param contactUri Contact URI of the contact in the native address book
+     * @return Filename of vCard
+     * @throws JoynServiceException
+     */
+    public String getVCard(Uri contactUri) throws JoynServiceException {
+        Logger.i(TAG, "getVCard() entry ");
+        String fileName = null;
+        Cursor cursor = mContext.getContentResolver().query(contactUri, null, null, null, null);
+        while (cursor.moveToNext()) {
+            String name = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME));
+            String lookupKey = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.LOOKUP_KEY));
+            Uri vCardUri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_VCARD_URI, lookupKey);
+            Logger.i(TAG, "getVCard() uri= " + vCardUri);
+            AssetFileDescriptor fd;
+            try {
+                fd = mContext.getContentResolver().openAssetFileDescriptor(vCardUri, "r");
+                FileInputStream fis = fd.createInputStream();
+                byte[] buf = new byte[(int) fd.getDeclaredLength()];
+                fis.read(buf);
+                String Vcard = new String(buf);
+
+                fileName = Environment.getExternalStorageDirectory().toString() + File.separator + name + ".vcf";
+                Logger.i(TAG, "getVCard() filename= " + fileName);
+                File vCardFile = new File(fileName);
+
+                if (vCardFile.exists())
+                    vCardFile.delete();
+
+                FileOutputStream mFileOutputStream = new FileOutputStream(vCardFile, true);
+                mFileOutputStream.write(Vcard.toString().getBytes());
+                mFileOutputStream.close();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        }
+        cursor.close();
+        return fileName;
+    }
+
+    /**
+     * Get all IM blocked contacts that stored in the local copy
+     * @return
+     */
+    public List<String> getImBlockedContactsFromLocal() {
+        Logger.i(TAG, "getImBlockedContactsFromLocal entry");
+        if (api != null) {
+            try {
+                return api.getImBlockedContactsFromLocal();
+            } catch (Exception e) {
+                //throw new JoynServiceException(e.getMessage());
+                return null;
+            }
+        } else {
+            //throw new JoynServiceNotAvailableException();
+            return null;
+        }
+    }
+
+    /**
+     * Get whether the "IM" feature is enabled or not for the contact
+     *
+     * @param contact
+     * @return flag indicating if IM sessions with the contact are enabled or not
+     */
+    public boolean isImBlockedForContact(String contact) throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.isImBlockedForContact(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+    /**
+     * Get the contacts that are "IM blocked"
+     *
+     * @return list containing all contacts that are "IM blocked"
+     */
+    public List<String> getImBlockedContacts() throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.getImBlockedContacts();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    public String getTimeStampForBlockedContact(String contact) throws JoynServiceException {
+        Logger.i(TAG, "getTimeStampForBlockedContact entry" + contact);
+        if (api != null) {
+            try {
+                return api.getTimeStampForBlockedContact(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /*public static Set<String> getAllBlockedList(){
+        Logger.i(TAG, "getAllBlockedList entry");
+        if (api != null) {
+            try {
+                return api.getAllBlockedList();
+            } catch(Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }*/
+
+    /**
+     * Mark the contact as "blocked for IM"
+     *
+     * @param contact
+     * @param flag indicating if we enable or disable the IM sessions with the contact
+     */
+    public void setImBlockedForContact(String contact, boolean flag) throws JoynServiceException {
+        Logger.i(TAG, "setImBlockedForContact entry" + contact + ",flag=" + flag);
+        if (api != null) {
+            try {
+                api.setImBlockedForContact(contact, flag);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Mark the contact as "blocked for FT"
+     *
+     * @param contact
+     * @param flag indicating if we enable or disable the FT sessions with the contact
+     */
+    public void setFtBlockedForContact(String contact, boolean flag) throws JoynServiceException {
+        Logger.i(TAG, "setFtBlockedForContact entry" + contact + ",flag=" + flag);
+        if (api != null) {
+            try {
+                api.setFtBlockedForContact(contact, flag);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Check if number provided is a valid number for RCS
+     * <br>It is not valid if :
+     * <li>well formatted (not digits only or '+')
+     * <li>minimum length
+     *
+     * @param number Phone number
+     * @return Returns true if it is a RCS valid number
+     */
+    public boolean isRcsValidNumber(String number) throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.isRcsValidNumber(number);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Get the registration state of a contact in the EAB
+     *
+     * @param contact Contact
+     * @return Contact info
+     */
+    public int getRegistrationState(String contact) throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.getRegistrationState(contact);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Load the IM blocked contacts to the local copy
+     */
+    public void loadImBlockedContactsToLocal() throws JoynServiceException {
+        if (api != null) {
+            try {
+                api.loadImBlockedContactsToLocal();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+}
diff --git a/src/java/org/gsma/joyn/contacts/IContactsService.aidl b/src/java/org/gsma/joyn/contacts/IContactsService.aidl
new file mode 100644
index 0000000..387f1a9
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/IContactsService.aidl
@@ -0,0 +1,37 @@
+package org.gsma.joyn.contacts;
+
+import org.gsma.joyn.contacts.JoynContact;
+
+/**
+ * Contacts service API
+ */
+interface IContactsService {
+	JoynContact getJoynContact(String contactId);
+
+	List<JoynContact> getJoynContacts();
+
+	List<JoynContact> getJoynContactsOnline();
+
+	List<JoynContact> getJoynContactsSupporting(in String tag);
+	
+	int getServiceVersion();
+	
+	List<String> getImBlockedContactsFromLocal();
+	
+	boolean isImBlockedForContact(String contact);
+	
+	List<String> getImBlockedContacts();
+	
+	String getTimeStampForBlockedContact(in String contact);
+	
+	void setImBlockedForContact(in String contact, in boolean flag);
+	
+	void setFtBlockedForContact(in String contact, in boolean flag);
+	
+	boolean isRcsValidNumber(in String number);
+	
+	int getRegistrationState(in String contact);
+	
+	void loadImBlockedContactsToLocal();
+	
+}
diff --git a/src/java/org/gsma/joyn/contacts/JoynContact.aidl b/src/java/org/gsma/joyn/contacts/JoynContact.aidl
new file mode 100644
index 0000000..0327cd9
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/JoynContact.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.contacts;
+
+/**
+ * Joyn contact object
+ */
+parcelable JoynContact;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/contacts/JoynContact.java b/src/java/org/gsma/joyn/contacts/JoynContact.java
new file mode 100644
index 0000000..42b6fd9
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/JoynContact.java
@@ -0,0 +1,153 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.contacts;
+
+import org.gsma.joyn.capability.Capabilities;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * Joyn contact
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class JoynContact implements Parcelable {
+    /**
+     * Capabilities
+     */
+    private Capabilities capabilities = null;
+
+    /**
+     * Contact ID
+     */
+    private String contactId = null;
+
+    /**
+     * Registration state
+     */
+    private boolean registered = false;
+
+    public static final String TAG = "TAPI-JoynContact";
+    /**
+     * Constructor
+     *
+     * @param contactId Contact ID
+     * @param registered Registration state
+     * @param capabilities Capabilities
+     * @hide
+     */
+    public JoynContact(String contactId, boolean registered, Capabilities capabilities) {
+        Logger.i(TAG, "JoynContact entry" + "contactId =" + contactId + " registered=" + registered + " capabilities=" + capabilities) ;
+        this.contactId = contactId;
+        this.registered = registered;
+        this.capabilities = capabilities;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public JoynContact(Parcel source) {
+        contactId = source.readString();
+        registered = source.readInt() != 0;
+        boolean flag = source.readInt() != 0;
+        if (flag) {
+            this.capabilities = source.readParcelable(getClass().getClassLoader());
+        } else {
+            this.capabilities = null;
+        }
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(contactId);
+        dest.writeInt(registered ? 1 : 0);
+        if (capabilities != null) {
+            dest.writeInt(1);
+            dest.writeParcelable(capabilities, flags);
+        } else {
+            dest.writeInt(0);
+        }
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<JoynContact> CREATOR
+            = new Parcelable.Creator<JoynContact>() {
+        public JoynContact createFromParcel(Parcel source) {
+            return new JoynContact(source);
+        }
+
+        public JoynContact[] newArray(int size) {
+            return new JoynContact[size];
+        }
+    };
+
+    /**
+     * Returns the canonical contact ID (i.e. MSISDN)
+     *
+     * @return Contact ID
+     */
+    public String getContactId() {
+        return contactId;
+    }
+
+    /**
+     * Is contact online (i.e. registered to the service platform)
+     *
+     * @return Returns true if registered else returns false
+     */
+    public boolean isRegistered() {
+        return registered;
+    }
+
+    /**
+     * Returns the capabilities associated to the contact
+     *
+     * @return Capabilities
+     */
+    public Capabilities getCapabilities() {
+        return capabilities;
+    }
+}
diff --git a/src/java/org/gsma/joyn/contacts/package-info.java b/src/java/org/gsma/joyn/contacts/package-info.java
new file mode 100644
index 0000000..9b3f789
--- /dev/null
+++ b/src/java/org/gsma/joyn/contacts/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * This API exposes all infos related to joyn contacts.
+ * <p>
+ */
+package org.gsma.joyn.contacts;
diff --git a/src/java/org/gsma/joyn/ft/FileSpamReportListener.java b/src/java/org/gsma/joyn/ft/FileSpamReportListener.java
new file mode 100644
index 0000000..c7ecea6
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileSpamReportListener.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+
+/**
+ * New chat invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class FileSpamReportListener extends IFileSpamReportListener.Stub {
+    /**
+     * Callback called when a new chat invitation has been received
+     *
+     * @param contact Remote contact
+     * @param msgId Chat message ID
+     * @see ChatMessage
+     */
+    public abstract void onFileSpamReportSuccess(String contact, String ftId);
+
+    /**
+     * Callback called when a new group chat invitation has been received
+     *
+     * @param contact contact
+     * @param msgId msgId
+     * @param errorCode errorCode
+     */
+    public abstract void onFileSpamReportFailed(String contact, String ftId, int errorCode);
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransfer.java b/src/java/org/gsma/joyn/ft/FileTransfer.java
new file mode 100644
index 0000000..8498c61
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransfer.java
@@ -0,0 +1,393 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import org.gsma.joyn.JoynServiceException;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * File transfer
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransfer {
+
+    public static final String TAG = "TAPI-FileTransfer";
+    /**
+     * File transfer state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * File transfer invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * File transfer invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * File transfer is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * File transfer has been transferred with success
+         */
+        public final static int TRANSFERRED = 4;
+
+        /**
+         * File transfer has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * File transfer has failed
+         */
+        public final static int FAILED = 6;
+
+        /**
+         * File transfer has been delivered
+         */
+        public final static int DELIVERED = 7;
+
+        /**
+         * File transfer has been displayed or opened
+         */
+        public final static int DISPLAYED = 8;
+
+        /**
+         * File transfer has been PAUSED
+         */
+        public final static int PAUSED = 8;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the transfer
+     */
+    public static class Direction {
+        /**
+         * Incoming transfer
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing transfer
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * File transfer error
+     */
+    public static class Error {
+        /**
+         * Transfer has failed
+         */
+        public final static int TRANSFER_FAILED = 0;
+
+        /**
+         * Transfer invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        /**
+         * File saving has failed
+         */
+        public final static int SAVING_FAILED = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * File transfer interface
+     */
+    private IFileTransfer transferInf;
+
+    /**
+     * Constructor
+     *
+     * @param transferIntf File transfer interface
+     * @hide
+     */
+    public FileTransfer(IFileTransfer transferIntf) {
+        this.transferInf = transferIntf;
+    }
+
+    /**
+     * Is the file transfer via HTTP
+     *
+     * @return Returns true if file transfer is via HTPP else returns false
+     */
+    public boolean isHttpFileTransfer() throws JoynServiceException {
+        Logger.i(TAG, "isHttpFileTransfer ");
+        try {
+            return transferInf.isHttpFileTransfer();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the file transfer ID of the file transfer
+     *
+     * @return Transfer ID
+     * @throws JoynServiceException
+     */
+    public String getTransferId() throws JoynServiceException {
+        Logger.i(TAG, "getTransferId() entry ");
+        try {
+            return transferInf.getTransferId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the file transfer duration of the file transfer
+     *
+     * @return Transfer ID
+     * @throws JoynServiceException
+     */
+    public int getTransferDuration() throws JoynServiceException {
+        Logger.i(TAG, "getTransferDuration() entry ");
+        try {
+            return transferInf.getTransferDuration();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact() entry ");
+        try {
+            return transferInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the complete filename including the path of the file to be transferred
+     *
+     * @return Filename
+     * @throws JoynServiceException
+     */
+    public String getFileName() throws JoynServiceException {
+        Logger.i(TAG, "getFileName() entry ");
+        try {
+            return transferInf.getFileName();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the size of the file to be transferred
+     *
+     * @return Size in bytes
+     * @throws JoynServiceException
+     */
+    public long getFileSize() throws JoynServiceException {
+        Logger.i(TAG, "getFileSize() entry ");
+        try {
+            return transferInf.getFileSize();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the MIME type of the file to be transferred
+     *
+     * @return Type
+     * @throws JoynServiceException
+     */
+    public String getFileType() throws JoynServiceException {
+        Logger.i(TAG, "getFileType() entry ");
+        try {
+            return transferInf.getFileType();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the complete filename including the path of the file icon
+     *
+     * @return Filename
+     * @throws JoynServiceException
+     */
+    public String getFileIconName() throws JoynServiceException {
+        Logger.i(TAG, "getFileIconName() entry ");
+        try {
+            return transferInf.getFileIconName();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the file transfer
+     *
+     * @return State
+     * @see FileTransfer.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        Logger.i(TAG, "getState() entry ");
+        try {
+            return transferInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the transfer (incoming or outgoing)
+     *
+     * @return Direction
+     * @see FileTransfer.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        Logger.i(TAG, "getDirection() entry ");
+        try {
+            return transferInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts file transfer invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        Logger.i(TAG, "acceptInvitation() entry ");
+        try {
+            transferInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects file transfer invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        Logger.i(TAG, "rejectInvitation() entry ");
+        try {
+            transferInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the file transfer
+     *
+     * @throws JoynServiceException
+     */
+    public void abortTransfer() throws JoynServiceException {
+        Logger.i(TAG, "abortTransfer() entry ");
+        try {
+            transferInf.abortTransfer();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Pauses the file transfer
+     *
+     * @throws JoynServiceException
+     */
+    public void pauseTransfer() throws JoynServiceException {
+        Logger.i(TAG, "pauseTransfer() entry ");
+        try {
+            transferInf.pauseTransfer();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Resumes the file transfer
+     *
+     * @throws JoynServiceException
+     */
+    public void resumeTransfer() throws JoynServiceException {
+        Logger.i(TAG, "resumeTransfer() entry ");
+        try {
+            transferInf.resumeTransfer();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on file transfer events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(FileTransferListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener() entry " + listener);
+        try {
+            transferInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from file transfer
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(FileTransferListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener() entry " + listener);
+        try {
+            transferInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferIntent.java b/src/java/org/gsma/joyn/ft/FileTransferIntent.java
new file mode 100644
index 0000000..cba8c75
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferIntent.java
@@ -0,0 +1,98 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+/**
+ * Intent for file transfer invitation
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransferIntent {
+    /**
+     * Broadcast action: a new file transfer has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_TRANSFER_ID} containing the unique ID of the file transfer.
+     * <li> {@link #EXTRA_FILENAME} containing the filename of file to be transferred.
+     * <li> {@link #EXTRA_FILESIZE} containing the size of the file to be transferred.
+     * <li> {@link #EXTRA_FILETYPE} containing the MIME type of the file to be transferred.
+     * <li> {@link #EXTRA_FILEICON} containing the filename of the file icon associated to the file to be transferred.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.ft.action.NEW_FILE_TRANSFER";
+
+    public final static String ACTION_RESUME_FILE = "org.gsma.joyn.ft.action.RESUME_FILE_TRANSFER";
+
+    public final static String ACTION_DELIVERY_STATUS = "org.gsma.joyn.ft.action.DELIVERY_REPORT_FILE_TRANSFER";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation (extracted from the SIP address)
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the file transfer
+     */
+    public final static String EXTRA_TRANSFER_ID = "transferId";
+
+    /**
+     * Unique ID of the file transfer
+     */
+    public final static String RESUMED_TRANSFER_ID = "resumeTransferId";
+
+    /**
+     * Name of the file
+     */
+    public final static String EXTRA_FILENAME = "filename";
+
+    /**
+     * Size of the file in byte
+     */
+    public final static String EXTRA_FILESIZE = "filesize";
+
+    /**
+     * MIME type of the file
+     */
+    public final static String EXTRA_FILETYPE = "filetype";
+
+    /**
+     * MIME type of the file
+     */
+    public final static String TIME_LEN = "timelength";
+
+    /**
+     * MIME type of the file
+     */
+    public final static String GEOLOC_FILE = "geolocfile";
+
+    /**
+     * Name of the file icon
+     */
+    public final static String EXTRA_FILEICON = "fileicon";
+
+    public final static String EXTRA_BURN = "isBurn";
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferListener.java b/src/java/org/gsma/joyn/ft/FileTransferListener.java
new file mode 100644
index 0000000..5138e48
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferListener.java
@@ -0,0 +1,74 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+
+/**
+ * File transfer event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class FileTransferListener extends IFileTransferListener.Stub {
+    /**
+     * Callback called when the file transfer is started
+     */
+    public abstract void onTransferStarted();
+
+    /**
+     * Callback called when the file transfer has been aborted
+     */
+    public abstract void onTransferAborted();
+
+    /**
+     * Callback called when the transfer has failed
+     *
+     * @param error Error
+     * @see FileTransfer.Error
+     */
+    public abstract void onTransferError(int error);
+
+    /**
+     * Callback called during the transfer progress
+     *
+     * @param currentSize Current transferred size in bytes
+     * @param totalSize Total size to transfer in bytes
+     */
+    public abstract void onTransferProgress(long currentSize, long totalSize);
+
+    /**
+     * Callback called when the file has been transferred
+     *
+     * @param filename Filename including the path of the transferred file
+     */
+    public abstract void onFileTransferred(String filename);
+
+    /**
+     * Callback called when the file transfer has been aborted
+     */
+    public void onTransferPaused() {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when the file transfer has been aborted
+     */
+    public void onTransferResumed(String oldFTid, String newFTId) {
+        // default implementation for TAPI extension
+    }
+
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferLog.java b/src/java/org/gsma/joyn/ft/FileTransferLog.java
new file mode 100644
index 0000000..a24c7a8
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferLog.java
@@ -0,0 +1,150 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import android.net.Uri;
+
+/**
+ * Content provider for file transfer history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransferLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.ft/ft");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the file transfer.
+     * <P>Type: TEXT</P>
+     */
+    public static final String FT_ID = "ft_id";
+
+    /**
+     * The name of the column containing the MSISDN of the sender.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the filename (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILENAME = "filename";
+
+    /**
+     * The name of the column containing the file size to be transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String FILESIZE = "filesize";
+
+    /**
+     * The name of the column containing the MIME-type of the file.
+     * <P>Type: TEXT</P>
+     */
+    public static final String MIME_TYPE = "mime_type";
+
+    /**
+     * The name of the column containing the direction of the transfer.
+     * <P>Type: INTEGER</P>
+     * @see FileTransfer.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the amount of data transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String TRANSFERRED = "transferred";
+
+    /**
+     * The name of the column containing the time when transfer is initiated.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the time when file is sent. If 0 means not sent.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_SENT = "timestamp_sent";
+
+    /**
+     * The name of the column containing the time when file is delivered. If 0 means not delivered.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_DELIVERED = "timestamp_delivered";
+
+    /**
+     * The name of the column containing the time when file is displayed. If 0 means not displayed.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_DISPLAYED = "timestamp_displayed";
+
+    /**
+     * The name of the column containing the state of the transfer.
+     * <P>Type: INTEGER</P>
+     * @see FileTransfer.State
+     */
+    public static final String STATE = "state";
+
+    /**
+     * The name of the column containing the file icon (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILEICON = "fileicon";
+
+    /**
+     * The name of the column containing the chat ID used for the file transfer in group chat.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CHAT_ID = "chat_id";
+
+    public static final String MSG_ID = "msg_id";
+
+    public static final String DURATION = "duration";
+
+
+    public static final String SESSION_TYPE = "session_type";
+
+    public static final String HASH = "hash";
+
+
+    /**
+     * Type of the SESSION
+     */
+    public static class Type {
+        /**
+         * Content
+         */
+        public static final int CHAT = 0;
+
+        /**
+         * BURN message
+         */
+        public static final int BURN = 1;
+
+    }
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferService.java b/src/java/org/gsma/joyn/ft/FileTransferService.java
new file mode 100644
index 0000000..e927cb7
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferService.java
@@ -0,0 +1,739 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+import org.gsma.joyn.Logger;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+
+/**
+ * This class offers the main entry point to transfer files and to
+ * receive files. Several applications may connect/disconnect to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransferService extends JoynService {
+    /**
+     * API
+     */
+    private IFileTransferService api = null;
+
+    public static final String TAG = "TAPI-FileTransferService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public FileTransferService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "FileTransfer connected() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        intent.setAction(IFileTransferService.class.getName());
+
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "FileTransfer disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IFileTransferService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry " + className);
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getFileTransferServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IFileTransferService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected entry " + className);
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of the file transfer service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public FileTransferServiceConfiguration getConfiguration() throws JoynServiceException {
+        Logger.i(TAG, "getConfiguration() entry " + api);
+        if (api != null) {
+            try {
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Transfers a file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferFile(String contact, String filename, FileTransferListener listener) throws JoynServiceException, JoynContactFormatException {
+        return transferFile(contact, filename, null, listener);
+    }
+
+    /**
+     * Transfers a file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferFile(String contact, String filename, String fileicon, FileTransferListener listener) throws JoynServiceException, JoynContactFormatException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferFile() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " listener=" + listener);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferFile(contact, filename, fileicon, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Resumes an interrupted file from the point it got interrupted. Only for MSRP FT
+     *
+     * @param fileTranferId fileTranferId
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer resumeFileTransfer(String fileTranferId, FileTransferListener listener) throws JoynServiceException
+    {
+        Logger.i(TAG, "resumeFileTransfer() entry fileTranferId=" + fileTranferId);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.resumeFileTransfer(fileTranferId, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Resumes an interrupted file from the point it got interrupted. Only for MSRP FT
+     *
+     * @param fileTranferId fileTranferId
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer resumePublicFileTransfer(String fileTranferId, FileTransferListener listener, int timeLen) throws JoynServiceException
+    {
+        Logger.i(TAG, "resumePublicFileTransfer() entry fileTranferId=" + fileTranferId);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.resumePublicFileTransfer(fileTranferId, listener, timeLen);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+
+    /**
+     * Resumes an interrupted file from the point it got interrupted. Only for MSRP FT
+     *
+     * @param fileTranferId fileTranferId
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer resumeGroupFileTransfer(String chatId, String fileTranferId, FileTransferListener listener) throws JoynServiceException
+    {
+        Logger.i(TAG, "resumeGroupFileTransfer() entry fileTranferId=" + fileTranferId);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.resumeGroupFileTransfer(chatId, fileTranferId, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Transfers a file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferGeoLocFile(String contact, String filename, String fileicon, FileTransferListener listener) throws JoynServiceException, JoynContactFormatException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferGeoLocFile() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " listener=" + listener);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferFile(contact, filename, fileicon, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+   /**
+     * Transfers a file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @param timeLen Length of the audio/video file
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferPublicChatFile(String contact, String filename, String fileicon, FileTransferListener listener, int timeLen) throws JoynServiceException, JoynContactFormatException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferPublicChatFile() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " listener=" + listener + " ,timelen=" + timeLen);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferPublicChatFile(contact, filename, fileicon, listener, timeLen);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * transfers a file to a group of contacts outside of a current group chat. The
+     * parameter file contains the complete filename including the path to be transferred.
+     * See also the method GroupChat.sendFile() of the Chat API to send a file from an
+     * existing group chat conversation
+     *
+     * @param chat id of the group chat
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param length of the audio/video file
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToGroup(String chatId, Set<String> contacts, String filename, int timeLen, FileTransferListener listener) throws JoynServiceException
+    {
+        return transferFileToGroup(chatId, contacts, filename, null, timeLen, listener);
+    }
+
+    /**
+     * transfers a file to a group of contacts with an optional file icon.
+     *
+     * @param chat id of the group chat
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param length of the audio/video file
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToGroup(String chatId, Set<String> contacts, String filename, String fileicon, int timeLen, FileTransferListener listener) throws JoynServiceException
+    {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }*/
+        Logger.i(TAG, "transferFileToGroup() entry contact= " + contacts + " chatId=" + chatId + " filename=" + filename + " fileicon = " + fileicon + " timelen:" + timeLen + " listener=" + listener);
+        if (api != null) {
+            try {
+                List<String> contactsList = new ArrayList<String>(contacts);
+                IFileTransfer ftIntf = api.transferFileToGroup(chatId, contactsList, filename, fileicon, timeLen, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * transfers a file to a group of contacts outside of a group chat with an optional file icon.
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToGroup(Set<String> contacts, String filename, String fileicon, FileTransferListener listener) throws JoynServiceException
+    {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }*/
+
+        if (api != null) {
+            try {
+            return null;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * transfers a file to a group of contacts outside of a group chat.
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToGroup(Set<String> contacts, String filename, FileTransferListener listener) throws JoynServiceException
+    {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }*/
+
+        if (api != null) {
+            try {
+            return null;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Transfers a media file to a contact. The parameter filename contains the complete
+     * path of the file to be transferred. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or
+     * Tel-URI. If the format of the contact is not supported an exception is thrown.
+     *
+     * @param contact
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param timeLen Length of audio/video file
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public FileTransfer transferMedia(String contact, String filename, String fileicon, int timeLen, FileTransferListener listener) throws JoynServiceException
+    {
+            /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferMedia() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " timeLen = " + timeLen + " listener=" + listener);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferMedia(contact, filename, fileicon, listener, timeLen);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * transfers a file to a group of contacts outside of a group chat with an optional file icon.
+     *
+     * @param set of contacts
+     * @param filename Filename to transfer
+     * @param fileicon Filename of the file icon associated to the file to be transfered
+     * @param listener File transfer event listener
+     * @return File transfer
+     * @throws JoynServiceException
+     */
+    public FileTransfer transferFileToMultirecepient(Set<String> contacts, String filename, boolean fileIcon, FileTransferListener listener, int timeLen) throws JoynServiceException
+    {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }*/
+        Logger.i(TAG, "transferFileToMultirecepient() entry contact= " + contacts + " filename= " + filename + " listener= " + listener + " Timelen" + timeLen);
+        if (api != null) {
+            try {
+                List<String> contactsList = new ArrayList<String>(contacts);
+                IFileTransfer ftIntf = api.transferFileToMultirecepient(contactsList, filename, fileIcon, listener, timeLen);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of file transfers in progress
+     *
+     * @return List of file transfers
+     * @throws JoynServiceException
+     */
+    public Set<FileTransfer> getFileTransfers() throws JoynServiceException {
+        Logger.i(TAG, "getFileTransfers() entry " + api);
+        if (api != null) {
+            try {
+                Set<FileTransfer> result = new HashSet<FileTransfer>();
+                List<IBinder> ftList = api.getFileTransfers();
+                for (IBinder binder : ftList) {
+                    FileTransfer ft = new FileTransfer(IFileTransfer.Stub.asInterface(binder));
+                    result.add(ft);
+                }
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current file transfer from its unique ID
+     *
+     * @return File transfer or null if not found
+     * @throws JoynServiceException
+     */
+    public FileTransfer getFileTransfer(String transferId) throws JoynServiceException {
+        Logger.i(TAG, "getFileTransfer() entry " + transferId + " api=" + api);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.getFileTransfer(transferId);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current file transfer from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return File transfer or null if not found
+     * @throws JoynServiceException
+     */
+    public FileTransfer getFileTransferFor(Intent intent) throws JoynServiceException {
+        Logger.i(TAG, "getFileTransferFor() entry " + intent + " api=" + api);
+        if (api != null) {
+            try {
+                String transferId = intent.getStringExtra(FileTransferIntent.EXTRA_TRANSFER_ID);
+                if (transferId != null) {
+                    return getFileTransfer(transferId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public void initiateFileSpamReport(String contact, String FtId) throws JoynServiceException {
+        Logger.i(TAG, "initiateSpamReport entry " + contact + ":" + FtId);
+        if (api != null) {
+            try {
+                api.initiateFileSpamReport(contact, FtId);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Adds a spam listener.
+     *
+     * @param listener Spam Report listener
+     * @throws JoynServiceException
+     */
+    public void addFileSpamReportListener(FileSpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addSpamReportListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addFileSpamReportListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Removes a spam listener
+     *
+     * @param listener Spam Report listener
+     * @throws JoynServiceException
+     */
+    public void removeFileSpamReportListener(FileSpamReportListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeSpamReportListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeFileSpamReportListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a file transfer invitation listener
+     *
+     * @param listener New file transfer listener
+     * @throws JoynServiceException
+     */
+    public void addNewFileTransferListener(NewFileTransferListener listener) throws JoynServiceException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_RECEIVE) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_RECEIVE");
+        }*/
+        Logger.i(TAG, "addNewFileTransferListener() entry " + listener + " api=" + api);
+        if (api != null) {
+            try {
+                api.addNewFileTransferListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a file transfer invitation listener
+     *
+     * @param listener New file transfer listener
+     * @throws JoynServiceException
+     */
+    public void removeNewFileTransferListener(NewFileTransferListener listener) throws JoynServiceException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_RECEIVE) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_RECEIVE");
+        }*/
+        Logger.i(TAG, "removeNewFileTransferListener() entry " + listener + " api=" + api);
+        if (api != null) {
+            try {
+                api.removeNewFileTransferListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    public FileTransfer transferBurnFile(String contact, String filename, String fileicon, FileTransferListener listener) throws JoynServiceException, JoynContactFormatException {
+        /*if (ctx.checkCallingOrSelfPermission(Permissions.RCS_FILETRANSFER_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_FILETRANSFER_SEND");
+        }
+        */
+        Logger.i(TAG, "transferBurnFile() entry contact= " + contact + " filename=" + filename + " fileicon = " + fileicon + " listener=" + listener);
+        if (api != null) {
+            try {
+                IFileTransfer ftIntf = api.transferBurnFile(contact, filename, fileicon, listener);
+                if (ftIntf != null) {
+                    return new FileTransfer(ftIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+}
diff --git a/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.aidl b/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.aidl
new file mode 100644
index 0000000..37f728d
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ft;
+
+/**
+ * File transfer configuration object
+ */
+parcelable FileTransferServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.java b/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.java
new file mode 100644
index 0000000..76e9038
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/FileTransferServiceConfiguration.java
@@ -0,0 +1,197 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+
+/**
+ * File transfer service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class FileTransferServiceConfiguration implements Parcelable {
+
+    public static final String TAG = "TAPI-FileTransferServiceConfiguration";
+    /**
+     * File transfer size threshold
+     */
+    private long warnSize;
+
+    /**
+     * File transfer size limit
+     */
+    private long maxSize;
+
+    /**
+     * File transfer auto accept mode
+     */
+    private boolean autoAcceptMode;
+
+    /**
+     * File icon
+     */
+    private boolean fileIcon;
+
+    /**
+     * File icon size limit
+     */
+    private long maxFileIconSize;
+
+    /**
+     * File icon size limit
+     */
+    private int maxFileTransfers;
+
+
+    /**
+     * Constructor
+     *
+     * @param warnSize File transfer size threshold
+     * @param maxSize File transfer size limit
+     * @param autoAcceptMode File transfer auto accept mode
+     * @param fileIcon File icon
+     * @param maxFileIconSize File icon size limit
+     * @hide
+     */
+    public FileTransferServiceConfiguration(long warnSize, long maxSize, boolean autoAcceptMode, boolean fileIcon, long maxFileIconSize , int maxFileTransfers) {
+        Logger.i(TAG, "FileTransferServiceConfiguration entry" + "warnSize " + warnSize + "maxSize " + maxSize + "autoAcceptMode " + autoAcceptMode +
+                "fileIcon" + fileIcon + "maxFileIconSize " + maxFileIconSize + "maxFileTransfers" + maxFileTransfers);
+        this.warnSize = warnSize;
+        this.maxSize = maxSize;
+        this.autoAcceptMode = autoAcceptMode;
+        this.fileIcon = fileIcon;
+        this.maxFileIconSize = maxFileIconSize;
+        this.maxFileTransfers = maxFileTransfers;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public FileTransferServiceConfiguration(Parcel source) {
+        this.warnSize = source.readLong();
+        this.maxSize = source.readLong();
+        this.autoAcceptMode = source.readInt() != 0;
+        this.fileIcon = source.readInt() != 0;
+        this.maxFileIconSize = source.readLong();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(warnSize);
+        dest.writeLong(maxSize);
+        dest.writeInt(autoAcceptMode ? 1 : 0);
+        dest.writeInt(fileIcon ? 1 : 0);
+        dest.writeLong(maxFileIconSize);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<FileTransferServiceConfiguration> CREATOR
+            = new Parcelable.Creator<FileTransferServiceConfiguration>() {
+        public FileTransferServiceConfiguration createFromParcel(Parcel source) {
+            return new FileTransferServiceConfiguration(source);
+        }
+
+        public FileTransferServiceConfiguration[] newArray(int size) {
+            return new FileTransferServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Returns the file transfer size threshold when the user should be warned about
+     * the potential charges associated to the transfer of a large file. It returns
+     * 0 if there no need to warn.
+     *
+     * @return Size in kilobytes
+     */
+    public long getWarnSize() {
+        return warnSize;
+    }
+
+    /**
+     * Returns the file transfer size limit. It returns 0 if there is no limitation.
+     *
+     * @return Size in kilobytes
+     */
+    public long getMaxSize() {
+        return maxSize;
+    }
+
+    /**
+     * Is file transfer invitation automatically accepted
+     *
+     * @return Returns true if automatically accepted else returns false
+     */
+    public boolean getAutoAcceptMode() {
+        return autoAcceptMode;
+    }
+
+    /**
+     * Is file icon supported
+     *
+     * @return Returns true if supported else returns false
+     */
+    public boolean isFileIconSupported() {
+        return fileIcon;
+    }
+
+    /**
+     * Returns the file transfer size limit. It returns 0 if there is no limitation.
+     *
+     * @return Size in kilobytes
+     */
+    public long getMaxFileIconSize() {
+        return maxFileIconSize;
+    }
+
+    /**
+     * Returns the maximum number of file transfer session simultaneously
+     *
+     * @return numenr of sessions
+     */
+    public int getMaxFileTransfers() {
+        return maxFileTransfers;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl b/src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl
new file mode 100644
index 0000000..2aae4ae
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/IFileSpamReportListener.aidl
@@ -0,0 +1,10 @@
+package org.gsma.joyn.ft;
+
+/**
+ * New chat invitation event listener
+ */
+interface IFileSpamReportListener {
+	void onFileSpamReportSuccess( String contact, String ftId);
+	
+	void onFileSpamReportFailed( String contact, String ftId, int errorCode);
+}
diff --git a/src/java/org/gsma/joyn/ft/IFileTransfer.aidl b/src/java/org/gsma/joyn/ft/IFileTransfer.aidl
new file mode 100644
index 0000000..acb3a78
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/IFileTransfer.aidl
@@ -0,0 +1,43 @@
+package org.gsma.joyn.ft;
+
+import org.gsma.joyn.ft.IFileTransferListener;
+
+/**
+ * File transfer interface
+ */
+interface IFileTransfer {
+
+	String getTransferId();
+
+	String getRemoteContact();
+
+	String getFileName();
+
+	long getFileSize();
+
+	String getFileType();
+
+	String getFileIconName();
+
+	int getState();
+	
+	int getDirection();
+		
+	boolean isHttpFileTransfer();
+		
+	int getTransferDuration();
+		
+	void acceptInvitation();
+
+	void rejectInvitation();
+
+	void abortTransfer();
+	
+	void pauseTransfer();
+	
+	void resumeTransfer();
+
+	void addEventListener(in IFileTransferListener listener);
+
+	void removeEventListener(in IFileTransferListener listener);
+}
diff --git a/src/java/org/gsma/joyn/ft/IFileTransferListener.aidl b/src/java/org/gsma/joyn/ft/IFileTransferListener.aidl
new file mode 100644
index 0000000..d3bd179
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/IFileTransferListener.aidl
@@ -0,0 +1,20 @@
+package org.gsma.joyn.ft;
+
+/**
+ * Callback methods for file transfer events
+ */
+interface IFileTransferListener {
+	void onTransferStarted();
+	
+	void onTransferAborted();
+
+	void onTransferPaused();
+	
+	void onTransferResumed(in String oldFileTransferId, in String newFileTransferId);
+
+	void onTransferError(in int error);
+	
+	void onTransferProgress(in long currentSize, in long totalSize);
+
+	void onFileTransferred(in String filename);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/IFileTransferService.aidl b/src/java/org/gsma/joyn/ft/IFileTransferService.aidl
new file mode 100644
index 0000000..6521240
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/IFileTransferService.aidl
@@ -0,0 +1,64 @@
+package org.gsma.joyn.ft;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.ft.IFileTransfer;
+import org.gsma.joyn.ft.IFileTransferListener;
+import org.gsma.joyn.ft.INewFileTransferListener;
+import org.gsma.joyn.ft.IFileSpamReportListener;
+import org.gsma.joyn.ft.FileTransferServiceConfiguration;
+
+/**
+ * File transfer service API
+ */
+interface IFileTransferService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	FileTransferServiceConfiguration getConfiguration();
+
+	List<IBinder> getFileTransfers();
+	
+	IFileTransfer getFileTransfer(in String transferId);
+
+	IFileTransfer transferFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+	
+	IFileTransfer resumeFileTransfer(in String fileTranferId, in IFileTransferListener listener);
+
+	IFileTransfer transferBurnFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+
+        IFileTransfer transferGeoLocFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+	
+      IFileTransfer transferPublicChatFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener,int timeLen);
+	
+	IFileTransfer transferLargeModeFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+
+    IFileTransfer transferLargeModeBurnFile(in String contact, in String filename, in String fileicon, in IFileTransferListener listener);
+	
+	IFileTransfer transferFileToGroup(in String chatId,in List<String> contacts, in String filename, in String fileicon,in int timeLen, in IFileTransferListener listener);
+	
+	IFileTransfer transferMedia(in String contact,in String filename,in String fileicon,in IFileTransferListener listener,in int timeLen);
+	
+	IFileTransfer transferFileToMultirecepient(in List<String> contacts,in String filename,in boolean fileIcon,in IFileTransferListener listener,in int timeLen);
+	
+	void addNewFileTransferListener(in INewFileTransferListener listener);
+
+	void removeNewFileTransferListener(in INewFileTransferListener listener);
+	
+	int getServiceVersion();
+
+	void initiateFileSpamReport(String contact, String messageId);
+	
+	void addFileSpamReportListener(in IFileSpamReportListener listener);
+	
+	void removeFileSpamReportListener(in IFileSpamReportListener listener);
+
+  int getMaxFileTransfers();
+  
+  IFileTransfer resumeGroupFileTransfer(in String chatId, in String fileTranferId, in IFileTransferListener listener);
+  
+  IFileTransfer resumePublicFileTransfer(in String fileTranferId, in IFileTransferListener listener, int timeLen);
+  
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl b/src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl
new file mode 100644
index 0000000..d7eb0cb
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/INewFileTransferListener.aidl
@@ -0,0 +1,24 @@
+package org.gsma.joyn.ft;
+
+/**
+ * Callback method for new file transfer invitations and delivery reports
+ */
+interface INewFileTransferListener {
+	void onNewFileTransfer(in String transferId);
+	
+	void onReportFileDelivered(String transferId);
+	
+	void onReportFileDisplayed(String transferId);
+	
+	void onFileDeliveredReport(String transferId,String contact);
+	
+	void onFileDisplayedReport(String transferId,String contact);
+	
+	void onNewFileTransferReceived(String transferId,boolean isAutoAccept,boolean isGroup,String chatSessionId,String ChatId,int timeLen);
+	
+	void onNewPublicAccountChatFile(String transferId,boolean isAutoAccept,boolean isGroup,String chatSessionId,String ChatId);
+	
+    void onNewBurnFileTransfer(String transferId,boolean isGroup,String chatSessionId,String ChatId); 
+	
+	
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/MultiFileTransferLog.java b/src/java/org/gsma/joyn/ft/MultiFileTransferLog.java
new file mode 100644
index 0000000..5452e79
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/MultiFileTransferLog.java
@@ -0,0 +1,134 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+import android.net.Uri;
+
+/**
+ * Content provider for file transfer history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultiFileTransferLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.multift/multift");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the file transfer.
+     * <P>Type: TEXT</P>
+     */
+    public static final String FT_ID = "ft_id";
+
+    /**
+     * The name of the column containing the MSISDN of the sender.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the filename (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILENAME = "filename";
+
+    /**
+     * The name of the column containing the file size to be transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String FILESIZE = "filesize";
+
+    /**
+     * The name of the column containing the MIME-type of the file.
+     * <P>Type: TEXT</P>
+     */
+    public static final String MIME_TYPE = "mime_type";
+
+    /**
+     * The name of the column containing the direction of the transfer.
+     * <P>Type: INTEGER</P>
+     * @see FileTransfer.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the amount of data transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String TRANSFERRED = "transferred";
+
+    /**
+     * The name of the column containing the time when transfer is initiated.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the time when file is sent. If 0 means not sent.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_SENT = "timestamp_sent";
+
+    /**
+     * The name of the column containing the time when file is delivered. If 0 means not delivered.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_DELIVERED = "timestamp_delivered";
+
+    /**
+     * The name of the column containing the time when file is displayed. If 0 means not displayed.
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP_DISPLAYED = "timestamp_displayed";
+
+    /**
+     * The name of the column containing the state of the transfer.
+     * <P>Type: INTEGER</P>
+     * @see FileTransfer.State
+     */
+    public static final String STATE = "state";
+
+    /**
+     * The name of the column containing the file icon (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILEICON = "fileicon";
+
+    /**
+         * The name of the column containing the subject of the group chat.
+         * <P>Type: TEXT</P>
+         */
+        public static final String PARTICIPANTS_LIST = "participants";
+
+    /**
+     * The name of the column containing the chat ID used for the file transfer in group chat.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CHAT_ID = "chat_id";
+
+    public static final String MSG_ID = "msg_id";
+
+    public static final String DURATION = "duration";
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ft/NewFileTransferListener.java b/src/java/org/gsma/joyn/ft/NewFileTransferListener.java
new file mode 100644
index 0000000..97d7182
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/NewFileTransferListener.java
@@ -0,0 +1,97 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ft;
+
+
+/**
+ * New file transfer invitations event and delivery reports listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewFileTransferListener extends INewFileTransferListener.Stub {
+    /**
+     * Callback method for new file transfer invitations
+     *
+     * @param transferId Transfer ID
+     */
+    public abstract void onNewFileTransfer(String transferId);
+
+    /**
+     * Callback called when the file has been delivered
+     *
+     * @param transferId Transfer ID
+     */
+    public abstract void onReportFileDelivered(String transferId);
+
+    /**
+     * Callback called when the file has been displayed
+     *
+     * @param transferId Transfer ID
+     */
+    public abstract void onReportFileDisplayed(String transferId);
+
+    /**
+     * Callback method for new file transfer invitations
+     *
+     * @param transferId Transfer ID
+     */
+    public void onNewFileTransferReceived(
+                String transferId,
+                boolean isAutoAccept,
+                boolean isGroup,
+                String chatSessionId,
+                String ChatId,
+                int timeLen) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when the file has been delivered
+     *
+     * @param transferId Transfer ID
+     */
+    public void onFileDeliveredReport(String transferId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    /**
+     * Callback called when the file has been displayed
+     *
+     * @param transferId Transfer ID
+     */
+    public void onFileDisplayedReport(String transferId,String contact) {
+        // default implementation for TAPI extension
+    }
+
+    public void onNewBurnFileTransfer(
+                String transferId,
+                boolean isGroup,
+                String chatSessionId,
+                String ChatId) {
+        // default implementation for TAPI extension
+    }
+
+    public void onNewPublicAccountChatFile(
+                String transferId,
+                boolean isAutoAccept,
+                boolean isGroup,
+                String chatSessionId,
+                String ChatId) {
+        // default implementation for TAPI extension
+    }
+}
diff --git a/src/java/org/gsma/joyn/ft/package-info.java b/src/java/org/gsma/joyn/ft/package-info.java
new file mode 100644
index 0000000..51feeae
--- /dev/null
+++ b/src/java/org/gsma/joyn/ft/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * This API exposes all functionality to transfer files in real time.
+ * <p>
+ */
+package org.gsma.joyn.ft;
diff --git a/src/java/org/gsma/joyn/gsh/GeolocSharing.java b/src/java/org/gsma/joyn/gsh/GeolocSharing.java
new file mode 100644
index 0000000..b6f6cd4
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/GeolocSharing.java
@@ -0,0 +1,272 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.chat.Geoloc;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * Geoloc sharing
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GeolocSharing {
+
+    public static final String TAG = "TAPI-GeolocSharing";
+    /**
+     * Geoloc sharing state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Sharing invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Sharing invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Sharing is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Geoloc has been transferred with success
+         */
+        public final static int TRANSFERRED = 4;
+
+        /**
+         * Sharing has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Sharing has failed
+         */
+        public final static int FAILED = 6;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the sharing
+     */
+    public static class Direction {
+        /**
+         * Incoming sharing
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing sharing
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Geoloc sharing error
+     */
+    public static class Error {
+        /**
+         * Sharing has failed
+         */
+        public final static int SHARING_FAILED = 0;
+
+        /**
+         * Sharing invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Geoloc sharing interface
+     */
+    private IGeolocSharing sharingInf;
+
+    /**
+     * Constructor
+     *
+     * @param sharingInf Geoloc sharing interface
+     */
+    GeolocSharing(IGeolocSharing sharingInf) {
+        this.sharingInf = sharingInf;
+    }
+
+    /**
+     * Returns the sharing ID of the geoloc sharing
+     *
+     * @return Sharing ID
+     * @throws JoynServiceException
+     */
+    public String getSharingId() throws JoynServiceException {
+        Logger.i(TAG, "getSharingId() entry ");
+        try {
+            return sharingInf.getSharingId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact() entry ");
+        try {
+            return sharingInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the geolocation info
+     *
+     * @return Geoloc object
+     * @throws JoynServiceException
+     * @see Geoloc
+     */
+    public Geoloc getGeoloc() throws JoynServiceException {
+        Logger.i(TAG, "getGeoloc() entry ");
+        try {
+            return sharingInf.getGeoloc();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the sharing
+     *
+     * @return State
+     * @see GeolocSharing.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        Logger.i(TAG, "getState() entry ");
+        try {
+            return sharingInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the sharing (incoming or outgoing)
+     *
+     * @return Direction
+     * @see GeolocSharing.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        Logger.i(TAG, "getDirection() entry ");
+        try {
+            return sharingInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts geoloc sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        Logger.i(TAG, "acceptInvitation() entry ");
+        try {
+            sharingInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects geoloc sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        Logger.i(TAG, "rejectInvitation() entry ");
+        try {
+            sharingInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the sharing
+     *
+     * @throws JoynServiceException
+     */
+    public void abortSharing() throws JoynServiceException {
+        Logger.i(TAG, "abortSharing() entry ");
+        try {
+            sharingInf.abortSharing();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on geoloc sharing events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(GeolocSharingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addEventListener() entry " + listener);
+        try {
+            sharingInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from geoloc sharing
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(GeolocSharingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeEventListener() entry " + listener);
+        try {
+            sharingInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/gsh/GeolocSharingIntent.java b/src/java/org/gsma/joyn/gsh/GeolocSharingIntent.java
new file mode 100644
index 0000000..d8fff30
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/GeolocSharingIntent.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+/**
+ * Intent for geoloc sharing invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GeolocSharingIntent {
+    /**
+     * Broadcast action: a new geoloc sharing invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_SHARING_ID} containing the unique ID of the geoloc sharing.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.gsh.action.NEW_GEOLOC_SHARING";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the geoloc sharing
+     */
+    public final static String EXTRA_SHARING_ID = "sharingId";
+}
diff --git a/src/java/org/gsma/joyn/gsh/GeolocSharingListener.java b/src/java/org/gsma/joyn/gsh/GeolocSharingListener.java
new file mode 100644
index 0000000..d0c5a0a
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/GeolocSharingListener.java
@@ -0,0 +1,60 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Geoloc sharing event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class GeolocSharingListener extends IGeolocSharingListener.Stub {
+    /**
+     * Callback called when the sharing is started
+     */
+    public abstract void onSharingStarted();
+
+    /**
+     * Callback called when the sharing has been aborted
+     */
+    public abstract void onSharingAborted();
+
+    /**
+     * Callback called when the sharing has failed
+     *
+     * @param error Error
+     * @see GeolocSharing.Error
+     */
+    public abstract void onSharingError(int error);
+
+    /**
+     * Callback called during the sharing progress
+     *
+     * @param currentSize Current transferred size in bytes
+     * @param totalSize Total size to transfer in bytes
+     */
+    public abstract void onSharingProgress(long currentSize, long totalSize);
+
+    /**
+     * Callback called when the geoloc has been shared
+     *
+     * @param geoloc Geoloc object
+     */
+    public abstract void onGeolocShared(Geoloc geoloc);
+}
diff --git a/src/java/org/gsma/joyn/gsh/GeolocSharingService.java b/src/java/org/gsma/joyn/gsh/GeolocSharingService.java
new file mode 100644
index 0000000..c9f7e57
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/GeolocSharingService.java
@@ -0,0 +1,286 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.Permissions;
+import org.gsma.joyn.chat.Geoloc;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+import org.gsma.joyn.Logger;
+/**
+ * This class offers the main entry point to share geolocation info
+ * during a CS call. Several applications may connect/disconnect to
+ * the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class GeolocSharingService extends JoynService {
+    /**
+     * API
+     */
+    private IGeolocSharingService api = null;
+
+    public static final String TAG = "TAPI-GeolocSharingService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public GeolocSharingService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "GeolocSharing connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IGeolocSharingService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected entry " + className);
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getGeolocServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IGeolocSharingService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected entry " + className);
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Shares a geolocation with a contact. An exception if thrown if there is no ongoing
+     * CS call. The parameter contact supports the following formats: MSISDN in national
+     * or international format, SIP address, SIP-URI or Tel-URI. If the format of the
+     * contact is not supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @param geoloc Geolocation info
+     * @param listener Geoloc sharing event listener
+     * @return Geoloc sharing
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     * @see Geoloc
+     */
+    public GeolocSharing shareGeoloc(String contact, Geoloc geoloc, GeolocSharingListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_LOCATION_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_LOCATION_SEND");
+        }
+        if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_USE_CHAT) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_USE_CHAT");
+        }
+
+        Logger.i(TAG, "shareGeoloc() entry contact=" + contact + " geoloc =" + geoloc + " listener =" + listener);
+        if (api != null) {
+            try {
+                IGeolocSharing sharingIntf = api.shareGeoloc(contact, geoloc, listener);
+                if (sharingIntf != null) {
+                    return new GeolocSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of geoloc sharings in progress
+     *
+     * @return List of geoloc sharings
+     * @throws JoynServiceException
+     */
+    public Set<GeolocSharing> getGeolocSharings() throws JoynServiceException {
+        Logger.i(TAG, "getGeolocSharings entry ");
+        if (api != null) {
+            try {
+                Set<GeolocSharing> result = new HashSet<GeolocSharing>();
+                List<IBinder> ishList = api.getGeolocSharings();
+                for (IBinder binder : ishList) {
+                    GeolocSharing sharing = new GeolocSharing(IGeolocSharing.Stub.asInterface(binder));
+                    result.add(sharing);
+                }
+                Logger.i(TAG, "getGeolocSharings returning " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current geoloc sharing from its unique ID
+     *
+     * @param sharingId Sharing ID
+     * @return Geoloc sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public GeolocSharing getGeolocSharing(String sharingId) throws JoynServiceException {
+        Logger.i(TAG, "getGeolocSharing entry " + sharingId);
+        if (api != null) {
+            try {
+                IGeolocSharing sharingIntf = api.getGeolocSharing(sharingId);
+                if (sharingIntf != null) {
+                    return new GeolocSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current geoloc sharing from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return Geoloc sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public GeolocSharing getGeolocSharingFor(Intent intent) throws JoynServiceException {
+        Logger.i(TAG, "getGeolocSharingFor entry " + intent);
+        if (api != null) {
+            try {
+                String sharingId = intent.getStringExtra(GeolocSharingIntent.EXTRA_SHARING_ID);
+                if (sharingId != null) {
+                    return getGeolocSharing(sharingId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a new geoloc sharing invitation listener
+     *
+     * @param listener New geoloc sharing listener
+     * @throws JoynServiceException
+     */
+    public void addNewGeolocSharingListener(NewGeolocSharingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addNewGeolocSharingListener entry " + listener);
+        if (api != null) {
+            try {
+                api.addNewGeolocSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a new geoloc sharing invitation listener
+     *
+     * @param listener New geoloc sharing listener
+     * @throws JoynServiceException
+     */
+    public void removeNewGeolocSharingListener(NewGeolocSharingListener listener) throws JoynServiceException {
+        Logger.i(TAG, "removeNewGeolocSharingListener entry " + listener);
+        if (api != null) {
+            try {
+                api.removeNewGeolocSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl b/src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl
new file mode 100644
index 0000000..bf30a39
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/IGeolocSharing.aidl
@@ -0,0 +1,30 @@
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.gsh.IGeolocSharingListener;
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Geoloc sharing interface
+ */
+interface IGeolocSharing {
+
+	String getSharingId();
+
+	String getRemoteContact();
+
+	Geoloc getGeoloc();
+
+	int getState();
+	
+	int getDirection();
+		
+	void acceptInvitation();
+
+	void rejectInvitation();
+
+	void abortSharing();
+	
+	void addEventListener(in IGeolocSharingListener listener);
+
+	void removeEventListener(in IGeolocSharingListener listener);
+}
diff --git a/src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl b/src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl
new file mode 100644
index 0000000..64199bf
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/IGeolocSharingListener.aidl
@@ -0,0 +1,18 @@
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Callback methods for geoloc sharing events
+ */
+interface IGeolocSharingListener {
+	void onSharingStarted();
+	
+	void onSharingAborted();
+
+	void onSharingError(in int error);
+	
+	void onSharingProgress(in long currentSize, in long totalSize);
+
+	void onGeolocShared(in Geoloc geoloc);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl b/src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl
new file mode 100644
index 0000000..110a663
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/IGeolocSharingService.aidl
@@ -0,0 +1,30 @@
+package org.gsma.joyn.gsh;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.gsh.IGeolocSharing;
+import org.gsma.joyn.gsh.IGeolocSharingListener;
+import org.gsma.joyn.gsh.INewGeolocSharingListener;
+import org.gsma.joyn.chat.Geoloc;
+
+/**
+ * Geoloc sharing service API
+ */
+interface IGeolocSharingService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	List<IBinder> getGeolocSharings();
+	
+	IGeolocSharing getGeolocSharing(in String sharingId);
+
+	IGeolocSharing shareGeoloc(in String contact, in Geoloc geoloc, in IGeolocSharingListener listener);
+	
+	void addNewGeolocSharingListener(in INewGeolocSharingListener listener);
+
+	void removeNewGeolocSharingListener(in INewGeolocSharingListener listener);
+	
+	int getServiceVersion();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl b/src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl
new file mode 100644
index 0000000..87df505
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/INewGeolocSharingListener.aidl
@@ -0,0 +1,8 @@
+package org.gsma.joyn.gsh;
+
+/**
+ * Callback method for new geoloc sharing invitations
+ */
+interface INewGeolocSharingListener {
+	void onNewGeolocSharing(in String sharingId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/gsh/NewGeolocSharingListener.java b/src/java/org/gsma/joyn/gsh/NewGeolocSharingListener.java
new file mode 100644
index 0000000..af4da26
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/NewGeolocSharingListener.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.gsh;
+
+
+/**
+ * New geoloc sharing invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewGeolocSharingListener extends INewGeolocSharingListener.Stub {
+    /**
+     * Callback called when a new geoloc sharing invitation has been received
+     *
+     * @param sharingId Sharing ID
+     */
+    public abstract void onNewGeolocSharing(String sharingId);
+}
diff --git a/src/java/org/gsma/joyn/gsh/package-info.java b/src/java/org/gsma/joyn/gsh/package-info.java
new file mode 100644
index 0000000..ff846c2
--- /dev/null
+++ b/src/java/org/gsma/joyn/gsh/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * This API exposes exposes all functionality related to sharing geolocations
+ * during a CS call via the Geoloc Sharing service.
+ * <p>
+ */
+package org.gsma.joyn.gsh;
diff --git a/src/java/org/gsma/joyn/ipcall/AudioCodec.aidl b/src/java/org/gsma/joyn/ipcall/AudioCodec.aidl
new file mode 100644
index 0000000..16b123c
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/AudioCodec.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * Audio codec object
+ */
+parcelable AudioCodec;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/AudioCodec.java b/src/java/org/gsma/joyn/ipcall/AudioCodec.java
new file mode 100644
index 0000000..fa615b9
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/AudioCodec.java
@@ -0,0 +1,202 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Audio codec
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class AudioCodec implements Parcelable {
+    /**
+     * Audio encoding
+     */
+    private String encoding;
+
+    /**
+     * Payload
+     */
+    private int payload;
+
+    /**
+     * Sample rate
+     */
+    private int sampleRate;
+
+    /**
+     * Audio parameters
+     */
+    private String parameters;
+
+    public static final String TAG = "AudioCodec";
+
+    /**
+     * Constructor
+     *
+     * @param encoding Audio encoding
+     * @param payload Payload
+     * @param sampleRate Sample rate
+     * @param parameters Codec parameters
+     * @hide
+     */
+    public AudioCodec(String encoding, int payload, int sampleRate, String parameters) {
+        Logger.i(TAG, "AudioCodec entry " + "encoding-" + encoding + "payload-" + "sampleRate-" + sampleRate + "parameters-" + parameters);
+        this.encoding = encoding;
+        this.payload = payload;
+        this.sampleRate = sampleRate;
+        this.parameters = parameters;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public AudioCodec(Parcel source) {
+        this.encoding = source.readString();
+        this.payload = source.readInt();
+        this.sampleRate = source.readInt();
+        this.parameters = source.readString();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(encoding);
+        dest.writeInt(payload);
+        dest.writeInt(sampleRate);
+        dest.writeString(parameters);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<AudioCodec> CREATOR
+            = new Parcelable.Creator<AudioCodec>() {
+        public AudioCodec createFromParcel(Parcel source) {
+            return new AudioCodec(source);
+        }
+
+        public AudioCodec[] newArray(int size) {
+            return new AudioCodec[size];
+        }
+    };
+
+    /**
+    * Returns the encoding name (e.g. H264)
+    *
+    * @return Encoding name
+    */
+    public String getEncoding() {
+        Logger.i(TAG, "getEncoding value " + encoding);
+        return encoding;
+    }
+
+    /**
+     * Returns the codec payload type (e.g. 96)
+     *
+     * @return Payload type
+     */
+    public int getPayloadType() {
+        Logger.i(TAG, "getPayloadType value " + payload);
+        return payload;
+    }
+
+    /**
+     * Returns the codec sample rate (e.g. 15)
+     *
+     * @return Clock rate
+     */
+    public int getSampleRate() {
+        Logger.i(TAG, "getSampleRate value " + sampleRate);
+        return sampleRate;
+    }
+
+    /**
+     * Returns the list of codec parameters (e.g. packetization-mode).
+     * Parameters are are semicolon separated.
+     *
+     * @return Parameters
+     */
+    public String getParameters() {
+        Logger.i(TAG, "getParameters value " + parameters);
+        return parameters;
+    }
+
+    /**
+     * Returns the value of codec parameter key (e.g. profile-level-id, packetization-mode).
+     *
+     * @return Parameters
+     */
+    public String getParameter(String key) {
+        String value = null;
+        String[] parameters = getParameters().split(",");
+        ArrayList<String> codecparams = new ArrayList<String>(Arrays.asList(parameters));
+        for (int i = 0; i < codecparams.size() ; i++)
+        {
+            if (codecparams.get(i).startsWith(key))
+            {
+                value = codecparams.get(i).substring(key.length() + 1);
+            }
+        }
+        Logger.i(TAG, "getParameter key - " + key + " value -" + value);
+        return value;
+    }
+
+    /**
+     * Compare codec encodings
+     *
+     * @param codec Codec to compare
+     * @return True if codecs are equals
+     */
+    public boolean compare(AudioCodec codec) {
+        boolean ret = false;
+        if (getEncoding().equalsIgnoreCase(codec.getEncoding())) {
+            ret = true;
+        }
+        Logger.i(TAG, "compare value " + ret);
+        return ret;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCall.aidl b/src/java/org/gsma/joyn/ipcall/IIPCall.aidl
new file mode 100644
index 0000000..434f0d6
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCall.aidl
@@ -0,0 +1,41 @@
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.ipcall.IIPCallListener;
+import org.gsma.joyn.ipcall.IIPCallPlayer;
+import org.gsma.joyn.ipcall.IIPCallRenderer;
+
+/**
+ * IP call interface
+ */
+interface IIPCall {
+
+	String getCallId();
+
+	String getRemoteContact();
+
+	int getState();
+
+	int getDirection();
+	
+	void acceptInvitation(IIPCallPlayer player, IIPCallRenderer renderer);
+
+	void rejectInvitation();
+
+	void abortCall();
+
+	boolean isVideo();
+
+	void addVideo();
+
+	void removeVideo();
+
+	boolean isOnHold();
+
+	void holdCall();
+
+	void continueCall();
+	
+	void addEventListener(in IIPCallListener listener);
+
+	void removeEventListener(in IIPCallListener listener);
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl
new file mode 100644
index 0000000..4f32392
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallListener.aidl
@@ -0,0 +1,17 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * Callback methods for IP call events
+ */
+interface IIPCallListener {	
+
+	void onCallStarted();
+	
+	void onCallAborted();
+
+	void onCallHeld();
+
+	void onCallContinue();
+
+	void onCallError(in int error);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl
new file mode 100644
index 0000000..51f28e1
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallPlayer.aidl
@@ -0,0 +1,34 @@
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.ipcall.IIPCallPlayerListener;
+import org.gsma.joyn.ipcall.AudioCodec;
+import org.gsma.joyn.ipcall.VideoCodec;
+
+/**
+ * IP call player interface
+ */
+interface IIPCallPlayer {
+	void open(in AudioCodec audiocodec, in VideoCodec videocodec, in String remoteHost, in int remoteAudioPort, in int remoteVideoPort);
+	
+	void close();
+
+	void start();
+
+	void stop();
+
+	int getLocalAudioRtpPort();
+
+	AudioCodec getAudioCodec();
+
+	AudioCodec[] getSupportedAudioCodecs();
+
+	int getLocalVideoRtpPort();
+
+	VideoCodec getVideoCodec();
+	
+	VideoCodec[] getSupportedVideoCodecs();
+
+	void addEventListener(in IIPCallPlayerListener listener);
+
+	void removeEventListener(in IIPCallPlayerListener listener);
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl
new file mode 100644
index 0000000..9414885
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallPlayerListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * IP call player event listener interface
+ */
+interface IIPCallPlayerListener {
+	void onPlayerOpened();
+
+	void onPlayerStarted();
+
+	void onPlayerStopped();
+
+	void onPlayerClosed();
+
+	void onPlayerFailed();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl
new file mode 100644
index 0000000..927d52e
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallRenderer.aidl
@@ -0,0 +1,34 @@
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.ipcall.IIPCallRendererListener;
+import org.gsma.joyn.ipcall.AudioCodec;
+import org.gsma.joyn.ipcall.VideoCodec;
+
+/**
+ * IP call renderer interface
+ */
+interface IIPCallRenderer {
+	void open(in AudioCodec audiocodec, in VideoCodec videocodec, in String remoteHost, in int remoteAudioPort, in int remoteVideoPort);
+
+	void close();
+
+	void start();
+
+	void stop();
+
+	int getLocalAudioRtpPort();
+
+	AudioCodec getAudioCodec();
+
+	AudioCodec[] getSupportedAudioCodecs();
+
+	int getLocalVideoRtpPort();
+
+	VideoCodec getVideoCodec();
+	
+	VideoCodec[] getSupportedVideoCodecs();
+
+	void addEventListener(in IIPCallRendererListener listener);
+
+	void removeEventListener(in IIPCallRendererListener listener);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl
new file mode 100644
index 0000000..46786a1
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallRendererListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * IP call renderer event listener interface
+ */
+interface IIPCallRendererListener {
+	void onRendererOpened();
+
+	void onRendererStarted();
+
+	void onRendererStopped();
+
+	void onRendererClosed();
+
+	void onRendererFailed();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IIPCallService.aidl b/src/java/org/gsma/joyn/ipcall/IIPCallService.aidl
new file mode 100644
index 0000000..52b3f08
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IIPCallService.aidl
@@ -0,0 +1,36 @@
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.ipcall.IIPCall;
+import org.gsma.joyn.ipcall.IIPCallListener;
+import org.gsma.joyn.ipcall.INewIPCallListener;
+import org.gsma.joyn.ipcall.IIPCallPlayer;
+import org.gsma.joyn.ipcall.IIPCallRenderer;
+import org.gsma.joyn.ipcall.IPCallServiceConfiguration;
+
+/**
+ * IP call service API
+ */
+interface IIPCallService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	IPCallServiceConfiguration getConfiguration();
+
+	List<IBinder> getIPCalls();
+	
+	IIPCall getIPCall(in String callId);
+
+	IIPCall initiateCall(in String contact, in IIPCallPlayer player, in IIPCallRenderer renderer, in IIPCallListener listener);
+	
+	IIPCall initiateVisioCall(in String contact, in IIPCallPlayer player, in IIPCallRenderer renderer, in IIPCallListener listener);
+
+	void addNewIPCallListener(in INewIPCallListener listener);
+
+	void removeNewIPCallListener(in INewIPCallListener listener);
+	
+	int getServiceVersion();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl b/src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl
new file mode 100644
index 0000000..6981562
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/INewIPCallListener.aidl
@@ -0,0 +1,8 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * Callback method for new IP call invitations
+ */
+interface INewIPCallListener {
+	void onNewIPCall(in String callId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/IPCall.java b/src/java/org/gsma/joyn/ipcall/IPCall.java
new file mode 100644
index 0000000..26e7c09
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCall.java
@@ -0,0 +1,361 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.JoynServiceException;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * IP call
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCall {
+
+    /**
+     * IP call state
+     */
+
+    public static final String TAG = "IPCall";
+
+
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Call invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Call invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Call is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * call has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Call has been terminated
+         */
+        public static final int TERMINATED = 6;
+
+        /**
+         * Call has failed
+         */
+        public final static int FAILED = 7;
+
+        /**
+         * Call on hold
+         */
+        public final static int HOLD = 8;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the call
+     */
+    public static class Direction {
+        /**
+         * Incoming call
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing call
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Call error
+     */
+    public static class Error {
+        /**
+         * Call has failed
+         */
+        public final static int CALL_FAILED = 0;
+
+        /**
+         * Call invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * IP call interface
+     */
+    private IIPCall callInf;
+
+    /**
+     * Constructor
+     *
+     * @param callInf IP call interface
+     */
+    IPCall(IIPCall callInf) {
+        this.callInf = callInf;
+    }
+
+    /**
+     * Returns the call ID of call
+     *
+     * @return Call ID
+     * @throws JoynServiceException
+     */
+    public String getCallId() throws JoynServiceException {
+        Logger.i(TAG, "getCallId entry");
+        try {
+            String callId = callInf.getCallId();
+            Logger.i(TAG, "getCallId entry" + callId);
+            return callId;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        Logger.i(TAG, "getRemoteContact entry");
+        try {
+            String contact = callInf.getRemoteContact();
+            Logger.i(TAG, "getRemoteContact value " + contact);
+            return contact;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the call
+     *
+     * @return State
+     * @see IPCall.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        Logger.i(TAG, "getState entry");
+        try {
+            int State = callInf.getState();
+            Logger.i(TAG, "getState value " + State);
+            return State;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the call (incoming or outgoing)
+     *
+     * @return Direction
+     * @see IPCall.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        Logger.i(TAG, "getDirection entry");
+        try {
+            int direction = callInf.getDirection();
+            Logger.i(TAG, "getDirection value" + direction);
+            return direction;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts call invitation
+     *
+     * @param player IP call player
+     * @param renderer IP call renderer
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation(IPCallPlayer player, IPCallRenderer renderer) throws JoynServiceException {
+        try {
+            Logger.i(TAG, "acceptInvitation entry");
+            callInf.acceptInvitation(player, renderer);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects call invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "rejectInvitation entry");
+            callInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the call
+     *
+     * @throws JoynServiceException
+     */
+    public void abortCall() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "abortCall entry");
+            callInf.abortCall();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Is video activated
+     *
+     * @return Boolean
+     * @throws JoynServiceException
+     */
+    public boolean isVideo() throws JoynServiceException {
+        try {
+            boolean isVideo = callInf.isVideo();
+            Logger.i(TAG, "abortCall value" + isVideo);
+            return isVideo;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Add video stream
+     *
+     * @throws JoynServiceException
+     */
+    public void addVideo() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "addVideo entry");
+            callInf.addVideo();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Remove video stream
+     *
+     * @throws JoynServiceException
+     */
+    public void removeVideo() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "removeVideo entry");
+            callInf.removeVideo();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Is call on hold
+     *
+     * @return Boolean
+     * @throws JoynServiceException
+     */
+    public boolean isOnHold() throws JoynServiceException {
+        try {
+            boolean isonHold = callInf.isOnHold();
+            Logger.i(TAG, "isOnHold value" + isonHold);
+            return isonHold;
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Puts the call on hold
+     *
+     * @throws JoynServiceException
+     */
+    public void holdCall() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "holdCall entry");
+            callInf.holdCall();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Continues the call that hold's on
+     *
+     * @throws JoynServiceException
+     */
+    public void continueCall() throws JoynServiceException {
+        try {
+            Logger.i(TAG, "continueCall entry");
+            callInf.continueCall();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on IP call events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(IPCallListener listener) throws JoynServiceException {
+        try {
+            Logger.i(TAG, "addEventListener entry" + listener);
+            callInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from IP call events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(IPCallListener listener) throws JoynServiceException {
+        try {
+            Logger.i(TAG, "removeEventListener entry" + listener);
+            callInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallIntent.java b/src/java/org/gsma/joyn/ipcall/IPCallIntent.java
new file mode 100644
index 0000000..248545e
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallIntent.java
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+/**
+ * Intent for IP call invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCallIntent {
+    /**
+     * Broadcast action: a new IP call invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_CALL_ID} containing the unique ID of the IP call.
+     * <li> {@link #EXTRA_AUDIO_ENCODING} containing the audio encoding.
+     * <li> {@link #EXTRA_VIDEO_ENCODING} containing the video encoding.
+     * <li> {@link #EXTRA_VIDEO_FORMAT} containing the video format.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.ipcall.action.NEW_CALL";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the call
+     */
+    public final static String EXTRA_CALL_ID = "callId";
+
+    /**
+     * Audio encoding (e.g. AMR)
+     */
+    public final static String EXTRA_AUDIO_ENCODING = "audioEncoding";
+
+    /**
+     * Video encoding (e.g. H264)
+     */
+    public final static String EXTRA_VIDEO_ENCODING = "videoEncoding";
+
+    /**
+     * Video format (e.g. QCIF)
+     */
+    public final static String EXTRA_VIDEO_FORMAT = "videoFormat";
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallListener.java b/src/java/org/gsma/joyn/ipcall/IPCallListener.java
new file mode 100644
index 0000000..b4d88c1
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallListener.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+
+/**
+ * IP call event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallListener extends IIPCallListener.Stub {
+
+
+    /**
+     * Callback called when the call is started
+     */
+    public abstract void onCallStarted();
+
+    /**
+     * Callback called when the call has been aborted or terminated
+     */
+    public abstract void onCallAborted();
+
+    /**
+     * Callback called when the call has failed
+     *
+     * @param error Error
+     * @see IPCall.Error
+     */
+    public abstract void onCallError(int error);
+
+    /**
+     * Callback called when the call has been held
+     */
+    public abstract void onCallHeld();
+
+    /**
+     * Callback called when the call continues after on hold
+     */
+    public abstract void onCallContinue();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallLog.java b/src/java/org/gsma/joyn/ipcall/IPCallLog.java
new file mode 100644
index 0000000..054c463
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallLog.java
@@ -0,0 +1,77 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import android.net.Uri;
+
+/**
+ * Content provider for IP call history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCallLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.ipcall/ipcall");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the call.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CALL_ID = "call_id";
+
+    /**
+     * The name of the column containing the MSISDN of the remote party.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the direction of the call.
+     * <P>Type: INTEGER</P>
+     * @see IPCall.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the date of the call (in milliseconds).
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the duration of the call (in seconds). The
+     * value is only set at the end of the call.
+     * <P>Type: LONG</P>
+     */
+    public static final String DURATION = "duration";
+
+    /**
+     * The name of the column containing the state of the call.
+     * <P>Type: INTEGER</P>
+     * @see IPCall.State
+     */
+    public static final String STATE = "state";
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallPlayer.java b/src/java/org/gsma/joyn/ipcall/IPCallPlayer.java
new file mode 100644
index 0000000..ada02d4
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallPlayer.java
@@ -0,0 +1,167 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.HashSet;
+import java.util.Set;
+
+
+
+/**
+ * IP call player offers an interface to manage the IP call player instance
+ * independently of the joyn service. The IP call player is implemented in
+ * the application side. The IP call player captures the audio/video from the
+ * device micro/camera, encodes the audio/video into the selected formats,
+ * streams the encoded audio samples and video frames over the network in RTP.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallPlayer extends IIPCallPlayer.Stub {
+    /**
+     * IP call player error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Network connection failed
+         */
+        public final static int NETWORK_FAILURE = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * IP call player event listeners
+     */
+    private Set<IPCallPlayerListener> listeners = new HashSet<IPCallPlayerListener>();
+
+    /**
+     * Constructor
+     */
+    public IPCallPlayer() {
+    }
+
+    /**
+     * Opens the player and prepares resources (e.g. encoder, micro, camera)
+     *
+     * @param audiocodec Audio codec
+     * @param videocodec Video codec
+     * @param remoteHost Remote RTP host
+     * @param remoteAudioPort Remote audio RTP port
+     * @param remoteVideoPort Remote video RTP port
+     */
+    public abstract void open(AudioCodec audiocodec, VideoCodec videocodec, String remoteHost, int remoteAudioPort, int remoteVideoPort);
+
+    /**
+     * Closes the player and deallocates resources
+     *
+     * @throws JoynServiceException
+     */
+    public abstract void close();
+
+    /**
+     * Starts the player
+     */
+    public abstract void start();
+
+    /**
+     * Stops the player
+     */
+    public abstract void stop();
+
+    /**
+     * Returns the local RTP port used to stream audio
+     *
+     * @return Port number
+     */
+    public abstract int getLocalAudioRtpPort();
+
+    /**
+     * Returns the current audio codec
+     *
+     * @return Audo codec
+     */
+    public abstract AudioCodec getAudioCodec();
+
+    /**
+     * Returns the list of audio codecs supported by the player
+     *
+     * @return List of audio codecs
+     */
+    public abstract AudioCodec[] getSupportedAudioCodecs();
+
+    /**
+     * Returns the local RTP port used to stream video
+     *
+     * @return Port number
+     */
+    public abstract int getLocalVideoRtpPort();
+
+    /**
+     * Returns the current video codec
+     *
+     * @return Video codec
+     */
+    public abstract VideoCodec getVideoCodec();
+
+    /**
+     * Returns the list of video codecs supported by the player
+     *
+     * @return List of video codecs
+     */
+    public abstract VideoCodec[] getSupportedVideoCodecs();
+
+    /**
+     * Returns the list of player event listeners
+     *
+     * @return Listeners
+     */
+    public Set<IPCallPlayerListener> getEventListeners() {
+        return listeners;
+    }
+
+    /**
+     * Adds a listener on player events
+     *
+     * @param listener Listener
+     */
+    public void addEventListener(IPCallPlayerListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a listener from player events
+     *
+     * @param listener Listener
+     */
+    public void removeEventListener(IPCallPlayerListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all listeners from player events
+     */
+    public void removeAllEventListeners() {
+        listeners.clear();
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallPlayerListener.java b/src/java/org/gsma/joyn/ipcall/IPCallPlayerListener.java
new file mode 100644
index 0000000..65083c5
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallPlayerListener.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+
+/**
+ * This class offers callback methods on IP call player events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallPlayerListener extends IIPCallPlayerListener.Stub {
+    /**
+     * Callback called when the player is opened
+     */
+    public abstract void onPlayerOpened();
+
+    /**
+     * Callback called when the player is started
+     */
+    public abstract void onPlayerStarted();
+
+    /**
+     * Callback called when the player is stopped
+     */
+    public abstract void onPlayerStopped();
+
+    /**
+     * Callback called when the player is closed
+     */
+    public abstract void onPlayerClosed();
+
+    /**
+     * Callback called when the player has failed
+     *
+     * @param error Error
+     */
+    public abstract void onPlayerFailed();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallRenderer.java b/src/java/org/gsma/joyn/ipcall/IPCallRenderer.java
new file mode 100644
index 0000000..588b527
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallRenderer.java
@@ -0,0 +1,163 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * IP call renderer offers an interface to manage the IP call renderer instance
+ * independently of the joyn service. The IP call renderer is implemented in
+ * the application side. The IP call renderer receives the audio/video streaming
+ * over the network in RTP, decodes the audio samples and video frames, plays
+ * decoded audio samples and displays the decoded picture on the device screen.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallRenderer extends IIPCallRenderer.Stub {
+    /**
+     * IP call renderer error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Network connection failed
+         */
+        public final static int NETWORK_FAILURE = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * IP call renderer event listeners
+     */
+    private Set<IPCallRendererListener> listeners = new HashSet<IPCallRendererListener>();
+
+    /**
+     * Constructor
+     */
+    public IPCallRenderer() {
+    }
+
+    /**
+     * Opens the renderer and prepares resources (e.g. decoder)
+     *
+     * @param audiocodec Audio codec
+     * @param videocodec Video codec
+     * @param remoteHost Remote RTP host
+     * @param remoteAudioPort Remote audio RTP port
+     * @param remoteVideoPort Remote video RTP port
+     */
+    public abstract void open(AudioCodec audiocodec, VideoCodec videocodec, String remoteHost, int remoteAudioPort, int remoteVideoPort);
+
+    /**
+     * Closes the renderer and deallocates resources
+     */
+    public abstract void close();
+
+    /**
+     * Starts the renderer
+     */
+    public abstract void start();
+
+    /**
+     * Stops the renderer
+     */
+    public abstract void stop();
+
+    /**
+     * Returns the current audio codec
+     *
+     * @return Audo codec
+     */
+    public abstract AudioCodec getAudioCodec();
+
+    /**
+     * Returns the list of audio codecs supported by the player
+     *
+     * @return List of audio codecs
+     */
+    public abstract AudioCodec[] getSupportedAudioCodecs();
+
+    /**
+     * Returns the local RTP port used to stream video
+     *
+     * @return Port number
+     */
+    public abstract int getLocalVideoRtpPort();
+
+    /**
+     * Returns the local RTP port used to stream audio
+     *
+     * @return Port number
+     */
+    public abstract int getLocalAudioRtpPort();
+
+    /**
+     * Returns the current video codec
+     *
+     * @return Video codec
+     */
+    public abstract VideoCodec getVideoCodec();
+
+    /**
+     * Returns the list of video codecs supported by the player
+     *
+     * @return List of video codecs
+     */
+    public abstract VideoCodec[] getSupportedVideoCodecs();
+
+    /**
+     * Returns the list of renderer event listeners
+     *
+     * @return Listeners
+     */
+    public Set<IPCallRendererListener> getEventListeners() {
+        return listeners;
+    }
+
+    /**
+     * Adds a listener on renderer events
+     *
+     * @param listener Listener
+     */
+    public void addEventListener(IPCallRendererListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a listener from renderer events
+     *
+     * @param listener Listener
+     */
+    public void removeEventListener(IPCallRendererListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all listeners from renderer events
+     */
+    public void removeAllEventListeners() {
+        listeners.clear();
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallRendererListener.java b/src/java/org/gsma/joyn/ipcall/IPCallRendererListener.java
new file mode 100644
index 0000000..72cf6e7
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallRendererListener.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+
+/**
+ * This class offers callback methods on IP call renderer events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class IPCallRendererListener extends IIPCallRendererListener.Stub {
+    /**
+     * Callback called when the renderer is opened
+     */
+    public abstract void onRendererOpened();
+
+    /**
+     * Callback called when the renderer is started
+     */
+    public abstract void onRendererStarted();
+
+    /**
+     * Callback called when the renderer is stopped
+     */
+    public abstract void onRendererStopped();
+
+    /**
+     * Callback called when the renderer is closed
+     */
+    public abstract void onRendererClosed();
+
+    /**
+     * Callback called when the renderer has failed
+     *
+     * @param error Error
+     */
+    public abstract void onRendererFailed();
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallService.java b/src/java/org/gsma/joyn/ipcall/IPCallService.java
new file mode 100644
index 0000000..8a0a8f1
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallService.java
@@ -0,0 +1,415 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+import org.gsma.joyn.Permissions;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.pm.PackageManager;
+import android.os.IBinder;
+import android.os.IInterface;
+
+import android.os.RemoteException;
+import org.gsma.joyn.Logger;
+
+/**
+ * This class offers the main entry point to initiate IP calls. Several
+ * applications may connect/disconnect to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCallService extends JoynService {
+    /**
+     * API
+     */
+    private IIPCallService api = null;
+
+    public static final String TAG = "IPCallService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public IPCallService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_USE_IPCALL) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_USE_IPCALL");
+        }
+        Logger.i(TAG, "connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            Logger.i(TAG, "disconnect() entry");
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+        Logger.i(TAG, "setApi() entry" + api);
+        this.api = (IIPCallService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            Logger.i(TAG, "onServiceConnected() entry");
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getIPCallServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IIPCallService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            Logger.i(TAG, "onServiceDisconnected() entry");
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of IP call service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public IPCallServiceConfiguration getConfiguration() throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "getConfiguration() entry");
+            try {
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates an IP call with a contact (audio only). The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or Tel-URI. If the
+     * format of the contact is not supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @param player IP call player
+     * @param renderer IP call renderer
+     * @param listener IP call event listener
+     * @return IP call
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public IPCall initiateCall(String contact, IPCallPlayer player, IPCallRenderer renderer, IPCallListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            Logger.i(TAG, "initiateCall() entry" + "contact" + contact + "player" + player + "renderer" + renderer +  "listener" + listener);
+            try {
+                IIPCall callIntf = api.initiateCall(contact, player, renderer, listener);
+                if (callIntf != null) {
+                    return new IPCall(callIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Initiates an IP call visio with a contact (audio and video). The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI or Tel-URI. If the format of
+     * the contact is not supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @param player IP call player
+     * @param renderer IP call renderer
+     * @param listener IP call event listener
+     * @return IP call
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public IPCall initiateVisioCall(String contact, IPCallPlayer player, IPCallRenderer renderer, IPCallListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            try {
+                Logger.i(TAG, "initiateVisioCall() entry" + "contact" + contact + "player" + player + "renderer" + renderer +  "listener" + listener);
+                IIPCall callIntf = api.initiateVisioCall(contact, player, renderer, listener);
+                if (callIntf != null) {
+                    return new IPCall(callIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of IP calls in progress
+     *
+     * @return List of IP calls
+     * @throws JoynServiceException
+     */
+    public Set<IPCall> getIPCalls() throws JoynServiceException {
+        if (api != null) {
+            try {
+                Set<IPCall> result = new HashSet<IPCall>();
+                List<IBinder> vshList = api.getIPCalls();
+                for (IBinder binder : vshList) {
+                    IPCall call = new IPCall(IIPCall.Stub.asInterface(binder));
+                    result.add(call);
+                }
+                Logger.i(TAG, "getIPCalls() value - " + result);
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current IP call from its unique ID
+     *
+     * @param callId Call ID
+     * @return IP call or null if not found
+     * @throws JoynServiceException
+     */
+    public IPCall getIPCall(String callId) throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "getIPCall() entry");
+            try {
+                IIPCall callIntf = api.getIPCall(callId);
+                if (callIntf != null) {
+                    return new IPCall(callIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current IP call from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return IP call or null if not found
+     * @throws JoynServiceException
+     */
+    public IPCall getIPCallFor(Intent intent) throws JoynServiceException {
+        if (api != null) {
+            try {
+                Logger.i(TAG, "getIPCallFor() entry");
+                String callId = intent.getStringExtra(IPCallIntent.EXTRA_CALL_ID);
+                if (callId != null) {
+                    return getIPCall(callId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        Logger.i(TAG, "getServiceVersion() entry");
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                    Logger.i(TAG, "getServiceVersion() value" + version);
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "isServiceRegistered() entry");
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+                Logger.i(TAG, "isServiceRegistered() value" + serviceStatus);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a new IP call invitation listener
+     *
+     * @param listener New IP call listener
+     * @throws JoynServiceException
+     */
+    public void addNewIPCallListener(NewIPCallListener listener) throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "addNewIPCallListener() entry" + listener);
+            try {
+                api.addNewIPCallListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a new IP call invitation listener
+     *
+     * @param listener New IP call listener
+     * @throws JoynServiceException
+     */
+    public void removeNewIPCallListener(NewIPCallListener listener) throws JoynServiceException {
+        if (api != null) {
+            Logger.i(TAG, "removeNewIPCallListener() entry" + listener);
+            try {
+                api.removeNewIPCallListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.aidl b/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.aidl
new file mode 100644
index 0000000..e13b080
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * IP call configuration object
+ */
+parcelable IPCallServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.java b/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.java
new file mode 100644
index 0000000..fa605d5
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/IPCallServiceConfiguration.java
@@ -0,0 +1,108 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import org.gsma.joyn.Logger;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * IP call service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class IPCallServiceConfiguration implements Parcelable {
+    /**
+     * Voice call breakout
+     */
+    private boolean voiceBreakout;
+
+    public static final String TAG = "IPCallServiceConfiguration";
+
+    /**
+     * Constructor
+     *
+     * @param voiceBreakout Voice call breakout
+     * @hide
+     */
+    public IPCallServiceConfiguration(boolean voiceBreakout) {
+        Logger.i(TAG, "IPCallServiceConfiguration entry" + voiceBreakout);
+        this.voiceBreakout = voiceBreakout;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public IPCallServiceConfiguration(Parcel source) {
+        this.voiceBreakout = source.readInt() != 0;
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(voiceBreakout ? 1 : 0);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<IPCallServiceConfiguration> CREATOR
+            = new Parcelable.Creator<IPCallServiceConfiguration>() {
+        public IPCallServiceConfiguration createFromParcel(Parcel source) {
+            return new IPCallServiceConfiguration(source);
+        }
+
+        public IPCallServiceConfiguration[] newArray(int size) {
+            return new IPCallServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Is voice call breakout activated. It returns True if the service can reach
+     * any user, else returns False if only joyn users supporting the IP call
+     * capability may be called.
+     *
+     * @return Boolean
+     */
+    public boolean isVoiceCallBreakout() {
+        Logger.i(TAG, "isVoiceCallBreakout value " + voiceBreakout);
+        return voiceBreakout;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/NewIPCallListener.java b/src/java/org/gsma/joyn/ipcall/NewIPCallListener.java
new file mode 100644
index 0000000..40cea4b
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/NewIPCallListener.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+
+/**
+ * New IP call invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewIPCallListener extends INewIPCallListener.Stub {
+    /**
+     * Callback called when a new IP call invitation has been received
+     *
+     * @param callId Call ID
+     */
+    public abstract void onNewIPCall(String callId);
+}
diff --git a/src/java/org/gsma/joyn/ipcall/VideoCodec.aidl b/src/java/org/gsma/joyn/ipcall/VideoCodec.aidl
new file mode 100644
index 0000000..363d4be
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/VideoCodec.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ipcall;
+
+/**
+ * Video codec object
+ */
+parcelable VideoCodec;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ipcall/VideoCodec.java b/src/java/org/gsma/joyn/ipcall/VideoCodec.java
new file mode 100644
index 0000000..4d01ac4
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/VideoCodec.java
@@ -0,0 +1,291 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ipcall;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.gsma.joyn.H264Config;
+import org.gsma.joyn.Logger;
+
+
+/**
+ * Video codec
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoCodec implements Parcelable {
+    /**
+     * Video encoding
+     */
+    private String encoding;
+
+    /**
+     * Payload
+     */
+    private int payload;
+
+    /**
+     * Clock rate
+     */
+    private int clockRate;
+
+    /**
+     * Frame rate
+     */
+    private int frameRate;
+
+    /**
+     * Bit rate
+     */
+    private int bitRate;
+
+    /**
+     * Screen width
+     */
+    private int width;
+
+    /**
+     * Screen height
+     */
+    private int height;
+
+    /**
+     * Video parameters
+     */
+    private String parameters;
+
+    public static final String TAG = "VideoCodec";
+
+    /**
+     * Constructor
+     *
+     * @param encoding Video encoding
+     * @param payload Payload
+     * @param clockRate Clock rate
+     * @param framerate Frame rate
+     * @param bitRate Bit rate
+     * @param width Video width
+     * @param height Video height
+     * @param parameters Codec parameters
+     * @hide
+     */
+    public VideoCodec(String encoding, int payload, int clockRate, int frameRate, int bitRate, int width, int height, String parameters) {
+        Logger.i(TAG, "VideoCodec entry" + "encoding" + encoding + "payload" + "clockRate" + clockRate + "frameRate" + frameRate + "bitRate" +
+        bitRate + "width" + width + "height" + height +  "parameters" + parameters);
+        this.encoding = encoding;
+        this.payload = payload;
+        this.clockRate = clockRate;
+        this.frameRate = frameRate;
+        this.bitRate = bitRate;
+        this.width = width;
+        this.height = height;
+        this.parameters = parameters;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public VideoCodec(Parcel source) {
+        this.encoding = source.readString();
+        this.payload = source.readInt();
+        this.clockRate = source.readInt();
+        this.frameRate = source.readInt();
+        this.bitRate = source.readInt();
+        this.width = source.readInt();
+        this.height = source.readInt();
+        this.parameters = source.readString();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(encoding);
+        dest.writeInt(payload);
+        dest.writeInt(clockRate);
+        dest.writeInt(frameRate);
+        dest.writeInt(bitRate);
+        dest.writeInt(width);
+        dest.writeInt(height);
+        dest.writeString(parameters);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<VideoCodec> CREATOR
+            = new Parcelable.Creator<VideoCodec>() {
+        public VideoCodec createFromParcel(Parcel source) {
+            return new VideoCodec(source);
+        }
+
+        public VideoCodec[] newArray(int size) {
+            return new VideoCodec[size];
+        }
+    };
+
+    /**
+    * Returns the encoding name (e.g. H264)
+    *
+    * @return Encoding name
+    */
+    public String getEncoding() {
+        Logger.i(TAG, "getEncoding value " + encoding);
+        return encoding;
+    }
+
+    /**
+     * Returns the codec payload type (e.g. 96)
+     *
+     * @return Payload type
+     */
+    public int getPayloadType() {
+        Logger.i(TAG, "getPayloadType value " + payload);
+        return payload;
+    }
+
+    /**
+     * Returns the codec clock rate (e.g. 90000)
+     *
+     * @return Clock rate
+     */
+    public int getClockRate() {
+        Logger.i(TAG, "getClockRate value " + clockRate);
+        return clockRate;
+    }
+
+    /**
+     * Returns the codec frame rate (e.g. 10)
+     *
+     * @return Frame rate
+     */
+    public int getFrameRate() {
+        Logger.i(TAG, "getFrameRate value " + frameRate);
+        return frameRate;
+    }
+
+    /**
+     * Returns the codec bit rate (e.g. 64000)
+     *
+     * @return Bit rate
+     */
+    public int getBitRate() {
+        Logger.i(TAG, "getBitRate value " + bitRate);
+        return bitRate;
+    }
+
+    /**
+     * Returns the video width (e.g. 176)
+     *
+     * @return Video width
+     */
+    public int getVideoWidth() {
+        Logger.i(TAG, "getVideoWidth value " + width);
+        return width;
+    }
+
+    /**
+     * Returns the video height (e.g. 144)
+     *
+     * @return Video height
+     */
+    public int getVideoHeight() {
+        Logger.i(TAG, "getVideoHeight value " + height);
+        return height;
+    }
+
+    /**
+     * Returns the list of codec parameters (e.g. profile-level-id, packetization-mode).
+     * Parameters are are semicolon separated.
+     *
+     * @return Parameters
+     */
+    public String getParameters() {
+        Logger.i(TAG, "getParameters value " + parameters);
+        return parameters;
+    }
+
+    /**
+     * Returns the value of codec parameter key (e.g. profile-level-id, packetization-mode).
+     *
+     * @return Parameters
+     */
+    public String getParameter(String key) {
+        String value = null;
+        String[] parameters = getParameters().split(",");
+        ArrayList<String> codecparams = new ArrayList<String>(Arrays.asList(parameters));
+        for (int i = 0; i < codecparams.size() ; i++)
+        {
+            if (codecparams.get(i).startsWith(key))
+            {
+                value = codecparams.get(i).substring(key.length() + 1);
+            }
+        }
+        Logger.i(TAG, "getParameter value " + value);
+        return value;
+    }
+
+    /**
+     * Compare codec
+     *
+     * @param codec Codec to compare
+     * @return Returns True if codecs are equals, else returns False
+     */
+    public boolean compare(VideoCodec codec) {
+        boolean ret = false;
+        if (getEncoding().equalsIgnoreCase(codec.getEncoding())
+                && (getVideoWidth() == codec.getVideoWidth() || getVideoWidth() == 0 || codec.getVideoWidth() == 0)
+                && (getVideoHeight() == codec.getVideoHeight() || getVideoHeight() == 0 || codec.getVideoHeight() == 0)) {
+            if (getEncoding().equalsIgnoreCase(H264Config.CODEC_NAME)) {
+                if (H264Config.getCodecProfileLevelId(getParameters()).compareToIgnoreCase(H264Config.getCodecProfileLevelId(codec.getParameters())) == 0) {
+                    ret =  true;
+                }
+            } else {
+                if (getParameters().equalsIgnoreCase(codec.getParameters())) {
+                    ret = true;
+                }
+            }
+        }
+        Logger.i(TAG, "compare value " + ret);
+        return ret;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ipcall/package-info.java b/src/java/org/gsma/joyn/ipcall/package-info.java
new file mode 100644
index 0000000..4bdb9fa
--- /dev/null
+++ b/src/java/org/gsma/joyn/ipcall/package-info.java
@@ -0,0 +1,5 @@
+/**
+ * This API exposes all functionality related to IP voice call and IP video call services.
+ * <p>
+ */
+package org.gsma.joyn.ipcall;
diff --git a/src/java/org/gsma/joyn/ish/IImageSharing.aidl b/src/java/org/gsma/joyn/ish/IImageSharing.aidl
new file mode 100644
index 0000000..6e38443
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/IImageSharing.aidl
@@ -0,0 +1,33 @@
+package org.gsma.joyn.ish;
+
+import org.gsma.joyn.ish.IImageSharingListener;
+
+/**
+ * Image sharing interface
+ */
+interface IImageSharing {
+
+	String getSharingId();
+
+	String getRemoteContact();
+
+	String getFileName();
+
+	long getFileSize();
+
+	String getFileType();
+
+	int getState();
+	
+	int getDirection();
+		
+	void acceptInvitation();
+
+	void rejectInvitation();
+
+	void abortSharing();
+	
+	void addEventListener(in IImageSharingListener listener);
+
+	void removeEventListener(in IImageSharingListener listener);
+}
diff --git a/src/java/org/gsma/joyn/ish/IImageSharingListener.aidl b/src/java/org/gsma/joyn/ish/IImageSharingListener.aidl
new file mode 100644
index 0000000..5258290
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/IImageSharingListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.ish;
+
+/**
+ * Callback methods for image sharing events
+ */
+interface IImageSharingListener {
+	void onSharingStarted();
+	
+	void onSharingAborted();
+
+	void onSharingError(in int error);
+	
+	void onSharingProgress(in long currentSize, in long totalSize);
+
+	void onImageShared(in String filename);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ish/IImageSharingService.aidl b/src/java/org/gsma/joyn/ish/IImageSharingService.aidl
new file mode 100644
index 0000000..dd2ef78
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/IImageSharingService.aidl
@@ -0,0 +1,34 @@
+package org.gsma.joyn.ish;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.ish.IImageSharing;
+import org.gsma.joyn.ish.IImageSharingListener;
+import org.gsma.joyn.ish.INewImageSharingListener;
+import org.gsma.joyn.ish.ImageSharingServiceConfiguration;
+
+/**
+ * Image sharing service API
+ */
+interface IImageSharingService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	ImageSharingServiceConfiguration getConfiguration();
+    
+	List<IBinder> getImageSharings();
+	
+	String getJoynAccountViaNumber(in String number);
+	
+	IImageSharing getImageSharing(in String sharingId);
+
+	IImageSharing shareImage(in String contact, in String filename, in IImageSharingListener listener);
+	
+	void addNewImageSharingListener(in INewImageSharingListener listener);
+
+	void removeNewImageSharingListener(in INewImageSharingListener listener);
+	
+	int getServiceVersion();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl b/src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl
new file mode 100644
index 0000000..d260046
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/INewImageSharingListener.aidl
@@ -0,0 +1,8 @@
+package org.gsma.joyn.ish;
+
+/**
+ * Callback method for new image sharing invitations
+ */
+interface INewImageSharingListener {
+	void onNewImageSharing(in String sharingId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ish/ImageSharing.java b/src/java/org/gsma/joyn/ish/ImageSharing.java
new file mode 100644
index 0000000..656b9bf
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharing.java
@@ -0,0 +1,290 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+import org.gsma.joyn.JoynServiceException;
+
+/**
+ * Image sharing
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharing {
+
+    /**
+     * Image sharing state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Sharing invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Sharing invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Sharing is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Image has been transferred with success
+         */
+        public final static int TRANSFERRED = 4;
+
+        /**
+         * Sharing has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Sharing has failed
+         */
+        public final static int FAILED = 6;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the sharing
+     */
+    public static class Direction {
+        /**
+         * Incoming sharing
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing sharing
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Image sharing error
+     */
+    public static class Error {
+        /**
+         * Sharing has failed
+         */
+        public final static int SHARING_FAILED = 0;
+
+        /**
+         * Sharing invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        /**
+         * Image saving has failed
+         */
+        public final static int SAVING_FAILED = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Image sharing interface
+     */
+    private IImageSharing sharingInf;
+
+    /**
+     * Constructor
+     *
+     * @param sharingInf Image sharing interface
+     */
+    ImageSharing(IImageSharing sharingInf) {
+        this.sharingInf = sharingInf;
+    }
+
+    /**
+     * Returns the sharing ID of the image sharing
+     *
+     * @return Sharing ID
+     * @throws JoynServiceException
+     */
+    public String getSharingId() throws JoynServiceException {
+        try {
+            return sharingInf.getSharingId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        try {
+            return sharingInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the complete filename including the path of the file to be transferred
+     *
+     * @return Filename
+     * @throws JoynServiceException
+     */
+    public String getFileName() throws JoynServiceException {
+        try {
+            return sharingInf.getFileName();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the size of the file to be transferred
+     *
+     * @return Size in bytes
+     * @throws JoynServiceException
+     */
+    public long getFileSize() throws JoynServiceException {
+        try {
+            return sharingInf.getFileSize();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the MIME type of the file to be transferred
+     *
+     * @return Type
+     * @throws JoynServiceException
+     */
+    public String getFileType() throws JoynServiceException {
+        try {
+            return sharingInf.getFileType();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the sharing
+     *
+     * @return State
+     * @see ImageSharing.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        try {
+            return sharingInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the sharing (incoming or outgoing)
+     *
+     * @return Direction
+     * @see ImageSharing.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        try {
+            return sharingInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts image sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        try {
+            sharingInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects image sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        try {
+            sharingInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the sharing
+     *
+     * @throws JoynServiceException
+     */
+    public void abortSharing() throws JoynServiceException {
+        try {
+            sharingInf.abortSharing();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on image sharing events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(ImageSharingListener listener) throws JoynServiceException {
+        try {
+            sharingInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from image sharing
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(ImageSharingListener listener) throws JoynServiceException {
+        try {
+            sharingInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingIntent.java b/src/java/org/gsma/joyn/ish/ImageSharingIntent.java
new file mode 100644
index 0000000..91f916a
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingIntent.java
@@ -0,0 +1,71 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+/**
+ * Intent for image sharing invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharingIntent {
+    /**
+     * Broadcast action: a new image sharing invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_SHARING_ID} containing the unique ID of the image sharing.
+     * <li> {@link #EXTRA_FILENAME} containing the filename of image to be shared.
+     * <li> {@link #EXTRA_FILESIZE} containing the size of the image to be shared.
+     * <li> {@link #EXTRA_FILETYPE} containing the MIME type of the image to be shared.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.ish.action.NEW_IMAGE_SHARING";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the image sharing
+     */
+    public final static String EXTRA_SHARING_ID = "sharingId";
+
+    /**
+     * Name of the file
+     */
+    public final static String EXTRA_FILENAME = "filename";
+
+    /**
+     * Size of the file in byte
+     */
+    public final static String EXTRA_FILESIZE = "filesize";
+
+    /**
+     * MIME type of the file
+     */
+    public final static String EXTRA_FILETYPE = "filetype";
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingListener.java b/src/java/org/gsma/joyn/ish/ImageSharingListener.java
new file mode 100644
index 0000000..63ec1ff
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingListener.java
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+
+/**
+ * Image sharing event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class ImageSharingListener extends IImageSharingListener.Stub {
+    /**
+     * Callback called when the sharing is started
+     */
+    public abstract void onSharingStarted();
+
+    /**
+     * Callback called when the sharing has been aborted
+     */
+    public abstract void onSharingAborted();
+
+    /**
+     * Callback called when the sharing has failed
+     *
+     * @param error Error
+     * @see ImageSharing.Error
+     */
+    public abstract void onSharingError(int error);
+
+    /**
+     * Callback called during the sharing progress
+     *
+     * @param currentSize Current transferred size in bytes
+     * @param totalSize Total size to transfer in bytes
+     */
+    public abstract void onSharingProgress(long currentSize, long totalSize);
+
+    /**
+     * Callback called when the image has been shared
+     *
+     * @param filename Filename including the path of the transferred file
+     */
+    public abstract void onImageShared(String filename);
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingLog.java b/src/java/org/gsma/joyn/ish/ImageSharingLog.java
new file mode 100644
index 0000000..68e6692
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingLog.java
@@ -0,0 +1,94 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+import android.net.Uri;
+
+/**
+ * Content provider for image sharing history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharingLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.ish/ish");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the image sharing.
+     * <P>Type: TEXT</P>
+     */
+    public static final String SHARING_ID = "sharing_id";
+
+    /**
+     * The name of the column containing the MSISDN of the sender.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the filename (absolute path).
+     * <P>Type: TEXT</P>
+     */
+    public static final String FILENAME = "filename";
+
+    /**
+     * The name of the column containing the image size to be transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String FILESIZE = "filesize";
+
+    /**
+     * The name of the column containing the MIME-type of the file.
+     * <P>Type: TEXT</P>
+     */
+    public static final String MIME_TYPE = "mime_type";
+
+    /**
+     * The name of the column containing the direction of the sharing.
+     * <P>Type: INTEGER</P>
+     * @see ImageSharing.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the amount of data transferred (in bytes).
+     * <P>Type: LONG</P>
+     */
+    public static final String TRANSFERRED = "transferred";
+
+    /**
+     * The name of the column containing the date of the sharing (in milliseconds).
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the state of the sharing.
+     * <P>Type: INTEGER</P>
+     * @see ImageSharing.State
+     */
+    public static final String STATE = "state";
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingService.java b/src/java/org/gsma/joyn/ish/ImageSharingService.java
new file mode 100644
index 0000000..eb058a4
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingService.java
@@ -0,0 +1,398 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+import org.gsma.joyn.ICoreServiceWrapper;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+
+import android.os.RemoteException;
+import org.gsma.joyn.Logger;
+
+/**
+ * This class offers the main entry point to transfer image during
+ * a CS call. Several applications may connect/disconnect to the API.
+ *
+ * The parameter contact in the API supports the following formats:
+ * MSISDN in national or international format, SIP address, SIP-URI
+ * or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharingService extends JoynService {
+    /**
+     * API
+     */
+    private IImageSharingService api = null;
+
+    public static final String TAG = "ImageSharingService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public ImageSharingService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IImageSharingService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getImageSharingServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IImageSharingService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of image sharing service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public ImageSharingServiceConfiguration getConfiguration() throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Shares an image with a contact. The parameter file contains the complete filename
+     * including the path of the image to be shared. An exception if thrown if there is
+     * no ongoing CS call. The parameter contact supports the following formats: MSISDN
+     * in national or international format, SIP address, SIP-URI or Tel-URI. If the format
+     * of the contact is not supported an exception is thrown.
+     *
+     * @param contact Contact
+     * @param filename Filename to share
+     * @param listener Image sharing event listener
+     * @return Image sharing
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public ImageSharing shareImage(String contact, String filename, ImageSharingListener listener) throws JoynServiceException, JoynContactFormatException {
+
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_IMAGESHARE_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_IMAGESHARE_SEND");
+        } */
+        if (api != null) {
+            try {
+                IImageSharing sharingIntf = api.shareImage(contact, filename, listener);
+                if (sharingIntf != null) {
+                    return new ImageSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of image sharings in progress
+     *
+     * @return List of image sharings
+     * @throws JoynServiceException
+     */
+    public Set<ImageSharing> getImageSharings() throws JoynServiceException {
+        if (api != null) {
+            try {
+                Set<ImageSharing> result = new HashSet<ImageSharing>();
+                List<IBinder> ishList = api.getImageSharings();
+                for (IBinder binder : ishList) {
+                    ImageSharing sharing = new ImageSharing(IImageSharing.Stub.asInterface(binder));
+                    result.add(sharing);
+                }
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current image sharing from its unique ID
+     *
+     * @param sharingId Sharing ID
+     * @return Image sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public ImageSharing getImageSharing(String sharingId) throws JoynServiceException {
+        if (api != null) {
+            try {
+                IImageSharing sharingIntf = api.getImageSharing(sharingId);
+                if (sharingIntf != null) {
+                    return new ImageSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current image sharing from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return Image sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public ImageSharing getImageSharingFor(Intent intent) throws JoynServiceException {
+        if (api != null) {
+            try {
+                String sharingId = intent.getStringExtra(ImageSharingIntent.EXTRA_SHARING_ID);
+                if (sharingId != null) {
+                    return getImageSharing(sharingId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Get joyn account mapped with the specific GSM number(Only in debug mode).
+     *
+     * @param number The GSM number to be mapped to joyn account.
+     * @return The joyn account.
+     * @throws JoynServiceException
+     */
+    public String getJoynAccountViaNumber(String number) throws JoynServiceException, JoynServiceNotAvailableException {
+        if (api != null) {
+            try {
+                return api.getJoynAccountViaNumber(number);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        if (api != null) {
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    /**
+     * Registers a new image sharing invitation listener
+     *
+     * @param listener New image sharing listener
+     * @throws JoynServiceException
+     */
+    public void addNewImageSharingListener(NewImageSharingListener listener) throws JoynServiceException {
+
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_IMAGESHARE_RECEIVE) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_IMAGESHARE_RECEIVE");
+        }*/
+        if (api != null) {
+            try {
+                api.addNewImageSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a new image sharing invitation listener
+     *
+     * @param listener New image sharing listener
+     * @throws JoynServiceException
+     */
+    public void removeNewImageSharingListener(NewImageSharingListener listener) throws JoynServiceException {
+
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_IMAGESHARE_RECEIVE) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_IMAGESHARE_RECEIVE");
+        }*/
+        if (api != null) {
+            try {
+                api.removeNewImageSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.aidl b/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.aidl
new file mode 100644
index 0000000..1f2eccf
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.ish;
+
+/**
+ * Image sharing configuration object
+ */
+parcelable ImageSharingServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.java b/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.java
new file mode 100644
index 0000000..00f5dbf
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/ImageSharingServiceConfiguration.java
@@ -0,0 +1,121 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Image sharing service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class ImageSharingServiceConfiguration {
+    /**
+     * Image size threshold
+     */
+    private long warnSize;
+
+    /**
+     * Image size limit
+     */
+    private long maxSize;
+
+    /**
+     * Constructor
+     *
+     * @param warnSize Image size threshold
+     * @param maxSize Image size limit
+     * @hide
+     */
+    public ImageSharingServiceConfiguration(long warnSize, long maxSize) {
+        this.warnSize = warnSize;
+        this.maxSize = maxSize;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public ImageSharingServiceConfiguration(Parcel source) {
+        this.warnSize = source.readLong();
+        this.maxSize = source.readLong();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(warnSize);
+        dest.writeLong(maxSize);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<ImageSharingServiceConfiguration> CREATOR
+            = new Parcelable.Creator<ImageSharingServiceConfiguration>() {
+        public ImageSharingServiceConfiguration createFromParcel(Parcel source) {
+            return new ImageSharingServiceConfiguration(source);
+        }
+
+        public ImageSharingServiceConfiguration[] newArray(int size) {
+            return new ImageSharingServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Returns the image size threshold when the user should be warned about the
+     * potential charges associated to the transfer of a large file. It returns 0
+     * if there no need to warn.
+     *
+     * @return Size in kilobytes
+     */
+    public long getWarnSize() {
+        return warnSize;
+    }
+
+    /**
+     * Returns the maximum authorized size of the image that can be sent. It
+     * returns 0 if there is no limitation.
+     *
+     * @return Size in kilobytes
+     */
+    public long getMaxSize() {
+        return maxSize;
+    }
+}
diff --git a/src/java/org/gsma/joyn/ish/NewImageSharingListener.java b/src/java/org/gsma/joyn/ish/NewImageSharingListener.java
new file mode 100644
index 0000000..bc5e695
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/NewImageSharingListener.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.ish;
+
+
+/**
+ * New image sharing invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewImageSharingListener extends INewImageSharingListener.Stub {
+    /**
+     * Callback called when a new image sharing invitation has been received
+     *
+     * @param sharingId Sharing ID
+     */
+    public abstract void onNewImageSharing(String sharingId);
+}
diff --git a/src/java/org/gsma/joyn/ish/package-info.java b/src/java/org/gsma/joyn/ish/package-info.java
new file mode 100644
index 0000000..782de90
--- /dev/null
+++ b/src/java/org/gsma/joyn/ish/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * This API exposes exposes all functionality related to transferring images
+ * during a CS call via the Image Sharing service.
+ * <p>
+ */
+package org.gsma.joyn.ish;
diff --git a/src/java/org/gsma/joyn/package-info.java b/src/java/org/gsma/joyn/package-info.java
new file mode 100644
index 0000000..3b9e9c3
--- /dev/null
+++ b/src/java/org/gsma/joyn/package-info.java
@@ -0,0 +1,41 @@
+/**
+ * The RCS service is implemented into an Android background service
+ * which offers a high level API: the RCS Terminal API.
+ * <p>
+ * The RCS API is a client/server interface based on database
+ * providers, AIDL API & Intents. Several UI may be connected at a time
+ * to manage RCS events and to interact with the single stack instance
+ * running in background.
+ * <p>
+ * The RCS API permits to implement RCS application (e.g. enhanced
+ * address book, content sharing app, chat view, widgets) by hiding RCS
+ * protocols complexity.
+ * <p>
+ * The RCS API offers the following service API:<br>
+ * - Capability API: contact capabilities discovery.<br>
+ * - Chat API: 1-1 chat and group chat.<br>
+ * - File Transfer API: transfer a file.<br>
+ * - Video Share API: live video sharing during a CS call.<br>
+ * - Image Share API: image sharing during a CS call.<br>
+ * - UX API: links third party applications with RCS applications.<br>
+ * <p>
+ * The RCS API uses the following Android concepts:<br>
+ * - Intents mechanism to broadcast incoming events (e.g. notification) and
+ * incoming invitations to any Android activity or broadcast receiver which are
+ * declared in the device.<br>
+ * - AIDL interfaces to initiate and to manage session in real time (start,
+ * session monitoring, stop). Session events are managed thanks to callback mechanism.<br>
+ * <p>
+ * Note: Methods of the RCS API throw an exception if the RCS service is not available, not
+ * initialized or not registered to the IMS platform.
+ * <p>
+ * Note: Remote application exceptions are not yet supported by the
+ * AIDL SDK, a generic AIDL exception is thrown instead.
+ * <p>
+ * Note: The supported formats for a contact used as a method parameter are:<br>
+ * - Phone number in national or international format (e.g. +33xxx).<br>
+ * - SIP address (e.g. "John" <sip:+33xxx@domain.com>).<br>
+ * - SIP-URI (e.g. sip:+33xxx@domain.com).<br>
+ * - Tel-URI (e.g. tel:+33xxx).<br>
+ */
+package org.gsma.joyn;
diff --git a/src/java/org/gsma/joyn/session/IMultimediaSession.aidl b/src/java/org/gsma/joyn/session/IMultimediaSession.aidl
new file mode 100644
index 0000000..fc8473e
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/IMultimediaSession.aidl
@@ -0,0 +1,31 @@
+package org.gsma.joyn.session;
+
+import org.gsma.joyn.session.IMultimediaSessionListener;
+
+/**
+ * Multimedia session interface
+ */
+interface IMultimediaSession {
+	String getSessionId();
+	
+	String getRemoteContact();
+	
+	String getServiceId();
+	
+	int getState();
+	
+	int getDirection();
+	
+	void acceptInvitation();
+	
+	void rejectInvitation();
+	
+	void abortSession();
+	
+	void addEventListener(in IMultimediaSessionListener listener);
+	
+	void removeEventListener(in IMultimediaSessionListener listener);
+
+	boolean sendMessage(in byte[] content);
+}
+
diff --git a/src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl b/src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl
new file mode 100644
index 0000000..78c6187
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/IMultimediaSessionListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.session;
+
+/**
+ * Callback methods for multimedia session events
+ */
+interface IMultimediaSessionListener {
+	void onSessionStarted();
+	
+	void onSessionRinging();
+
+	void onSessionAborted();
+
+	void onSessionError(in int error);
+
+	void onNewMessage(in byte[] content);
+}
diff --git a/src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl b/src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl
new file mode 100644
index 0000000..6f47c91
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/IMultimediaSessionService.aidl
@@ -0,0 +1,28 @@
+package org.gsma.joyn.session;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.session.IMultimediaSession;
+import org.gsma.joyn.session.IMultimediaSessionListener;
+
+/**
+ * Multimedia session service API
+ */
+interface IMultimediaSessionService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	List<IBinder> getSessions(in String serviceId);
+	
+	IMultimediaSession getSession(in String sessionId);
+	
+	IMultimediaSession initiateSession(in String serviceId, in String contact, in IMultimediaSessionListener listener);
+	
+	boolean sendMessage(in String serviceId, in String contact, in byte[] content);
+	
+	int getServiceVersion();
+}
+
+
diff --git a/src/java/org/gsma/joyn/session/MultimediaMessageIntent.java b/src/java/org/gsma/joyn/session/MultimediaMessageIntent.java
new file mode 100644
index 0000000..b5bc965
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaMessageIntent.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.session;
+
+/**
+ * Intent for incoming multimedia messages
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultimediaMessageIntent {
+    /**
+     * Broadcast action: a new multimedia message has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the message.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the message (extracted from the SIP address).
+     * <li> {@link #EXTRA_CONTENT} containing the multimedia message content.
+     * <li> The service ID is read from the method Intent.getType() which returns the MIME type included
+     *  in the intent and corresponding to the invoked service.
+     * </ul>
+     */
+    public final static String ACTION_NEW_MESSAGE = "org.gsma.joyn.session.action.NEW_MESSAGE";
+
+    /**
+     * MSISDN of the contact sending the message
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the message
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Multimedia message content
+     */
+    public final static String EXTRA_CONTENT = "content";
+}
diff --git a/src/java/org/gsma/joyn/session/MultimediaSession.java b/src/java/org/gsma/joyn/session/MultimediaSession.java
new file mode 100644
index 0000000..6d830ac
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaSession.java
@@ -0,0 +1,278 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.session;
+
+import org.gsma.joyn.JoynServiceException;
+
+/**
+ * This class maintains the information related to a multimedia
+ * session and offers methods to manage it and to send messages
+ * in real time.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultimediaSession {
+    /**
+     * Multimedia session state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Session invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Session invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Session is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Session has been aborted or
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Session has been terminated
+         */
+        public static final int TERMINATED = 6;
+
+        /**
+         * Session has failed
+         */
+        public final static int FAILED = 7;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the session
+     */
+    public static class Direction {
+        /**
+         * Incoming session
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing session
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Session error
+     */
+    public static class Error {
+        /**
+         * Session invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 0;
+
+        /**
+         * Session has failed
+         */
+        public final static int SESSION_FAILED = 1;
+
+        /**
+         * Media has failed
+         */
+        public final static int MEDIA_FAILED = 2;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Multimedia session interface
+     */
+    private IMultimediaSession sessionInf;
+
+    /**
+     * Constructor
+     *
+     * @param sessionInf Multimedia session interface
+     */
+    MultimediaSession(IMultimediaSession sessionInf) {
+        this.sessionInf = sessionInf;
+    }
+
+    /**
+     * Returns the session ID of the multimedia session
+     *
+     * @return Session ID
+     * @throws JoynServiceException
+     */
+    public String getSessionId() throws JoynServiceException {
+        try {
+            return sessionInf.getSessionId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        try {
+            return sessionInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the service ID
+     *
+     * @return Service ID
+     * @throws JoynServiceException
+     */
+    public String getServiceId() throws JoynServiceException {
+        try {
+            return sessionInf.getServiceId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the session
+     *
+     * @return State
+     * @see MultimediaSession.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        try {
+            return sessionInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the session (incoming or outgoing)
+     *
+     * @return Direction
+     * @see MultimediaSession.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        try {
+            return sessionInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts session invitation.
+     *
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation() throws JoynServiceException {
+        try {
+            sessionInf.acceptInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects session invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        try {
+            sessionInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the session
+     *
+     * @throws JoynServiceException
+     */
+    public void abortSession() throws JoynServiceException {
+        try {
+            sessionInf.abortSession();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on session events
+     *
+     * @param listener Session event listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(MultimediaSessionListener listener) throws JoynServiceException {
+        try {
+            sessionInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener on session events
+     *
+     * @param listener Session event listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(MultimediaSessionListener listener) throws JoynServiceException {
+        try {
+            sessionInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Sends a message in real time
+     *
+     * @param content Message content
+     * @return Returns true if sent successfully else returns false
+     * @throws JoynServiceException
+     */
+    public boolean sendMessage(byte[] content) throws JoynServiceException {
+        try {
+            return sessionInf.sendMessage(content);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/session/MultimediaSessionIntent.java b/src/java/org/gsma/joyn/session/MultimediaSessionIntent.java
new file mode 100644
index 0000000..474a730
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaSessionIntent.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.session;
+
+/**
+ * Intent for multimedia session invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultimediaSessionIntent {
+    /**
+     * Broadcast action: a new multimedia session invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_SESSION_ID} containing the unique ID of the multimedia session.
+     * <li> The service ID is read from the method Intent.getType() which returns the MIME type included
+     *  in the intent and corresponding to the invoked service.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.session.action.NEW_SESSION";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the multimedia session
+     */
+    public final static String EXTRA_SESSION_ID = "sessionId";
+}
diff --git a/src/java/org/gsma/joyn/session/MultimediaSessionListener.java b/src/java/org/gsma/joyn/session/MultimediaSessionListener.java
new file mode 100644
index 0000000..b9073dd
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaSessionListener.java
@@ -0,0 +1,57 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.session;
+
+
+
+/**
+ * This class offers callback methods on multimedia session events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class MultimediaSessionListener extends IMultimediaSessionListener.Stub {
+    /**
+     * Callback called when the session is pending.
+     */
+    public abstract void onSessionRinging();
+
+    /**
+     * Callback called when the session is started
+     */
+    public abstract void onSessionStarted();
+
+    /**
+     * Callback called when the session has been aborted or terminated
+     */
+    public abstract void onSessionAborted();
+
+    /**
+     * Callback called when the session has failed
+     *
+     * @param error Error
+     * @see MultimediaSession.Error
+     */
+    public abstract void onSessionError(int error);
+
+    /**
+     * Callback called when a new message has been received
+     *
+     * @param content Message content
+     */
+    public abstract void onNewMessage(byte[] content);
+}
diff --git a/src/java/org/gsma/joyn/session/MultimediaSessionService.java b/src/java/org/gsma/joyn/session/MultimediaSessionService.java
new file mode 100644
index 0000000..aa3ffed
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/MultimediaSessionService.java
@@ -0,0 +1,250 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package org.gsma.joyn.session;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+
+import org.gsma.joyn.ICoreServiceWrapper;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+
+/**
+ * This class offers the main entry point to initiate and to manage
+ * multimedia sessions. Several applications may connect/disconnect
+ * to the API.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class MultimediaSessionService extends JoynService {
+    /**
+     * API
+     */
+    private IMultimediaSessionService api = null;
+
+    /**
+     * Constructor
+     *
+     * @param ctx Application context
+     * @param listener Service listener
+     */
+    public MultimediaSessionService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IMultimediaSessionService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getMultimediaSessionServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IMultimediaSessionService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener.onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Initiates a new multimedia session for real time messaging with a remote contact and
+     * for a given service. The messages exchanged in real time during the session may be from
+     * any type. The parameter contact supports the following formats: MSISDN in national or
+     * international format, SIP address, SIP-URI or Tel-URI. If the format of the contact is
+     * not supported an exception is thrown.
+     *
+     * @param serviceId Service ID
+     * @param contact Contact
+     * @param listener Multimedia session event listener
+     * @return Multimedia session
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public MultimediaSession initiateSession(String serviceId, String contact, MultimediaSessionListener listener) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            try {
+                IMultimediaSession sessionIntf = api.initiateSession(serviceId, contact, listener);
+                if (sessionIntf != null) {
+                    return new MultimediaSession(sessionIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of sessions associated to a given service ID
+     *
+     * @param serviceId Service ID
+     * @return List of sessions
+     * @throws JoynServiceException
+     */
+    public Set<MultimediaSession> getSessions(String serviceId) throws JoynServiceException {
+        if (api != null) {
+            try {
+                Set<MultimediaSession> result = new HashSet<MultimediaSession>();
+                List<IBinder> mmsList = api.getSessions(serviceId);
+                for (IBinder binder : mmsList) {
+                    MultimediaSession session = new MultimediaSession(IMultimediaSession.Stub.asInterface(binder));
+                    result.add(session);
+                }
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current session from its unique session ID
+     *
+     * @return Multimedia session or null if not found
+     * @throws JoynServiceException
+     */
+    public MultimediaSession getSession(String sessionId) throws JoynServiceException {
+        if (api != null) {
+            try {
+                IMultimediaSession sessionIntf = api.getSession(sessionId);
+                if (sessionIntf != null) {
+                    return new MultimediaSession(sessionIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current session from its invitation Intent
+     *
+     * @param intent Invitation intent
+     * @return Multimedia session or null if not found
+     * @throws JoynServiceException
+     */
+    public MultimediaSession getSessionFor(Intent intent) throws JoynServiceException {
+        if (api != null) {
+            try {
+                String sessionId = intent.getStringExtra(MultimediaSessionIntent.EXTRA_SESSION_ID);
+                if (sessionId != null) {
+                    return getSession(sessionId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Sends a message in pager mode to a contact and for a given service. The message may
+     * be any type of content. The parameter contact supports the following formats: MSISDN in
+     * national or international format, SIP address, SIP-URI or Tel-URI. If the format of the
+     * contact is not supported an exception is thrown.
+     *
+     * @param serviceId Service ID
+     * @param contact Contact
+     * @param content Message content
+     * @return Returns true if sent successfully else returns false
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public boolean sendMessage(String serviceId, String contact, byte[] content) throws JoynServiceException, JoynContactFormatException {
+        if (api != null) {
+            try {
+                return api.sendMessage(serviceId, contact, content);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/session/package-info.java b/src/java/org/gsma/joyn/session/package-info.java
new file mode 100644
index 0000000..7e9e4ea
--- /dev/null
+++ b/src/java/org/gsma/joyn/session/package-info.java
@@ -0,0 +1,4 @@
+/**
+ * This API exposes all functionality to initiate multimedia sessions between two end points based on a dedicated service ID (or feature tag).<p>
+ */
+package org.gsma.joyn.session;
diff --git a/src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl b/src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl
new file mode 100644
index 0000000..b519ff5
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/INewVideoSharingListener.aidl
@@ -0,0 +1,8 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Callback method for new video sharing invitations
+ */
+interface INewVideoSharingListener {
+	void onNewVideoSharing(in String sharingId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl b/src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl
new file mode 100644
index 0000000..78dc47a
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoPlayer.aidl
@@ -0,0 +1,28 @@
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.vsh.VideoCodec;
+import org.gsma.joyn.vsh.IVideoPlayerListener;
+
+/**
+ * Video player interface
+ */
+interface IVideoPlayer {
+	void open(in VideoCodec codec, in String remoteHost, in int remotePort);
+	
+	void close();
+
+	void start();
+
+	void stop();
+
+	int getLocalRtpPort();
+
+	VideoCodec getCodec();
+
+	VideoCodec[] getSupportedCodecs();
+
+	void addEventListener(in IVideoPlayerListener listener);
+
+	void removeEventListener(in IVideoPlayerListener listener);	
+    void setOrientationHeaderId(in int headerId);
+}
diff --git a/src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl b/src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl
new file mode 100644
index 0000000..613c23c
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoPlayerListener.aidl
@@ -0,0 +1,16 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Video player event listener interface
+ */
+interface IVideoPlayerListener {
+	void onPlayerOpened();
+
+	void onPlayerStarted();
+
+	void onPlayerStopped();
+
+	void onPlayerClosed();
+
+	void onPlayerFailed();
+}
diff --git a/src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl b/src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl
new file mode 100644
index 0000000..33f8445
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoRenderer.aidl
@@ -0,0 +1,29 @@
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.vsh.VideoCodec;
+import org.gsma.joyn.vsh.IVideoRendererListener;
+
+/**
+ * Video renderer interface
+ */
+interface IVideoRenderer {
+	void open(in VideoCodec codec, in String remoteHost, in int remotePort);
+
+	void close();
+
+	void start();
+
+	void stop();
+
+	int getLocalRtpPort();
+
+	VideoCodec getCodec();
+
+	VideoCodec[] getSupportedCodecs();
+	
+	void addEventListener(in IVideoRendererListener listener);
+
+	void removeEventListener(in IVideoRendererListener listener);
+	
+	void setOrientationHeaderId(in int headerId);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl b/src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl
new file mode 100644
index 0000000..24d28b2
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoRendererListener.aidl
@@ -0,0 +1,17 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Video renderer event listener interface
+ */
+interface IVideoRendererListener {
+	void onRendererOpened();
+
+	void onRendererStarted();
+
+	void onRendererStopped();
+
+	void onRendererClosed();
+
+	void onRendererFailed();		
+	
+}
diff --git a/src/java/org/gsma/joyn/vsh/IVideoSharing.aidl b/src/java/org/gsma/joyn/vsh/IVideoSharing.aidl
new file mode 100644
index 0000000..a1ba72b
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoSharing.aidl
@@ -0,0 +1,35 @@
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.vsh.IVideoSharingListener;
+import org.gsma.joyn.vsh.IVideoRenderer;
+import org.gsma.joyn.vsh.VideoCodec;
+
+/**
+ * Video sharing interface
+ */
+interface IVideoSharing {
+
+	String getSharingId();
+
+	String getRemoteContact();
+
+	VideoCodec getVideoCodec();
+
+	int getState();
+
+	String getVideoEncoding();
+	
+	String getVideoFormat();
+
+	int getDirection();
+	
+	void acceptInvitation(IVideoRenderer renderer);
+
+	void rejectInvitation();
+
+	void abortSharing();
+	
+	void addEventListener(in IVideoSharingListener listener);
+
+	void removeEventListener(in IVideoSharingListener listener);
+}
diff --git a/src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl b/src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl
new file mode 100644
index 0000000..4b3cf09
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoSharingListener.aidl
@@ -0,0 +1,12 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Callback methods for video sharing events
+ */
+interface IVideoSharingListener {
+	void onSharingStarted();
+	
+	void onSharingAborted();
+
+	void onSharingError(in int error);
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl b/src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl
new file mode 100644
index 0000000..98cd0a3
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/IVideoSharingService.aidl
@@ -0,0 +1,33 @@
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.IJoynServiceRegistrationListener;
+import org.gsma.joyn.vsh.IVideoSharing;
+import org.gsma.joyn.vsh.IVideoSharingListener;
+import org.gsma.joyn.vsh.INewVideoSharingListener;
+import org.gsma.joyn.vsh.IVideoPlayer;
+import org.gsma.joyn.vsh.VideoSharingServiceConfiguration;
+
+/**
+ * Video sharing service API
+ */
+interface IVideoSharingService {
+	boolean isServiceRegistered();
+
+	void addServiceRegistrationListener(IJoynServiceRegistrationListener listener);
+
+	void removeServiceRegistrationListener(IJoynServiceRegistrationListener listener); 
+
+	VideoSharingServiceConfiguration getConfiguration();
+
+	List<IBinder> getVideoSharings();
+	
+	IVideoSharing getVideoSharing(in String sharingId);
+
+	IVideoSharing shareVideo(in String contact, in IVideoPlayer player, in IVideoSharingListener listener);
+	
+	void addNewVideoSharingListener(in INewVideoSharingListener listener);
+
+	void removeNewVideoSharingListener(in INewVideoSharingListener listener);
+	
+	int getServiceVersion();
+}
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/NewVideoSharingListener.java b/src/java/org/gsma/joyn/vsh/NewVideoSharingListener.java
new file mode 100644
index 0000000..332813e
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/NewVideoSharingListener.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+
+/**
+ * New video sharing invitation event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class NewVideoSharingListener extends INewVideoSharingListener.Stub {
+    /**
+     * Callback called when a new video sharing invitation has been received
+     *
+     * @param sharingId Sharing ID
+     */
+    public abstract void onNewVideoSharing(String sharingId);
+
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoCodec.aidl b/src/java/org/gsma/joyn/vsh/VideoCodec.aidl
new file mode 100644
index 0000000..f6c95a9
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoCodec.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Video codec object
+ */
+parcelable VideoCodec;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/VideoCodec.java b/src/java/org/gsma/joyn/vsh/VideoCodec.java
new file mode 100644
index 0000000..3d2bbf6
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoCodec.java
@@ -0,0 +1,276 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import org.gsma.joyn.H264Config;
+
+/**
+ * Video codec
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoCodec implements Parcelable {
+    /**
+     * Video encoding
+     */
+    private String encoding;
+
+    /**
+     * Payload
+     */
+    private int payload;
+
+    /**
+     * Clock rate
+     */
+    private int clockRate;
+
+    /**
+     * Frame rate
+     */
+    private int frameRate;
+
+    /**
+     * Bit rate
+     */
+    private int bitRate;
+
+    /**
+     * Screen width
+     */
+    private int width;
+
+    /**
+     * Screen height
+     */
+    private int height;
+
+    /**
+     * Video parameters
+     */
+    private String parameters;
+
+    /**
+     * Constructor
+     *
+     * @param encoding Video encoding
+     * @param payload Payload
+     * @param clockRate Clock rate
+     * @param framerate Frame rate
+     * @param bitRate Bit rate
+     * @param width Video width
+     * @param height Video height
+     * @param parameters Codec parameters
+     * @hide
+     */
+    public VideoCodec(String encoding, int payload, int clockRate, int frameRate, int bitRate, int width, int height, String parameters) {
+        this.encoding = encoding;
+        this.payload = payload;
+        this.clockRate = clockRate;
+        this.frameRate = frameRate;
+        this.bitRate = bitRate;
+        this.width = width;
+        this.height = height;
+        this.parameters = parameters;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public VideoCodec(Parcel source) {
+        this.encoding = source.readString();
+        this.payload = source.readInt();
+        this.clockRate = source.readInt();
+        this.frameRate = source.readInt();
+        this.bitRate = source.readInt();
+        this.width = source.readInt();
+        this.height = source.readInt();
+        this.parameters = source.readString();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(encoding);
+        dest.writeInt(payload);
+        dest.writeInt(clockRate);
+        dest.writeInt(frameRate);
+        dest.writeInt(bitRate);
+        dest.writeInt(width);
+        dest.writeInt(height);
+        dest.writeString(parameters);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<VideoCodec> CREATOR
+            = new Parcelable.Creator<VideoCodec>() {
+        public VideoCodec createFromParcel(Parcel source) {
+            return new VideoCodec(source);
+        }
+
+        public VideoCodec[] newArray(int size) {
+            return new VideoCodec[size];
+        }
+    };
+
+    /**
+    * Returns the encoding name (e.g. H264)
+    *
+    * @return Encoding name
+    */
+    public String getEncoding() {
+        return encoding;
+    }
+
+    /**
+     * Returns the codec payload type (e.g. 96)
+     *
+     * @return Payload type
+     */
+    public int getPayloadType() {
+        return payload;
+    }
+
+    /**
+     * Returns the codec clock rate (e.g. 90000)
+     *
+     * @return Clock rate
+     */
+    public int getClockRate() {
+        return clockRate;
+    }
+
+    /**
+     * Returns the codec frame rate (e.g. 10)
+     *
+     * @return Frame rate
+     */
+    public int getFrameRate() {
+        return frameRate;
+    }
+
+    /**
+     * Returns the codec bit rate (e.g. 64000)
+     *
+     * @return Bit rate
+     */
+    public int getBitRate() {
+        return bitRate;
+    }
+
+    /**
+     * Returns the video width (e.g. 176)
+     *
+     * @return Video width
+     */
+    public int getVideoWidth() {
+        return width;
+    }
+
+    /**
+     * Returns the video height (e.g. 144)
+     *
+     * @return Video height
+     */
+    public int getVideoHeight() {
+        return height;
+    }
+
+    /**
+     * Returns the list of codec parameters (e.g. profile-level-id, packetization-mode).
+     * Parameters are are semicolon separated.
+     *
+     * @return Parameters
+     */
+    public String getParameters() {
+        return parameters;
+    }
+
+
+    /**
+     * Returns the value of codec parameter key (e.g. profile-level-id, packetization-mode).
+     *
+     * @return Parameters
+     */
+    public String getParameter(String key) {
+        String value = null;
+        String[] parameters = getParameters().split(",");
+        ArrayList<String> codecparams = new ArrayList<String>(Arrays.asList(parameters));
+        for (int i = 0; i < codecparams.size() ; i++)
+        {
+            if (codecparams.get(i).startsWith(key))
+            {
+                value = codecparams.get(i).substring(key.length() + 1);
+            }
+        }
+        return value;
+    }
+
+    /**
+     * Compare codec
+     *
+     * @param codec Codec to compare
+     * @return Returns True if codecs are equals, else returns False
+     */
+    public boolean compare(VideoCodec codec) {
+        boolean ret = false;
+        if (getEncoding().equalsIgnoreCase(codec.getEncoding())
+                && (getVideoWidth() == codec.getVideoWidth() || getVideoWidth() == 0 || codec.getVideoWidth() == 0)
+                && (getVideoHeight() == codec.getVideoHeight() || getVideoHeight() == 0 || codec.getVideoHeight() == 0)) {
+            if (getEncoding().equalsIgnoreCase(H264Config.CODEC_NAME)) {
+                if (H264Config.getCodecProfileLevelId(getParameters()).compareToIgnoreCase(H264Config.getCodecProfileLevelId(codec.getParameters())) == 0) {
+                    ret =  true;
+                }
+            } else {
+                if (getParameters().equalsIgnoreCase(codec.getParameters())) {
+                    ret = true;
+                }
+            }
+        }
+        return ret;
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoPlayer.java b/src/java/org/gsma/joyn/vsh/VideoPlayer.java
new file mode 100644
index 0000000..f1a800d
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoPlayer.java
@@ -0,0 +1,145 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import java.util.HashSet;
+import java.util.Set;
+
+
+
+
+/**
+ * Video player offers an interface to manage the video player instance
+ * independently of the joyn service. The video player is implemented in
+ * the application side. The video player captures the video from the device
+ * camera, encodes the video into the selected format and streams the encoded
+ * video frames over the network in RTP.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoPlayer extends IVideoPlayer.Stub {
+    /**
+     * Video player error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Network connection failed
+         */
+        public final static int NETWORK_FAILURE = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Video player event listeners
+     */
+    private Set<IVideoPlayerListener> listeners = new HashSet<IVideoPlayerListener>();
+
+    /**
+     * Constructor
+     */
+    public VideoPlayer() {
+    }
+
+    /**
+     * Opens the player and prepares resources (e.g. encoder, camera)
+     *
+     * @param codec Video codec
+     * @param remoteHost Remote RTP host
+     * @param remotePort Remote RTP port
+     */
+    public abstract void open(VideoCodec codec, String remoteHost, int remotePort);
+
+    /**
+     * Closes the player and deallocates resources
+     *
+     * @throws JoynServiceException
+     */
+    public abstract void close();
+
+    /**
+     * Starts the player
+     */
+    public abstract void start();
+
+    /**
+     * Stops the player
+     */
+    public abstract void stop();
+
+    /**
+     * Returns the local RTP port used to stream video
+     *
+     * @return Port number
+     */
+    public abstract int getLocalRtpPort();
+
+    /**
+     * Returns the list of codecs supported by the player
+     *
+     * @return List of codecs
+     */
+    public abstract VideoCodec[] getSupportedCodecs();
+
+    /**
+     * Returns the current codec
+     *
+     * @return Codec
+     */
+    public abstract VideoCodec getCodec();
+
+    /**
+     * Returns the list of player event listeners
+     *
+     * @return Listeners
+     */
+    public Set<IVideoPlayerListener> getEventListeners() {
+        return listeners;
+    }
+
+    /**
+     * Adds a listener on player events
+     *
+     * @param listener Listener
+     */
+    public void addEventListener(IVideoPlayerListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a listener from player events
+     *
+     * @param listener Listener
+     */
+    public void removeEventListener(IVideoPlayerListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all listeners from player events
+     */
+    public void removeAllEventListeners() {
+        listeners.clear();
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoPlayerListener.java b/src/java/org/gsma/joyn/vsh/VideoPlayerListener.java
new file mode 100644
index 0000000..555a1f6
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoPlayerListener.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+
+/**
+ * This class offers callback methods on video player events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoPlayerListener extends IVideoPlayerListener.Stub {
+    /**
+     * Callback called when the player is opened
+     */
+    public abstract void onPlayerOpened();
+
+    /**
+     * Callback called when the player is started
+     */
+    public abstract void onPlayerStarted();
+
+    /**
+     * Callback called when the player is stopped
+     */
+    public abstract void onPlayerStopped();
+
+    /**
+     * Callback called when the player is closed
+     */
+    public abstract void onPlayerClosed();
+
+    /**
+     * Callback called when the player has failed
+     *
+     * @param error Error
+     */
+    public abstract void onPlayerFailed();
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoRenderer.java b/src/java/org/gsma/joyn/vsh/VideoRenderer.java
new file mode 100644
index 0000000..2fec64d
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoRenderer.java
@@ -0,0 +1,140 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Video renderer offers an interface to manage the video renderer instance
+ * independently of the joyn service. The video renderer is implemented in
+ * the application side. The video renderer receives the video streaming over
+ * the network in RTP, decodes the video frames and displays the decoded
+ * picture on the device screen.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoRenderer extends IVideoRenderer.Stub {
+    /**
+     * Video renderer error
+     */
+    public static class Error {
+        /**
+         * Internal error
+         */
+        public final static int INTERNAL_ERROR = 0;
+
+        /**
+         * Network connection failed
+         */
+        public final static int NETWORK_FAILURE = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Video renderer event listeners
+     */
+    private Set<IVideoRendererListener> listeners = new HashSet<IVideoRendererListener>();
+
+    /**
+     * Constructor
+     */
+    public VideoRenderer() {
+    }
+
+    /**
+     * Opens the renderer and prepares resources (e.g. decoder)
+     *
+     * @param codec Video codec
+     * @param remoteHost Remote RTP host
+     * @param remotePort Remote RTP port
+     */
+    public abstract void open(VideoCodec codec, String remoteHost, int remotePort);
+
+    /**
+     * Closes the renderer and deallocates resources
+     */
+    public abstract void close();
+
+    /**
+     * Starts the renderer
+     */
+    public abstract void start();
+
+    /**
+     * Stops the renderer
+     */
+    public abstract void stop();
+
+    /**
+     * Returns the local RTP port used to stream video
+     *
+     * @return Port number
+     */
+    public abstract int getLocalRtpPort();
+
+    /**
+     * Returns the current codec
+     *
+     * @return Codec
+     */
+    public abstract VideoCodec getCodec();
+
+    /**
+     * Returns the list of codecs supported by the renderer
+     *
+     * @return List of codecs
+     */
+    public abstract VideoCodec[] getSupportedCodecs();
+
+    /**
+     * Returns the list of renderer event listeners
+     *
+     * @return Listeners
+     */
+    public Set<IVideoRendererListener> getEventListeners() {
+        return listeners;
+    }
+
+    /**
+     * Adds a listener on renderer events
+     *
+     * @param listener Listener
+     */
+    public void addEventListener(IVideoRendererListener listener) {
+        listeners.add(listener);
+    }
+
+    /**
+     * Removes a listener from renderer events
+     *
+     * @param listener Listener
+     */
+    public void removeEventListener(IVideoRendererListener listener) {
+        listeners.remove(listener);
+    }
+
+    /**
+     * Removes all listeners from renderer events
+     */
+    public void removeAllEventListeners() {
+        listeners.clear();
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoRendererListener.java b/src/java/org/gsma/joyn/vsh/VideoRendererListener.java
new file mode 100644
index 0000000..b903ff3
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoRendererListener.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+
+/**
+ * This class offers callback methods on video renderer events
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoRendererListener extends IVideoRendererListener.Stub {
+    /**
+     * Callback called when the renderer is opened
+     */
+    public abstract void onRendererOpened();
+
+    /**
+     * Callback called when the renderer is started
+     */
+    public abstract void onRendererStarted();
+
+    /**
+     * Callback called when the renderer is stopped
+     */
+    public abstract void onRendererStopped();
+
+    /**
+     * Callback called when the renderer is closed
+     */
+    public abstract void onRendererClosed();
+
+    /**
+     * Callback called when the renderer has failed
+     *
+     * @param error Error
+     */
+    public abstract void onRendererFailed();
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharing.java b/src/java/org/gsma/joyn/vsh/VideoSharing.java
new file mode 100644
index 0000000..06b307d
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharing.java
@@ -0,0 +1,300 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import org.gsma.joyn.JoynServiceException;
+
+/**
+ * Video sharing
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharing {
+
+    /**
+     * Video sharing state
+     */
+    public static class State {
+        /**
+         * Unknown state
+         */
+        public final static int UNKNOWN = 0;
+
+        /**
+         * Sharing invitation received
+         */
+        public final static int INVITED = 1;
+
+        /**
+         * Sharing invitation sent
+         */
+        public final static int INITIATED = 2;
+
+        /**
+         * Sharing is started
+         */
+        public final static int STARTED = 3;
+
+        /**
+         * Sharing has been aborted
+         */
+        public final static int ABORTED = 5;
+
+        /**
+         * Sharing has been terminated
+         */
+        public static final int TERMINATED = 6;
+
+        /**
+         * Sharing has failed
+         */
+        public final static int FAILED = 7;
+
+        private State() {
+        }
+    }
+
+    /**
+     * Direction of the sharing
+     */
+    public static class Direction {
+        /**
+         * Incoming sharing
+         */
+        public static final int INCOMING = 0;
+
+        /**
+         * Outgoing sharing
+         */
+        public static final int OUTGOING = 1;
+    }
+
+    /**
+     * Video sharing error
+     */
+    public static class Error {
+        /**
+         * Sharing has failed
+         */
+        public final static int SHARING_FAILED = 0;
+
+        /**
+         * Sharing invitation has been declined by remote
+         */
+        public final static int INVITATION_DECLINED = 1;
+
+        private Error() {
+        }
+    }
+
+    /**
+     * Video encoding
+     */
+    public static class Encoding {
+        /**
+         * H264
+         */
+        public static final int H264 = 0;
+    }
+
+    /**
+     * Video sharing interface
+     */
+    private IVideoSharing sharingInf;
+
+    /**
+     * Constructor
+     *
+     * @param sharingInf Video sharing interface
+     */
+    VideoSharing(IVideoSharing sharingInf) {
+        this.sharingInf = sharingInf;
+    }
+
+    /**
+     * Returns the sharing ID of the video sharing
+     *
+     * @return Sharing ID
+     * @throws JoynServiceException
+     */
+    public String getSharingId() throws JoynServiceException {
+        try {
+            return sharingInf.getSharingId();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the remote contact
+     *
+     * @return Contact
+     * @throws JoynServiceException
+     */
+    public String getRemoteContact() throws JoynServiceException {
+        try {
+            return sharingInf.getRemoteContact();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+
+    /**
+     * Returns the video Encoding like H264
+     *
+     * @return Video codec
+     * @see VideoCodec
+     * @throws JoynServiceException
+     */
+    public String getVideoEncoding() throws JoynServiceException {
+        try {
+            return sharingInf.getVideoEncoding();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the video Format (e.g. QCIF)
+     *
+     * @return Video codec
+     * @see VideoCodec
+     * @throws JoynServiceException
+     */
+    public String getVideoFormat() throws JoynServiceException {
+        try {
+            return sharingInf.getVideoFormat();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the video codec
+     *
+     * @return Video codec
+     * @see VideoCodec
+     * @throws JoynServiceException
+     */
+    public VideoCodec getVideoCodec() throws JoynServiceException {
+        try {
+            return sharingInf.getVideoCodec();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the state of the sharing
+     *
+     * @return State
+     * @see VideoSharing.State
+     * @throws JoynServiceException
+     */
+    public int getState() throws JoynServiceException {
+        try {
+            return sharingInf.getState();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Returns the direction of the sharing (incoming or outgoing)
+     *
+     * @return Direction
+     * @see VideoSharing.Direction
+     * @throws JoynServiceException
+     */
+    public int getDirection() throws JoynServiceException {
+        try {
+            return sharingInf.getDirection();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Accepts video sharing invitation
+     *
+     * @param renderer Video renderer
+     * @throws JoynServiceException
+     */
+    public void acceptInvitation(VideoRenderer renderer) throws JoynServiceException {
+        try {
+            sharingInf.acceptInvitation(renderer);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Rejects video sharing invitation
+     *
+     * @throws JoynServiceException
+     */
+    public void rejectInvitation() throws JoynServiceException {
+        try {
+            sharingInf.rejectInvitation();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Aborts the sharing
+     *
+     * @throws JoynServiceException
+     */
+    public void abortSharing() throws JoynServiceException {
+        try {
+            sharingInf.abortSharing();
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Adds a listener on video sharing events
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void addEventListener(VideoSharingListener listener) throws JoynServiceException {
+        try {
+            sharingInf.addEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+
+    /**
+     * Removes a listener from video sharing
+     *
+     * @param listener Listener
+     * @throws JoynServiceException
+     */
+    public void removeEventListener(VideoSharingListener listener) throws JoynServiceException {
+        try {
+            sharingInf.removeEventListener(listener);
+        } catch (Exception e) {
+            throw new JoynServiceException(e.getMessage());
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingIntent.java b/src/java/org/gsma/joyn/vsh/VideoSharingIntent.java
new file mode 100644
index 0000000..7e5e862
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingIntent.java
@@ -0,0 +1,77 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+/**
+ * Intent for video sharing invitations
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharingIntent {
+    /**
+     * Broadcast action: a new video sharing invitation has been received.
+     * <p>Intent includes the following extras:
+     * <ul>
+     * <li> {@link #EXTRA_CONTACT} containing the MSISDN of the contact
+     *  sending the invitation.
+     * <li> {@link #EXTRA_DISPLAY_NAME} containing the display name of the
+     *  contact sending the invitation (extracted from the SIP address).
+     * <li> {@link #EXTRA_SHARING_ID} containing the unique ID of the video sharing.
+     * <li> {@link #EXTRA_ENCODING} containing the video encoding.
+     * <li> {@link #EXTRA_FORMAT} containing the video format.
+     * <li> {@link #EXTRA_WIDTH} containing the video width.
+     * <li> {@link #EXTRA_HEIGHT} containing the video height.
+     * </ul>
+     */
+    public final static String ACTION_NEW_INVITATION = "org.gsma.joyn.vsh.action.NEW_VIDEO_SHARING";
+
+    /**
+     * MSISDN of the contact sending the invitation
+     */
+    public final static String EXTRA_CONTACT = "contact";
+
+    /**
+     * Display name of the contact sending the invitation
+     */
+    public final static String EXTRA_DISPLAY_NAME = "contactDisplayname";
+
+    /**
+     * Unique ID of the video sharing
+     */
+    public final static String EXTRA_SHARING_ID = "sharingId";
+
+    /**
+     * Video encoding (e.g. H264)
+     */
+    public final static String EXTRA_ENCODING = "encoding";
+
+    /**
+     * Video format (e.g. QCIF)
+     */
+    public final static String EXTRA_FORMAT = "format";
+
+    /**
+     * Video width (in pixels)
+     */
+    public final static String EXTRA_WIDTH = "width";
+
+    /**
+     * Video height (in pixels)
+     */
+    public final static String EXTRA_HEIGHT = "height";
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingListener.java b/src/java/org/gsma/joyn/vsh/VideoSharingListener.java
new file mode 100644
index 0000000..c8edea9
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingListener.java
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+
+/**
+ * Video sharing event listener
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public abstract class VideoSharingListener extends IVideoSharingListener.Stub {
+    /**
+     * Callback called when the sharing is started
+     */
+    public abstract void onSharingStarted();
+
+    /**
+     * Callback called when the sharing has been aborted or terminated
+     */
+    public abstract void onSharingAborted();
+
+    /**
+     * Callback called when the sharing has failed
+     *
+     * @param error Error
+     * @see VideoSharing.Error
+     */
+    public abstract void onSharingError(int error);
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingLog.java b/src/java/org/gsma/joyn/vsh/VideoSharingLog.java
new file mode 100644
index 0000000..d4a3b1c
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingLog.java
@@ -0,0 +1,77 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import android.net.Uri;
+
+/**
+ * Content provider for video sharing history
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharingLog {
+    /**
+     * Content provider URI
+     */
+    public static final Uri CONTENT_URI = Uri.parse("content://org.gsma.joyn.provider.vsh/vsh");
+
+    /**
+     * The name of the column containing the unique ID for a row.
+     * <P>Type: primary key</P>
+     */
+    public static final String ID = "_id";
+
+    /**
+     * The name of the column containing the unique ID of the video sharing.
+     * <P>Type: TEXT</P>
+     */
+    public static final String SHARING_ID = "sharing_id";
+
+    /**
+     * The name of the column containing the MSISDN of the sender.
+     * <P>Type: TEXT</P>
+     */
+    public static final String CONTACT_NUMBER = "contact_number";
+
+    /**
+     * The name of the column containing the direction of the sharing.
+     * <P>Type: INTEGER</P>
+     * @see VideoSharing.Direction
+     */
+    public static final String DIRECTION = "direction";
+
+    /**
+     * The name of the column containing the date of the sharing (in milliseconds).
+     * <P>Type: LONG</P>
+     */
+    public static final String TIMESTAMP = "timestamp";
+
+    /**
+     * The name of the column containing the duration of the sharing (in seconds). The
+     * value is only set at the end of the call.
+     * <P>Type: LONG</P>
+     */
+    public static final String DURATION = "duration";
+
+    /**
+     * The name of the column containing the state of the sharing.
+     * <P>Type: INTEGER</P>
+     * @see VideoSharing.State
+     */
+    public static final String STATE = "state";
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingService.java b/src/java/org/gsma/joyn/vsh/VideoSharingService.java
new file mode 100644
index 0000000..c42930f
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingService.java
@@ -0,0 +1,397 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.gsma.joyn.JoynContactFormatException;
+import org.gsma.joyn.JoynService;
+import org.gsma.joyn.JoynServiceException;
+import org.gsma.joyn.JoynServiceListener;
+import org.gsma.joyn.JoynServiceNotAvailableException;
+import org.gsma.joyn.JoynServiceRegistrationListener;
+import org.gsma.joyn.ICoreServiceWrapper;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.RemoteException;
+
+import org.gsma.joyn.Logger;
+
+/**
+ * This class offers the main entry point to share live video during a CS call.
+ * Several applications may connect/disconnect to the API.
+ *
+ * The parameter contact in the API supports the following formats: MSISDN in
+ * national or international format, SIP address, SIP-URI or Tel-URI.
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharingService extends JoynService {
+    /**
+     * API
+     */
+    private IVideoSharingService api = null;
+
+    public static final String TAG = "VideoSharingService";
+
+    /**
+     * Constructor
+     *
+     * @param ctx
+     *            Application context
+     * @param listener
+     *            Service listener
+     */
+    public VideoSharingService(Context ctx, JoynServiceListener listener) {
+        super(ctx, listener);
+    }
+
+    /**
+     * Connects to the API
+     */
+    public void connect() {
+        Logger.i(TAG, "connect() entry");
+        Intent intent = new Intent();
+        ComponentName cmp = new ComponentName("com.orangelabs.rcs", "com.orangelabs.rcs.service.RcsCoreService");
+        intent.setComponent(cmp);
+        ctx.bindService(intent, apiConnection, 0);
+
+    }
+
+    /**
+     * Disconnects from the API
+     */
+    public void disconnect() {
+        try {
+            ctx.unbindService(apiConnection);
+        } catch (IllegalArgumentException e) {
+            // Nothing to do
+        }
+    }
+
+    /**
+     * Set API interface
+     *
+     * @param api API interface
+     */
+    protected void setApi(IInterface api) {
+        super.setApi(api);
+
+        this.api = (IVideoSharingService) api;
+    }
+
+    /**
+     * Service connection
+     */
+    private ServiceConnection apiConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            ICoreServiceWrapper mCoreServiceWrapperBinder = ICoreServiceWrapper.Stub.asInterface(service);
+            IBinder binder = null;
+            try {
+                binder = mCoreServiceWrapperBinder.getVideoSharingServiceBinder();
+            } catch (RemoteException e1) {
+                e1.printStackTrace();
+            }
+            setApi(IVideoSharingService.Stub.asInterface(binder));
+            if (serviceListener != null) {
+                serviceListener.onServiceConnected();
+            }
+        }
+
+        public void onServiceDisconnected(ComponentName className) {
+            setApi(null);
+            if (serviceListener != null) {
+                serviceListener
+                        .onServiceDisconnected(JoynService.Error.CONNECTION_LOST);
+            }
+        }
+    };
+
+    /**
+     * Returns the configuration of video sharing service
+     *
+     * @return Configuration
+     * @throws JoynServiceException
+     */
+    public VideoSharingServiceConfiguration getConfiguration()
+            throws JoynServiceException {
+        if (api != null) {
+            try {
+                return api.getConfiguration();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Shares a live video with a contact. The parameter renderer contains the
+     * video player provided by the application. An exception if thrown if there
+     * is no ongoing CS call. The parameter contact supports the following
+     * formats: MSISDN in national or international format, SIP address, SIP-URI
+     * or Tel-URI. If the format of the contact is not supported an exception is
+     * thrown.
+     *
+     * @param contact
+     *            Contact
+     * @param player
+     *            Video player
+     * @param listener
+     *            Video sharing event listener
+     * @return Video sharing
+     * @throws JoynServiceException
+     * @throws JoynContactFormatException
+     */
+    public VideoSharing shareVideo(String contact, VideoPlayer player,
+            VideoSharingListener listener) throws JoynServiceException,
+            JoynContactFormatException {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_VIDEOSHARE_SEND) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_VIDEOSHARE_SEND");
+        }  */
+        if (api != null) {
+            try {
+                IVideoSharing sharingIntf = api.shareVideo(contact, player,
+                        listener);
+                if (sharingIntf != null) {
+                    return new VideoSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns the list of video sharings in progress
+     *
+     * @return List of video sharings
+     * @throws JoynServiceException
+     */
+    public Set<VideoSharing> getVideoSharings() throws JoynServiceException {
+        if (api != null) {
+            try {
+                Set<VideoSharing> result = new HashSet<VideoSharing>();
+                List<IBinder> vshList = api.getVideoSharings();
+                for (IBinder binder : vshList) {
+                    VideoSharing sharing = new VideoSharing(
+                            IVideoSharing.Stub.asInterface(binder));
+                    result.add(sharing);
+                }
+                return result;
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current video sharing from its unique ID
+     *
+     * @param sharingId
+     *            Sharing ID
+     * @return Video sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public VideoSharing getVideoSharing(String sharingId)
+            throws JoynServiceException {
+        if (api != null) {
+            try {
+                IVideoSharing sharingIntf = api.getVideoSharing(sharingId);
+                if (sharingIntf != null) {
+                    return new VideoSharing(sharingIntf);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns a current video sharing from its invitation Intent
+     *
+     * @param intent
+     *            Invitation intent
+     * @return Video sharing or null if not found
+     * @throws JoynServiceException
+     */
+    public VideoSharing getVideoSharingFor(Intent intent)
+            throws JoynServiceException {
+        if (api != null) {
+            try {
+                String sharingId = intent
+                        .getStringExtra(VideoSharingIntent.EXTRA_SHARING_ID);
+                if (sharingId != null) {
+                    return getVideoSharing(sharingId);
+                } else {
+                    return null;
+                }
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns service version
+     *
+     * @return Version
+     * @see Build.VERSION_CODES
+     * @throws JoynServiceException
+     */
+    public int getServiceVersion() throws JoynServiceException {
+        if (api != null) {
+            if (version == null) {
+                try {
+                    version = api.getServiceVersion();
+                } catch (Exception e) {
+                    throw new JoynServiceException(e.getMessage());
+                }
+            }
+            return version;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Returns true if the service is registered to the platform, else returns
+     * false
+     *
+     * @return Returns true if registered else returns false
+     * @throws JoynServiceException
+     */
+    public boolean isServiceRegistered() throws JoynServiceException {
+        if (api != null) {
+            boolean serviceStatus = false;
+            try {
+                serviceStatus = api.isServiceRegistered();
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+            return serviceStatus;
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Registers a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void addServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException {
+        Logger.i(TAG, "addServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.addServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a listener on service registration events
+     *
+     * @param listener Service registration listener
+     * @throws JoynServiceException
+     */
+    public void removeServiceRegistrationListener(JoynServiceRegistrationListener listener) throws JoynServiceException  {
+        Logger.i(TAG, "removeServiceRegistrationListener entry" + listener);
+        if (api != null) {
+            try {
+                api.removeServiceRegistrationListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+
+    /**
+     * Registers a new video sharing invitation listener
+     *
+     * @param listener
+     *            New video sharing listener
+     * @throws JoynServiceException
+     */
+    public void addNewVideoSharingListener(NewVideoSharingListener listener)
+            throws JoynServiceException {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_VIDEOSHARE_READ) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_VIDEOSHARE_READ");
+        } */
+        if (api != null) {
+            try {
+                api.addNewVideoSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+
+    /**
+     * Unregisters a new video sharing invitation listener
+     *
+     * @param listener
+     *            New video sharing listener
+     * @throws JoynServiceException
+     */
+    public void removeNewVideoSharingListener(NewVideoSharingListener listener)
+            throws JoynServiceException {
+        /*if (this.ctx.checkCallingOrSelfPermission(Permissions.RCS_VIDEOSHARE_READ) != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException(" Required permission RCS_VIDEOSHARE_READ");
+        } */
+        if (api != null) {
+            try {
+                api.removeNewVideoSharingListener(listener);
+            } catch (Exception e) {
+                throw new JoynServiceException(e.getMessage());
+            }
+        } else {
+            throw new JoynServiceNotAvailableException();
+        }
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.aidl b/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.aidl
new file mode 100644
index 0000000..f45a174
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.aidl
@@ -0,0 +1,6 @@
+package org.gsma.joyn.vsh;
+
+/**
+ * Video sharing configuration object
+ */
+parcelable VideoSharingServiceConfiguration;
\ No newline at end of file
diff --git a/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.java b/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.java
new file mode 100644
index 0000000..82d70bf
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/VideoSharingServiceConfiguration.java
@@ -0,0 +1,101 @@
+/*******************************************************************************
+ * Software Name : RCS IMS Stack
+ *
+ * Copyright (C) 2010 France Telecom S.A.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package org.gsma.joyn.vsh;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Video sharing service configuration
+ *
+ * @author Jean-Marc AUFFRET
+ */
+public class VideoSharingServiceConfiguration implements Parcelable {
+    /**
+     * Maximum duration of the video sharing
+     */
+    private long maxTime;
+
+    /**
+     * Constructor
+     *
+     * @param maxTime Maximum authorized duration of the video sharing
+     * @hide
+     */
+    public VideoSharingServiceConfiguration(long maxTime) {
+        this.maxTime = maxTime;
+    }
+
+    /**
+     * Constructor
+     *
+     * @param source Parcelable source
+     * @hide
+     */
+    public VideoSharingServiceConfiguration(Parcel source) {
+        this.maxTime = source.readLong();
+    }
+
+    /**
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation
+     *
+     * @return Integer
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Write parcelable object
+     *
+     * @param dest The Parcel in which the object should be written
+     * @param flags Additional flags about how the object should be written
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(maxTime);
+    }
+
+    /**
+     * Parcelable creator
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<VideoSharingServiceConfiguration> CREATOR
+            = new Parcelable.Creator<VideoSharingServiceConfiguration>() {
+        public VideoSharingServiceConfiguration createFromParcel(Parcel source) {
+            return new VideoSharingServiceConfiguration(source);
+        }
+
+        public VideoSharingServiceConfiguration[] newArray(int size) {
+            return new VideoSharingServiceConfiguration[size];
+        }
+    };
+
+    /**
+     * Returns the maximum authorized duration of the video sharing. It returns 0 if
+     * there is no limitation.
+     *
+     * @return Duration in seconds
+     */
+    public long getMaxTime() {
+        return maxTime;
+    }
+}
diff --git a/src/java/org/gsma/joyn/vsh/package-info.java b/src/java/org/gsma/joyn/vsh/package-info.java
new file mode 100644
index 0000000..fa778cf
--- /dev/null
+++ b/src/java/org/gsma/joyn/vsh/package-info.java
@@ -0,0 +1,6 @@
+/**
+ * This API exposes all functionality related to sharing live video stream
+ * during a CS call via the Video Sharing service.
+ * <p>
+ */
+package org.gsma.joyn.vsh;
