commit 7e851478c861d850977b404635b94dc466e5981c
Author: Deepflex <hqdevnews@gmail.com>
Date:   Mon Aug 1 18:43:03 2016 +0700

    mtk frameworks base
    
    Change-Id: Ia5963a38d8bc3119f12c951e527e06a82860ba2f

diff --git a/Android.mk b/Android.mk
index 03651fa..36f197c 100644
--- a/Android.mk
+++ b/Android.mk
@@ -411,7 +411,7 @@ LOCAL_SRC_FILES += \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
 	telephony/java/com/android/internal/telephony/ITelephonyRegistry.aidl \
 	telephony/java/com/android/internal/telephony/IWapPushManager.aidl \
-        telephony/java/com/android/internal/telephony/IExtTelephony.aidl \
+    telephony/java/com/android/internal/telephony/IExtTelephony.aidl \
 	wifi/java/android/net/wifi/IWifiManager.aidl \
 	wifi/java/android/net/wifi/passpoint/IWifiPasspointManager.aidl \
 	wifi/java/android/net/wifi/p2p/IWifiP2pManager.aidl \
@@ -421,6 +421,10 @@ LOCAL_SRC_FILES += \
 	packages/services/Proxy/com/android/net/IProxyCallback.aidl \
 	packages/services/Proxy/com/android/net/IProxyPortListener.aidl \
 	../../vendor/cmsdk/sdk/src/java/org/cyanogenmod/internal/themes/IIconCacheManager.aidl \
+    core/java/com/mediatek/gba/IGbaService.aidl \
+	telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl \
+    telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl \
+    telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl \
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
 LOCAL_AIDL_INCLUDES += $(FRAMEWORKS_BASE_JAVA_SRC_DIRS)
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index 7ddda11..d5deb97 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -3017,6 +3017,19 @@ public abstract class Context {
      */
     public static final String TELEPHONY_SERVICE = "phone";
 
+    // MTK
+    /**
+     * Use with {@link #getSystemService} to retrieve a
+     * {@link android.telephony.TelephonyManagerEx} for handling management the
+     * telephony features of the device.
+     *
+     * @see #getSystemService
+     * @see android.telephony.TelephonyManagerEx
+     * @hide
+     * @internal
+     */
+    public static final String TELEPHONY_SERVICE_EX = "phoneEx";
+
     /**
      * Use with {@link #getSystemService} to retrieve a
      * {@link android.telephony.SubscriptionManager} for handling management the
diff --git a/core/java/android/net/ConnectivityManager.java b/core/java/android/net/ConnectivityManager.java
index 6bbd9c8..1d381d7 100644
--- a/core/java/android/net/ConnectivityManager.java
+++ b/core/java/android/net/ConnectivityManager.java
@@ -472,11 +472,41 @@ public class ConnectivityManager {
      */
     public static final int TYPE_VPN = 17;
 
+    // MTK
+    /**
+     * Device Managment purpose.
+     * {@hide}
+     * @internal
+     */
+    public static final int TYPE_MOBILE_DM = 34;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_WAP = 35;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_NET = 36;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_CMMAIL = 37;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_TETHERING = 38;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_RCSE = 39;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_XCAP = 40;
+    /** {@hide} */
+    public static final int TYPE_MOBILE_RCS = 41;
+    /** M: end */
+
+    ///M @add  for 3gdongle
+    /** {@hide} */
+    public static final int TYPE_TEDONGLE = 49;
+
     /** {@hide} */
     public static final int MAX_RADIO_TYPE   = TYPE_VPN;
 
     /** {@hide} */
-    public static final int MAX_NETWORK_TYPE = TYPE_VPN;
+    public static final int MAX_AOSP_NETWORK_TYPE = TYPE_VPN;
+
+    /** {@hide} */
+    public static final int MAX_NETWORK_TYPE = TYPE_TEDONGLE;
 
     /**
      * If you want to set the default network preference,you can directly
@@ -525,7 +555,9 @@ public class ConnectivityManager {
      *             validate a network type.
      */
     public static boolean isNetworkTypeValid(int networkType) {
-        return networkType >= 0 && networkType <= MAX_NETWORK_TYPE;
+        // MTK
+        return (networkType >= 0 && networkType <= MAX_AOSP_NETWORK_TYPE)
+            || (networkType >= TYPE_MOBILE_DM && networkType <= MAX_NETWORK_TYPE);
     }
 
     /**
@@ -598,6 +630,9 @@ public class ConnectivityManager {
             case TYPE_MOBILE_CBS:
             case TYPE_MOBILE_IA:
             case TYPE_MOBILE_EMERGENCY:
+            // MTK
+            case TYPE_MOBILE_XCAP:
+            case TYPE_MOBILE_RCS:
                 return true;
             default:
                 return false;
@@ -1010,6 +1045,13 @@ public class ConnectivityManager {
                 cap = NetworkCapabilities.NET_CAPABILITY_IMS;
             } else if ("enableCBS".equals(feature)) {
                 cap = NetworkCapabilities.NET_CAPABILITY_CBS;
+            // MTK
+            } else if ("enableEmergency".equals(feature)) {
+                cap = NetworkCapabilities.NET_CAPABILITY_EIMS;
+            } else if ("enableXCAP".equals(feature)) {
+                cap = NetworkCapabilities.NET_CAPABILITY_XCAP;
+            } else if ("enableRCS".equals(feature)) {
+                cap = NetworkCapabilities.NET_CAPABILITY_RCS;
             } else {
                 return null;
             }
@@ -1077,6 +1119,16 @@ public class ConnectivityManager {
         } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
             type = "enableHIPRI";
             result = TYPE_MOBILE_HIPRI;
+        // MTK
+        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_EIMS)) {
+            type = "enableEmergency";
+            result = TYPE_MOBILE_EMERGENCY;
+        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_XCAP)) {
+            type = "enableXCAP";
+            result = TYPE_MOBILE_XCAP;
+        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_RCS)) {
+            type = "enableRCS";
+            result = TYPE_MOBILE_RCS;
         }
         if (type != null) {
             NetworkCapabilities testCap = networkCapabilitiesForFeature(TYPE_MOBILE, type);
@@ -1113,6 +1165,10 @@ public class ConnectivityManager {
         if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_WIFI_P2P)) {
             return TYPE_WIFI_P2P;
         }
+        // MTK
+        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_EIMS)) {
+            return TYPE_MOBILE_EMERGENCY;
+        }
         return TYPE_NONE;
     }
 
@@ -1886,6 +1942,22 @@ public class ConnectivityManager {
     /** {@hide} */
     public static final int TETHER_ERROR_IFACE_CFG_ERROR      = 10;
 
+    // MTK
+    /** M: ipv6 tethering @{ */
+    /** {@hide}
+     * @internal
+     */
+    public static final int TETHER_ERROR_IPV6_NO_ERROR      = 0x10;
+    /** {@hide}
+     * @internal
+     */
+    public static final int TETHER_ERROR_IPV6_AVAIABLE      = 0x20;
+    /** {@hide}
+     * @internal
+     */
+    public static final int TETHER_ERROR_IPV6_UNAVAIABLE      = 0x30;
+    /** @} */
+
     /**
      * Get a more detailed error code after a Tethering or Untethering
      * request asynchronously failed.
@@ -2944,4 +3016,54 @@ public class ConnectivityManager {
         return NetworkUtils.bindProcessToNetworkForHostResolution(
                 network == null ? NETID_UNSET : network.netId);
     }
+
+    // MTK
+
+    /**
+     * support Tether dediated APN feature  for OP03APNSettingExt
+     * @internal
+     * @return true if tethering is completed or false
+     * @hide
+     */
+    public boolean isTetheringChangeDone() {
+        /*
+        try {
+            return mService.isTetheringChangeDone();
+        } catch (RemoteException e) {
+            return false;
+        }
+        */
+        return false;
+    }
+
+    /**
+     * Ipv6 Tethering Feature
+     * @internal
+     * @param enable to set ipv6 tethering function
+     * @hide
+     */
+    public void setTetheringIpv6Enable(boolean enable) {
+        /*
+        try {
+            mService.setTetheringIpv6Enable(enable);
+        } catch (RemoteException e) { }
+        */
+    }
+
+    /**
+     * Ipv6 Tethering Feature
+     * @internal
+     * @return the value to latest set by setTetheringIpv6Enable
+     * @hide
+     */
+    public boolean getTetheringIpv6Enable() {
+        /*
+        try {
+            return mService.getTetheringIpv6Enable();
+        } catch (RemoteException e) {
+            return false;
+        }
+        */
+        return false;
+    }
 }
diff --git a/core/java/android/os/storage/DiskInfo.java b/core/java/android/os/storage/DiskInfo.java
index db0b0fd..badf013 100644
--- a/core/java/android/os/storage/DiskInfo.java
+++ b/core/java/android/os/storage/DiskInfo.java
@@ -110,7 +110,7 @@ public class DiskInfo implements Parcelable {
                 return res.getString(com.android.internal.R.string.storage_usb_drive);
             }
         } else {
-            return null;
+            return res.getString(com.android.internal.R.string.storage_sd_card);
         }
     }
 
diff --git a/core/java/com/mediatek/gba/GbaBaseCredential.java b/core/java/com/mediatek/gba/GbaBaseCredential.java
new file mode 100644
index 0000000..3646461
--- /dev/null
+++ b/core/java/com/mediatek/gba/GbaBaseCredential.java
@@ -0,0 +1,182 @@
+package com.mediatek.gba;
+
+import android.content.Context;
+import android.net.Network;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+
+/**
+ * HTTP Authenticator for GBA procedure.
+ * It is based class.
+ *
+ * @hide
+ */
+public abstract class GbaBaseCredential {
+    private final static String TAG = "GbaBaseCredential";
+
+    static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID_HTTP =
+        new byte[] {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02};
+    static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID_TLS =
+        new byte[] {(byte) 0x01, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x2F};
+    final protected static char[] HEX_ARRAY = "0123456789abcdef".toCharArray();
+
+    protected static Context sContext;
+    protected static Network sNetwork;
+    protected static int sSubId;
+    protected static boolean sIsTlsEnabled;
+    protected static boolean sCachedSessionKeyUsed;
+    protected static String sPasswd;
+    protected static String sNafAddress;
+    protected static IGbaService sService;
+
+    /**
+      * Empty construciton function.
+      *
+      */
+    GbaBaseCredential() {
+
+    }
+
+    /**
+      * Construciton function with initalization parameters.
+      *
+      */
+    GbaBaseCredential(Context context, String nafAddress, int subId) {
+        super();
+        sContext = context;
+        sSubId = subId;
+
+        if (nafAddress.charAt(nafAddress.length() - 1) == '/') {
+            nafAddress = nafAddress.substring(0, nafAddress.length() - 1);
+        }
+
+        sIsTlsEnabled = true;
+        sCachedSessionKeyUsed = false;
+        sNafAddress = nafAddress.toLowerCase();
+
+        if (sNafAddress.indexOf("http://") != -1) {
+            sNafAddress = nafAddress.substring(7);
+            sIsTlsEnabled = false;
+        } else if (sNafAddress.indexOf("https://") != -1) {
+            sNafAddress = nafAddress.substring(8);
+            sIsTlsEnabled = true;
+        }
+
+        Log.d(TAG, "nafAddress:" + sNafAddress);
+    }
+
+    /**
+      * Tell GbaCredential the connection is TLS or not.
+      *
+      * @param tlsEnabled indicate the connection is over TLS or not.
+      *
+      */
+    public void setTlsEnabled(boolean tlsEnabled) {
+        sIsTlsEnabled = tlsEnabled;
+    }
+
+    /**
+      * Configure which subscription to use in GBA procedure.
+      *
+      * @param subId indicate the subscription id.
+      *
+      */
+    public void setSubId(int subId) {
+        sSubId = subId;
+    }
+
+    /**
+      * Configure dedicated network.
+      *
+      * @param network network that will be used to establish socket connection.
+      *
+      */
+    public void setNetwork(Network network) {
+        if (network != null) {
+            Log.i(TAG, "GBA dedicated network netid:" + network);
+            sNetwork = network;
+        }
+    }
+
+    /**
+      * Get session key for NAF server by GBA procedure.
+      *
+      @return NafSessionKey: the session key of NAF server.
+      */
+    public static NafSessionKey getNafSessionKey() {
+        NafSessionKey nafSessionKey = null;
+
+        try {
+            IBinder b = ServiceManager.getService("GbaService");
+
+            if (b == null) {
+                Log.i("debug", "The binder is null");
+                return null;
+            }
+
+            sService = IGbaService.Stub.asInterface(b);
+        } catch (NullPointerException e) {
+            e.printStackTrace();
+        }
+
+        try {
+            byte[] uaId = DEFAULT_UA_SECURITY_PROTOCOL_ID_TLS;
+
+            if (sIsTlsEnabled) {
+                String gbaStr = System.getProperty("gba.ciper.suite", "");
+
+                if (gbaStr.length() > 0) {
+                    GbaCipherSuite cipherSuite = GbaCipherSuite.getByName(gbaStr);
+
+                    if (cipherSuite != null) {
+                        byte[] cipherSuiteCode = cipherSuite.getCode();
+                        uaId[3] = cipherSuiteCode[0];
+                        uaId[4] = cipherSuiteCode[1];
+                    }
+                }
+            } else {
+                uaId = DEFAULT_UA_SECURITY_PROTOCOL_ID_HTTP;
+            }
+
+            if (sNetwork != null) {
+                sService.setNetwork(sNetwork);
+            }
+
+            String realm = System.getProperty("digest.realm", "");
+            Log.i(TAG, "realm:" + realm);
+            if (realm.length() > 0) {
+                String[] segments = realm.split(";");
+                sNafAddress = segments[0].substring(segments[0].indexOf("@") + 1);
+                Log.i(TAG, "NAF FQDN:" + sNafAddress);
+            } else {
+                return null;
+            }
+
+            if (SubscriptionManager.INVALID_SUBSCRIPTION_ID == sSubId) {
+                nafSessionKey = sService.runGbaAuthentication(sNafAddress,
+                                uaId, sCachedSessionKeyUsed);
+            } else {
+                nafSessionKey = sService.runGbaAuthenticationForSubscriber(sNafAddress,
+                                uaId, sCachedSessionKeyUsed, sSubId);
+            }
+
+            if (nafSessionKey != null && (nafSessionKey.getException() != null) &&
+                    (nafSessionKey.getException() instanceof IllegalStateException)) {
+                String msg = ((IllegalStateException) nafSessionKey.getException())
+                        .getMessage();
+
+                if ("HTTP 403 Forbidden".equals(msg)) {
+                    Log.i(TAG, "GBA hit 403");
+                    System.setProperty("gba.auth", "403");
+                }
+            }
+        } catch (RemoteException re) {
+            re.printStackTrace();
+        }
+
+        return nafSessionKey;
+    }
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/gba/GbaCipherSuite.java b/core/java/com/mediatek/gba/GbaCipherSuite.java
new file mode 100644
index 0000000..6be8854
--- /dev/null
+++ b/core/java/com/mediatek/gba/GbaCipherSuite.java
@@ -0,0 +1,465 @@
+package com.mediatek.gba;
+
+import java.util.Hashtable;
+
+/**
+* Represents Cipher Suite as defined in TLS 1.0 spec.,
+* A.5. The CipherSuite;
+* C. CipherSuite definitions.
+* @see <a href="http://www.ietf.org/rfc/rfc2246.txt">TLS 1.0 spec.</a>
+ * @hide
+*
+*/
+class GbaCipherSuite {
+    // cipher suite code
+    private final byte[] mCipherSuiteCode;
+
+    // cipher suite name
+    private final String mCipherSuiteName;
+
+    // hash for quick access to cipher suite by name
+    private static final Hashtable<String, GbaCipherSuite> mSuiteByName;
+
+    /**
+    * TLS cipher suite codes.
+    */
+    static final byte[] CODE_SSL_NULL_WITH_NULL_NULL = { 0x00, 0x00 };
+    static final byte[] CODE_SSL_RSA_WITH_NULL_MD5 = { 0x00, 0x01 };
+    static final byte[] CODE_SSL_RSA_WITH_NULL_SHA = { 0x00, 0x02 };
+    static final byte[] CODE_SSL_RSA_EXPORT_WITH_RC4_40_MD5 = { 0x00, 0x03 };
+    static final byte[] CODE_SSL_RSA_WITH_RC4_128_MD5 = { 0x00, 0x04 };
+    static final byte[] CODE_SSL_RSA_WITH_RC4_128_SHA = { 0x00, 0x05 };
+    static final byte[] CODE_SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = { 0x00, 0x06 };
+    // BEGIN android-removed
+    // static final byte[] CODE_TLS_RSA_WITH_IDEA_CBC_SHA = { 0x00, 0x07 };
+    // END android-removed
+    static final byte[] CODE_SSL_RSA_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x08 };
+    static final byte[] CODE_SSL_RSA_WITH_DES_CBC_SHA = { 0x00, 0x09 };
+    static final byte[] CODE_SSL_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x0A };
+    // BEGIN android-removed
+    // static final byte[] CODE_SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x0B };
+    // static final byte[] CODE_SSL_DH_DSS_WITH_DES_CBC_SHA = { 0x00, 0x0C };
+    // static final byte[] CODE_SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x0D };
+    // static final byte[] CODE_SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x0E };
+    // static final byte[] CODE_SSL_DH_RSA_WITH_DES_CBC_SHA = { 0x00, 0x0F };
+    // static final byte[] CODE_SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x10 };
+    // END android-removed
+    static final byte[] CODE_SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x11 };
+    static final byte[] CODE_SSL_DHE_DSS_WITH_DES_CBC_SHA = { 0x00, 0x12 };
+    static final byte[] CODE_SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x13 };
+    static final byte[] CODE_SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x14 };
+    static final byte[] CODE_SSL_DHE_RSA_WITH_DES_CBC_SHA = { 0x00, 0x15 };
+    static final byte[] CODE_SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x16 };
+    static final byte[] CODE_SSL_DH_anon_EXPORT_WITH_RC4_40_MD5 = { 0x00, 0x17 };
+    static final byte[] CODE_SSL_DH_anon_WITH_RC4_128_MD5 = { 0x00, 0x18 };
+    static final byte[] CODE_SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA = { 0x00, 0x19 };
+    static final byte[] CODE_SSL_DH_anon_WITH_DES_CBC_SHA = { 0x00, 0x1A };
+    static final byte[] CODE_SSL_DH_anon_WITH_3DES_EDE_CBC_SHA = { 0x00, 0x1B };
+
+    // AES Cipher Suites from RFC 3268 - http://www.ietf.org/rfc/rfc3268.txt
+    static final byte[] CODE_TLS_RSA_WITH_AES_128_CBC_SHA = { 0x00, 0x2F };
+    //static final byte[] CODE_TLS_DH_DSS_WITH_AES_128_CBC_SHA = { 0x00, 0x30 };
+    //static final byte[] CODE_TLS_DH_RSA_WITH_AES_128_CBC_SHA = { 0x00, 0x31 };
+    static final byte[] CODE_TLS_DHE_DSS_WITH_AES_128_CBC_SHA = { 0x00, 0x32 };
+    static final byte[] CODE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA = { 0x00, 0x33 };
+    static final byte[] CODE_TLS_DH_anon_WITH_AES_128_CBC_SHA = { 0x00, 0x34 };
+    static final byte[] CODE_TLS_RSA_WITH_AES_256_CBC_SHA = { 0x00, 0x35 };
+    //static final byte[] CODE_TLS_DH_DSS_WITH_AES_256_CBC_SHA = { 0x00, 0x36 };
+    //static final byte[] CODE_TLS_DH_RSA_WITH_AES_256_CBC_SHA = { 0x00, 0x37 };
+    static final byte[] CODE_TLS_DHE_DSS_WITH_AES_256_CBC_SHA = { 0x00, 0x38 };
+    static final byte[] CODE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA = { 0x00, 0x39 };
+    static final byte[] CODE_TLS_DH_anon_WITH_AES_256_CBC_SHA = { 0x00, 0x3A };
+
+    // EC Cipher Suites from RFC 4492 - http://www.ietf.org/rfc/rfc4492.txt
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_NULL_SHA = { (byte) 0xc0, 0x01};
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_RC4_128_SHA = { (byte) 0xc0, 0x02};
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x03};
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x04};
+    static final byte[] CODE_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x05};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_NULL_SHA = { (byte) 0xc0, 0x06};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = { (byte) 0xc0, 0x07};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x08};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x09};
+    static final byte[] CODE_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x0A};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_NULL_SHA = { (byte) 0xc0, 0x0B};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_RC4_128_SHA = { (byte) 0xc0, 0x0C};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x0D};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x0E};
+    static final byte[] CODE_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x0F};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_NULL_SHA = { (byte) 0xc0, 0x10};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_RC4_128_SHA = { (byte) 0xc0, 0x11};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x12};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x13};
+    static final byte[] CODE_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x14};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_NULL_SHA = { (byte) 0xc0, 0x15};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_RC4_128_SHA = { (byte) 0xc0, 0x16};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = { (byte) 0xc0, 0x17};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_AES_128_CBC_SHA = { (byte) 0xc0, 0x18};
+    static final byte[] CODE_TLS_ECDH_anon_WITH_AES_256_CBC_SHA = { (byte) 0xc0, 0x19};
+
+    static final  GbaCipherSuite SSL_NULL_WITH_NULL_NULL = new GbaCipherSuite(
+        "SSL_NULL_WITH_NULL_NULL", CODE_SSL_NULL_WITH_NULL_NULL);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_NULL_MD5 = new GbaCipherSuite(
+        "SSL_RSA_WITH_NULL_MD5", CODE_SSL_RSA_WITH_NULL_MD5);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_NULL_SHA = new GbaCipherSuite(
+        "SSL_RSA_WITH_NULL_SHA", CODE_SSL_RSA_WITH_NULL_SHA);
+
+    static final  GbaCipherSuite SSL_RSA_EXPORT_WITH_RC4_40_MD5 = new GbaCipherSuite(
+        "SSL_RSA_EXPORT_WITH_RC4_40_MD5", CODE_SSL_RSA_EXPORT_WITH_RC4_40_MD5);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_RC4_128_MD5 = new GbaCipherSuite(
+        "SSL_RSA_WITH_RC4_128_MD5", CODE_SSL_RSA_WITH_RC4_128_MD5);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_RC4_128_SHA = new GbaCipherSuite(
+        "SSL_RSA_WITH_RC4_128_SHA", CODE_SSL_RSA_WITH_RC4_128_SHA);
+
+    static final  GbaCipherSuite SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5 = new GbaCipherSuite(
+        "SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5", CODE_SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5);
+
+    // BEGIN android-removed
+    // static final  GbaCipherSuite TLS_RSA_WITH_IDEA_CBC_SHA = new GbaCipherSuite(
+    //         "TLS_RSA_WITH_IDEA_CBC_SHA", CODE_TLS_RSA_WITH_IDEA_CBC_SHA);
+    // END android-removed
+
+    static final  GbaCipherSuite SSL_RSA_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+        "SSL_RSA_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_RSA_EXPORT_WITH_DES40_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_DES_CBC_SHA = new GbaCipherSuite(
+        "SSL_RSA_WITH_DES_CBC_SHA", CODE_SSL_RSA_WITH_DES_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_RSA_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+        "SSL_RSA_WITH_3DES_EDE_CBC_SHA", CODE_SSL_RSA_WITH_3DES_EDE_CBC_SHA);
+
+    // BEGIN android-removed
+    // static final  GbaCipherSuite SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_DSS_WITH_DES_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_DSS_WITH_DES_CBC_SHA", CODE_SSL_DH_DSS_WITH_DES_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_RSA_WITH_DES_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_RSA_WITH_DES_CBC_SHA", CODE_SSL_DH_RSA_WITH_DES_CBC_SHA);
+    //
+    // static final  GbaCipherSuite SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+    //         "SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA);
+    // END android-removed
+
+    static final  GbaCipherSuite SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_DSS_WITH_DES_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_DSS_WITH_DES_CBC_SHA", CODE_SSL_DHE_DSS_WITH_DES_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_RSA_WITH_DES_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_RSA_WITH_DES_CBC_SHA", CODE_SSL_DHE_RSA_WITH_DES_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+        "SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DH_anon_EXPORT_WITH_RC4_40_MD5 = new GbaCipherSuite(
+        "SSL_DH_anon_EXPORT_WITH_RC4_40_MD5", CODE_SSL_DH_anon_EXPORT_WITH_RC4_40_MD5);
+
+    static final  GbaCipherSuite SSL_DH_anon_WITH_RC4_128_MD5 = new GbaCipherSuite(
+        "SSL_DH_anon_WITH_RC4_128_MD5", CODE_SSL_DH_anon_WITH_RC4_128_MD5);
+
+    static final  GbaCipherSuite SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA = new GbaCipherSuite(
+        "SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA", CODE_SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DH_anon_WITH_DES_CBC_SHA = new GbaCipherSuite(
+        "SSL_DH_anon_WITH_DES_CBC_SHA", CODE_SSL_DH_anon_WITH_DES_CBC_SHA);
+
+    static final  GbaCipherSuite SSL_DH_anon_WITH_3DES_EDE_CBC_SHA = new GbaCipherSuite(
+        "SSL_DH_anon_WITH_3DES_EDE_CBC_SHA", CODE_SSL_DH_anon_WITH_3DES_EDE_CBC_SHA);
+
+    static final  GbaCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_RSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_RSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_DHE_DSS_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_DHE_RSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_DH_anon_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_DH_anon_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_RSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_RSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_DHE_DSS_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_DHE_RSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_DH_anon_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_DH_anon_WITH_AES_256_CBC_SHA);
+
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_NULL_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_NULL_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_NULL_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_NULL_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_NULL_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_NULL_SHA",
+                         CODE_TLS_ECDH_anon_WITH_NULL_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_RC4_128_SHA",
+                         CODE_TLS_ECDH_anon_WITH_RC4_128_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA",
+                         CODE_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_AES_128_CBC_SHA",
+                         CODE_TLS_ECDH_anon_WITH_AES_128_CBC_SHA);
+    static final  GbaCipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA
+    = new GbaCipherSuite("TLS_ECDH_anon_WITH_AES_256_CBC_SHA",
+                         CODE_TLS_ECDH_anon_WITH_AES_256_CBC_SHA);
+
+    // arrays for quick access to cipher suite by code
+    private static final  GbaCipherSuite[] SUITES_BY_CODE_0x00 = {
+        // http://www.iana.org/assignments/tls-parameters/tls-parameters.xml
+        SSL_NULL_WITH_NULL_NULL,                          // { 0x00, 0x00 };
+        SSL_RSA_WITH_NULL_MD5,                            // { 0x00, 0x01 };
+        SSL_RSA_WITH_NULL_SHA,                            // { 0x00, 0x02 };
+        SSL_RSA_EXPORT_WITH_RC4_40_MD5,                   // { 0x00, 0x03 };
+        SSL_RSA_WITH_RC4_128_MD5,                         // { 0x00, 0x04 };
+        SSL_RSA_WITH_RC4_128_SHA,                         // { 0x00, 0x05 };
+        // BEGIN android-changed
+        null, // SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5,      // { 0x00, 0x06 };
+        null, // TLS_RSA_WITH_IDEA_CBC_SHA,               // { 0x00, 0x07 };
+        // END android-changed
+        SSL_RSA_EXPORT_WITH_DES40_CBC_SHA,                // { 0x00, 0x08 };
+        SSL_RSA_WITH_DES_CBC_SHA,                         // { 0x00, 0x09 };
+        SSL_RSA_WITH_3DES_EDE_CBC_SHA,                    // { 0x00, 0x0a };
+        // BEGIN android-changed
+        null, // SSL_DH_DSS_EXPORT_WITH_DES40_CBC_SHA     // { 0x00, 0x0b };
+        null, // SSL_DH_DSS_WITH_DES_CBC_SHA,             // { 0x00, 0x0c };
+        null, // SSL_DH_DSS_WITH_3DES_EDE_CBC_SHA,        // { 0x00, 0x0d };
+        null, // SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA,    // { 0x00, 0x0e };
+        null, // SSL_DH_RSA_WITH_DES_CBC_SHA,             // { 0x00, 0x0f };
+        null, // SSL_DH_RSA_WITH_3DES_EDE_CBC_SHA,        // { 0x00, 0x10 };
+        // END android-changed
+        SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA,            // { 0x00, 0x11 };
+        SSL_DHE_DSS_WITH_DES_CBC_SHA,                     // { 0x00, 0x12 };
+        SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA,                // { 0x00, 0x13 };
+        SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA,            // { 0x00, 0x14 };
+        SSL_DHE_RSA_WITH_DES_CBC_SHA,                     // { 0x00, 0x15 };
+        SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA,                // { 0x00, 0x16 };
+        SSL_DH_anon_EXPORT_WITH_RC4_40_MD5,               // { 0x00, 0x17 };
+        SSL_DH_anon_WITH_RC4_128_MD5,                     // { 0x00, 0x18 };
+        SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA,            // { 0x00, 0x19 };
+        SSL_DH_anon_WITH_DES_CBC_SHA,                     // { 0x00, 0x1A };
+        SSL_DH_anon_WITH_3DES_EDE_CBC_SHA,                // { 0x00, 0x1B };
+        // BEGIN android-added
+        null, // SSL_FORTEZZA_KEA_WITH_NULL_SHA           // { 0x00, 0x1C };
+        null, // SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA   // { 0x00, 0x1D };
+        null, // TLS_KRB5_WITH_DES_CBC_SHA                // { 0x00, 0x1E };
+        null, // TLS_KRB5_WITH_3DES_EDE_CBC_SHA           // { 0x00, 0x1F };
+        null, // TLS_KRB5_WITH_RC4_128_SHA                // { 0x00, 0x20 };
+        null, // TLS_KRB5_WITH_IDEA_CBC_SHA               // { 0x00, 0x21 };
+        null, // TLS_KRB5_WITH_DES_CBC_MD5                // { 0x00, 0x22 };
+        null, // TLS_KRB5_WITH_3DES_EDE_CBC_MD5           // { 0x00, 0x23 };
+        null, // TLS_KRB5_WITH_RC4_128_MD5                // { 0x00, 0x24 };
+        null, // TLS_KRB5_WITH_IDEA_CBC_MD5               // { 0x00, 0x25 };
+        null, // TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA      // { 0x00, 0x26 };
+        null, // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA      // { 0x00, 0x27 };
+        null, // TLS_KRB5_EXPORT_WITH_RC4_40_SHA          // { 0x00, 0x28 };
+        null, // TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5      // { 0x00, 0x29 };
+        null, // TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5      // { 0x00, 0x2A };
+        null, // TLS_KRB5_EXPORT_WITH_RC4_40_MD5          // { 0x00, 0x2B };
+        null, // TLS_PSK_WITH_NULL_SHA                    // { 0x00, 0x2C };
+        null, // TLS_DHE_PSK_WITH_NULL_SHA                // { 0x00, 0x2D };
+        null, // TLS_RSA_PSK_WITH_NULL_SHA                // { 0x00, 0x2E };
+        TLS_RSA_WITH_AES_128_CBC_SHA,                     // { 0x00, 0x2F };
+        null, // TLS_DH_DSS_WITH_AES_128_CBC_SHA          // { 0x00, 0x30 };
+        null, // TLS_DH_RSA_WITH_AES_128_CBC_SHA          // { 0x00, 0x31 };
+        TLS_DHE_DSS_WITH_AES_128_CBC_SHA,                 // { 0x00, 0x32 };
+        TLS_DHE_RSA_WITH_AES_128_CBC_SHA,                 // { 0x00, 0x33 };
+        TLS_DH_anon_WITH_AES_128_CBC_SHA,                 // { 0x00, 0x34 };
+        TLS_RSA_WITH_AES_256_CBC_SHA,                     // { 0x00, 0x35 };
+        null, // TLS_DH_DSS_WITH_AES_256_CBC_SHA,         // { 0x00, 0x36 };
+        null, // TLS_DH_RSA_WITH_AES_256_CBC_SHA,         // { 0x00, 0x37 };
+        TLS_DHE_DSS_WITH_AES_256_CBC_SHA,                 // { 0x00, 0x38 };
+        TLS_DHE_RSA_WITH_AES_256_CBC_SHA,                 // { 0x00, 0x39 };
+        TLS_DH_anon_WITH_AES_256_CBC_SHA,                 // { 0x00, 0x3A };
+        // END android-added
+    };
+    private static final  GbaCipherSuite[] SUITES_BY_CODE_0xc0 = {
+        null,                                             // { 0xc0, 0x00};
+        TLS_ECDH_ECDSA_WITH_NULL_SHA,                     // { 0xc0, 0x01};
+        TLS_ECDH_ECDSA_WITH_RC4_128_SHA,                  // { 0xc0, 0x02};
+        TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,             // { 0xc0, 0x03};
+        TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,              // { 0xc0, 0x04};
+        TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA,              // { 0xc0, 0x05};
+        TLS_ECDHE_ECDSA_WITH_NULL_SHA,                    // { 0xc0, 0x06};
+        TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,                 // { 0xc0, 0x07};
+        TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA,            // { 0xc0, 0x08};
+        TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,             // { 0xc0, 0x09};
+        TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,             // { 0xc0, 0x0A};
+        TLS_ECDH_RSA_WITH_NULL_SHA,                       // { 0xc0, 0x0B};
+        TLS_ECDH_RSA_WITH_RC4_128_SHA,                    // { 0xc0, 0x0C};
+        TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA,               // { 0xc0, 0x0D};
+        TLS_ECDH_RSA_WITH_AES_128_CBC_SHA,                // { 0xc0, 0x0E};
+        TLS_ECDH_RSA_WITH_AES_256_CBC_SHA,                // { 0xc0, 0x0F};
+        TLS_ECDHE_RSA_WITH_NULL_SHA,                      // { 0xc0, 0x10};
+        TLS_ECDHE_RSA_WITH_RC4_128_SHA,                   // { 0xc0, 0x11};
+        TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,              // { 0xc0, 0x12};
+        TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,               // { 0xc0, 0x13};
+        TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,               // { 0xc0, 0x14};
+        TLS_ECDH_anon_WITH_NULL_SHA,                      // { 0xc0, 0x15};
+        TLS_ECDH_anon_WITH_RC4_128_SHA,                   // { 0xc0, 0x16};
+        TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA,              // { 0xc0, 0x17};
+        TLS_ECDH_anon_WITH_AES_128_CBC_SHA,               // { 0xc0, 0x18};
+        TLS_ECDH_anon_WITH_AES_256_CBC_SHA,               // { 0xc0, 0x19};
+        // TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA,             // { 0xc0, 0x1A};
+        // TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA,         // { 0xc0, 0x1B};
+        // TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA,         // { 0xc0, 0x1C};
+        // TLS_SRP_SHA_WITH_AES_128_CBC_SHA,              // { 0xc0, 0x1D};
+        // TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA,          // { 0xc0, 0x1E};
+        // TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA,          // { 0xc0, 0x1F};
+        // TLS_SRP_SHA_WITH_AES_256_CBC_SHA,              // { 0xc0, 0x20};
+        // TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA,          // { 0xc0, 0x21};
+        // TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA,          // { 0xc0, 0x22};
+        // TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,       // { 0xc0, 0x23};
+        // TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,       // { 0xc0, 0x24};
+        // TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256,        // { 0xc0, 0x25};
+        // TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384,        // { 0xc0, 0x26};
+        // TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,         // { 0xc0, 0x27};
+        // TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,         // { 0xc0, 0x28};
+        // TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256,          // { 0xc0, 0x29};
+        // TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384,          // { 0xc0, 0x2A};
+        // TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,       // { 0xc0, 0x2B};
+        // TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,       // { 0xc0, 0x2C};
+        // TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256,        // { 0xc0, 0x2D};
+        // TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384,        // { 0xc0, 0x2E};
+        // TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,         // { 0xc0, 0x2F};
+        // TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,         // { 0xc0, 0x30};
+        // TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256,          // { 0xc0, 0x31};
+        // TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384,          // { 0xc0, 0x32};
+        // TLS_ECDHE_PSK_WITH_RC4_128_SHA,                // { 0xc0, 0x33};
+        // TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA,           // { 0xc0, 0x34};
+        // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,            // { 0xc0, 0x35};
+        // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,            // { 0xc0, 0x36};
+        // TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256,         // { 0xc0, 0x37};
+        // TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384,         // { 0xc0, 0x38};
+        // TLS_ECDHE_PSK_WITH_NULL_SHA,                   // { 0xc0, 0x39};
+        // TLS_ECDHE_PSK_WITH_NULL_SHA256,                // { 0xc0, 0x3A};
+        // TLS_ECDHE_PSK_WITH_NULL_SHA384,                // { 0xc0, 0x3B};
+    };
+
+    private GbaCipherSuite(String name, byte[] code) {
+        this.mCipherSuiteName = name;
+        this.mCipherSuiteCode = code;
+    }
+
+    static {
+        mSuiteByName = new Hashtable<String, GbaCipherSuite>();
+        registerCipherSuitesByCode(SUITES_BY_CODE_0x00);
+        registerCipherSuitesByCode(SUITES_BY_CODE_0xc0);
+    }
+
+    private static int registerCipherSuitesByCode(GbaCipherSuite[] cipherSuites) {
+        int count = 0;
+
+        for (int i = 0; i < cipherSuites.length; i++) {
+            if (cipherSuites[i] == SSL_NULL_WITH_NULL_NULL) {
+                continue;
+            }
+
+            if (cipherSuites[i] == null) {
+                continue;
+            }
+
+            mSuiteByName.put(cipherSuites[i].getName(), cipherSuites[i]);
+        }
+
+        return count;
+    }
+
+    /**
+     * Returns CipherSuite by name.
+     */
+    public static GbaCipherSuite getByName(String name) {
+        return mSuiteByName.get(name);
+    }
+
+    public String getName() {
+        return mCipherSuiteName;
+    }
+
+    public byte[] getCode() {
+        return mCipherSuiteCode;
+    }
+
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/gba/GbaHttpUrlCredential.java b/core/java/com/mediatek/gba/GbaHttpUrlCredential.java
new file mode 100644
index 0000000..3c85f21
--- /dev/null
+++ b/core/java/com/mediatek/gba/GbaHttpUrlCredential.java
@@ -0,0 +1,86 @@
+package com.mediatek.gba;
+
+import android.content.Context;
+import android.telephony.SubscriptionManager;
+import android.util.Base64;
+import android.util.Log;
+
+import java.net.Authenticator;
+import java.net.PasswordAuthentication;
+
+/**
+ * HTTP Authenticator for GBA procedure.
+ * This is designed for HttpUrlConnection.
+ *
+ * @hide
+ */
+public class GbaHttpUrlCredential extends GbaBaseCredential {
+    private final static String TAG = "GbaCredentials";
+
+    private Authenticator mAuthenticator = new GbaAuthenticator();
+
+    /**
+      * Construction function for GbaCredentials.
+      *
+      * @param context the application context.
+      * @param nafAddress the sceme name + FQDN value of NAF server address.
+      * e.g. https://www.google.com or http://www.google.com
+      *
+      * @hide
+      */
+    public GbaHttpUrlCredential(Context context, String nafAddress) {
+        this(context, nafAddress, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+    }
+
+    /**
+      * Construction function for GbaCredentials.
+      *
+      * @param context the application context.
+      * @param nafAddress the sceme name + FQDN value of NAF server address.
+      * @param subId the subscription id.
+      * e.g. https://www.google.com or http://www.google.com
+      *
+      * @hide
+      */
+    public GbaHttpUrlCredential(Context context, String nafAddress, int subId) {
+        super(context, nafAddress, subId);
+        System.setProperty("http.digest.support", "true");
+    }
+
+    public Authenticator getAuthenticator() {
+        return mAuthenticator;
+    }
+
+    /**
+      * Authenticator for OkHttp stack.
+      * Used for HTTP digest method.
+      *
+      */
+    private class GbaAuthenticator extends Authenticator {
+        private PasswordAuthentication mPasswordAuthentication;
+
+        protected PasswordAuthentication getPasswordAuthentication() {
+            Log.i(TAG, "getPasswordAuthentication");
+
+            if (mPasswordAuthentication == null || sCachedSessionKeyUsed) {
+                Log.i(TAG, "Run GBA procedure");
+                NafSessionKey nafSessionKey = GbaBaseCredential.getNafSessionKey();
+                if (nafSessionKey == null ||
+                        (nafSessionKey != null && nafSessionKey.getKey() == null)) {
+                    return null;
+                }
+                String password = Base64.encodeToString(nafSessionKey.getKey(), Base64.NO_WRAP);
+                mPasswordAuthentication = new PasswordAuthentication(
+                    nafSessionKey.getBtid(),
+                    password.toCharArray());
+            } else {
+                if (!sCachedSessionKeyUsed) {
+                    sCachedSessionKeyUsed = true;
+                }
+            }
+
+            return mPasswordAuthentication;
+        }
+    }
+
+}
diff --git a/core/java/com/mediatek/gba/GbaManager.java b/core/java/com/mediatek/gba/GbaManager.java
new file mode 100644
index 0000000..b5c9e3f
--- /dev/null
+++ b/core/java/com/mediatek/gba/GbaManager.java
@@ -0,0 +1,201 @@
+package com.mediatek.gba;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+
+/**
+ * A class provides the GBA service APIs.
+ *
+ * @hide
+ */
+public final class GbaManager {
+    private static final String TAG = "GbaManager";
+
+    private final Context mContext;
+    private static IGbaService mService;
+    private static GbaManager mGbaManager = null;
+
+    public static final int IMS_GBA_NONE     = 0;
+    public static final int IMS_GBA_ME       = 1;
+    public static final int IMS_GBA_U        = 2;
+
+    public static final String IMS_GBA_KS_NAF       = "Ks_NAF";
+    public static final String IMS_GBA_KS_EXT_NAF   = "Ks_ext_NAF";
+
+    public static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID0 = new byte[]
+                    {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00};
+    public static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID1 = new byte[]
+                    {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01}; //MBMS
+    public static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID2 = new byte[]
+                    {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02};
+    public static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID3 = new byte[]
+                    {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x03}; //MBMS
+
+    private static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID_HTTP =
+        new byte[] {(byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x02};
+    private static final byte[] DEFAULT_UA_SECURITY_PROTOCOL_ID_TLS =
+        new byte[] {(byte) 0x01, (byte) 0x00, (byte) 0x01, (byte) 0x00, (byte) 0x2F};
+
+    /**
+     * Helpers to get the default GbaManager.
+     */
+    public static GbaManager getDefaultGbaManager(Context context) {
+        if (context == null) {
+            throw new IllegalArgumentException("context cannot be null");
+        }
+
+        synchronized (GbaManager.class) {
+            if (mGbaManager == null) {
+                IBinder b = ServiceManager.getService("GbaService");
+
+                if (b == null) {
+                    Log.i("debug", "The binder is null");
+                    return null;
+                }
+
+                mService = IGbaService.Stub.asInterface(b);
+                mGbaManager = new GbaManager(context);
+            }
+
+            return mGbaManager;
+        }
+    }
+
+    GbaManager(Context context) {
+        mContext = context;
+    }
+
+    /**
+     * Check GBA is supported and support type or not.
+     *
+     * @return GBA Support Type
+     */
+    public int getGbaSupported() {
+        try {
+            return mService.getGbaSupported();
+        } catch (RemoteException e) {
+            return 0;
+        }
+    }
+
+    /**
+     * Check GBA is supported and support type or not for a particular subscription.
+     *
+     * @param subId subscription whose subscriber id is returned
+     *
+     * @return GBA Support Type
+     */
+    public int getGbaSupported(int subId) {
+        try {
+            return mService.getGbaSupported();
+        } catch (RemoteException e) {
+            return 0;
+        }
+    }
+
+    /**
+     * Check GBA NAFSession key is expired or not.
+     *
+     * @param nafFqdn The FQDN address of NAF server
+     * @param nafSecurProtocolId The security protocol id of NAF server
+     *
+     * @return indicate key is expired or not
+     */
+    public boolean isGbaKeyExpired(String nafFqdn, byte[] nafSecurProtocolId) {
+        try {
+            return mService.isGbaKeyExpired(nafFqdn, nafSecurProtocolId);
+        } catch (RemoteException e) {
+            return true;
+        }
+    }
+
+    /**
+     * Check GBA NAFSession key is expired or not for a particular subscription.
+     *
+     * @param nafFqdn The FQDN address of NAF server
+     * @param nafSecurProtocolId The security protocol id of NAF server
+     * @param subId subscription whose subscriber id is returned
+     *
+     * @return indicate key is expired or not
+     */
+    public boolean isGbaKeyExpired(String nafFqdn, byte[] nafSecurProtocolId, int subId) {
+        try {
+            return mService.isGbaKeyExpired(nafFqdn, nafSecurProtocolId);
+        } catch (RemoteException e) {
+            return true;
+        }
+    }
+
+    /**
+     * Perform GBA bootstrap authentication.
+     *
+     * @param nafFqdn The FQDN address of NAF server
+     * @param nafSecureProtocolId The security protocol id of NAF server
+     * @param forceRun Indicate to force run GBA bootstrap procedure without
+     *                 get NAS Session key from GBA cache
+     *
+     * @return GBA NAS Session Key
+     */
+    public NafSessionKey runGbaAuthentication(String nafFqdn, byte[] nafSecureProtocolId,
+            boolean forceRun) {
+        try {
+            return mService.runGbaAuthentication(nafFqdn, nafSecureProtocolId, forceRun);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Perform GBA bootstrap authentication for a particular subscription.
+     *
+     * @param nafFqdn The FQDN address of NAF server
+     * @param nafSecureProtocolId The security protocol id of NAF server
+     * @param forceRun Indicate to force run GBA bootstrap procedure without
+     *                 get NAS Session key from GBA cache
+     * @param subId subscription whose subscriber id is returned
+     *
+     * @return GBA NAS Session Key
+     */
+    public NafSessionKey runGbaAuthentication(String nafFqdn, byte[] nafSecureProtocolId,
+            boolean forceRun, int subId) {
+        try {
+            return mService.runGbaAuthenticationForSubscriber(nafFqdn,
+                    nafSecureProtocolId, forceRun, subId);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /**
+     * Get the NAF security protocol id.
+     * If NAF client uses TLS connection, this API should be called after the TLS connection
+     * is established. By this case, the cipher suite has been decided.
+     * @param isTls Indicate to connect with server with TLS connection or not.
+     *
+     * @return return the NAF security protocol id.
+     */
+
+   public byte[] getNafSecureProtocolId(boolean isTls) {
+        byte[] uaId = DEFAULT_UA_SECURITY_PROTOCOL_ID_TLS;
+
+        if (isTls) {
+            String gbaStr = System.getProperty("gba.ciper.suite", "");
+            if (gbaStr.length() > 0) {
+                GbaCipherSuite cipherSuite = GbaCipherSuite.getByName(gbaStr);
+                if (cipherSuite != null) {
+                    byte[] cipherSuiteCode = cipherSuite.getCode();
+                    uaId[3] = cipherSuiteCode[0];
+                    uaId[4] = cipherSuiteCode[1];
+                }
+            }
+        } else {
+            uaId = DEFAULT_UA_SECURITY_PROTOCOL_ID_HTTP;
+        }
+
+        return uaId;
+   }
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/gba/IGbaService.aidl b/core/java/com/mediatek/gba/IGbaService.aidl
new file mode 100644
index 0000000..53474e1
--- /dev/null
+++ b/core/java/com/mediatek/gba/IGbaService.aidl
@@ -0,0 +1,17 @@
+package com.mediatek.gba;
+
+import android.net.Network;
+import com.mediatek.gba.NafSessionKey;
+
+/**
+ * @hide
+ */
+interface IGbaService {
+    int getGbaSupported();
+    int getGbaSupportedForSubscriber(in int subId);
+    boolean isGbaKeyExpired(String nafFqdn, in byte[] nafSecurProtocolId);
+    boolean isGbaKeyExpiredForSubscriber(String nafFqdn, in byte[] nafSecurProtocolId, in int subId);
+    NafSessionKey runGbaAuthentication(in String nafFqdn, in byte[] nafSecurProtocolId, boolean forceRun);
+    NafSessionKey runGbaAuthenticationForSubscriber(in String nafFqdn, in byte[] nafSecurProtocolId, boolean forceRun, in int subId);
+    void setNetwork(in Network network);
+}
\ No newline at end of file
diff --git a/core/java/com/mediatek/gba/NafSessionKey.aidl b/core/java/com/mediatek/gba/NafSessionKey.aidl
new file mode 100644
index 0000000..1c85657
--- /dev/null
+++ b/core/java/com/mediatek/gba/NafSessionKey.aidl
@@ -0,0 +1,3 @@
+package com.mediatek.gba;
+
+parcelable NafSessionKey;
\ No newline at end of file
diff --git a/core/java/com/mediatek/gba/NafSessionKey.java b/core/java/com/mediatek/gba/NafSessionKey.java
new file mode 100644
index 0000000..8c1783b
--- /dev/null
+++ b/core/java/com/mediatek/gba/NafSessionKey.java
@@ -0,0 +1,157 @@
+package com.mediatek.gba;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Utitity contain class for NafSessionKey.
+ * @hide
+ */
+public class NafSessionKey implements Parcelable {
+    private String mBtid;
+    private byte[] mKey;
+    private String mKeylifetime;
+    private String mNafKeyName;
+    private byte[] mNafId;
+    private Exception mException;
+
+    public NafSessionKey() {
+        super();
+
+    }
+
+    public NafSessionKey(final String btid, final byte[] key, final String keylifetime) {
+        mBtid = btid;
+        mKey = key;
+        mKeylifetime = keylifetime;
+    }
+
+    public String getBtid() {
+        return mBtid;
+    }
+
+    public void setBtid(final String btid) {
+        mBtid = btid;
+    }
+
+    public byte[] getKey() {
+        return mKey;
+    }
+
+    public void setKey(final byte[] key) {
+        mKey = key;
+    }
+
+    public String getKeylifetime() {
+        return mKeylifetime;
+    }
+
+    public void setKeylifetime(final String keylifetime) {
+        mKeylifetime = keylifetime;
+    }
+
+    public String getNafKeyName() {
+        return mNafKeyName;
+    }
+
+    public void setNafKeyName(String nafKeyName) {
+        mNafKeyName = nafKeyName;
+    }
+
+    public void setNafId(byte[] nafId) {
+        mNafId = nafId;
+    }
+
+    public byte[] getNafId() {
+        return mNafId;
+    }
+
+    public void setException(Exception e) {
+        mException = e;
+    }
+
+    public Exception getException() {
+        return mException;
+    }
+
+    /**
+     * Implement the Parcelable interface
+     * @hide
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     *
+     * @param dest The Parcel in which the object should be written.
+     * @param flags Additional flags about how the object should be written.
+     * @hide
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(mBtid);
+        dest.writeByteArray(mKey);
+        dest.writeString(mKeylifetime);
+        dest.writeString(mNafKeyName);
+        if (mException != null) {
+            dest.writeException(mException);
+        }
+    }
+
+    /**
+     * Implement the Parcelable interface.
+     * @hide
+     */
+    public static final Creator<NafSessionKey> CREATOR =
+        new Creator<NafSessionKey>() {
+            public NafSessionKey createFromParcel(Parcel in) {
+                NafSessionKey nafSessionKey = new NafSessionKey();
+                String btid = in.readString();
+
+                if (btid != null) {
+                    nafSessionKey.setBtid(btid);
+                }
+
+                byte[] key = in.createByteArray();
+
+                if (key != null) {
+                    nafSessionKey.setKey(key);
+                }
+
+                String keylifetime = in.readString();
+
+                if (keylifetime != null) {
+                    nafSessionKey.setKeylifetime(keylifetime);
+                }
+
+                String nafKeyName = in.readString();
+
+                if (nafKeyName != null) {
+                    nafSessionKey.setNafKeyName(nafKeyName);
+                }
+
+                int exceptionCode = in.readInt();
+                String exceptionString = in.readString();
+
+                if (exceptionString != null) {
+                    nafSessionKey.setException(new IllegalStateException(exceptionString));
+                }
+
+                return nafSessionKey;
+            }
+
+            public NafSessionKey[] newArray(int size) {
+                return new NafSessionKey[size];
+            }
+        };
+
+    @Override
+    public String toString() {
+        synchronized (this) {
+            StringBuilder builder = new StringBuilder("NafSessionKey: btid:");
+            builder.append(mBtid).append(":").append(mKeylifetime).append(":").append(mNafKeyName);
+            return builder.toString();
+        }
+    }
+}
diff --git a/services/core/java/com/android/server/lights/LightsManager.java b/services/core/java/com/android/server/lights/LightsManager.java
index e1e5aa3..434fff5 100644
--- a/services/core/java/com/android/server/lights/LightsManager.java
+++ b/services/core/java/com/android/server/lights/LightsManager.java
@@ -20,8 +20,8 @@ public abstract class LightsManager {
     public static final int LIGHT_ID_BACKLIGHT = 0;
     public static final int LIGHT_ID_KEYBOARD = 1;
     public static final int LIGHT_ID_BUTTONS = 2;
-    public static final int LIGHT_ID_BATTERY = 3;
-    public static final int LIGHT_ID_NOTIFICATIONS = 4;
+    public static final int LIGHT_ID_NOTIFICATIONS = 3;
+    public static final int LIGHT_ID_BATTERY = 4;
     public static final int LIGHT_ID_ATTENTION = 5;
     public static final int LIGHT_ID_BLUETOOTH = 6;
     public static final int LIGHT_ID_WIFI = 7;
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index 755592f..5e10539 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -5967,7 +5967,8 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             }
         }
 
-        if (useHapticFeedback) {
+        if (useHapticFeedback && mDisplay != null
+                && mDisplay.getState() != Display.STATE_OFF) {
             performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
         }
 
diff --git a/telephony/java/android/telephony/PhoneNumberUtils.java b/telephony/java/android/telephony/PhoneNumberUtils.java
index a70233f..2bcc0c2 100644
--- a/telephony/java/android/telephony/PhoneNumberUtils.java
+++ b/telephony/java/android/telephony/PhoneNumberUtils.java
@@ -45,6 +45,14 @@ import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import java.util.ArrayList;
+import java.util.HashMap;
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+import java.io.FileReader;
+import java.io.IOException;
+
 /**
  * Various utilities for dealing with phone number strings.
  */
@@ -87,6 +95,78 @@ public class PhoneNumberUtils
     private static final Pattern GLOBAL_PHONE_NUMBER_PATTERN =
             Pattern.compile("[\\+]?[0-9.-]+");
 
+    // MTK
+
+    /** @hide */
+    public static class EccEntry {
+        public static final String ECC_LIST_PATH = "/system/etc/ecc_list.xml";
+        public static final String ECC_ENTRY_TAG = "EccEntry";
+        public static final String ECC_ATTR = "Ecc";
+        public static final String CATEGORY_ATTR = "Category";
+        public static final String CONDITION_ATTR = "Condition";
+
+        public static final String ECC_NO_SIM = "0";
+        public static final String ECC_ALWAYS = "1";
+        public static final String ECC_FOR_MMI = "2";
+
+        private String mEcc;
+        private String mCategory;
+        private String mCondition; // ECC_NO_SIM, ECC_ALWAYS, or ECC_FOR_MMI
+
+        public EccEntry() {
+            mEcc = new String("");
+            mCategory = new String("");
+            mCondition = new String("");
+        }
+
+        public void setEcc(String strEcc) {
+            mEcc = strEcc;
+        }
+        public void setCategory(String strCategory) {
+            mCategory = strCategory;
+        }
+        public void setCondition(String strCondition) {
+            mCondition = strCondition;
+        }
+
+        public String getEcc() {
+            return mEcc;
+        }
+        public String getCategory() {
+            return mCategory;
+        }
+        public String getCondition() {
+            return mCondition;
+        }
+
+        @Override
+        public String toString() {
+            return ("\n" + ECC_ATTR + "=" + getEcc() + ", " + CATEGORY_ATTR + "="
+                    + getCategory() + ", " + CONDITION_ATTR + "=" + getCondition());
+        }
+    }
+
+    private static ArrayList<EccEntry> mCustomizedEccList = null;
+    private static HashMap<String, Integer> mHashMapForNetworkEccCategory = null;
+
+    // private static IPhoneNumberExt sPhoneNumberExt = null;
+
+    private static boolean sIsCtaSupport = false;
+    private static boolean sIsCtaSet = false;
+
+    static {
+        sIsCtaSupport = "1".equals(SystemProperties.get("persist.mtk_cta_support"));
+        sIsCtaSet = "1".equals(SystemProperties.get("ro.mtk_cta_set"));
+        /*
+        if (!SystemProperties.get("ro.mtk_bsp_package").equals("1")) {
+            sPhoneNumberExt = MPlugin.createInstance(IPhoneNumberExt.class.getName());
+        }
+        */
+        mCustomizedEccList = new ArrayList<EccEntry>();
+        parseEccList();
+        mHashMapForNetworkEccCategory = new HashMap<String, Integer>();
+    }
+
     /** True if c is ISO-LATIN characters 0-9 */
     public static boolean
     isISODigit (char c) {
@@ -1891,6 +1971,8 @@ public class PhoneNumberUtils
     private static boolean isEmergencyNumberInternal(int subId, String number,
                                                      String defaultCountryIso,
                                                      boolean useExactMatch) {
+        boolean bSIMInserted = false;
+
         // If the number passed in is null, just return false:
         if (number == null) return false;
 
@@ -1912,6 +1994,28 @@ public class PhoneNumberUtils
         Rlog.d(LOG_TAG, "subId:" + subId + ", defaultCountryIso:" +
                 ((defaultCountryIso == null) ? "NULL" : defaultCountryIso));
 
+        // MTK
+        // 1. Check ECCs updated by network
+        mHashMapForNetworkEccCategory.clear();
+        String strEccCategoryList = SystemProperties.get("ril.ecc.service.category.list");
+        if (!TextUtils.isEmpty(strEccCategoryList)) {
+            for (String strEccCategory : strEccCategoryList.split(";")) {
+                if (!strEccCategory.isEmpty()) {
+                    String[] strEccCategoryAry = strEccCategory.split(",");
+                    if (2 == strEccCategoryAry.length)
+                        mHashMapForNetworkEccCategory.put(strEccCategoryAry[0], Integer.parseInt(strEccCategoryAry[1]));
+                }
+            }
+        }
+        for (String emergencyNum : mHashMapForNetworkEccCategory.keySet()) {
+            String numberPlus = emergencyNum + "+";
+            if (emergencyNum.equals(number)
+                 || numberPlus.equals(number)) {
+                Rlog.d(LOG_TAG, "[isEmergencyNumber] match network ecc list");
+                return true;
+            }
+        }
+
         String emergencyNumbers = "";
         int slotId = SubscriptionManager.getSlotId(subId);
 
@@ -1920,6 +2024,7 @@ public class PhoneNumberUtils
         String ecclist = (slotId <= 0) ? "ril.ecclist" : ("ril.ecclist" + slotId);
 
         emergencyNumbers = SystemProperties.get(ecclist, "");
+        bSIMInserted = slotId >= 0;
 
         Rlog.d(LOG_TAG, "slotId:" + slotId + ", emergencyNumbers: " +  emergencyNumbers);
 
@@ -1950,6 +2055,36 @@ public class PhoneNumberUtils
             return false;
         }
 
+        // MTK
+        // 3. Check ECCs customized by user
+        if (bSIMInserted) {
+            if (mCustomizedEccList != null) {
+                for (EccEntry eccEntry : mCustomizedEccList) {
+                    if (!eccEntry.getCondition().equals(EccEntry.ECC_NO_SIM)) {
+                        String ecc = eccEntry.getEcc();
+                        String numberPlus = ecc + "+";
+                        if (ecc.equals(number)
+                             || numberPlus.equals(number)) {
+                            Rlog.d(LOG_TAG, "[isEmergencyNumber] match customized ecc list");
+                            return true;
+                        }
+                    }
+                }
+            }
+        } else {
+            if (mCustomizedEccList != null) {
+                for (EccEntry eccEntry : mCustomizedEccList) {
+                    String ecc = eccEntry.getEcc();
+                    String numberPlus = ecc + "+";
+                    if (ecc.equals(number)
+                         || numberPlus.equals(number)) {
+                        Rlog.d(LOG_TAG, "[isEmergencyNumber] match customized ecc list when no sim");
+                        return true;
+                    }
+                }
+            }
+        }
+
         Rlog.d(LOG_TAG, "System property doesn't provide any emergency numbers."
                 + " Use embedded logic for determining ones.");
 
@@ -3135,4 +3270,149 @@ public class PhoneNumberUtils
         return SubscriptionManager.getDefaultVoiceSubId();
     }
     //==== End of utility methods used only in compareStrictly() =====
+
+    // MTK
+
+    /**
+     * Parse Ecc List From XML File
+     *
+     * @param none.
+     * @return none.
+     * @hide
+     */
+    private static void parseEccList() {
+        mCustomizedEccList.clear();
+
+        try {
+            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
+            XmlPullParser parser = factory.newPullParser();
+            if (parser == null) {
+                Rlog.d(LOG_TAG, "XmlPullParserFactory.newPullParser() return null");
+                return;
+            }
+            FileReader fileReader = new FileReader(EccEntry.ECC_LIST_PATH);
+            parser.setInput(fileReader);
+            int eventType = parser.getEventType();
+            EccEntry record = null;
+
+            while (eventType != XmlPullParser.END_DOCUMENT) {
+                switch (eventType) {
+                    case XmlPullParser.START_TAG:
+                        if (parser.getName().equals(EccEntry.ECC_ENTRY_TAG)) {
+                            record = new EccEntry();
+                            int attrNum = parser.getAttributeCount();
+                            for (int i = 0; i < attrNum; ++i) {
+                                String name = parser.getAttributeName(i);
+                                String value = parser.getAttributeValue(i);
+                                if (name.equals(EccEntry.ECC_ATTR))
+                                    record.setEcc(value);
+                                else if (name.equals(EccEntry.CATEGORY_ATTR))
+                                    record.setCategory(value);
+                                else if (name.equals(EccEntry.CONDITION_ATTR))
+                                    record.setCondition(value);
+                            }
+                        }
+                        break;
+                    case XmlPullParser.END_TAG:
+                        if (parser.getName().equals(EccEntry.ECC_ENTRY_TAG) && record != null)
+                            mCustomizedEccList.add(record);
+                        break;
+                }
+                eventType = parser.next();
+            }
+            fileReader.close();
+
+            if (sIsCtaSet) {
+                String [] emergencyCTAList = {"120", "122"};
+                for (String emergencyNum : emergencyCTAList) {
+                    record = new EccEntry();
+                    record.setEcc(emergencyNum);
+                    record.setCategory("0");
+                    record.setCondition(EccEntry.ECC_FOR_MMI);
+
+                    boolean bFound = false;
+                    int nIndex = 0;
+                    for (EccEntry eccEntry : mCustomizedEccList) {
+                        String ecc = eccEntry.getEcc();
+                        if (ecc.equals(emergencyNum)) {
+                            bFound = true;
+                            Rlog.d(LOG_TAG, "[parseEccList]"
+                                    + "CTA ecc match customized ecc list, ecc=" + ecc);
+                            break;
+                        }
+                        nIndex++;
+                    }
+
+                    if (bFound)
+                        mCustomizedEccList.set(nIndex, record);
+                    else
+                        mCustomizedEccList.add(record);
+                }
+            }
+        } catch (XmlPullParserException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        Rlog.d(LOG_TAG, "parseEccList: " + mCustomizedEccList);
+    }
+
+    /**
+     * Get Ecc List
+     *
+     * @param none.
+     * @return Ecc List with type ArrayList<EccEntry>.
+     * @hide
+     */
+    public static ArrayList<EccEntry> getEccList() {
+        return mCustomizedEccList;
+    }
+
+    /**
+     * Get the service category for the given ECC number.
+     * @param number The ECC number.
+     * @return The service category for the given number.
+     * @hide
+     */
+    public static int getServiceCategoryFromEcc(String number) {
+        String numberPlus = null;
+
+        // 1. Get category from network
+        for (String emergencyNum : mHashMapForNetworkEccCategory.keySet()) {
+            numberPlus = emergencyNum + "+";
+            if (emergencyNum.equals(number)
+                 || numberPlus.equals(number)) {
+                Integer nSC = mHashMapForNetworkEccCategory.get(emergencyNum);
+                if (nSC != null) {
+                    Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] match network ecc list, "
+                            + "Ecc= " + number + ", Category= " + nSC);
+                    return nSC;
+                }
+            }
+        }
+
+        // 2. Get category from sim
+        // ToDo: EF_Ecc will convey service category later
+
+        // 3. Get category from user-customized
+        if (mCustomizedEccList != null) {
+            for (EccEntry eccEntry : mCustomizedEccList) {
+                String ecc = eccEntry.getEcc();
+                numberPlus = ecc + "+";
+                if (ecc.equals(number)
+                     || numberPlus.equals(number)) {
+                    Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] match customized ecc list, "
+                            + "Ecc= " + ecc + ", Category= " + eccEntry.getCategory());
+                    return Integer.parseInt(eccEntry.getCategory());
+                }
+            }
+        }
+
+        Rlog.d(LOG_TAG, "[getServiceCategoryFromEcc] no matched for Ecc =" + number + ", return 0");
+        return 0;
+    }
+
 }
diff --git a/telephony/java/android/telephony/ServiceState.java b/telephony/java/android/telephony/ServiceState.java
index d411376..686e1a5 100644
--- a/telephony/java/android/telephony/ServiceState.java
+++ b/telephony/java/android/telephony/ServiceState.java
@@ -159,6 +159,35 @@ public class ServiceState implements Parcelable {
      */
     public static final int RIL_RADIO_TECHNOLOGY_LTE_CA = 19;
 
+    // MTK
+    // For HSPAP detail radio technology
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_MTK = 128;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSDPAP = RIL_RADIO_TECHNOLOGY_MTK + 1;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSDPAP_UPA = RIL_RADIO_TECHNOLOGY_MTK + 2;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSUPAP = RIL_RADIO_TECHNOLOGY_MTK + 3;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_HSUPAP_DPA = RIL_RADIO_TECHNOLOGY_MTK + 4;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_DPA = RIL_RADIO_TECHNOLOGY_MTK + 5;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_UPA = RIL_RADIO_TECHNOLOGY_MTK + 6;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP = RIL_RADIO_TECHNOLOGY_MTK + 7;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP_UPA = RIL_RADIO_TECHNOLOGY_MTK + 8;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSDPAP_DPA = RIL_RADIO_TECHNOLOGY_MTK + 9;
+    /** @hide */
+    public static final int RIL_RADIO_TECHNOLOGY_DC_HSPAP = RIL_RADIO_TECHNOLOGY_MTK + 10;
+
+    // for LTEA (carrier aggregation)
+    /** @hide*/
+    public static final int RIL_RADIO_TECHNOLOGY_LTEA = RIL_RADIO_TECHNOLOGY_MTK + 11;
+
     /**
      * Available registration states for GSM, UMTS and CDMA.
      */
@@ -174,6 +203,17 @@ public class ServiceState implements Parcelable {
     public static final int REGISTRATION_STATE_UNKNOWN = 4;
     /** @hide */
     public static final int REGISTRATION_STATE_ROAMING = 5;
+    // MTK
+    /** @hide */
+    public static final int
+            REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING_EMERGENCY_CALL_ENABLED = 10;
+    /** @hide */
+    public static final int REGISTRATION_STATE_NOT_REGISTERED_AND_SEARCHING_EMERGENCY_CALL_ENABLED
+            = 12;
+    /** @hide */
+    public static final int REGISTRATION_STATE_REGISTRATION_DENIED_EMERGENCY_CALL_ENABLED = 13;
+    /** @hide */
+    public static final int REGISTRATION_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED = 14;
 
     private int mVoiceRegState = STATE_OUT_OF_SERVICE;
     private int mDataRegState = STATE_OUT_OF_SERVICE;
@@ -228,6 +268,30 @@ public class ServiceState implements Parcelable {
 
     private boolean mIsDataRoamingFromRegistration;
 
+    // MTK
+    //MTK-START
+    private int mRilVoiceRegState = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+    private int mRilDataRegState  = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+    //[ALPS01675318] -START
+    private int mProprietaryDataRadioTechnology;
+    //[ALPS01675318] -END
+    private int mVoiceRejectCause = -1;
+    private int mDataRejectCause = -1;
+    //MTK-END
+
+    //support by via start [ALPS00421033]
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_UNKOWN    = 0;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_1X_ONLY   = 2;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_EVDO_ONLY = 4;
+    /** @hide */
+    public static final int RIL_CDMA_NETWORK_MODE_1X_EVDO   = 8;
+    /** @hide */
+    protected int mCdmaNetWorkMode = RIL_CDMA_NETWORK_MODE_UNKOWN;
+    //support by via end. [ALPS00421033]
+
     /**
      * get String description of roaming type
      * @hide
@@ -306,6 +370,13 @@ public class ServiceState implements Parcelable {
         mCdmaEriIconMode = s.mCdmaEriIconMode;
         mIsEmergencyOnly = s.mIsEmergencyOnly;
         mIsDataRoamingFromRegistration = s.mIsDataRoamingFromRegistration;
+        // MTK
+        mRilVoiceRegState = s.mRilVoiceRegState;
+        mRilDataRegState = s.mRilDataRegState;
+        mProprietaryDataRadioTechnology = s.mProprietaryDataRadioTechnology;
+        mVoiceRejectCause = s.mVoiceRejectCause;
+        mDataRejectCause = s.mDataRejectCause;
+        mCdmaNetWorkMode = s.mCdmaNetWorkMode;
     }
 
     /**
@@ -333,6 +404,16 @@ public class ServiceState implements Parcelable {
         mCdmaEriIconIndex = in.readInt();
         mCdmaEriIconMode = in.readInt();
         mIsEmergencyOnly = in.readInt() != 0;
+        // MTK
+        // xen0n: keep the order consistent with MTK sources to prevent some
+        // external components making assumptions about the parcel layout
+        mRilVoiceRegState = in.readInt();
+        mRilDataRegState = in.readInt();
+        mProprietaryDataRadioTechnology = in.readInt();
+        mVoiceRejectCause = in.readInt();
+        mDataRejectCause = in.readInt();
+        mCdmaNetWorkMode = in.readInt();
+        // MTK-END
         mIsDataRoamingFromRegistration = in.readInt() != 0;
     }
 
@@ -358,6 +439,16 @@ public class ServiceState implements Parcelable {
         out.writeInt(mCdmaEriIconIndex);
         out.writeInt(mCdmaEriIconMode);
         out.writeInt(mIsEmergencyOnly ? 1 : 0);
+        // MTK
+        // xen0n: keep the order consistent with MTK sources to prevent some
+        // external components making assumptions about the parcel layout
+        out.writeInt(mRilVoiceRegState);
+        out.writeInt(mRilDataRegState);
+        out.writeInt(mProprietaryDataRadioTechnology);
+        out.writeInt(mVoiceRejectCause);
+        out.writeInt(mDataRejectCause);
+        out.writeInt(mCdmaNetWorkMode);
+        // MTK-END
         out.writeInt(mIsDataRoamingFromRegistration ? 1 : 0);
     }
 
@@ -631,6 +722,13 @@ public class ServiceState implements Parcelable {
                 + mCdmaRoamingIndicator
                 + mCdmaDefaultRoamingIndicator
                 + (mIsEmergencyOnly ? 1 : 0)
+                // xen0n: MTK impl didn't take their additions into account
+                + mRilVoiceRegState
+                + mRilDataRegState
+                + mProprietaryDataRadioTechnology
+                + mVoiceRejectCause
+                + mDataRejectCause
+                // xen0n end
                 + (mIsDataRoamingFromRegistration ? 1 : 0));
     }
 
@@ -668,6 +766,15 @@ public class ServiceState implements Parcelable {
                 && equalsHandlesNulls(mCdmaDefaultRoamingIndicator,
                         s.mCdmaDefaultRoamingIndicator)
                 && mIsEmergencyOnly == s.mIsEmergencyOnly
+                // MTK
+                && mRilVoiceRegState == s.mRilVoiceRegState
+                && mRilDataRegState == s.mRilDataRegState
+                && equalsHandlesNulls(mProprietaryDataRadioTechnology,
+                        s.mProprietaryDataRadioTechnology)
+                && mVoiceRejectCause == s.mVoiceRejectCause
+                && mDataRejectCause == s.mDataRejectCause
+                && mCdmaNetWorkMode == s.mCdmaNetWorkMode
+                // MTK-END
                 && mIsDataRoamingFromRegistration == s.mIsDataRoamingFromRegistration);
     }
 
@@ -776,6 +883,14 @@ public class ServiceState implements Parcelable {
                 + " RoamInd=" + mCdmaRoamingIndicator
                 + " DefRoamInd=" + mCdmaDefaultRoamingIndicator
                 + " EmergOnly=" + mIsEmergencyOnly
+                // MTK
+                + " Ril Voice Regist state: " + mRilVoiceRegState
+                + " Ril Data Regist state: " + mRilDataRegState
+                + " mProprietaryDataRadioTechnology: " + mProprietaryDataRadioTechnology
+                + " VoiceRejectCause: " + mVoiceRejectCause
+                + " DataRejectCause: " + mDataRejectCause
+                + " mCdmaNetWorkMode: " + mCdmaNetWorkMode
+                // MTK-END
                 + " IsDataRoamingFromRegistration=" + mIsDataRoamingFromRegistration);
     }
 
@@ -803,6 +918,12 @@ public class ServiceState implements Parcelable {
         mCdmaEriIconMode = -1;
         mIsEmergencyOnly = false;
         mIsDataRoamingFromRegistration = false;
+        // MTK
+        mRilVoiceRegState = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+        mRilDataRegState  = REGISTRATION_STATE_NOT_REGISTERED_AND_NOT_SEARCHING;
+        mProprietaryDataRadioTechnology = 0;
+        mVoiceRejectCause = -1;
+        mDataRejectCause = -1;
     }
 
     public void setStateOutOfService() {
@@ -976,6 +1097,13 @@ public class ServiceState implements Parcelable {
         mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
         mIsEmergencyOnly = m.getBoolean("emergencyOnly");
         mIsDataRoamingFromRegistration = m.getBoolean("isDataRoamingFromRegistration");
+        // MTK
+        mRilVoiceRegState = m.getInt("RilVoiceRegState");
+        mRilDataRegState = m.getInt("RilDataRegState");
+        mProprietaryDataRadioTechnology = m.getInt("proprietaryDataRadioTechnology");
+        mVoiceRejectCause= m.getInt("VoiceRejectCause");
+        mDataRejectCause= m.getInt("DataRejectCause");
+        mCdmaNetWorkMode = m.getInt("cdmaNetWorkMode");
     }
 
     /**
@@ -1005,6 +1133,13 @@ public class ServiceState implements Parcelable {
         m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
         m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
         m.putBoolean("isDataRoamingFromRegistration", Boolean.valueOf(mIsDataRoamingFromRegistration));
+        // MTK
+        m.putInt("RilVoiceRegState", mRilVoiceRegState);
+        m.putInt("RilDataRegState", mRilDataRegState);
+        m.putInt("proprietaryDataRadioTechnology", mProprietaryDataRadioTechnology);
+        m.putInt("VoiceRejectCause", mVoiceRejectCause);
+        m.putInt("DataRejectCause", mDataRejectCause);
+        m.putInt("cdmaNetWorkMode", mCdmaNetWorkMode);
     }
 
     /** @hide */
@@ -1223,4 +1358,169 @@ public class ServiceState implements Parcelable {
 
         return newSs;
     }
+
+    // MTK
+
+    /**
+     * Get current voice network registration reject cause.
+     * See 3GPP TS 24.008,section 10.5.3.6 and Annex G.
+     * @return registration reject cause or INVALID value (-1)
+     * @hide
+     */
+    public int getVoiceRejectCause() {
+        return mVoiceRejectCause;
+    }
+
+    /**
+     * Get current data network registration reject cause.
+     * See 3GPP TS 24.008 Annex G.6 "Additional cause codes for GMM".
+     * @return registration reject cause or INVALID value (-1)
+     * @hide
+     */
+    public int getDataRejectCause() {
+        return mDataRejectCause;
+    }
+
+    /** @hide */
+    public void setVoiceRejectCause(int cause) {
+        mVoiceRejectCause = cause;
+    }
+
+    /** @hide */
+    public void setDataRejectCause(int cause) {
+        mDataRejectCause = cause;
+    }
+
+    //[ALPS01675318] -START
+    /** @hide */
+    public int getProprietaryDataRadioTechnology() {
+        return this.mProprietaryDataRadioTechnology;
+    }
+
+    /** @hide */
+    public void setProprietaryDataRadioTechnology(int rt) {
+        if (rt > ServiceState.RIL_RADIO_TECHNOLOGY_MTK) {
+            if (DBG) Rlog.d(LOG_TAG, "[ServiceState] setProprietaryDataRadioTechnology =" + rt);
+            mProprietaryDataRadioTechnology = rt;
+            //carrier aggregation
+            if (rt == ServiceState.RIL_RADIO_TECHNOLOGY_LTEA) {
+                // xen0n: for CM CAF code
+                // rt = ServiceState.RIL_RADIO_TECHNOLOGY_LTE;
+                rt = ServiceState.RIL_RADIO_TECHNOLOGY_LTE_CA;
+            } else {
+                rt = ServiceState.RIL_RADIO_TECHNOLOGY_HSPAP;
+            }
+        } else {
+            if (DBG) Rlog.d(LOG_TAG, "[ServiceState] setProprietaryDataRadioTechnology=0");
+            mProprietaryDataRadioTechnology = 0;
+        }
+        setRilDataRadioTechnology(rt);
+    }
+
+    /** @hide */
+    public int getRegState() {
+        return getRilVoiceRegState();
+    }
+
+   /** @hide */
+    public int getRilVoiceRegState() {
+        return mRilVoiceRegState;
+    }
+
+   /** @hide */
+    public int getRilDataRegState() {
+        return mRilDataRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public void setRegState(int nRegState) {
+        setRilVoiceRegState(nRegState);
+    }
+
+    /**
+     * @hide
+     */
+    public void setRilVoiceRegState(int nRegState) {
+        mRilVoiceRegState = nRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public void setRilDataRegState(int nDataRegState) {
+        mRilDataRegState = nDataRegState;
+    }
+
+    /**
+     * @hide
+     */
+    public boolean isVoiceRadioTechnologyHigher(int nRadioTechnology) {
+        return compareTwoRadioTechnology(mRilVoiceRadioTechnology, nRadioTechnology);
+    }
+
+    /**
+     * @hide
+     */
+     public boolean isDataRadioTechnologyHigher(int nRadioTechnology) {
+        return compareTwoRadioTechnology(mRilDataRadioTechnology, nRadioTechnology);
+    }
+
+    /**
+     * @hide
+     */
+     public boolean compareTwoRadioTechnology(int nRadioTechnology1, int nRadioTechnology2) {
+         if (nRadioTechnology1 == nRadioTechnology2) {
+             return false;
+         } else if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_LTE) {
+             return true;
+         } else if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_LTE) {
+             return false;
+         // xen0n: take CAF constant into consideration
+         // reason for not using or expressions is just for cleaner diff
+         } else if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_LTE_CA) {
+             return true;
+         } else if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_LTE_CA) {
+             return false;
+         // xen0n end
+         } else if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_GSM) {
+             // ALPS02230032-START
+             if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+                 return true;
+             }
+             // ALPS00230032-END
+             return false;
+         } else if (nRadioTechnology2 == RIL_RADIO_TECHNOLOGY_GSM) {
+             // ALPS02230032-START
+             if (nRadioTechnology1 == RIL_RADIO_TECHNOLOGY_UNKNOWN) {
+                 return false;
+             }
+             // ALPS00230032-END
+             return true;
+         } else if (nRadioTechnology1 > nRadioTechnology2) {
+             return true;
+         } else {
+             return false;
+         }
+     }
+
+     //M: MTK Added methods END
+
+
+    //support by via start [ALPS00421033]
+    /**
+     * @hide
+     */
+    public int getCdmaNetworkMode() {
+        return mCdmaNetWorkMode;
+    }
+
+    /**
+     * @hide
+     */
+    public void setCdmaNetworkMode(int networkMode) {
+        mCdmaNetWorkMode = networkMode;
+    }
+    //support by via end. [ALPS00421033]
 }
diff --git a/telephony/java/android/telephony/SubscriptionManager.java b/telephony/java/android/telephony/SubscriptionManager.java
index 3b375e2..1f0470c 100644
--- a/telephony/java/android/telephony/SubscriptionManager.java
+++ b/telephony/java/android/telephony/SubscriptionManager.java
@@ -95,6 +95,63 @@ public class SubscriptionManager {
     /** @hide */
     public static final Uri CONTENT_URI = Uri.parse("content://telephony/siminfo");
 
+    // MTK
+    /** @hide */
+    public static final int LTE_DC_PHONE_ID = TelephonyManager.getDefault().getPhoneCount();
+
+    /**
+     * M: Indicates the specified phone id for slot1 LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_PHONE_ID_1 = 10;
+
+    /**
+     * M: Indicates the specified phone id for slot2 LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_PHONE_ID_2 = 11;
+
+    /**
+     * M: Indicates the specified subscription identifier for LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_SUB_ID = -999;
+
+    /**
+     * M: Indicates the specified subscription identifier for slot1 LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_SUB_ID_1 = -10;
+
+    /**
+     * M: Indicates the specified subscription identifier for slot2 LteDcPhone.
+     */
+    /** @hide */
+    public static final int LTE_DC_SUB_ID_2 = -11;
+
+    private static final boolean MTK_LTEDC_SUPPORT =
+                        "1".equals(android.os.SystemProperties.get("ro.mtk_svlte_support"))
+                        || "1".equals(android.os.SystemProperties.get("ro.mtk_srlte_support"));
+
+    /** @hide */
+    public static final int EXTRA_VALUE_NEW_SIM = 1;
+    /** @hide */
+    public static final int EXTRA_VALUE_REMOVE_SIM = 2;
+    /** @hide */
+    public static final int EXTRA_VALUE_REPOSITION_SIM = 3;
+    /** @hide */
+    public static final int EXTRA_VALUE_NOCHANGE = 4;
+
+    /** @hide */
+    public static final String INTENT_KEY_DETECT_STATUS = "simDetectStatus";
+    /** @hide */
+    public static final String INTENT_KEY_SIM_COUNT = "simCount";
+    /** @hide */
+    public static final String INTENT_KEY_NEW_SIM_SLOT = "newSIMSlot";
+    /** @hide */
+    public static final String INTENT_KEY_NEW_SIM_STATUS = "newSIMStatus";
+    // MTK-END
+
     /**
      * TelephonyProvider unique key column name is the subscription id.
      * <P>Type: TEXT (String)</P>
@@ -915,6 +972,12 @@ public class SubscriptionManager {
             if (DBG) {
                 logd("[getPhoneId]- fail");
             }
+            // MTK
+            if (subId > DUMMY_SUBSCRIPTION_ID_BASE - TelephonyManager.getDefault().getSimCount()) {
+                logd("[getPhoneId]- return dummy value, subId = " + subId);
+                return (DUMMY_SUBSCRIPTION_ID_BASE  - subId);
+            }
+            // MTK-END
             return INVALID_PHONE_INDEX;
         }
 
@@ -1136,6 +1199,13 @@ public class SubscriptionManager {
      * @hide
      */
     public static boolean isValidSubscriptionId(int subId) {
+        // MTK-START
+        // Add the special handle for LTEDC
+        if (MTK_LTEDC_SUPPORT) {
+            return subId > INVALID_SUBSCRIPTION_ID || subId == LTE_DC_SUB_ID_1
+                    || subId == LTE_DC_SUB_ID_2;
+        }
+        // MTK-END
         return subId > INVALID_SUBSCRIPTION_ID ;
     }
 
@@ -1155,6 +1225,13 @@ public class SubscriptionManager {
 
     /** @hide */
     public static boolean isValidPhoneId(int phoneId) {
+        // MTK-START
+        // Add the special handle for LTEDC
+        if (MTK_LTEDC_SUPPORT) {
+            return (phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount())
+                    || phoneId == LTE_DC_PHONE_ID_1 || phoneId == LTE_DC_PHONE_ID_2;
+        }
+        // MTK-END
         return phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount();
     }
 
@@ -1420,4 +1497,148 @@ public class SubscriptionManager {
         }
         return false;
     }
+
+    // MTK
+
+    /**
+     * Get subId associated with the slotId.
+     * @param phoneId the specified phoneId
+     * @return subId as a positive integer
+     * INVALID_SUBSCRIPTION_ID if an invalid phone index
+     * @hide
+     */
+    public static int getSubIdUsingPhoneId(int phoneId) {
+        if (VDBG) logd("[getSubIdUsingPhoneId]+ phoneId:" + phoneId);
+
+        int subId = INVALID_SUBSCRIPTION_ID;
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                subId = iSub.getSubIdUsingPhoneId(phoneId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return subId;
+    }
+
+    // xen0n: MTK TODO
+    /**
+     * Set subId as default SubId.
+     * @param subId the specified subId
+     * @hide
+     */
+    /*
+    public static void setDefaultSubId(int subId) {
+        if (VDBG) logd("setDefaultSubId sub id = " + subId);
+
+        if (subId <= 0) {
+            printStackTrace("setDefaultSubId subId 0");
+        }
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                iSub.setDefaultFallbackSubId(subId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+    */
+
+    // MTK-START
+    // FIXME: getSubscriptionInfo and getSubscriptionInfoForIccId seem could be removed.
+    // It could be replace by AOSP API. It seems only for simple usage.
+    // xen0n: What, you know it already? Then why do you write and use them in the first place? :-/
+    /**
+     * Get the SubscriptionInfo with the subId key.
+     * @param subId The unique SubscriptionInfo key in database
+     * @return SubscriptionInfo, maybe null if not found
+     * @hide
+     */
+    /*
+    public SubscriptionInfo getSubscriptionInfo(int subId) {
+        if (VDBG) {
+            logd("[getSubscriptionInfo]+ subId=" + subId);
+        }
+
+        if (!isValidSubscriptionId(subId)) {
+            logd("[getSubscriptionInfo]- invalid subId, subId = " + subId);
+            return null;
+        }
+
+        SubscriptionInfo subInfo = null;
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                subInfo = iSub.getSubscriptionInfo(subId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return subInfo;
+    }
+    */
+
+    /**
+     * Get the SubscriptionInfo associated with the iccId.
+     * @param iccId the IccId of SIM card
+     * @return SubscriptionInfo, maybe null if not found
+     * @hide
+     */
+    /*
+    public SubscriptionInfo getSubscriptionInfoForIccId(String iccId) {
+        if (VDBG) {
+            logd("[getSubscriptionInfoForIccId]+ iccId=" + iccId);
+        }
+
+        if (iccId == null) {
+            logd("[getSubscriptionInfoForIccId]- null iccid");
+            return null;
+        }
+
+        SubscriptionInfo result = null;
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                result = iSub.getSubscriptionInfoForIccId(iccId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+
+        return result;
+    }
+    */
+
+    /**
+     * Set deafult data sub ID without invoking capability switch.
+     * @param subId the default data sub ID
+     * @hide
+     */
+    /*
+    public void setDefaultDataSubIdWithoutCapabilitySwitch(int subId) {
+        if (VDBG) { logd("setDefaultDataSubIdWithoutCapabilitySwitch sub id = " + subId); }
+
+        if (subId <= 0) {
+            printStackTrace("setDefaultDataSubIdWithoutCapabilitySwitch subId 0");
+        }
+
+        try {
+            ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
+            if (iSub != null) {
+                iSub.setDefaultDataSubIdWithoutCapabilitySwitch(subId);
+            }
+        } catch (RemoteException ex) {
+            // ignore it
+        }
+    }
+    */
+    // MTK-END
 }
diff --git a/telephony/java/com/android/ims/ImsCallForwardInfoEx.aidl b/telephony/java/com/android/ims/ImsCallForwardInfoEx.aidl
new file mode 100644
index 0000000..796ea10
--- /dev/null
+++ b/telephony/java/com/android/ims/ImsCallForwardInfoEx.aidl
@@ -0,0 +1,40 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.android.ims;
+
+parcelable ImsCallForwardInfoEx;
diff --git a/telephony/java/com/android/ims/ImsCallForwardInfoEx.java b/telephony/java/com/android/ims/ImsCallForwardInfoEx.java
new file mode 100644
index 0000000..ee3b752
--- /dev/null
+++ b/telephony/java/com/android/ims/ImsCallForwardInfoEx.java
@@ -0,0 +1,126 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2014. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+
+package com.android.ims;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Arrays;
+
+/**
+ * Provides the call forward information for the supplementary service configuration.
+ *
+ * @hide
+ */
+public class ImsCallForwardInfoEx implements Parcelable {
+    // Refer to ImsUtInterface#CDIV_CF_XXX
+    public int mCondition;
+    // 0: disabled, 1: enabled
+    public int mStatus;
+    // Sum of CommandsInterface.SERVICE_CLASS
+    public int mServiceClass;
+    // 0x91: International, 0x81: Unknown
+    public int mToA;
+    // Number (it will not include the "sip" or "tel" URI scheme)
+    public String mNumber;
+    // No reply timer for CF
+    public int mTimeSeconds;
+    // Time slot for CF
+    public long[] mTimeSlot;
+
+    public ImsCallForwardInfoEx() {
+    }
+
+    public ImsCallForwardInfoEx(Parcel in) {
+        readFromParcel(in);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int flags) {
+        out.writeInt(mCondition);
+        out.writeInt(mStatus);
+        out.writeInt(mServiceClass);
+        out.writeInt(mToA);
+        out.writeString(mNumber);
+        out.writeInt(mTimeSeconds);
+        out.writeLongArray(mTimeSlot);
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + ", Condition: " + mCondition
+            + ", Status: " + ((mStatus == 0) ? "disabled" : "enabled")
+            + ", ServiceClass: " + mServiceClass
+            + ", ToA: " + mToA + ", Number=" + mNumber
+            + ", Time (seconds): " + mTimeSeconds
+            + ", timeSlot: " + Arrays.toString(mTimeSlot);
+    }
+
+    private void readFromParcel(Parcel in) {
+        mCondition = in.readInt();
+        mStatus = in.readInt();
+        mServiceClass = in.readInt();
+        mToA = in.readInt();
+        mNumber = in.readString();
+        mTimeSeconds = in.readInt();
+        mTimeSlot = new long[2];
+        try {
+            in.readLongArray(mTimeSlot);
+        } catch (RuntimeException e) {
+            mTimeSlot = null;
+        }
+    }
+
+    public static final Creator<ImsCallForwardInfoEx> CREATOR =
+            new Creator<ImsCallForwardInfoEx>() {
+        @Override
+        public ImsCallForwardInfoEx createFromParcel(Parcel in) {
+            return new ImsCallForwardInfoEx(in);
+        }
+
+        @Override
+        public ImsCallForwardInfoEx[] newArray(int size) {
+            return new ImsCallForwardInfoEx[size];
+        }
+    };
+}
diff --git a/telephony/java/com/android/ims/ImsCallProfile.java b/telephony/java/com/android/ims/ImsCallProfile.java
index 50ee543..281a189 100644
--- a/telephony/java/com/android/ims/ImsCallProfile.java
+++ b/telephony/java/com/android/ims/ImsCallProfile.java
@@ -179,6 +179,7 @@ public class ImsCallProfile implements Parcelable {
      *  DisplayText: Display text for the call.
      *  AdditionalCallInfo: Additional call info.
      *  CallRadioTech: The radio tech on which the call is placed.
+     *  pau : Additional user identity information
      */
     public static final String EXTRA_OI = "oi";
     public static final String EXTRA_CNA = "cna";
@@ -189,6 +190,15 @@ public class ImsCallProfile implements Parcelable {
     public static final String EXTRA_DISPLAY_TEXT = "DisplayText";
     public static final String EXTRA_ADDITIONAL_CALL_INFO = "AdditionalCallInfo";
     public static final String EXTRA_IS_CALL_PULL = "CallPull";
+    // MTK
+    public static final String EXTRA_PAU = "pau";
+
+    /// M: @{
+    public static final String EXTRA_MPTY = "mpty";
+    public static final String EXTRA_INCOMING_MPTY = "incoming_mpty";
+    public static final String EXTRA_CONF_PARTICIPANT_INDEX = "conf_participant_index";
+    public static final String EXTRA_CONF_PARTICIPANT_STATE = "conf_participant_state";
+    /// @}
 
     /**
      * Extra key which the RIL can use to indicate the radio technology used for a call.
diff --git a/telephony/java/com/android/ims/ImsReasonInfo.java b/telephony/java/com/android/ims/ImsReasonInfo.java
index 85ec162..7cfb3d9 100644
--- a/telephony/java/com/android/ims/ImsReasonInfo.java
+++ b/telephony/java/com/android/ims/ImsReasonInfo.java
@@ -352,4 +352,20 @@ public class ImsReasonInfo implements Parcelable {
             return new ImsReasonInfo[size];
         }
     };
+
+    // MTK
+
+    /// M: @{
+    public static final int CODE_SIP_REDIRECTED_EMERGENCY = 329;
+    /// @}
+
+    public static final int CODE_UT_XCAP_403_FORBIDDEN = 830;
+    public static final int CODE_UT_UNKNOWN_HOST = 831;
+
+    ///M: ALPS02112553. For WFC @{
+    public static final int CODE_SIP_WIFI_SIGNAL_LOST = 905;
+    public static final int CODE_SIP_WFC_ISP_PROBLEM = 906;
+    public static final int CODE_SIP_HANDOVER_WIFI_FAIL = 907;
+    public static final int CODE_SIP_HANDOVER_LTE_FAIL = 908;
+    ///@}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsCallSession.aidl b/telephony/java/com/android/ims/internal/IImsCallSession.aidl
index b1f2d32..7e2fc74 100644
--- a/telephony/java/com/android/ims/internal/IImsCallSession.aidl
+++ b/telephony/java/com/android/ims/internal/IImsCallSession.aidl
@@ -17,6 +17,7 @@
 package com.android.ims.internal;
 
 import android.os.Message;
+import android.os.Messenger;
 import com.android.ims.ImsCallProfile;
 import com.android.ims.ImsStreamMediaProfile;
 import com.android.ims.internal.IImsCallSessionListener;
@@ -255,4 +256,33 @@ interface IImsCallSession {
      * @return {@code True} if the session is multiparty.
      */
     boolean isMultiparty();
+
+    // MTK
+
+    /// M: For one-key conference MT displayed as incoming conference call. @{
+    /**
+     * Determines if the current incoming session is multiparty.
+     * @return {@code True} if the incoming session is multiparty.
+     * @hide
+     */
+    boolean isIncomingCallMultiparty();
+    /// @}
+
+    /// M: ALPS02321477 @{
+    /// Google issue. Original sendDtmf could not pass Message.target to another process, because
+    /// Message.writeToParcel didn't write target. Workaround this issue by adding a new API
+    /// which passes target by Messenger.
+    /**
+     * Sends a DTMF code. According to <a href="http://tools.ietf.org/html/rfc2833">RFC 2833</a>,
+     * event 0 ~ 9 maps to decimal value 0 ~ 9, '*' to 10, '#' to 11, event 'A' ~ 'D' to 12 ~ 15,
+     * and event flash to 16. Currently, event flash is not supported. For usage of passing Message
+     * across processes.
+     *
+     * @param c the DTMF to send. '0' ~ '9', 'A' ~ 'D', '*', '#' are valid inputs.
+     * @param result.
+     * @param target Message target handler.
+     * @hide
+     */
+    void sendDtmfbyTarget(char c, in Message result, in Messenger target);
+    /// @}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl b/telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl
index d562ecc..1de1e63 100644
--- a/telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl
+++ b/telephony/java/com/android/ims/internal/IImsCallSessionListener.aidl
@@ -130,4 +130,17 @@ interface IImsCallSessionListener {
      */
     void callSessionSuppServiceReceived(in IImsCallSession session,
          in ImsSuppServiceNotification suppSrvNotification);
+
+    // MTK
+
+    /// M: ALPS02256671. PAU update. @{
+    /**
+     * Notifies of a change to the PAU information for this {@code ImsCallSession}.
+     *
+     * @param session The call session.
+     * @param profile The call profile.
+     * @hide
+     */
+    void callSessionPauInfoChanged(in IImsCallSession session, in ImsCallProfile profile);
+    /// @}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsService.aidl b/telephony/java/com/android/ims/internal/IImsService.aidl
index 30c48d7..5918e4d 100644
--- a/telephony/java/com/android/ims/internal/IImsService.aidl
+++ b/telephony/java/com/android/ims/internal/IImsService.aidl
@@ -75,4 +75,38 @@ interface IImsService {
      * Used to set current TTY Mode.
      */
     void setUiTTYMode(int serviceId, int uiTtyMode, in Message onComplete);
+
+    // MTK
+
+    /**
+     * call interface for allowing/refusing the incoming call indication send to App.
+     */
+    void setCallIndication(String callId, int seqNum, boolean isAllow);
+
+    /**
+     * Use to query ims enable/disable status.
+     */
+    int getImsState();
+
+    /**
+     * Use to query ims registration information.
+     */
+    boolean getImsRegInfo(int phoneId);
+
+    /**
+     * Use to query ims registration extension information.
+     */
+    String getImsExtInfo();
+
+    /**
+     * Use to hang up all calls.
+     */
+    void hangupAllCall();
+
+    ///M: WFC: Use to get WFC registration status @ {
+    /**
+     * Use to get registration status.
+     */
+    int getRegistrationStatus();
+    /// @}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsUt.aidl b/telephony/java/com/android/ims/internal/IImsUt.aidl
index 2784653..f31cfc6 100644
--- a/telephony/java/com/android/ims/internal/IImsUt.aidl
+++ b/telephony/java/com/android/ims/internal/IImsUt.aidl
@@ -116,4 +116,19 @@ interface IImsUt {
      * Retrieves the configuration of the call forward for specified service class.
      */
     int queryCFForServiceClass(int condition, String number, int serviceClass);
+
+    // MTK
+
+    /// M: SS OP01 Ut @{
+    /**
+     * Retrieves the configuration of the call forward in time slot.
+     */
+    int queryCallForwardInTimeSlot(int condition);
+
+    /**
+     * Updates the configuration of the call forward in time slot.
+     */
+    int updateCallForwardInTimeSlot(int action, int condition,
+            String number, int timeSeconds, in long[] timeSlot);
+    /// @}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsUtListener.aidl b/telephony/java/com/android/ims/internal/IImsUtListener.aidl
index 6416631..50461bb 100644
--- a/telephony/java/com/android/ims/internal/IImsUtListener.aidl
+++ b/telephony/java/com/android/ims/internal/IImsUtListener.aidl
@@ -19,6 +19,8 @@ package com.android.ims.internal;
 import android.os.Bundle;
 
 import com.android.ims.ImsCallForwardInfo;
+/// M: SS OP01 Ut
+import com.android.ims.ImsCallForwardInfoEx;
 import com.android.ims.ImsSsInfo;
 import com.android.ims.internal.IImsUt;
 import com.android.ims.ImsReasonInfo;
@@ -56,4 +58,14 @@ interface IImsUtListener {
      */
     void utConfigurationCallWaitingQueried(in IImsUt ut,
             int id, in ImsSsInfo[] cwInfo);
+
+    // MTK
+
+    /// M: SS OP01 Ut @{
+    /**
+     * Notifies the status of the call forwarding in a time slot supplementary service.
+     */
+    void utConfigurationCallForwardInTimeSlotQueried(in IImsUt ut,
+            int id, in ImsCallForwardInfoEx[] cfInfo);
+    /// @}
 }
diff --git a/telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl b/telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl
index 9499c9f..2eeb182 100644
--- a/telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl
+++ b/telephony/java/com/android/ims/internal/IImsVideoCallCallback.aidl
@@ -45,4 +45,11 @@ oneway interface IImsVideoCallCallback {
     void changeCameraCapabilities(in VideoProfile.CameraCapabilities cameraCapabilities);
 
     void changeVideoQuality(int videoQuality);
+
+    // MTK
+
+    /* M: ViLTE part start */
+    /* Different from AOSP, additional parameter "rotation" is added. */
+    void changePeerDimensionsWithAngle(int width, int height, int rotation);
+    /* M: ViLTE part end */
 }
diff --git a/telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl b/telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl
index 39e83c6..24592ff 100644
--- a/telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl
+++ b/telephony/java/com/android/ims/internal/IImsVideoCallProvider.aidl
@@ -62,4 +62,10 @@ oneway interface IImsVideoCallProvider {
     void requestCallDataUsage();
 
     void setPauseImage(in Uri uri);
+
+    // MTK
+
+    /* M: ViLTE part start */
+    void setUIMode(int mode);
+    /* M: ViLTE part end */
 }
diff --git a/telephony/java/com/android/internal/telephony/DctConstants.java b/telephony/java/com/android/internal/telephony/DctConstants.java
index a4e9486..e928531 100644
--- a/telephony/java/com/android/internal/telephony/DctConstants.java
+++ b/telephony/java/com/android/internal/telephony/DctConstants.java
@@ -114,7 +114,15 @@ public class DctConstants {
     public static final int APN_CBS_ID = 7;
     public static final int APN_IA_ID = 8;
     public static final int APN_EMERGENCY_ID = 9;
-    public static final int APN_NUM_TYPES = 10;
+    // MTK
+    public static final int APN_DM_ID = 10;
+    public static final int APN_WAP_ID = 11;
+    public static final int APN_NET_ID = 12;
+    public static final int APN_CMMAIL_ID = 13;
+    public static final int APN_RCSE_ID = 14;
+    public static final int APN_XCAP_ID = 15;
+    public static final int APN_RCS_ID = 16;
+    public static final int APN_NUM_TYPES = APN_RCS_ID + 1;
 
     public static final int INVALID = -1;
     public static final int DISABLED = 0;
@@ -122,4 +130,30 @@ public class DctConstants {
 
     public static final String APN_TYPE_KEY = "apnType";
     public static final String PROVISIONING_URL_KEY = "provisioningUrl";
+
+    // MTK
+
+    /** M: start */
+    public static final int MTK_BASE = BASE + 500;
+    public static final int EVENT_DATA_ROAMING_CHANGED = MTK_BASE + 1;
+    public static final int EVENT_INIT_EMERGENCY_APN_SETTINGS = MTK_BASE + 2;
+    public static final int EVENT_APN_CHANGED_DONE = MTK_BASE + 3;
+    public static final int EVENT_SETUP_DATA_WHEN_LOADED = MTK_BASE + 4;
+    public static final int EVENT_VOICE_CALL_STARTED_PEER = MTK_BASE + 5;
+    public static final int EVENT_VOICE_CALL_ENDED_PEER = MTK_BASE + 6;
+    public static final int EVENT_FDN_CHANGED = MTK_BASE + 7;
+
+    // M: CC33 LTE.
+    public static final int EVENT_REMOVE_RESTRICT_EUTRAN = MTK_BASE + 25;
+    public static final int EVENT_RESET_PDP_DONE = MTK_BASE + 26;
+    // M: Reset Attach Apn
+    public static final int EVENT_RESET_ATTACH_APN = MTK_BASE + 27;
+    /* M: end */
+    // M: Send this event when DcTracker is creating, and all phones has been created
+    //    when handle this event. So we can do registration which need peer phone.
+    public static final int EVENT_POST_CREATE_PHONE = MTK_BASE + 28;
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    public static final int EVENT_DEFAULT_APN_REFERENCE_COUNT_CHANGED = MTK_BASE + 29;
+    public static final int EVENT_LTE_ACCESS_STRATUM_STATE = MTK_BASE +30;
+    // M: [LTE][Low Power][UL traffic shaping] End
 }
diff --git a/telephony/java/com/android/internal/telephony/ISub.aidl b/telephony/java/com/android/internal/telephony/ISub.aidl
index 1323258..6cb0ba2 100755
--- a/telephony/java/com/android/internal/telephony/ISub.aidl
+++ b/telephony/java/com/android/internal/telephony/ISub.aidl
@@ -191,4 +191,8 @@ interface ISub {
     int setSubState(int subId, int subStatus);
 
     int getSubState(int subId);
+
+    // MTK
+
+    int getSubIdUsingPhoneId(int phoneId);
 }
diff --git a/telephony/java/com/android/internal/telephony/IccCardConstants.java b/telephony/java/com/android/internal/telephony/IccCardConstants.java
index c1e2518..9567cd6 100644
--- a/telephony/java/com/android/internal/telephony/IccCardConstants.java
+++ b/telephony/java/com/android/internal/telephony/IccCardConstants.java
@@ -102,4 +102,113 @@ public class IccCardConstants {
             }
         }
     }
+
+    // MTK
+
+    // Added by M begin
+    /**
+     * NETWORK_SUBSET means ICC is locked on NETWORK SUBSET PERSONALIZATION.
+     * @internal
+     */
+    public static final String INTENT_VALUE_LOCKED_NETWORK_SUBSET = "NETWORK_SUBSET";
+    /**
+     * CORPORATE means ICC is locked on CORPORATE PERSONALIZATION.
+     * @internal
+     */
+    public static final String INTENT_VALUE_LOCKED_CORPORATE = "CORPORATE";
+    /**
+     * SERVICE_PROVIDER means ICC is locked on SERVICE_PROVIDER PERSONALIZATION.
+     * @internal
+     */
+    public static final String INTENT_VALUE_LOCKED_SERVICE_PROVIDER = "SERVICE_PROVIDER";
+    /**
+     * SIM means ICC is locked on SIM PERSONALIZATION.
+     * @internal
+     */
+    public static final String INTENT_VALUE_LOCKED_SIM = "SIM";
+    // Added by M end
+
+    // MTK-START
+    /**
+     * This card type is report by CDMA(VIA) modem.
+     * for CT requset to detect card type then give a warning
+     * @deprecated - use IccCardType instead
+     */
+    @Deprecated public enum CardType {
+        UIM_CARD(1),             //ICC structure, non CT UIM card
+        SIM_CARD(2),             //ICC structure, non CT SIM card
+        UIM_SIM_CARD(3),         //ICC structure, non CT dual mode card
+        UNKNOW_CARD(4),          //card is present, but can't detect type
+        CT_3G_UIM_CARD(5),       //ICC structure, CT 3G UIM card
+        CT_UIM_SIM_CARD(6),      //ICC structure, CT 3G dual mode card
+        PIN_LOCK_CARD(7),        //this card need PIN
+        CT_4G_UICC_CARD(8),      //UICC structure, CT 4G dual mode UICC card
+        NOT_CT_UICC_CARD(9),     //UICC structure, Non CT 4G dual mode UICC card
+        LOCKED_CARD(18),         //card is locked
+        CARD_NOT_INSERTED(255);  //card is not inserted
+
+        private int mValue;
+
+        public int getValue() {
+            return mValue;
+        }
+
+        /**
+         * Get CardType from integer.
+         * ASSERT: Please DON'T directly use CardType.values(), otherwise JE will occur
+         * @param cardTypeInt for cardType index.
+         * @return CardType.
+         */
+        public static IccCardConstants.CardType getCardTypeFromInt(int cardTypeInt) {
+            CardType cardType = CARD_NOT_INSERTED;
+            CardType[] cardTypes = CardType.values();
+            for (int i = 0; i < cardTypes.length; i++) {
+                if (cardTypes[i].getValue() == cardTypeInt) {
+                    cardType = cardTypes[i];
+                    break;
+                }
+            }
+            return cardType;
+        }
+
+        /**
+         * Check if it is 4G card.
+         * @return true if it is 4G card
+         */
+        public boolean is4GCard() {
+            return ((this == CT_4G_UICC_CARD) || (this == NOT_CT_UICC_CARD));
+        }
+
+        /**
+         * Check if it is 3G card.
+         * @return true if it is 3G card
+         */
+        public boolean is3GCard() {
+            return ((this == UIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_3G_UIM_CARD) || (this == CT_UIM_SIM_CARD));
+        }
+
+        /**
+         * Check if it is dual mode card.
+         * @return true if it is dual mode card
+         */
+        public boolean isDualModeCard() {
+            return ((this == UIM_SIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_4G_UICC_CARD) || (this == NOT_CT_UICC_CARD));
+        }
+
+        /**
+         * Check if it is OP09 card.
+         * @return true if it is OP09 card
+         */
+        public boolean isOPO9Card() {
+            return ((this == CT_3G_UIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_4G_UICC_CARD));
+        }
+
+        private CardType(int value) {
+            mValue = value;
+        }
+    }
+    // MTK-END
 }
diff --git a/telephony/java/com/android/internal/telephony/PhoneConstants.java b/telephony/java/com/android/internal/telephony/PhoneConstants.java
index ca3c8a8..9bebe2b 100755
--- a/telephony/java/com/android/internal/telephony/PhoneConstants.java
+++ b/telephony/java/com/android/internal/telephony/PhoneConstants.java
@@ -203,4 +203,115 @@ public class PhoneConstants {
 
     /** Copied from ContactsCommon. See comments in ContactsCommon app for more detail. */
     public static final String EXTRA_CALL_ORIGIN = "com.android.phone.CALL_ORIGIN";
+
+    // MTK
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    // abnormal mode
+    public static final String LTE_ACCESS_STRATUM_STATE_UNKNOWN  = "unknown";
+    // power saving mode candidate
+    public static final String LTE_ACCESS_STRATUM_STATE_IDLE  = "idle";
+    // normal power mode
+    public static final String LTE_ACCESS_STRATUM_STATE_CONNECTED  = "connected";
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    public static final String LTE_ACCESS_STRATUM_STATE_KEY = "lteAccessStratumState";
+    public static final String SHARED_DEFAULT_APN_KEY = "sharedDefaultApn";
+    public static final String PS_NETWORK_TYPE_KEY = "psNetworkType";
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /** M: APN type for device management */
+    public static final String APN_TYPE_DM = "dm";
+    /** M: APN type for WAP */
+    public static final String APN_TYPE_WAP = "wap";
+    /** M: APN type for NET */
+    public static final String APN_TYPE_NET = "net";
+    /** M: APN type for CMMAIL */
+    public static final String APN_TYPE_CMMAIL = "cmmail";
+    /** M: APN type for dedicate tethering apn */
+    public static final String APN_TYPE_TETHERING = "tethering";
+    /** M: APN type for RCSE */
+    public static final String APN_TYPE_RCSE = "rcse";
+    /** M: APN type for XCAP */
+    public static final String APN_TYPE_XCAP = "xcap";
+    /** M: APN type for RCS */
+    public static final String APN_TYPE_RCS = "rcs";
+
+    /* M: SS part */
+    // CFU query type
+    public static final String CFU_QUERY_TYPE_PROP = "persist.radio.cfu.querytype";
+    public static final String CFU_QUERY_TYPE_DEF_VALUE = "0";
+    /* M: SS part end */
+
+    /**
+     * used to query current capability switch setting value.
+     * @internal
+     */
+    public static final String PROPERTY_CAPABILITY_SWITCH = "persist.radio.simswitch";
+
+    /// M: CC055: Notify Call state with phoneType @{
+    public static final String PHONE_TYPE_KEY = "phoneType";
+    /// @}
+
+    public static final int EVENT_SUBSCRIPTION_ACTIVATED   = 500;
+    public static final int EVENT_SUBSCRIPTION_DEACTIVATED = 501;
+
+    // Added by M begin
+    // MVNO-API START
+    public static final String MVNO_TYPE_NONE = "";
+    public static final String MVNO_TYPE_SPN = "spn";
+    public static final String MVNO_TYPE_IMSI = "imsi";
+    public static final String MVNO_TYPE_PNN = "pnn";
+    public static final String MVNO_TYPE_GID = "gid";
+    // MVNO-API END
+    // Added by M end
+
+    //[ALPS01577029]-START
+    // The TELEPHONY_MISC_FEATURE_CONFIG for tester to switch some features via engineering mode
+    //Bit 1: To support auto switch rat mode to 2G only for 3M TDD csfb project when we are not in china
+    public static final int MISC_FEATURE_CONFIG_MASK_AUTO_SWITCH_RAT = 0x01;
+    //[ALPS01577029]-END
+
+    //VOLTE IMS STATE
+    public static final int IMS_STATE_DISABLED = 0;
+
+    public static final int IMS_STATE_ENABLE = 1;
+
+    public static final int IMS_STATE_ENABLING = 2;
+
+    public static final int IMS_STATE_DISABLING = 3;
+
+    /**
+     * UT/XCAP Supplementary Service request domain selection constant definitions from IR.92 A.4
+     * IMS Voice Service settings management when using CS access.
+     * UT_CSFB_PS_PREFERRED is to indicate that sending SS request in the PS domain.
+     * @internal
+     */
+    public static final int UT_CSFB_PS_PREFERRED = 0;
+    /**
+     * UT_CSFB_ONCE is to indicate that sending SS request in the CS domain once, and restore to
+     * the PS domain next time.
+     * @internal
+     */
+    public static final int UT_CSFB_ONCE = 1;
+    /**
+     * UT_CSFB_UNTIL_NEXT_BOOT is to indicate that sending SS request in the CS domain until the
+     * UE performs a power-off/power-on or the UE detects a change of USIM/ISIM.
+     # @internal
+     */
+    public static final int UT_CSFB_UNTIL_NEXT_BOOT = 2;
+
+    public static final int STATE_DISCONNECTED = 0;
+    public static final int STATE_CONNECTED = 1;
+    public static final int RAT_MODE_GSM = 0;
+    public static final int RAT_MODE_C2K = 7;
+
+    /// M:Svlte solution2 modify, used in ACTION_RADIO_TECHNOLOGY_CHANGED @{
+    public static final String OLD_PHONE_KEY = "oldphone";
+
+    public static final String OLD_SUBSCRIPTION_KEY  = "oldsubscription";
+
+    public static final String OLD_SLOT_KEY  = "oldslot";
+    /// @}
 }
diff --git a/telephony/java/com/android/internal/telephony/RILConstants.java b/telephony/java/com/android/internal/telephony/RILConstants.java
index 216dd38..7264c79 100755
--- a/telephony/java/com/android/internal/telephony/RILConstants.java
+++ b/telephony/java/com/android/internal/telephony/RILConstants.java
@@ -77,7 +77,15 @@ public interface RILConstants {
     int SIM_SAP_MSG_SIZE_TOO_SMALL = 34;
     int SIM_SAP_CONNECT_OK_CALL_ONGOING = 35;
     int LCE_NOT_SUPPORTED = 36;               /* Link Capacity Estimation (LCE) not supported */
-    int INVALID_PARAMETER = 37;
+    // MTK
+    // int INVALID_PARAMETER = 37;
+    int EXTERNAL_APP_CAUSE_BEGIN = 2000;
+    int BT_SAP_UNDEFINED = 2001;    /*Used in Connect, Disconnect, Reset, Power on when reset fails with no reason. */
+    int BT_SAP_NOT_ACCESSIBLE = 2002;  /*Used in APDU when SIM card can't perform any commands anymore*/
+    int BT_SAP_CARD_REMOVED = 2003; /*Used in Connect, Reset, Power on when reset fails because SIM card doesn't exist*/
+    int INVALID_PARAMETER = 2004;
+    /// M: ALPS02147333 call control part
+    int CC_CALL_HOLD_FAILED_CAUSED_BY_TERMINATED = 6000;
 
     /* NETWORK_MODE_* See ril.h RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE */
     int NETWORK_MODE_WCDMA_PREF     = 0; /* GSM/WCDMA (WCDMA preferred) */
@@ -106,8 +114,20 @@ public interface RILConstants {
     int NETWORK_MODE_LTE_TDSCDMA_GSM_WCDMA   = 20; /* TD-SCDMA, GSM/WCDMA and LTE */
     int NETWORK_MODE_TDSCDMA_CDMA_EVDO_GSM_WCDMA  = 21; /*TD-SCDMA,EvDo,CDMA,GSM/WCDMA*/
     int NETWORK_MODE_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA = 22; /* TD-SCDMA/LTE/GSM/WCDMA, CDMA, and EvDo */
+    // MTK
+    int MTK_PREFERRED_NETWORK_MODE  = (SystemProperties.getInt("ro.mtk_lte_support", 0) == 1) ? NETWORK_MODE_LTE_GSM_WCDMA : NETWORK_MODE_WCDMA_PREF;
     int PREFERRED_NETWORK_MODE      = SystemProperties.getInt("ro.telephony.default_network",
-            NETWORK_MODE_WCDMA_PREF);
+            MTK_PREFERRED_NETWORK_MODE);
+
+    // MTK
+    int DIAL_STRING_TOO_LONG = 1001;
+    int TEXT_STRING_TOO_LONG = 1002;
+    int SIM_MEM_FULL = 1003;
+    int ADDITIONAL_NUMBER_STRING_TOO_LONG = 1010;
+    int ADN_LIST_NOT_EXIST = 1011;
+    int ADDITIONAL_NUMBER_SAVE_FAILURE = 1012;
+    int EMAIL_SIZE_LIMIT = 1005;
+    int EMAIL_NAME_TOOLONG = 1006;
 
     int CDMA_CELL_BROADCAST_SMS_DISABLED = 1;
     int CDMA_CELL_BROADCAST_SMS_ENABLED  = 0;
@@ -158,6 +178,17 @@ public interface RILConstants {
     int LCE_STOPPED = 0;
     int LCE_ACTIVE = 1;
 
+    // MTK
+    /* PHB Storage type, PHB_XDN*/
+    int PHB_ADN = 0;
+    int PHB_FDN = 1;
+    int PHB_MSISDN = 2;
+    int PHB_ECC = 3;
+
+    /* Max PHB entryies to be read at once,
+        Refer to RIL_MAX_PHB_ENTRY defined in the ril_sim.c */
+    int PHB_MAX_ENTRY = 10;
+
 /*
 cat include/telephony/ril.h | \
    egrep '^#define' | \
@@ -334,7 +365,8 @@ cat include/telephony/ril.h | \
     int RIL_REQUEST_STOP_LCE = 133;
     int RIL_REQUEST_PULL_LCEDATA = 134;
     int RIL_REQUEST_GET_ACTIVITY_INFO = 135;
-    int RIL_REQUEST_SIM_GET_ATR = 136;
+    // MTK please
+    // int RIL_REQUEST_SIM_GET_ATR = 136;
     int RIL_REQUEST_CAF_SIM_OPEN_CHANNEL_WITH_P2 = 137;
     int RIL_REQUEST_SET_MAX_TRANSMIT_POWER = 139;
 
@@ -387,4 +419,462 @@ cat include/telephony/ril.h | \
     int RIL_UNSOL_LCEDATA_RECV = 1045;
 
     int RIL_UNSOL_STK_SEND_SMS_RESULT = 11002; /* Samsung STK */
+
+    // MTK
+
+    /* Add MTK proprietary below */
+    int RIL_REQUEST_VENDOR_BASE = 2000;
+    int RIL_REQUEST_GET_COLP = (RIL_REQUEST_VENDOR_BASE + 0);
+    int RIL_REQUEST_SET_COLP = (RIL_REQUEST_VENDOR_BASE + 1);
+    int RIL_REQUEST_GET_COLR = (RIL_REQUEST_VENDOR_BASE + 2);
+    int RIL_REQUEST_GET_CCM = (RIL_REQUEST_VENDOR_BASE + 3);
+    int RIL_REQUEST_GET_ACM = (RIL_REQUEST_VENDOR_BASE + 4);
+    int RIL_REQUEST_GET_ACMMAX = (RIL_REQUEST_VENDOR_BASE + 5);
+    int RIL_REQUEST_GET_PPU_AND_CURRENCY = (RIL_REQUEST_VENDOR_BASE + 6);
+    int RIL_REQUEST_SET_ACMMAX = (RIL_REQUEST_VENDOR_BASE + 7);
+    int RIL_REQUEST_RESET_ACM = (RIL_REQUEST_VENDOR_BASE + 8);
+    int RIL_REQUEST_SET_PPU_AND_CURRENCY = (RIL_REQUEST_VENDOR_BASE + 9);
+    int RIL_REQUEST_MODEM_POWEROFF = (RIL_REQUEST_VENDOR_BASE + 10);
+    int RIL_REQUEST_DUAL_SIM_MODE_SWITCH = (RIL_REQUEST_VENDOR_BASE + 11);
+    int RIL_REQUEST_QUERY_PHB_STORAGE_INFO = (RIL_REQUEST_VENDOR_BASE + 12);
+    int RIL_REQUEST_WRITE_PHB_ENTRY = (RIL_REQUEST_VENDOR_BASE + 13);
+    int RIL_REQUEST_READ_PHB_ENTRY = (RIL_REQUEST_VENDOR_BASE + 14);
+    int RIL_REQUEST_SET_GPRS_CONNECT_TYPE = (RIL_REQUEST_VENDOR_BASE + 15);
+    int RIL_REQUEST_SET_GPRS_TRANSFER_TYPE = (RIL_REQUEST_VENDOR_BASE + 16);
+    int RIL_REQUEST_MOBILEREVISION_AND_IMEI = (RIL_REQUEST_VENDOR_BASE + 17); //Add by mtk80372 for Barcode Number
+    int RIL_REQUEST_QUERY_SIM_NETWORK_LOCK = (RIL_REQUEST_VENDOR_BASE + 18);
+    int RIL_REQUEST_SET_SIM_NETWORK_LOCK = (RIL_REQUEST_VENDOR_BASE + 19);
+    int RIL_REQUEST_SET_SCRI = (RIL_REQUEST_VENDOR_BASE + 20);
+    int RIL_REQUEST_BTSIM_CONNECT = (RIL_REQUEST_VENDOR_BASE + 21);
+    int RIL_REQUEST_BTSIM_DISCONNECT_OR_POWEROFF = (RIL_REQUEST_VENDOR_BASE + 22);
+    int RIL_REQUEST_BTSIM_POWERON_OR_RESETSIM = (RIL_REQUEST_VENDOR_BASE + 23);
+    int RIL_REQUEST_BTSIM_TRANSFERAPDU = (RIL_REQUEST_VENDOR_BASE + 24);
+    int RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL_WITH_ACT = (RIL_REQUEST_VENDOR_BASE + 25);
+    int RIL_REQUEST_QUERY_ICCID = (RIL_REQUEST_VENDOR_BASE + 26);
+    int RIL_REQUEST_USIM_AUTHENTICATION = (RIL_REQUEST_VENDOR_BASE + 27);
+    int RIL_REQUEST_MODEM_POWERON = (RIL_REQUEST_VENDOR_BASE + 28);
+    int RIL_REQUEST_GET_SMS_SIM_MEM_STATUS = (RIL_REQUEST_VENDOR_BASE + 29);
+    /* 3G switch start */
+    int RIL_REQUEST_GET_PHONE_CAPABILITY = (RIL_REQUEST_VENDOR_BASE + 30);
+    int RIL_REQUEST_SET_PHONE_CAPABILITY = (RIL_REQUEST_VENDOR_BASE + 31);
+    /* 3G switch end */
+    /* User controlled PLMN selector with Access Technology  begin */
+    int RIL_REQUEST_GET_POL_CAPABILITY = (RIL_REQUEST_VENDOR_BASE + 32);
+    int RIL_REQUEST_GET_POL_LIST = (RIL_REQUEST_VENDOR_BASE + 33);
+    int RIL_REQUEST_SET_POL_ENTRY = (RIL_REQUEST_VENDOR_BASE + 34);
+    /* User controlled PLMN selector with Access Technology  end */
+    /* UPB start */
+    int RIL_REQUEST_QUERY_UPB_CAPABILITY = (RIL_REQUEST_VENDOR_BASE + 35);
+    int RIL_REQUEST_EDIT_UPB_ENTRY = (RIL_REQUEST_VENDOR_BASE + 36);
+    int RIL_REQUEST_DELETE_UPB_ENTRY = (RIL_REQUEST_VENDOR_BASE + 37);
+    int RIL_REQUEST_READ_UPB_GAS_LIST = (RIL_REQUEST_VENDOR_BASE + 38);
+    int RIL_REQUEST_READ_UPB_GRP = (RIL_REQUEST_VENDOR_BASE + 39);
+    int RIL_REQUEST_WRITE_UPB_GRP = (RIL_REQUEST_VENDOR_BASE + 40);
+    /* UPB end */
+    int RIL_REQUEST_SET_SIM_RECOVERY_ON = (RIL_REQUEST_VENDOR_BASE + 41);
+    int RIL_REQUEST_GET_SIM_RECOVERY_ON = (RIL_REQUEST_VENDOR_BASE + 42);
+    int RIL_REQUEST_SET_TRM = (RIL_REQUEST_VENDOR_BASE + 43);
+    int RIL_REQUEST_DETECT_SIM_MISSING = (RIL_REQUEST_VENDOR_BASE + 44);
+    int RIL_REQUEST_GET_CALIBRATION_DATA = (RIL_REQUEST_VENDOR_BASE + 45);
+
+     //For LGE APIs start
+    int RIL_REQUEST_GET_PHB_STRING_LENGTH = (RIL_REQUEST_VENDOR_BASE + 46);
+    int RIL_REQUEST_GET_PHB_MEM_STORAGE = (RIL_REQUEST_VENDOR_BASE + 47);
+    int RIL_REQUEST_SET_PHB_MEM_STORAGE = (RIL_REQUEST_VENDOR_BASE + 48);
+    int RIL_REQUEST_READ_PHB_ENTRY_EXT = (RIL_REQUEST_VENDOR_BASE + 49);
+    int RIL_REQUEST_WRITE_PHB_ENTRY_EXT = (RIL_REQUEST_VENDOR_BASE + 50);
+
+    // requests for read/write EFsmsp
+    int RIL_REQUEST_GET_SMS_PARAMS = (RIL_REQUEST_VENDOR_BASE + 51);
+    int RIL_REQUEST_SET_SMS_PARAMS = (RIL_REQUEST_VENDOR_BASE + 52);
+
+    // NFC SEEK start
+    int RIL_REQUEST_SIM_TRANSMIT_BASIC = (RIL_REQUEST_VENDOR_BASE + 53);
+    int RIL_REQUEST_SIM_TRANSMIT_CHANNEL = (RIL_REQUEST_VENDOR_BASE + 54);
+    int RIL_REQUEST_SIM_GET_ATR = (RIL_REQUEST_VENDOR_BASE + 55);
+    // NFC SEEK end
+
+    // MTK-START, SMS part, CB extension
+    int RIL_REQUEST_SET_CB_CHANNEL_CONFIG_INFO = (RIL_REQUEST_VENDOR_BASE + 56);
+    int RIL_REQUEST_SET_CB_LANGUAGE_CONFIG_INFO = (RIL_REQUEST_VENDOR_BASE + 57);
+    int RIL_REQUEST_GET_CB_CONFIG_INFO = (RIL_REQUEST_VENDOR_BASE + 58);
+    int RIL_REQUEST_SET_ALL_CB_LANGUAGE_ON = (RIL_REQUEST_VENDOR_BASE + 59);
+    // MTK-END, SMS part, CB extension
+
+    int RIL_REQUEST_SET_ETWS = (RIL_REQUEST_VENDOR_BASE + 60);
+
+    // [New R8 modem FD]
+    int RIL_REQUEST_SET_FD_MODE = (RIL_REQUEST_VENDOR_BASE + 61);
+
+    // detach PS service request
+    int RIL_REQUEST_DETACH_PS = (RIL_REQUEST_VENDOR_BASE + 62);
+
+    int RIL_REQUEST_SIM_OPEN_CHANNEL_WITH_SW = (RIL_REQUEST_VENDOR_BASE + 63); // NFC SEEK
+
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+    int RIL_REQUEST_SET_REG_SUSPEND_ENABLED  = (RIL_REQUEST_VENDOR_BASE + 64);
+    int RIL_REQUEST_RESUME_REGISTRATION  = (RIL_REQUEST_VENDOR_BASE + 65);
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+    int RIL_REQUEST_STORE_MODEM_TYPE = (RIL_REQUEST_VENDOR_BASE + 66);
+    int RIL_REQUEST_QUERY_MODEM_TYPE = (RIL_REQUEST_VENDOR_BASE + 67);
+    int RIL_REQUEST_SIM_INTERFACE_SWITCH = (RIL_REQUEST_VENDOR_BASE + 68);
+
+    //MTK-START [mtk80776] WiFi Calling
+    int RIL_REQUEST_UICC_SELECT_APPLICATION = (RIL_REQUEST_VENDOR_BASE + 69);
+    int RIL_REQUEST_UICC_DEACTIVATE_APPLICATION = (RIL_REQUEST_VENDOR_BASE + 70);
+    int RIL_REQUEST_UICC_APPLICATION_IO = (RIL_REQUEST_VENDOR_BASE + 71);
+    int RIL_REQUEST_UICC_AKA_AUTHENTICATE = (RIL_REQUEST_VENDOR_BASE + 72);
+    int RIL_REQUEST_UICC_GBA_AUTHENTICATE_BOOTSTRAP = (RIL_REQUEST_VENDOR_BASE + 73);
+    int RIL_REQUEST_UICC_GBA_AUTHENTICATE_NAF = (RIL_REQUEST_VENDOR_BASE + 74);
+    //MTK-END [mtk80776] WiFi Calling
+    int RIL_REQUEST_STK_EVDL_CALL_BY_AP = (RIL_REQUEST_VENDOR_BASE + 75);
+
+    // Femtocell (CSG)
+    int RIL_REQUEST_GET_FEMTOCELL_LIST  = (RIL_REQUEST_VENDOR_BASE + 76);
+    int RIL_REQUEST_ABORT_FEMTOCELL_LIST = (RIL_REQUEST_VENDOR_BASE + 77);
+    int RIL_REQUEST_SELECT_FEMTOCELL = (RIL_REQUEST_VENDOR_BASE + 78);
+
+    // For OPLMN update
+    int RIL_REQUEST_SEND_OPLMN = (RIL_REQUEST_VENDOR_BASE + 79);
+    int RIL_REQUEST_GET_OPLMN_VERSION = (RIL_REQUEST_VENDOR_BASE + 80);
+
+    // For PLMN List abort
+    int RIL_REQUEST_ABORT_QUERY_AVAILABLE_NETWORKS = (RIL_REQUEST_VENDOR_BASE + 81);
+    // CSD
+    int RIL_REQUEST_DIAL_UP_CSD = (RIL_REQUEST_VENDOR_BASE + 82);
+
+    // M: For telephony modes update
+    int RIL_REQUEST_SET_TELEPHONY_MODE = (RIL_REQUEST_VENDOR_BASE + 83);
+
+    /// M: CC010: Add RIL interface @{
+    int RIL_REQUEST_HANGUP_ALL = (RIL_REQUEST_VENDOR_BASE + 84);
+    int RIL_REQUEST_FORCE_RELEASE_CALL = (RIL_REQUEST_VENDOR_BASE + 85);
+    int RIL_REQUEST_SET_CALL_INDICATION = (RIL_REQUEST_VENDOR_BASE + 86);
+    int RIL_REQUEST_EMERGENCY_DIAL = (RIL_REQUEST_VENDOR_BASE + 87);
+    int RIL_REQUEST_SET_ECC_SERVICE_CATEGORY = (RIL_REQUEST_VENDOR_BASE + 88);
+    int RIL_REQUEST_SET_ECC_LIST = (RIL_REQUEST_VENDOR_BASE + 89);
+    /// @}
+
+    //New SIM Authentication
+    int RIL_REQUEST_GENERAL_SIM_AUTH = (RIL_REQUEST_VENDOR_BASE + 90);
+    //ISIM
+    int RIL_REQUEST_OPEN_ICC_APPLICATION = (RIL_REQUEST_VENDOR_BASE + 91);
+    int RIL_REQUEST_GET_ICC_APPLICATION_STATUS = (RIL_REQUEST_VENDOR_BASE + 92);
+    //SIM_IO_EX
+    int RIL_REQUEST_SIM_IO_EX = (RIL_REQUEST_VENDOR_BASE + 93);
+
+    // IMS
+    int RIL_REQUEST_SET_IMS_ENABLE = (RIL_REQUEST_VENDOR_BASE + 94);
+    int RIL_REQUEST_QUERY_AVAILABLE_NETWORKS_WITH_ACT = (RIL_REQUEST_VENDOR_BASE + 95);
+
+    /* M: SS part */
+    ///M: For query CNAP
+    int RIL_REQUEST_SEND_CNAP = (RIL_REQUEST_VENDOR_BASE + 96);
+    int RIL_REQUEST_SET_CLIP = (RIL_REQUEST_VENDOR_BASE + 97);
+    /* M: SS part end */
+
+    // MTK-START, SMS part, CB extension
+    int RIL_REQUEST_REMOVE_CB_MESSAGE = (RIL_REQUEST_VENDOR_BASE + 104);
+    // MTK-END, SMS part, CB extension
+
+    // NAS configuration for voice call
+    // 0: voice centric
+    // 1: data centric
+    int RIL_REQUEST_SET_DATA_CENTRIC = (RIL_REQUEST_VENDOR_BASE + 105);
+
+    /// M: IMS feature. @{
+    int RIL_REQUEST_ADD_IMS_CONFERENCE_CALL_MEMBER = (RIL_REQUEST_VENDOR_BASE + 106);
+    int RIL_REQUEST_REMOVE_IMS_CONFERENCE_CALL_MEMBER = (RIL_REQUEST_VENDOR_BASE + 107);
+    int RIL_REQUEST_DIAL_WITH_SIP_URI = (RIL_REQUEST_VENDOR_BASE + 108);
+    int RIL_REQUEST_RESUME_CALL = (RIL_REQUEST_VENDOR_BASE + 109);
+    /// @}
+
+    /// M: CC010: Add RIL interface @{
+    int RIL_REQUEST_SET_SPEECH_CODEC_INFO = (RIL_REQUEST_VENDOR_BASE + 110);
+    /// @}
+    /// M: CC33 LTE
+    int RIL_REQUEST_SET_DATA_ON_TO_MD = (RIL_REQUEST_VENDOR_BASE + 111);
+    int RIL_REQUEST_SET_REMOVE_RESTRICT_EUTRAN_MODE = (RIL_REQUEST_VENDOR_BASE + 112);
+
+    /// M: CC010: Add RIL interface @{
+    int RIL_REQUEST_SET_IMS_CALL_STATUS = (RIL_REQUEST_VENDOR_BASE + 113);
+    /// @}
+
+    /// M: For 3G VT only @{
+    int RIL_REQUEST_VT_DIAL = (RIL_REQUEST_VENDOR_BASE + 114);
+    int RIL_REQUEST_VOICE_ACCEPT = (RIL_REQUEST_VENDOR_BASE + 115);
+    int RIL_REQUEST_REPLACE_VT_CALL = (RIL_REQUEST_VENDOR_BASE + 116);
+    /// @}
+
+    //C2K SVLTE remote SIM access
+    int RIL_REQUEST_CONFIG_MODEM_STATUS = (RIL_REQUEST_VENDOR_BASE + 117);
+
+    // M: [C2K] MD IRAT RIL requests.
+    int RIL_REQUEST_SET_ACTIVE_PS_SLOT = RIL_REQUEST_VENDOR_BASE + 118;
+    int RIL_REQUEST_CONFIRM_INTER_3GPP_IRAT_CHANGE = RIL_REQUEST_VENDOR_BASE + 119;
+
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @{
+    int RIL_REQUEST_SET_SVLTE_RAT_MODE = (RIL_REQUEST_VENDOR_BASE + 120);
+    /// M: [C2K][SVLTE] Set the SVLTE RAT mode. @}
+
+    // M: [C2K] AP IRAT RIL requests.
+    int RIL_REQUEST_TRIGGER_LTE_BG_SEARCH = (RIL_REQUEST_VENDOR_BASE + 121);
+
+    /// M: IMS VoLTe conference dial feature. @{
+    int RIL_REQUEST_CONFERENCE_DIAL = (RIL_REQUEST_VENDOR_BASE + 122);
+    /// @}
+
+    /// M: CC072: Add Customer proprietary-IMS RIL interface. @{
+    /* To transfer IMS call context to modem */
+    int RIL_REQUEST_SET_SRVCC_CALL_CONTEXT_TRANSFER = (RIL_REQUEST_VENDOR_BASE + 123);
+    /* To update IMS registration status to modem */
+    int RIL_REQUEST_UPDATE_IMS_REGISTRATION_STATUS = (RIL_REQUEST_VENDOR_BASE + 124);
+    /// @}
+
+    int RIL_REQUEST_RELOAD_MODEM_TYPE = (RIL_REQUEST_VENDOR_BASE + 125);
+
+    /// M: IMS feature. @{
+    int RIL_REQUEST_HOLD_CALL = (RIL_REQUEST_VENDOR_BASE + 126);
+    /// @}
+
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @{
+    int RIL_REQUEST_SET_STK_UTK_MODE = (RIL_REQUEST_VENDOR_BASE + 127);
+    /// M: [C2K][SVLTE] Set the STK UTK mode. @}
+
+    int RIL_REQUEST_SWITCH_ANTENNA = (RIL_REQUEST_VENDOR_BASE + 128);
+
+    // M:[C2K] deactivate link down PDN. @{
+    int RIL_REQUEST_DEACTIVATE_LINK_DOWN_PDN = (RIL_REQUEST_VENDOR_BASE + 129);
+    ///@}
+    int RIL_REQUEST_AT_COMMAND_WITH_PROXY = (RIL_REQUEST_VENDOR_BASE + 130);
+    int RIL_REQUEST_SWITCH_CARD_TYPE = (RIL_REQUEST_VENDOR_BASE + 131);
+
+    int RIL_REQUEST_ENABLE_MD3_SLEEP = (RIL_REQUEST_VENDOR_BASE + 132);
+
+    /// M: IMS ViLTe feature. @{
+    int RIL_REQUEST_VIDEO_CALL_ACCEPT = (RIL_REQUEST_VENDOR_BASE + 133);
+    /// @}
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    int RIL_REQUEST_SET_LTE_ACCESS_STRATUM_REPORT = (RIL_REQUEST_VENDOR_BASE + 134);
+    int RIL_REQUEST_SET_LTE_UPLINK_DATA_TRANSFER = (RIL_REQUEST_VENDOR_BASE + 135);
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /// M: [EPDG] WiFi disconnect indication @{
+    int RIL_REQUEST_WIFI_DISCONNECT_IND = (RIL_REQUEST_VENDOR_BASE + 137);
+    /// @}
+
+    /// M: EPDG feature. Update PS state from MAL @{
+    int RIL_REQUEST_MAL_PS_RGEGISTRATION_STATE = (RIL_REQUEST_VENDOR_BASE + 138);
+    /// @}
+
+    int RIL_REQUEST_EVDO_SUPPORT_BASE = 2100;
+    int RIL_REQUEST_RADIO_POWER_CARD_SWITCH = (RIL_REQUEST_EVDO_SUPPORT_BASE + 0);
+
+    int RIL_UNSOL_VENDOR_BASE = 3000;
+    int RIL_UNSOL_NEIGHBORING_CELL_INFO = (RIL_UNSOL_VENDOR_BASE + 0);
+    int RIL_UNSOL_NETWORK_INFO = (RIL_UNSOL_VENDOR_BASE + 1);
+    int RIL_UNSOL_PHB_READY_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 2);
+    int RIL_UNSOL_SIM_INSERTED_STATUS = (RIL_UNSOL_VENDOR_BASE + 3);
+    int RIL_UNSOL_RADIO_TEMPORARILY_UNAVAILABLE = (RIL_UNSOL_VENDOR_BASE + 4);
+    int RIL_UNSOL_ME_SMS_STORAGE_FULL = (RIL_UNSOL_VENDOR_BASE + 5);
+    int RIL_UNSOL_SMS_READY_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 6);
+    int RIL_UNSOL_SCRI_RESULT = (RIL_UNSOL_VENDOR_BASE + 7);
+    int RIL_UNSOL_SIM_MISSING = (RIL_UNSOL_VENDOR_BASE + 8);
+    int RIL_UNSOL_GPRS_DETACH = (RIL_UNSOL_VENDOR_BASE + 9);
+    //MTK-START [mtk04070][120208][ALPS00233196] ATCI for unsolicited response
+    int RIL_UNSOL_ATCI_RESPONSE = (RIL_UNSOL_VENDOR_BASE + 10);
+    //MTK-END [mtk04070][120208][ALPS00233196] ATCI for unsolicited response
+    int RIL_UNSOL_SIM_RECOVERY = (RIL_UNSOL_VENDOR_BASE + 11);
+    int RIL_UNSOL_VIRTUAL_SIM_ON = (RIL_UNSOL_VENDOR_BASE + 12);
+    int RIL_UNSOL_VIRTUAL_SIM_OFF = (RIL_UNSOL_VENDOR_BASE + 13);
+    int RIL_UNSOL_INVALID_SIM = (RIL_UNSOL_VENDOR_BASE + 14);
+    int RIL_UNSOL_RESPONSE_PS_NETWORK_STATE_CHANGED = (RIL_UNSOL_VENDOR_BASE + 15);
+    int RIL_UNSOL_RESPONSE_ACMT = (RIL_UNSOL_VENDOR_BASE + 16);
+    int RIL_UNSOL_EF_CSP_PLMN_MODE_BIT = (RIL_UNSOL_VENDOR_BASE + 17);
+    int RIL_UNSOL_IMEI_LOCK = (RIL_UNSOL_VENDOR_BASE + 18);
+    int RIL_UNSOL_RESPONSE_MMRR_STATUS_CHANGED = (RIL_UNSOL_VENDOR_BASE + 19);
+    int RIL_UNSOL_SIM_PLUG_OUT = (RIL_UNSOL_VENDOR_BASE + 20);
+    int RIL_UNSOL_SIM_PLUG_IN = (RIL_UNSOL_VENDOR_BASE + 21);
+    int RIL_UNSOL_RESPONSE_ETWS_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 22);
+    int RIL_UNSOL_RESPONSE_PLMN_CHANGED = (RIL_UNSOL_VENDOR_BASE + 23);
+    int RIL_UNSOL_RESPONSE_REGISTRATION_SUSPENDED = (RIL_UNSOL_VENDOR_BASE + 24);
+    int RIL_UNSOL_STK_EVDL_CALL = (RIL_UNSOL_VENDOR_BASE + 25);
+    int RIL_UNSOL_DATA_PACKETS_FLUSH = (RIL_UNSOL_VENDOR_BASE + 26);
+    int RIL_UNSOL_FEMTOCELL_INFO = (RIL_UNSOL_VENDOR_BASE + 27);
+    int RIL_UNSOL_STK_SETUP_MENU_RESET = (RIL_UNSOL_VENDOR_BASE + 28);
+    int RIL_UNSOL_APPLICATION_SESSION_ID_CHANGED = (RIL_UNSOL_VENDOR_BASE + 29);
+    /// M: For updating call ids for conference call after SRVCC is done.
+    int RIL_UNSOL_ECONF_SRVCC_INDICATION = (RIL_UNSOL_VENDOR_BASE + 30);
+    // IMS
+    int RIL_UNSOL_IMS_ENABLE_DONE = (RIL_UNSOL_VENDOR_BASE + 31);
+    int RIL_UNSOL_IMS_DISABLE_DONE = (RIL_UNSOL_VENDOR_BASE + 32);
+    int RIL_UNSOL_IMS_REGISTRATION_INFO = (RIL_UNSOL_VENDOR_BASE + 33);
+
+    //sm cause rac
+    int RIL_UNSOL_RAC_UPDATE = (RIL_UNSOL_VENDOR_BASE + 37);
+
+    //[VoLTE]Conf. call merged/added result
+    int RIL_UNSOL_ECONF_RESULT_INDICATION = (RIL_UNSOL_VENDOR_BASE + 38);
+
+    //Remote SIM ME lock related APIs [Start]
+    int RIL_UNSOL_MELOCK_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 39);
+    //Remote SIM ME lock related APIs [END]
+
+    /// M: CC010: Add RIL interface @{
+    int RIL_UNSOL_CALL_FORWARDING = (RIL_UNSOL_VENDOR_BASE + 40);
+    int RIL_UNSOL_CRSS_NOTIFICATION = (RIL_UNSOL_VENDOR_BASE + 41);
+    int RIL_UNSOL_INCOMING_CALL_INDICATION = (RIL_UNSOL_VENDOR_BASE + 42);
+    int RIL_UNSOL_CIPHER_INDICATION = (RIL_UNSOL_VENDOR_BASE + 43);
+    int RIL_UNSOL_CNAP = (RIL_UNSOL_VENDOR_BASE + 44); //obsolete
+    /// @}
+    int RIL_UNSOL_SIM_COMMON_SLOT_NO_CHANGED = (RIL_UNSOL_VENDOR_BASE + 45);
+    //Combine attach
+    int RIL_UNSOL_DATA_ALLOWED = (RIL_UNSOL_VENDOR_BASE + 46);
+    int RIL_UNSOL_STK_CALL_CTRL = (RIL_UNSOL_VENDOR_BASE + 47);
+    int RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_SUPPORT = (RIL_UNSOL_VENDOR_BASE + 48);
+
+    /// M: IMS feature. @{
+    int RIL_UNSOL_CALL_INFO_INDICATION = (RIL_UNSOL_VENDOR_BASE + 49);
+    /// @}
+
+    int RIL_UNSOL_VOLTE_EPS_NETWORK_FEATURE_INFO = (RIL_UNSOL_VENDOR_BASE + 50);
+    int RIL_UNSOL_SRVCC_HANDOVER_INFO_INDICATION = (RIL_UNSOL_VENDOR_BASE + 51);
+    /// M: CC010: Add RIL interface @{
+    int RIL_UNSOL_SPEECH_CODEC_INFO = (RIL_UNSOL_VENDOR_BASE + 52);
+    /// @}
+
+    //MTK-START for MD state change
+    int RIL_UNSOL_MD_STATE_CHANGE = (RIL_UNSOL_VENDOR_BASE + 53);
+    //MTK-END for MD state change
+    // M: CC33 URC
+    int RIL_UNSOL_REMOVE_RESTRICT_EUTRAN = (RIL_UNSOL_VENDOR_BASE + 54);
+
+    // IMS client on AP shall get the information of MO Data Barring and SSAC barring
+    int RIL_UNSOL_MO_DATA_BARRING_INFO = (RIL_UNSOL_VENDOR_BASE + 55);
+    int RIL_UNSOL_SSAC_BARRING_INFO = (RIL_UNSOL_VENDOR_BASE + 56);
+    int RIL_UNSOL_SIP_CALL_PROGRESS_INDICATOR = (RIL_UNSOL_VENDOR_BASE + 57);
+
+    int RIL_UNSOL_ABNORMAL_EVENT = (RIL_UNSOL_VENDOR_BASE + 58);
+
+    /// M: CC071: Add Customer proprietary-IMS RIL interface . @{
+    int RIL_UNSOL_EMERGENCY_BEARER_SUPPORT_NOTIFY = (RIL_UNSOL_VENDOR_BASE + 59);
+    /// @}
+
+    /// M: [C2K] MD IRAT RIL URCs.
+    int RIL_UNSOL_INTER_3GPP_IRAT_STATE_CHANGE = RIL_UNSOL_VENDOR_BASE + 60;
+
+    // M: [C2K] AP IRAT RIL URCs.
+    int RIL_UNSOL_LTE_BG_SEARCH_STATUS = (RIL_UNSOL_VENDOR_BASE + 61);
+
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @{
+    int RIL_UNSOL_GMSS_RAT_CHANGED = (RIL_UNSOL_VENDOR_BASE + 62);
+    /// M: [C2K][IR][MD-IRAT] URC for GMSS RAT changed. @}
+
+    int RIL_UNSOL_CDMA_CARD_TYPE = (RIL_UNSOL_VENDOR_BASE + 63);
+
+    // IMS
+    int RIL_UNSOL_IMS_ENABLE_START = (RIL_UNSOL_VENDOR_BASE + 64);
+    int RIL_UNSOL_IMS_DISABLE_START = (RIL_UNSOL_VENDOR_BASE + 65);
+    int RIL_UNSOL_IMSI_REFRESH_DONE = (RIL_UNSOL_VENDOR_BASE + 66);
+    // M: Notify RILJ that the AT+EUSIM was received
+    int RIL_UNSOL_EUSIM_READY = (RIL_UNSOL_VENDOR_BASE + 67);
+    /// M: BIP {
+    int RIL_UNSOL_STK_BIP_PROACTIVE_COMMAND = (RIL_UNSOL_VENDOR_BASE + 68);
+    /// M: BIP }
+    //WorldMode
+    int RIL_UNSOL_WORLD_MODE_CHANGED = (RIL_UNSOL_VENDOR_BASE + 69);
+
+    /// M: For 3G VT only @{
+    int RIL_UNSOL_VT_STATUS_INFO = (RIL_UNSOL_VENDOR_BASE + 70);
+    int RIL_UNSOL_VT_RING_INFO = (RIL_UNSOL_VENDOR_BASE + 71);
+    /// @}
+
+    //External SIM [Start]
+    int RIL_UNSOL_VSIM_OPERATION_INDICATION = (RIL_UNSOL_VENDOR_BASE + 72);
+    //External SIM [End]
+
+    //Reset Attach APN
+    int RIL_UNSOL_SET_ATTACH_APN = (RIL_UNSOL_VENDOR_BASE + 73);
+
+    /// M: MAL @{
+    int RIL_UNSOL_MAL_AT_INFO = (RIL_UNSOL_VENDOR_BASE + 74);
+    //info the current 3G SIM
+    int RIL_UNSOL_MAIN_SIM_INFO = (RIL_UNSOL_VENDOR_BASE + 75);
+    /// @}
+    // M: The event for pluggin in the tray in common slot project
+    int RIL_UNSOL_TRAY_PLUG_IN = (RIL_UNSOL_VENDOR_BASE + 76);
+
+    // M: volte for call mode change notification
+    int RIL_UNSOL_CALLMOD_CHANGE_INDICATOR = (RIL_UNSOL_VENDOR_BASE + 77);
+
+    // M: vilte for video capability notification
+    int RIL_UNSOL_VIDEO_CAPABILITY_INDICATOR = (RIL_UNSOL_VENDOR_BASE + 78);
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    int RIL_UNSOL_LTE_ACCESS_STRATUM_STATE_CHANGE = (RIL_UNSOL_VENDOR_BASE + 79);
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /* M: Add C2K proprietary start */
+    int RIL_REQUEST_C2K_BASE = 4000;
+    int RIL_REQUEST_GET_NITZ_TIME = (RIL_REQUEST_C2K_BASE + 0);
+    int RIL_REQUEST_QUERY_UIM_INSERTED = (RIL_REQUEST_C2K_BASE + 1);
+    int RIL_REQUEST_SWITCH_HPF = (RIL_REQUEST_C2K_BASE + 2);
+    int RIL_REQUEST_SET_AVOID_SYS = (RIL_REQUEST_C2K_BASE + 3);
+    int RIL_REQUEST_QUERY_AVOID_SYS = (RIL_REQUEST_C2K_BASE + 4);
+    int RIL_REQUEST_QUERY_CDMA_NETWORK_INFO = (RIL_REQUEST_C2K_BASE + 5);
+    int RIL_REQUEST_GET_LOCAL_INFO =  (RIL_REQUEST_C2K_BASE + 6);
+    int RIL_REQUEST_UTK_REFRESH = (RIL_REQUEST_C2K_BASE + 7);
+    int RIL_REQUEST_QUERY_SMS_AND_PHONEBOOK_STATUS = (RIL_REQUEST_C2K_BASE + 8);
+    int RIL_REQUEST_QUERY_NETWORK_REGISTRATION = (RIL_REQUEST_C2K_BASE + 9);
+    int RIL_REQUEST_AGPS_TCP_CONNIND = (RIL_REQUEST_C2K_BASE + 10);
+    int RIL_REQUEST_AGPS_SET_MPC_IPPORT = (RIL_REQUEST_C2K_BASE + 11);
+    int RIL_REQUEST_AGPS_GET_MPC_IPPORT = (RIL_REQUEST_C2K_BASE + 12);
+    int RIL_REQUEST_SET_MEID = (RIL_REQUEST_C2K_BASE + 13);
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+    int RIL_REQUEST_RESUME_REGISTRATION_CDMA = (RIL_REQUEST_C2K_BASE + 14);
+    int RIL_REQUEST_SET_REG_SUSPEND_ENABLED_CDMA = (RIL_REQUEST_C2K_BASE + 15);
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+    int RIL_REQUEST_SET_ETS_DEV = (RIL_REQUEST_C2K_BASE + 16);
+    int RIL_REQUEST_WRITE_MDN = (RIL_REQUEST_C2K_BASE + 17);
+    int RIL_REQUEST_SET_VIA_TRM = (RIL_REQUEST_C2K_BASE + 18);
+    int RIL_REQUEST_SET_ARSI_THRESHOLD = (RIL_REQUEST_C2K_BASE + 19);
+
+    // [C2K] [AP IRAT] RIL request.
+    int RIL_REQUEST_SET_LTE_EARFCN_ENABLED = (RIL_REQUEST_C2K_BASE + 20);
+    // [C2K] [SVLTE] C2K SVLTE CDMA RAT control.
+    int RIL_REQUEST_CONFIG_IRAT_MODE = (RIL_REQUEST_C2K_BASE + 21);
+
+   // [C2K][SVLTE] C2K SVLTE CDMA eHPRD control
+    int RIL_REQUEST_CONFIG_EVDO_MODE = (RIL_REQUEST_C2K_BASE + 22);
+    /* M: SVLTE UTK part start */
+    int RIL_REQUEST_QUERY_UTK_MENU_FROM_MD = (RIL_REQUEST_C2K_BASE + 23);
+    int RIL_REQUEST_QUERY_STK_MENU_FROM_MD = (RIL_REQUEST_C2K_BASE + 24);
+    /* M: SVLTE UTK part end */
+
+    int RIL_UNSOL_C2K_BASE = 5000;
+    int RIL_UNSOL_CDMA_CALL_ACCEPTED = (RIL_UNSOL_C2K_BASE + 0);
+    int RIL_UNSOL_UTK_SESSION_END = (RIL_UNSOL_C2K_BASE + 1);
+    int RIL_UNSOL_UTK_PROACTIVE_COMMAND = (RIL_UNSOL_C2K_BASE + 2);
+    int RIL_UNSOL_UTK_EVENT_NOTIFY = (RIL_UNSOL_C2K_BASE + 3);
+    int RIL_UNSOL_VIA_GPS_EVENT = (RIL_UNSOL_C2K_BASE + 4);
+    int RIL_UNSOL_VIA_NETWORK_TYPE_CHANGE = (RIL_UNSOL_C2K_BASE + 5);
+    /// M: [C2K][IR] Support SVLTE IR feature. @{
+    int RIL_UNSOL_CDMA_PLMN_CHANGED = (RIL_UNSOL_C2K_BASE + 6);
+    /// M: [C2K][IR] Support SVLTE IR feature. @}
+    int RIL_UNSOL_VIA_INVALID_SIM_DETECTED = (RIL_UNSOL_C2K_BASE + 7);
+    /// M: For c2k eng mode
+    int RIL_UNSOL_ENG_MODE_NETWORK_INFO = (RIL_UNSOL_C2K_BASE + 8);
+    // M: [C2K] for ps type changed.
+    int RIL_UNSOL_RESPONSE_DATA_NETWORK_TYPE_CHANGED = (RIL_UNSOL_C2K_BASE + 9);
+    // [C2K] [AP IRAT] URCs
+    int RIL_UNSOL_LTE_EARFCN_INFO = (RIL_UNSOL_C2K_BASE + 10);
+    int RIL_UNSOL_CDMA_IMSI_READY = (RIL_UNSOL_C2K_BASE + 11);
+    // M: Notify RILJ that call fade happened
+    int RIL_UNSOL_CDMA_SIGNAL_FADE = (RIL_UNSOL_C2K_BASE + 12);
+    // M: Notify RILJ that the AT+EFNM was received
+    int RIL_UNSOL_CDMA_TONE_SIGNALS = (RIL_UNSOL_C2K_BASE + 13);
+    // M: add for ECC only
+    int RIL_UNSOL_NETWORK_EXIST = (RIL_UNSOL_C2K_BASE + 14);
+    /* M: Add C2K proprietary end */
 }
diff --git a/telephony/java/com/android/internal/telephony/TelephonyIntents.java b/telephony/java/com/android/internal/telephony/TelephonyIntents.java
index 77b8a67..d608f33 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyIntents.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyIntents.java
@@ -417,4 +417,370 @@ public class TelephonyIntents {
      */
     public static final String ACTION_SET_RADIO_CAPABILITY_FAILED =
             "android.intent.action.ACTION_SET_RADIO_CAPABILITY_FAILED";
+
+    // MTK
+
+// M: [LTE][Low Power][UL traffic shaping] Start
+    /**
+     * Broadcast Action: The LTE access stratum state has changed.
+     * The intent will have the following extra values:</p>
+     * <dl>
+     *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+     *   <dt>state</dt><dd>One of {@code UNKNOWN}, {@code IDLE},
+     *      or {@code CONNECTED}.</dd>
+     * </dl>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    public static final String ACTION_LTE_ACCESS_STRATUM_STATE_CHANGED
+            = "android.intent.action.LTE_ACCESS_STRATUM_STATE_CHANGED";
+
+    /**
+     * Broadcast Action: The PS network type has changed for low power feature on.
+     * The intent will have the following extra values:</p>
+     * <dl>
+     *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+     *   <dt>nwType</dt><dd>One of
+     *          {@code NETWORK_TYPE_UNKNOWN},
+     *          {@code NETWORK_TYPE_GPRS},
+     *          {@code NETWORK_TYPE_EDGE},
+     *          {@code NETWORK_TYPE_UMTS},
+     *          {@code NETWORK_TYPE_HSDPA},
+     *          {@code NETWORK_TYPE_HSUPA},
+     *          {@code NETWORK_TYPE_HSPA} or
+     *          {@code NETWORK_TYPE_LTE}.</dd>
+     * </dl>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    public static final String ACTION_PS_NETWORK_TYPE_CHANGED
+            = "android.intent.action.PS_NETWORK_TYPE_CHANGED";
+
+    /**
+     * Broadcast Action: The shared default apn state has changed.
+     * The intent will have the following extra values:</p>
+     * <dl>
+     *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+     *   <dt>state</dt><dd>One of {@code TRUE} or {@code FALSE}.</dd>
+     * </dl>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     */
+    public static final String ACTION_SHARED_DEFAULT_APN_STATE_CHANGED
+            = "android.intent.action.SHARED_DEFAULT_APN_STATE_CHANGED";
+// M: [LTE][Low Power][UL traffic shaping] End
+
+    /**
+     * Broadcast Action: An attempt to set phone RAT family has changed.  This has the following
+     * extra values:</p>
+     * <ul>
+     *   <li><em>phones RAT family</em> - A PhoneRatFamily array,
+     *          contain phone ID and new RAT family for each phone.</li>
+     * </ul>
+     * @internal
+     */
+    public static final String ACTION_SET_PHONE_RAT_FAMILY_DONE =
+            "android.intent.action.ACTION_SET_PHONE_RAT_FAMILY_DONE";
+    /**
+     * @internal
+     */
+    public static final String EXTRA_PHONES_RAT_FAMILY = "phonesRatFamily";
+
+    /**
+     * Broadcast Action: An attempt to set phone RAT family has failed.
+     * <ul>
+     *   <li><em>phone ID</em> - A int, indicates the failed phone.</li>
+     * </ul>
+     * @internal
+     */
+    public static final String ACTION_SET_PHONE_RAT_FAMILY_FAILED =
+            "android.intent.action.ACTION_SET_PHONE_RAT_FAMILY_FAILED";
+    /**
+     * @internal
+     */
+    public static final String EXTRA_PHONES_ID = "phoneId";
+
+    // Added by M begin
+
+    /**
+     * <p>Broadcast Action: To activate an application to unlock SIM lock.
+     * The intent will have the following extra value:</p>
+     * <dl>
+     *   <dt>reason</dt><dd>The reason why ss is {@code LOCKED}; null otherwise.</dd>
+     *   <dl>
+     *       <dt>{@code PIN}</dt><dd>locked on PIN1</dd>
+     *       <dt>{@code PUK}</dt><dd>locked on PUK1</dd>
+     *       <dt>{@code NETWORK}</dt><dd>locked on network personalization</dd>
+     *       <dt>{@code NETWORK_SUBSET}</dt><dd>locked on network subset personalization</dd>
+     *       <dt>{@code CORPORATE}</dt><dd>locked on corporate personalization</dd>
+     *       <dt>{@code SERVICE_PROVIDER}</dt><dd>locked on service proiver personalization</dd>
+     *       <dt>{@code SIM}</dt><dd>locked on SIM personalization</dd>
+     *   </dl>
+     * </dl>
+     * @internal
+     */
+     // FIXME: need to add subId, slotId, phoneId extra value comments.
+     public static final String ACTION_UNLOCK_SIM_LOCK
+            = "mediatek.intent.action.ACTION_UNLOCK_SIM_LOCK";
+
+
+     /**
+      * Broadcast Action: The sim card application state has changed. (only support ISIM currently)
+      * The intent will have the following extra values:</p>
+      * <dl>
+      *   <dt>phoneName</dt><dd>A string version of the phone name.</dd>
+      *   <dt>ss</dt><dd>The sim state. One of:
+      *     <dl>
+      *       <dt>{@code ABSENT}</dt><dd>SIM card not found</dd>
+      *       <dt>{@code LOCKED}</dt><dd>SIM card locked (see {@code reason})</dd>
+      *       <dt>{@code READY}</dt><dd>SIM card ready</dd>
+      *       <dt>{@code IMSI}</dt><dd>FIXME: what is this state?</dd>
+      *       <dt>{@code LOADED}</dt><dd>SIM card data loaded</dd>
+      *     </dl></dd>
+      *   <dt>reason</dt><dd>The reason why ss is {@code LOCKED}; null otherwise.</dd>
+      *   <dl>
+      *       <dt>{@code PIN}</dt><dd>locked on PIN1</dd>
+      *       <dt>{@code PUK}</dt><dd>locked on PUK1</dd>
+      *       <dt>{@code NETWORK}</dt><dd>locked on network personalization</dd>
+      *   </dl>
+      *   <dt>appid</dt><dd>The application id.</dd>
+      * </dl>
+      *
+      * <p class="note">This is a protected intent that can only be sent
+      * by the system.
+      */
+      // FIXME: need to add subId, slotId, phoneId extra value comments.
+     public static final String ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION
+             = "mediatek.intent.action.ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION";
+
+    /**
+    * Do SIM Recovery Done.
+    */
+    public static final String ACTION_SIM_RECOVERY_DONE = "com.android.phone.ACTION_SIM_RECOVERY_DONE";
+
+    // ALPS00302698 ENS
+    /**
+       * This event is broadcasted when CSP PLMN is changed
+       * @internal
+       */
+    public static final String ACTION_EF_CSP_CONTENT_NOTIFY = "android.intent.action.ACTION_EF_CSP_CONTENT_NOTIFY";
+    public static final String EXTRA_PLMN_MODE_BIT = "plmn_mode_bit";
+
+    // ALPS00302702 RAT balancing
+    /**
+       * This event is broadcasted when EF-RAT Mode is changed.
+       * @internal
+       */
+    public static final String ACTION_EF_RAT_CONTENT_NOTIFY = "android.intent.action.ACTION_EF_RAT_CONTENT_NOTIFY";
+    /**
+       * To notify the content of EF-RAT
+       * @internal
+       */
+    public static final String EXTRA_EF_RAT_CONTENT = "ef_rat_content";
+    /**
+       * To notify the status of EF-RAT
+       * @internal
+       */
+    public static final String EXTRA_EF_RAT_STATUS = "ef_rat_status";
+
+    public static final String ACTION_COMMON_SLOT_NO_CHANGED = "com.mediatek.phone.ACTION_COMMON_SLOT_NO_CHANGED";
+
+
+  /**
+      * Broadcast Action: ACMT Network Service Status Indicator
+      * The intent will have the following extra values:</p>
+      * <ul>
+      * <li><em>CauseCode</em> - specify the reject cause code from MM/GMM/EMM</li>
+      * <li><em>Cause</em> - the reject cause<li>
+      * </ul>
+      */
+    public static final String ACTION_ACMT_NETWORK_SERVICE_STATUS_INDICATOR
+            = "mediatek.intent.action.acmt_nw_service_status";
+
+    //MTK-START [mtk80589][121026][ALPS00376525] STK dialog pop up caused ISVR
+    public static final String ACTION_IVSR_NOTIFY
+        = "mediatek.intent.action.IVSR_NOTIFY";
+
+    public static final String INTENT_KEY_IVSR_ACTION = "action";
+    //MTK-END [mtk80589][121026][ALPS00376525] STK dialog pop up caused ISVR
+
+   /* ALPS01139189 */
+   /**
+     * This event is broadcasted when frmework start/stop hiding network state update
+     * @internal
+     */
+    public static final String ACTION_HIDE_NETWORK_STATE = "mediatek.intent.action.ACTION_HIDE_NETWORK_STATE";
+    public static final String EXTRA_ACTION = "action";
+    public static final String EXTRA_REAL_SERVICE_STATE = "state";
+
+    /**
+     * This event is broadcasted when the located PLMN is changed
+     * @internal
+     */
+    public static final String ACTION_LOCATED_PLMN_CHANGED = "mediatek.intent.action.LOCATED_PLMN_CHANGED";
+    public static final String EXTRA_ISO = "iso";
+
+  /**
+     * This extra value is the IMS registeration state
+     */
+    public static final String EXTRA_IMS_REG_STATE_KEY = "regState"; // 0: not registered  , 1: registered
+
+    // Femtocell (CSG) START
+    public static final String EXTRA_HNB_NAME   = "hnbName";
+    public static final String EXTRA_CSG_ID     = "csgId";
+    public static final String EXTRA_DOMAIN     = "domain";
+    // Femtocell (CSG) END
+
+    /**
+     * Broadcast Action: The PHB state has changed.
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>ready</em> - The PHB ready state.  True for ready, false for not ready</li>
+     *   <li><em>simId</em> - The SIM ID</li>
+     * </ul>
+     *
+     * <p class="note">
+     * Requires the READ_PHONE_STATE permission.
+     *
+     * <p class="note">This is a protected intent that can only be sent
+     * by the system.
+     * @internal
+     */
+    public static final String ACTION_PHB_STATE_CHANGED
+            = "android.intent.action.PHB_STATE_CHANGED";
+
+    /* SIM switch start */
+    /**
+     * To notify the capability switch procedure start
+     */
+    public static String EVENT_PRE_CAPABILITY_SWITCH = "com.mediatek.PRE_CAPABILITY_SWITCH";
+    /**
+     * To notify the capability switch procedure end
+     */
+    public static String EVENT_CAPABILITY_SWITCH_DONE = "com.mediatek.CAPABILITY_SWITCH_DONE";
+    /**
+     * The target SIM Id where capability is going to set to.
+     * This is an extra information comes with EVENT_CAPABILITY_PRE_SWITCH event.
+     */
+    public static String EXTRA_MAIN_PROTOCOL_SIM = "MAIN_PROTOCOL_SIM";
+    // Added by M end
+
+    /**
+     * Broadcast Action: The modem type changed.
+     * @internal
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>ready</em> - The modem type after switched.</li>
+     * </ul>
+     */
+    public static final String ACTION_MD_TYPE_CHANGE
+            = "android.intent.action.ACTION_MD_TYPE_CHANGE";
+    /** @internal */
+    public static final String EXTRA_MD_TYPE = "mdType";
+
+    /**
+    * This event is broadcasted when Stk Refresh with type REFRESH_RESULT_INIT,
+    * REFRESH_RESULT_RESET, REFRESH_INIT_FULL_FILE_UPDATED, REFRESH_INIT_FILE_UPDATED
+    * @internal
+    */
+    public static final String ACTION_REMOVE_IDLE_TEXT = "android.intent.aciton.stk.REMOVE_IDLE_TEXT";
+
+    /**
+    * @hide
+    */
+    public static final String ACTION_REMOVE_IDLE_TEXT_2 = "android.intent.aciton.stk.REMOVE_IDLE_TEXT_2";
+
+    /// M: IMS feature for SS Runtime  Indication. @{
+    public static final String ACTION_LTE_MESSAGE_WAITING_INDICATION = "android.intent.action.lte.mwi";
+    public static final String EXTRA_LTE_MWI_BODY = "lte_mwi_body";
+    /// @}
+
+    /// M: c2k modify, intents. @{
+    // MCC MNC Change
+    public static final String ACTION_MCC_MNC_CHANGED = "android.intent.action.MCC_MNC_CHANGED";
+    public static final String EXTRA_MCC_MNC_CHANGED_MCC = "mcc";
+    public static final String EXTRA_MCC_MNC_CHANGED_MNC = "mnc";
+    // RADIO AVAILABLE
+    public static final String ACTION_RADIO_AVAILABLE = "android.intent.action.RADIO_AVAILABLE";
+    public static final String EXTRA_RADIO_AVAILABLE_STATE = "radio_available_state";
+    /// @}
+
+    /**
+     * This event is for abnormal event for logger
+    */
+    public static final String ACTION_EXCEPTION_HAPPENED
+        = "com.mediatek.log2server.EXCEPTION_HAPPEND";
+    /**
+    * To identify CDMA card  type.
+    * For CT request, this type used for CDMA modem identify card type and report to framework
+    * <P>Type: int</P>
+    */
+    // MTK START
+    public static final String ACTION_CDMA_CARD_TYPE = "android.intent.action.CDMA_CARD_TYPE";
+    public static final String INTENT_KEY_CDMA_CARD_TYPE = "cdma_card_type";
+    public static final String INTENT_KEY_CDMA_CARD_NEW = "cdma_card_new";
+
+    public static final String ACTION_CDMA_CARD_IMSI = "android.intent.action.CDMA_CARD_IMSI";
+    public static final String INTENT_KEY_CDMA_CARD_CSIM_IMSI = "cdma_card_csim_imsi";
+    public static final String INTENT_KEY_CDMA_CARD_USIM_IMSI = "cdma_card_usim_imsi";
+    public static final String INTENT_KEY_SVLTE_MODE_SLOT_ID = "svlte_mode_slot_id";
+
+    public static final String ACTION_SVLTE_CARD_TYPE = "android.intent.action.SVLTE_CARD_TYPE";
+    public static final String INTENT_KEY_SVLTE_CARD_TYPE = "svlte_card_type";
+    // MTK END
+    /**
+     * Broadcast Action: The modem rat changed.
+     * @hide
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>ready</em> - The modem rat after changed.</li>
+     * </ul>
+     */
+    public static final String ACTION_RAT_CHANGED
+            = "android.intent.action.ACTION_RAT_CHANGED";
+    /** @hide */
+    public static final String EXTRA_RAT = "rat";
+
+    ///M: C2k WP s2 @{
+    /**
+     * Broadcast after all Radio technology switch done.
+     */
+    public static final String ACTION_SET_RADIO_TECHNOLOGY_DONE =
+                    "com.mediatek.phone.ACTION_SET_RADIO_TECHNOLOGY_DONE";
+
+    /**
+     * Broadcast Radio technology switch start.
+     */
+    public static final String ACTION_SET_RADIO_TECHNOLOGY_START =
+                    "com.mediatek.phone.ACTION_SET_RADIO_TECHNOLOGY_START";
+    ///@}
+
+    /**
+     * Broadcast Action: The world mode changed.
+     * The intent will have the following extra values:</p>
+     * <ul>
+     *   <li><em>worldModeState</em> - An int with one of the following values:
+     *          {@link com.mediatek.internal.telephony.worldphone.WorldMode#MD_WM_CHANGED_START} or
+     *          {@link com.mediatek.internal.telephony.worldphone.WorldMode#MD_WM_CHANGED_END}
+     *   </li>
+     * </ul>
+     */
+    public static final String ACTION_WORLD_MODE_CHANGED
+            = "android.intent.action.ACTION_WORLD_MODE_CHANGED";
+    /**
+     * Broadcast world mode change state.
+     */
+    public static final String EXTRA_WORLD_MODE_CHANGE_STATE = "worldModeState";
 }
diff --git a/telephony/java/com/android/internal/telephony/TelephonyProperties.java b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
index 73e778c..aeb70a2 100644
--- a/telephony/java/com/android/internal/telephony/TelephonyProperties.java
+++ b/telephony/java/com/android/internal/telephony/TelephonyProperties.java
@@ -262,4 +262,84 @@ public interface TelephonyProperties
     static final String EXTRA_IS_CALL_PULL =
             "org.codeaurora.extra.IS_CALL_PULL";
 
+    // MTK
+
+    /**
+    * Indicate Modem version for stack 2.
+    */
+    static final String PROPERTY_BASEBAND_VERSION_2 = "gsm.version.baseband.2";
+
+    //[ALPS01804936]-start:fix JE when change system language to "Burmese"
+    static final String PROPERTY_OPERATOR_ALPHA_2 = "gsm.operator.alpha.2";
+    static final String PROPERTY_OPERATOR_ALPHA_3 = "gsm.operator.alpha.3";
+    static final String PROPERTY_OPERATOR_ALPHA_4 = "gsm.operator.alpha.4";
+    //[ALPS01804936]-end
+
+    // Added by M begin
+    /** The IMSI of the SIM
+     *  Availability: SIM state must be "READY"
+     */
+    static String PROPERTY_ICC_OPERATOR_IMSI   = "gsm.sim.operator.imsi";
+
+    /**
+    * Indicate if chaneing to SIM locale is processing
+    */
+    static final String PROPERTY_SIM_LOCALE_SETTINGS = "gsm.sim.locale.waiting";
+
+    /** PROPERTY_ICC_OPERATOR_DEFAULT_NAME is the operator name for plmn which origins the SIM.
+     *  Availablity: SIM state must be "READY"
+     */
+    static String PROPERTY_ICC_OPERATOR_DEFAULT_NAME = "gsm.sim.operator.default-name";
+    // Added by M end
+
+    static final String PROPERTY_ACTIVE_MD = "ril.active.md";
+
+ /**
+    * Indicate the highest radio access capability(ex: UMTS,LTE,etc.) of modem
+    */
+    static String PROPERTY_BASEBAND_CAPABILITY = "gsm.baseband.capability";
+    static String PROPERTY_BASEBAND_CAPABILITY_MD2 = "gsm.baseband.capability.md2";
+
+ /**
+    * NITZ operator long name,short name, numeric (if ever received from MM information)
+    */
+    static String PROPERTY_NITZ_OPER_CODE = "persist.radio.nitz_oper_code";
+    static String PROPERTY_NITZ_OPER_LNAME = "persist.radio.nitz_oper_lname";
+    static String PROPERTY_NITZ_OPER_SNAME = "persist.radio.nitz_oper_sname";
+
+    /** PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE is the mode for the terminal-based call waiting
+     *  possible values: "disabled_tbcw", "enabled_tbcw_on" and "enabled_tbcw_off".
+     */
+    static String PROPERTY_TERMINAL_BASED_CALL_WAITING_MODE = "persist.radio.terminal-based.cw";
+    static String TERMINAL_BASED_CALL_WAITING_DISABLED = "disabled_tbcw";
+    static String TERMINAL_BASED_CALL_WAITING_ENABLED_ON = "enabled_tbcw_on";
+    static String TERMINAL_BASED_CALL_WAITING_ENABLED_OFF = "enabled_tbcw_off";
+
+    /** PROPERTY_UT_CFU_NOTIFICATION_MODE is the mode for the UT/XCAP CFU notification
+     * possible values: "disabled_ut_cfu_notification", "enabled_ut_cfu_notification_on"
+     * and "enabled_ut_cfu_notification_off".
+     */
+    static String PROPERTY_UT_CFU_NOTIFICATION_MODE = "persist.radio.ut.cfu.mode";
+    static String UT_CFU_NOTIFICATION_MODE_DISABLED = "disabled_ut_cfu_mode";
+    static String UT_CFU_NOTIFICATION_MODE_ON = "enabled_ut_cfu_mode_on";
+    static String UT_CFU_NOTIFICATION_MODE_OFF = "enabled_ut_cfu_mode_off";
+
+     /**
+     * Property to set/get svlte mode
+     * Type:  String(svlte, csfb)
+     */
+    static final String PROPERTY_RADIO_SVLTE_MODE = "persist.radio.svlte.mode";
+
+
+    /**
+     * External SIM enabled properties.
+     */
+    static final String PROPERTY_EXTERNAL_SIM_ENABLED = "gsm.external.sim.enabled";
+
+    /**
+     * External SIM inserted properties.
+     * 1: local SIM inserted, 2: remote sim inserted
+     */
+    static final String PROPERTY_EXTERNAL_SIM_INSERTED = "gsm.external.sim.inserted";
+
 }
diff --git a/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl
new file mode 100755
index 0000000..ffe11c7
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.aidl
@@ -0,0 +1,39 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+package com.mediatek.internal.telephony;
+
+parcelable BtSimapOperResponse;
+
diff --git a/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.java b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.java
new file mode 100755
index 0000000..9f73779e
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/BtSimapOperResponse.java
@@ -0,0 +1,271 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.mediatek.internal.telephony;
+
+ import android.os.Parcel;
+ import android.os.Parcelable;
+ /**
+ * Represents the response information of BTSimap operation, including
+ * Received protocal type and APDU data.
+ * @hide
+ */
+public class BtSimapOperResponse implements Parcelable {
+    public static final int SUCCESS = 0;
+    public static final int ERR_NO_REASON_DEFINED = 1;    //CME ERROR: 611
+    public static final int ERR_CARD_NOT_ACCESSIBLE = 2;   //CME ERROR: 612
+    public static final int ERR_CARD_POWERED_OFF = 3;
+    public static final int ERR_CARD_REMOVED = 4;              // CME ERROR:613
+    public static final int ERR_CARD_POWERED_ON = 5;   // already power on
+    public static final int ERR_DATA_NOT_AVAILABLE = 6;
+    public static final int ERR_NOT_SUPPORTED = 7;
+
+    private static final byte CURTYPE_MASK = 0x01;
+    private static final byte SUPPORTTYPE_MASK = 0x02;
+    private static final byte ATR_MASK = 0x04;
+    private static final byte APDU_RESPONSE_MASK = 0x08;
+
+    static final int UNKNOWN_PROTOCOL_TYPE = -1;
+
+    private int mParams;
+    private int mCurType;
+    private int mSupportType;
+    private String mStrATR;
+    private String mStrAPDU;
+
+    public BtSimapOperResponse() {
+        mParams = 0;
+        mCurType = UNKNOWN_PROTOCOL_TYPE;
+        mSupportType = UNKNOWN_PROTOCOL_TYPE;
+        mStrATR = null;
+        mStrAPDU = null;
+    }
+
+    /**
+     * Initialize the object from a parcel.
+     */
+    public BtSimapOperResponse(Parcel in) {
+        mParams = in.readInt();
+        mCurType = in.readInt();
+        mSupportType = in.readInt();
+        mStrATR = in.readString();
+        mStrAPDU = in.readString();
+    }
+
+    public boolean isCurTypeExist() {
+        if ((mParams & CURTYPE_MASK) > 0) {
+            return true;
+        } else {
+           return false;
+        }
+    }
+
+    public boolean isSupportTypeExist() {
+        if ((mParams & SUPPORTTYPE_MASK) > 0) {
+            return true;
+        } else {
+           return false;
+        }
+    }
+
+    public boolean isAtrExist() {
+        if ((mParams & ATR_MASK) > 0) {
+            return true;
+        } else {
+           return false;
+        }
+    }
+
+    public boolean isApduExist() {
+        if ((mParams & APDU_RESPONSE_MASK) > 0) {
+            return true;
+        } else {
+           return false;
+        }
+    }
+
+    /**
+     * Get Current type.
+     *
+     * @return Current type
+     *
+     * @internal
+     */
+    public int getCurType() {
+        if (isCurTypeExist()) {
+            return mCurType;
+        } else {
+            return UNKNOWN_PROTOCOL_TYPE;
+        }
+    }
+
+    /**
+     * Get support type.
+     *
+     * @return support type
+     *
+     * @internal
+     */
+    public int getSupportType() {
+        if (isSupportTypeExist()) {
+            return mSupportType;
+        } else {
+            return UNKNOWN_PROTOCOL_TYPE;
+        }
+    }
+
+    /**
+     * Get ATR String.
+     *
+     * @return ATR String
+     *
+     * @internal
+     */
+    public String getAtrString() {
+        if (isAtrExist()) {
+            return mStrATR;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Get APDU String.
+     *
+     * @return APDU String
+     *
+     * @internal
+     */
+    public String getApduString() {
+        if (isApduExist()) {
+            return mStrAPDU;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Set cuurent type.
+     *
+     * @param nType current protool type.
+     *
+     * @internal
+     */
+    public void setCurType(int nType) {
+        if (nType == 0 || nType == 1) {
+            mCurType = nType;
+            mParams |= CURTYPE_MASK;
+        }
+    }
+
+    /**
+     * Set support type.
+     *
+     * @param nType protool type.
+     *
+     * @internal
+     */
+    public void setSupportType(int nType) {
+        if (nType == 0 || nType == 1 || nType == 2) {
+            mSupportType = nType;
+            mParams |= SUPPORTTYPE_MASK;
+        }
+    }
+
+    /**
+     * Set ATR String.
+     *
+     * @param strVal ATR string
+     *
+     * @internal
+     */
+    public void setAtrString(String strVal) {
+        if (strVal != null) {
+            mStrATR = strVal;
+            mParams |= ATR_MASK;
+        }
+    }
+
+    /**
+     * Set APDU String.
+     *
+     * @param strVal APDU string
+     *
+     * @internal
+     */
+    public void setApduString(String strVal) {
+        if (strVal != null) {
+            mStrAPDU = strVal;
+            mParams |= APDU_RESPONSE_MASK;
+        }
+    }
+
+    public void readFromParcel(Parcel source) {
+        mParams = source.readInt();
+        mCurType = source.readInt();
+        mSupportType = source.readInt();
+        mStrATR = source.readString();
+        mStrAPDU = source.readString();
+    }
+
+    /**
+     * {@link Parcelable#describeContents}
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * {@link Parcelable.Creator}
+     *
+     * @hide
+     */
+    public static final Parcelable.Creator<BtSimapOperResponse> CREATOR = new Parcelable.Creator() {
+        public BtSimapOperResponse createFromParcel(Parcel in) {
+            return new BtSimapOperResponse(in);
+        }
+
+        public BtSimapOperResponse[] newArray(int size) {
+            return new BtSimapOperResponse[size];
+        }
+    };
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mParams);
+        dest.writeInt(mCurType);
+        dest.writeInt(mSupportType);
+        dest.writeString(mStrATR);
+        dest.writeString(mStrAPDU);
+    }
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/DefaultSmsSimSettings.java b/telephony/java/com/mediatek/internal/telephony/DefaultSmsSimSettings.java
new file mode 100755
index 0000000..7142d78
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/DefaultSmsSimSettings.java
@@ -0,0 +1,81 @@
+
+package com.mediatek.internal.telephony;
+
+import android.util.Log;
+import android.provider.Settings;
+import android.telephony.SubscriptionManager;
+import android.telephony.SubscriptionInfo;
+import android.os.SystemProperties;
+import java.util.List;
+import android.content.Context;
+
+public class DefaultSmsSimSettings {
+    private static final String TAG = "DefaultSmsSimSettings";
+    public static final int ASK_USER_SUB_ID = -2;
+
+    public static void setSmsTalkDefaultSim(List<SubscriptionInfo> subInfos, Context context) {
+        /*
+        if (!"1".equals(SystemProperties.get("ro.mtk_bsp_package"))) {
+            int oldSmsDefaultSIM = SubscriptionManager.getDefaultSmsSubId();
+            Log.i(TAG, "oldSmsDefaultSIM" + oldSmsDefaultSIM);
+
+            if (subInfos == null) {
+                Log.i(TAG, "subInfos == null, return");
+                //SubscriptionManager.from(context).setDefaultSmsSubId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+            } else {
+                Log.i(TAG, "subInfos size = " + subInfos.size());
+                if (subInfos.size() > 1) {
+                    if (isoldDefaultSMSSubIdActive(subInfos)) {
+                        Log.i(TAG, "subInfos size > 1 & old available, set to :"
+                                + oldSmsDefaultSIM);
+                        //SubscriptionManager.from(context).setDefaultSmsSubId(oldSmsDefaultSIM);
+                    } else {
+                        if ("OP01".equals(SystemProperties.get("ro.operator.optr"))) {
+                            Log.i(TAG, "subInfos size > 1, set to : AUTO");
+                            SubscriptionManager.from(context)
+                                .setDefaultSmsSubId((int) Settings.System.SMS_SIM_SETTING_AUTO);
+                        }else if ("OP09".equals(SystemProperties.get("ro.operator.optr"))) {
+                            int firstSubId = SubscriptionManager.from(context)
+                                   .getActiveSubscriptionInfoForSimSlotIndex(0).getSubscriptionId();
+                            SubscriptionManager.from(context).setDefaultSmsSubId(firstSubId);
+                            Log.i(TAG, "subInfos size > 1, set to " + firstSubId);
+                        } else {
+                            Log.i(TAG, "subInfos size > 1, set to : ASK_USER_SUB_ID");
+                            //SubscriptionManager.from(context).setDefaultSmsSubId(ASK_USER_SUB_ID);
+                        }
+                    }
+                } else if (subInfos.size() == 1) {
+                    if ("OP09".equals(SystemProperties.get("ro.operator.optr"))) {
+                        int defaultSubId = subInfos.get(0).getSubscriptionId();
+                        SubscriptionManager.from(context).setDefaultSmsSubId(defaultSubId);
+                        Log.i(TAG, "subInfos size = 1, set to " + defaultSubId);
+                    }
+                    //SubscriptionManager.from(context).setDefaultSmsSubId(subInfos.get(0).getSubscriptionId());
+                } else {
+                    Log.i(TAG, "setSmsTalkDefaultSim SIM not insert");
+                    //SubscriptionManager.from(context).setDefaultSmsSubId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+                }
+            }
+        }
+        */
+    }
+
+    private static boolean isoldDefaultSMSSubIdActive(List<SubscriptionInfo> subInfos) {
+        int oldSmsDefaultSIM = SubscriptionManager.getDefaultSmsSubId();
+
+        for (SubscriptionInfo subInfo : subInfos) {
+            if (subInfo.getSubscriptionId() == oldSmsDefaultSIM) {
+                return true;
+            }
+        }
+        /*
+        if ("OP01".equals(SystemProperties.get("ro.operator.optr"))) {
+            if (oldSmsDefaultSIM == ASK_USER_SUB_ID ||
+                       oldSmsDefaultSIM == (int) Settings.System.SMS_SIM_SETTING_AUTO) {
+                return true;
+            }
+        }
+        */
+        return false;
+    }
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/DefaultVoiceCallSubSettings.java b/telephony/java/com/mediatek/internal/telephony/DefaultVoiceCallSubSettings.java
new file mode 100644
index 0000000..0afa19b
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/DefaultVoiceCallSubSettings.java
@@ -0,0 +1,71 @@
+package com.mediatek.internal.telephony;
+
+import java.util.List;
+
+import android.os.SystemProperties;
+import android.telephony.SubscriptionInfo;
+import android.telephony.SubscriptionManager;
+import android.util.Log;
+
+/**
+ * This class is define the default voice call sub setting rule.
+ * 1. If there is no Sub inserted, the default voice call sub will be DEFAULT_SIM_NOT_SET.
+ * 2. If there is only one Sub, the default voice call sub will be that one.
+ * 3. If there are more than one Sub:
+ *      a. If the old default voice call sub is still available, the settings will not change.
+ *      b. If the old default voice call sub is not available, the settings will be ALWAYS_ASK.
+ */
+public class DefaultVoiceCallSubSettings {
+
+    private static final String LOG_TAG = "DefaultVoiceCallSubSettings";
+
+    public static void setVoiceCallDefaultSub(List<SubscriptionInfo> subInfos) {
+        if (!isMTKBspSupported()) {
+            int oldDefaultVoiceSubId = SubscriptionManager.getDefaultVoiceSubId();
+            logi("oldDefaultVoiceSubId = " + oldDefaultVoiceSubId);
+
+            if (subInfos == null) {
+                logi("subInfos == null, set to : INVALID_SUBSCRIPTION_ID");
+                // TODO: Fix this
+                //SubscriptionManager.setDefaultVoiceSubId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+            } else {
+                logi("subInfos size = " + subInfos.size());
+                if (subInfos.size() > 1) {
+                    if (isoldDefaultVoiceSubIdActive(subInfos)) {
+                        logi("subInfos size > 1 & old available, set to :" + oldDefaultVoiceSubId);
+                        //SubscriptionManager.setDefaultVoiceSubId(oldDefaultVoiceSubId);
+                    } else {
+                        logi("subInfos size > 1, set to : ASK_USER");
+                        //SubscriptionManager.setDefaultVoiceSubId(SubscriptionManager.ASK_USER_SUB_ID);
+                    }
+                } else if (subInfos.size() == 1) {
+                    logi("subInfos size == 1, set to :" + subInfos.get(0).getSubscriptionId());
+                    //SubscriptionManager.setDefaultVoiceSubId(subInfos.get(0).subId);
+                } else {
+                    logi("subInfos size = 0 set of : INVALID_SUBSCRIPTION_ID");
+                    //SubscriptionManager.setDefaultVoiceSubId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
+                }
+            }
+        }
+    }
+
+    private static boolean isMTKBspSupported() {
+        boolean isSupport = "1".equals(SystemProperties.get("ro.mtk_bsp_package"));
+        logi("isMTKBspSupported(): " + isSupport);
+        return isSupport;
+    }
+
+    private static boolean isoldDefaultVoiceSubIdActive(List<SubscriptionInfo> subInfos) {
+        int oldDefaultVoiceSubId = SubscriptionManager.getDefaultVoiceSubId();
+        for (SubscriptionInfo subInfo : subInfos) {
+            if (subInfo.getSubscriptionId() == oldDefaultVoiceSubId) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static void logi(String msg) {
+        Log.i(LOG_TAG, msg);
+    }
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl b/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl
new file mode 100644
index 0000000..51773f3
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl
@@ -0,0 +1,520 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+
+import android.net.LinkProperties;
+
+import android.os.Bundle;
+import android.os.Message;
+
+import android.telephony.RadioAccessFamily;
+
+import com.mediatek.internal.telephony.BtSimapOperResponse;
+
+/**
+ * Interface used to interact with the phone.  Mostly this is used by the
+ * TelephonyManager class.  A few places are still using this directly.
+ * Please clean them up if possible and use TelephonyManager insteadl.
+ *
+ * {@hide}
+ */
+interface ITelephonyEx {
+
+    Bundle queryNetworkLock(int subId, int category);
+
+    int supplyNetworkDepersonalization(int subId, String strPasswd);
+
+    /**
+     * Modem SML change feature.
+     * This function will query the SIM state of the given slot. And broadcast
+     * ACTION_UNLOCK_SIM_LOCK if the SIM state is in network lock.
+     *
+     * @param subId: Indicate which sub to query
+     * @param needIntent: The caller can deside to broadcast ACTION_UNLOCK_SIM_LOCK or not
+     *                    in this time, because some APs will receive this intent (eg. Keyguard).
+     *                    That can avoid this intent to effect other AP.
+     */
+    void repollIccStateForNetworkLock(int subId, boolean needIntent);
+
+    int setLine1Number(int subId, String alphaTag, String number);
+
+    boolean isFdnEnabled(int subId);
+
+    String getIccCardType(int subId);
+
+    /**
+     * Request to get UICC card type.
+     *
+     * @param slotId indicated sim id
+     *
+     * @return index for UICC card type
+     *
+     */
+    int getSvlteCardType(int slotId);
+
+    boolean isAppTypeSupported(int slotId, int appType);
+
+    boolean isTestIccCard(int slotId);
+
+    String getMvnoMatchType(int subId);
+
+    String getMvnoPattern(int subId, String type);
+
+    String getNetworkOperatorNameGemini(int slotId);
+    String getNetworkOperatorNameUsingSub(int subId);
+
+    String getNetworkOperatorGemini(int slotId);
+    String getNetworkOperatorUsingSub(int subId);
+
+    /**
+     *send BT SIM profile of Connect SIM
+     * @param simId specify which SIM to connect
+     * @param btRsp fetch the response data.
+     * @return success or error code.
+     */
+    int btSimapConnectSIM(int simId,  out BtSimapOperResponse btRsp);
+
+    /**
+     *send BT SIM profile of Disconnect SIM
+     * @param null
+     * @return success or error code.
+     */
+    int btSimapDisconnectSIM();
+
+   /**
+     *Transfer APDU data through BT SAP
+     * @param type Indicate which transport protocol is the preferred one
+     * @param cmdAPDU APDU data to transfer in hex character format
+     * @param btRsp fetch the response data.
+     * @return success or error code.
+     */
+    int btSimapApduRequest(int type, String cmdAPDU, out BtSimapOperResponse btRsp);
+
+    /**
+     *send BT SIM profile of Reset SIM
+     * @param type Indicate which transport protocol is the preferred one
+     * @param btRsp fetch the response data.
+     * @return success or error code.
+     */
+    int btSimapResetSIM(int type, out BtSimapOperResponse btRsp);
+
+   /**
+     *send BT SIM profile of Power On SIM
+     * @param type Indicate which transport protocol is the preferred onet
+     * @param btRsp fetch the response data.
+     * @return success or error code.
+     */
+    int btSimapPowerOnSIM(int type, out BtSimapOperResponse btRsp);
+
+   /**
+     *send BT SIM profile of PowerOff SIM
+     * @return success or error code.
+     */
+    int btSimapPowerOffSIM();
+
+    /**
+     * Request to run AKA authenitcation on UICC card by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteRand random challenge in byte array
+     * @param byteAutn authenication token in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    byte[] simAkaAuthentication(int slotId, int family, in byte[] byteRand, in byte[] byteAutn);
+
+    /**
+     * Request to run GBA authenitcation (Bootstrapping Mode)on UICC card
+     * by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteRand random challenge in byte array
+     * @param byteAutn authenication token in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    byte[] simGbaAuthBootStrapMode(int slotId, int family, in byte[] byteRand, in byte[] byteAutn);
+
+    /**
+     * Request to run GBA authenitcation (NAF Derivation Mode)on UICC card
+     * by indicated family.
+     *
+     * @param slotId indicated sim id
+     * @param family indiacted family category
+     *        UiccController.APP_FAM_3GPP =  1; //SIM/USIM
+     *        UiccController.APP_FAM_3GPP2 = 2; //RUIM/CSIM
+     *        UiccController.APP_FAM_IMS   = 3; //ISIM
+     * @param byteNafId network application function id in byte array
+     * @param byteImpi IMS private user identity in byte array
+     *
+     * @return reponse paramenters/data from UICC
+     *
+     */
+    byte[] simGbaAuthNafMode(int slotId, int family, in byte[] byteNafId, in byte[] byteImpi);
+
+    /**
+     * Since MTK keyguard has dismiss feature, we need to retrigger unlock event
+     * when user try to access the SIM card.
+     *
+     * @param subId inidicated subscription
+     *
+     * @return true represent broadcast a unlock intent to notify keyguard
+     *         false represent current state is not LOCKED state. No need to retrigger.
+     *
+     */
+    boolean broadcastIccUnlockIntent(int subId);
+
+    /**
+     * Query if the radio is turned off by user.
+     *
+     * @param subId inidicated subscription
+     *
+     * @return true radio is turned off by user.
+     *         false radio isn't turned off by user.
+     *
+     */
+    boolean isRadioOffBySimManagement(int subId);
+
+    /**
+     * Get current phone capability
+     *
+     * @return the capability of phone. (@see PhoneConstants)
+     * @internal
+     */
+    int getPhoneCapability(int phoneId);
+
+    /**
+     * Set capability to phones
+     *
+     * @param phoneId phones want to change capability
+     * @param capability new capability for each phone
+     * @internal
+     */
+    void setPhoneCapability(in int[] phoneId, in int[] capability);
+    /**
+     * To config SIM swap mode(for dsda).
+     *
+     * @return true if config SIM Swap mode successful, or return false
+     * @internal
+     */
+    boolean configSimSwap(boolean toSwapped);
+    /**
+     * To check SIM is swapped or not(for dsda).
+     *
+     * @return true if swapped, or return false
+     * @internal
+     */
+    boolean isSimSwapped();
+    /**
+     * To Check if Capability Switch Manual Control Mode Enabled.
+     *
+     * @return true if Capability Switch manual control mode is enabled, else false;
+     * @internal
+     */
+    boolean isCapSwitchManualEnabled();
+
+    /**
+     * Get item list that will be displayed on manual switch setting
+     *
+     * @return String[] contains items
+     * @internal
+     */
+    String[] getCapSwitchManualList();
+
+  /**
+     * To get located PLMN from sepcified SIM modem  protocol
+     * Returns current located PLMN string(ex: "46000") or null if not availble (ex: in flight mode or no signal area or this SIM is turned off)
+     * @param subId Indicate which SIM subscription to query
+     * @internal
+     */
+    String getLocatedPlmn(int subId);
+
+   /**
+     * Check if phone is hiding network temporary out of service state.
+     * @param subId Indicate which SIM subscription to query
+     * @return if phone is hiding network temporary out of service state.
+     * @internal
+    */
+    int getNetworkHideState(int subId);
+
+   /**
+     * get the network service state for specified SIM
+     * @param subId Indicate which SIM subscription to query
+     * @return service state.
+     * @internal
+    */
+    Bundle getServiceState(int subId);
+
+    /**
+     * This function is used to get SIM phonebook storage information
+     * by sim id.
+     *
+     * @param simId Indicate which sim(slot) to query
+     * @return int[] which incated the storage info
+     *         int[0]; // # of remaining entries
+     *         int[1]; // # of total entries
+     *         int[2]; // # max length of number
+     *         int[3]; // # max length of alpha id
+     *
+     * @internal
+     */
+    int[] getAdnStorageInfo(int subId);
+
+    /**
+     * This function is used to check if the SIM phonebook is ready
+     * by sim id.
+     *
+     * @param simId Indicate which sim(slot) to query
+     * @return true if phone book is ready.
+     * @internal
+     */
+    boolean isPhbReady(int subId);
+
+    /**
+     * Get service center address
+     *
+     * @param subId subscription identity
+     *
+     * @return bundle value with error code and service message center address
+     */
+    Bundle getScAddressUsingSubId(in int subId);
+
+    /**
+     * Set service message center address
+     *
+     * @param subId subscription identity
+     * @param service message center addressto be set
+     *
+     * @return true for success, false for failure
+     */
+    boolean setScAddressUsingSubId(in int subId, in String address);
+
+    /**
+     * This function will check if phone can enter airplane mode right now
+     *
+     * @return boolean: return phone can enter flight mode
+     *                true: phone can enter flight mode
+     *                false: phone cannot enter flight mode
+     */
+    boolean isAirplanemodeAvailableNow();
+
+    // VoLTE
+    /**
+     * This function will get DcFailCause with int format.
+     *
+     * @return int: return int failCause value
+     */
+    int getLastDataConnectionFailCause(String apnType, int phoneId);
+
+    /**
+     * This function will get link properties of input apn type.
+     *
+     * @param apnType input apn type for geting link properties
+     * @return LinkProperties: return correspondent link properties with input apn type
+     */
+    LinkProperties getLinkProperties(String apnType, int phoneId);
+
+    /**
+     * Set phone radio type and access technology.
+     *
+     * @param rafs an RadioAccessFamily array to indicate all phone's
+     *        new radio access family. The length of RadioAccessFamily
+     *        must equal to phone count.
+     * @return true if start setPhoneRat successfully.
+     */
+    boolean setRadioCapability(in RadioAccessFamily[] rafs);
+
+    /**
+     * Check if under capability switching.
+     *
+     * @return true if switching
+     */
+    boolean isCapabilitySwitching();
+
+    /// M: [C2K][SVLTE] Switch SVLTE RAT mode. @{
+    /**
+     * Switch SVLTE RAT mode.
+     * @param mode the RAT mode.
+     * @return void
+     */
+    void switchSvlteRatMode(int mode);
+
+    /**
+     * Set SVLTE RAT mode.
+     * @param mode the RAT mode.
+     * @param subId subscription ID to be queried
+     * @return void
+     */
+    void setSvlteRatMode(int mode, int subId);
+
+    /**
+     * Get the ServiceState for Svlte.
+     * @param subId for getting the current ServiceState for Svlte.
+     */
+    Bundle getSvlteServiceState(int subId);
+
+    /**
+     * Switch SVLTE RAT mode.
+     * @param mode the RAT mode.
+     */
+    void switchRadioTechnology(int networkType);
+
+    /**
+     * Set SVLTE Radio Technology.
+     * @param networkType the networktype want to switch.
+     * @param subId subscription ID to be queried
+     */
+    void setRadioTechnology(int networkType, int subId);
+    /// @}
+
+    /**
+    * Set TRM
+    *
+    * @param mode indicate which case want to set to modem
+    */
+    void setTrmForPhone(int phoneId, int mode);
+
+    /**
+     * Get subscriber Id of LTE phone.
+     * @param subId the subId of CDMAPhone
+     * @return The subscriber Id of LTE phone.
+     */
+    String getSubscriberIdForLteDcPhone(int subId);
+
+    /**
+     * Get Svlte imei.
+     * @param slotId slot id.
+     * @return String: imei.
+     */
+    String getSvlteImei(int slotId);
+
+    /**
+     * Get main capability phone id.
+     * @return The phone id with highest capability.
+     */
+    int getMainCapabilityPhoneId();
+
+    /**
+     * Return true if allow the airplane mode change.
+     */
+    boolean isAllowAirplaneModeChange();
+
+   /**
+     * Initialze external SIM service on phone process.
+     *
+     * @hide
+     */
+    void initializeService(String serviceName);
+
+   /**
+     * Finalize external SIM service on phone process.
+     *
+     * @hide
+     */
+    void finalizeService(String serviceName);
+
+    /**
+     * Return the sim card if in home network.
+     *
+     * @param subId subscription ID to be queried
+     * @return true if in home network
+     */
+    boolean isInHomeNetwork(int subId);
+
+    // M: [LTE][Low Power][UL traffic shaping] Start
+    /**
+     * Set LTE access stratum urc report
+     * @param enabled the LTE AS state URC report is enable or disable
+     * @return true if enabled/disable urc report successfully.
+     */
+    boolean setLteAccessStratumReport(boolean enabled);
+
+    /**
+     * Set LTE uplink data transfer
+     * @param isOn the LTE uplink data transfer is on or off
+     * @param timeMillis the close timer
+     * @return true if enabled/disable uplink data transfer successfully.
+     */
+    boolean setLteUplinkDataTransfer(boolean isOn, int timeMillis);
+
+    /**
+     * Get LTE access stratum state
+     * @return unknown/idle/connected if abnormal mode/power saving mode candidate/normal power mode.
+     */
+    String getLteAccessStratumState();
+
+    /**
+     * Get if shared default type apn
+     * @return true if is shared default type apn occurred.
+     */
+    boolean isSharedDefaultApn();
+    // M: [LTE][Low Power][UL traffic shaping] End
+
+    /**
+     * Get Svlte meid.
+     * @param slotId slot id.
+     * @return String: meid.
+     */
+    String getSvlteMeid(int slotId);
+}
+
diff --git a/telephony/java/com/mediatek/internal/telephony/IccCardType.java b/telephony/java/com/mediatek/internal/telephony/IccCardType.java
new file mode 100644
index 0000000..24de6f6
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/IccCardType.java
@@ -0,0 +1,141 @@
+/*
+* Copyright (C) 2014 MediaTek Inc.
+* Modification based on code covered by the mentioned copyright
+* and/or permission notice(s).
+*/
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+/**
+ * Report ICC Card Type.
+ */
+public class IccCardType {
+
+    /**
+      * This card type is report by SVLTE modems.
+      * {@hide}
+      */
+    public enum SvlteCardType {
+        INVALID_CARD(0),         //Invalid card type
+        UIM_CARD(1),             //With RUIM application
+        SIM_CARD(2),             //With only SIM application
+        UIM_SIM_CARD(3),         //With RUIM & SIM application, non CT dual mode card
+        UNKNOW_CARD(4),          //card is present, but can't detect type
+        CT_3G_UIM_CARD(5),       //With RUIM application, CT 3G UIM card
+        CT_UIM_SIM_CARD(6),      //With RUIM & SIM application, CT 3G dual mode card
+        PIN_LOCK_CARD(7),        //this card need PIN
+        CT_4G_UICC_CARD(8),      //With USIM & CSIM application, CT 4G dual mode UICC card
+        NOT_CT_UICC_CARD(9),     //With USIM & CSIM application, Non CT, 4G dual mode UICC card
+        LOCKED_CARD(18),         //card is locked
+        USIM_CARD(100),          //With USIM application only
+        CARD_NOT_INSERTED(255);  //card is not inserted
+
+        private int mValue;
+
+        public int getValue() {
+            return mValue;
+        }
+
+        /**
+         * Get CardType from integer.
+         * ASSERT: Please DON'T directly use CardType.values(), otherwise JE will occur
+         *
+         * @param cardTypeInt for cardType index.
+         * @return SvlteCardType.
+         */
+        public static SvlteCardType getCardTypeFromInt(int cardTypeInt) {
+            SvlteCardType cardType = INVALID_CARD;
+            SvlteCardType[] cardTypes = SvlteCardType.values();
+            for (int i = 0; i < cardTypes.length; i++) {
+                if (cardTypes[i].getValue() == cardTypeInt) {
+                    cardType = cardTypes[i];
+                    break;
+                }
+            }
+            return cardType;
+        }
+
+        /**
+         * Get CardType from String.
+         *
+         * @param cardType for card applications.
+         * @return SvlteCardType.
+         */
+        public static SvlteCardType transformCardTypeFromString(String cardType) {
+            if ("USIM".equals(cardType)) {
+                return USIM_CARD;
+            } else if ("SIM".equals(cardType)) {
+                return SIM_CARD;
+            } else {
+                return INVALID_CARD;
+            }
+        }
+
+        /**
+         * Check if it is 4G card.
+         *
+         * @return true if it is 4G card
+         */
+        public boolean is4GCard() {
+            return ((this == CT_4G_UICC_CARD) || (this == NOT_CT_UICC_CARD));
+        }
+
+        /**
+         * Check if it is 3G card.
+         *
+         * @return true if it is 3G card
+         */
+        public boolean is3GCard() {
+            return ((this == UIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_3G_UIM_CARD) || (this == CT_UIM_SIM_CARD));
+        }
+
+        /**
+         * Check if it is dual mode card.
+         *
+         * @return true if it is dual mode card
+         */
+        public boolean isDualModeCard() {
+            return ((this == UIM_SIM_CARD) || (this == CT_UIM_SIM_CARD)
+                    || (this == CT_4G_UICC_CARD) || (this == NOT_CT_UICC_CARD));
+        }
+
+        /**
+         * Check if it is OP09 card.
+         *
+         * @return true if it is OP09 card
+         */
+        public boolean isOPO9Card() {
+            return ((this == CT_3G_UIM_CARD) || (this == CT_UIM_SIM_CARD)
+            || (this == CT_4G_UICC_CARD));
+        }
+
+        /**
+         * Check if it is a valid card type.
+         *
+         * @return true if it is
+         */
+        public boolean isValidCardType() {
+            return this != INVALID_CARD;
+        }
+
+        private SvlteCardType(int value) {
+            mValue = value;
+        }
+    }
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl b/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl
new file mode 100644
index 0000000..ff852f7
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.aidl
@@ -0,0 +1,50 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/*
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package com.mediatek.internal.telephony;
+
+parcelable IccSmsStorageStatus;
diff --git a/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.java b/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.java
new file mode 100644
index 0000000..6676617
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/IccSmsStorageStatus.java
@@ -0,0 +1,130 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ *
+ * @internal
+ *
+ */
+public class IccSmsStorageStatus implements Parcelable {
+    public int mUsed;
+    public int mTotal;
+
+    public IccSmsStorageStatus() {
+        mUsed = 0;
+        mTotal = 0;
+    }
+
+    public IccSmsStorageStatus(int used, int total) {
+        mUsed = used;
+        mTotal = total;
+    }
+
+    /**
+     * Get the used count of sim sms memory.
+     *
+     * @return number of used sim sms memory
+     *
+     * @internal
+     */
+    public int getUsedCount() {
+        return mUsed;
+    }
+
+    /**
+     * Get the total count of sim sms memory.
+     *
+     * @return number of total sim sms memory
+     *
+     * @internal
+     */
+    public int getTotalCount() {
+        return mTotal;
+    }
+
+    public int getUnused() {
+        return (mTotal - mUsed);
+    }
+
+    public void reset() {
+        mUsed = 0;
+        mTotal = 0;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mUsed);
+        dest.writeInt(mTotal);
+    }
+
+    public static final Parcelable.Creator<IccSmsStorageStatus> CREATOR = new Parcelable.Creator<IccSmsStorageStatus>() {
+        public IccSmsStorageStatus createFromParcel(Parcel source) {
+            int used;
+            int total;
+
+            used = source.readInt();
+            total = source.readInt();
+            return new IccSmsStorageStatus(used, total);
+        }
+
+        public IccSmsStorageStatus[] newArray(int size) {
+            return new IccSmsStorageStatus[size];
+        }
+    };
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl b/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl
new file mode 100644
index 0000000..c2693af
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.aidl
@@ -0,0 +1,50 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ */
+
+/*
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package com.mediatek.internal.telephony;
+
+parcelable SmsCbConfigInfo;
diff --git a/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.java b/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.java
new file mode 100644
index 0000000..9124049
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/SmsCbConfigInfo.java
@@ -0,0 +1,70 @@
+/*
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+
+package com.mediatek.internal.telephony;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ *  A parcelable holder class of byte[] for ISms aidl implementation
+ */
+public class SmsCbConfigInfo implements Parcelable {
+    public int mFromServiceId;
+    public int mToServiceId;
+    public int mFromCodeScheme;
+    public int mToCodeScheme;
+    public boolean mSelected;
+
+    public SmsCbConfigInfo(int fromId, int toId, int fromScheme,
+            int toScheme, boolean selected) {
+        this.mFromServiceId = fromId;
+        this.mToServiceId = toId;
+        this.mFromCodeScheme = fromScheme;
+        this.mToCodeScheme = toScheme;
+        this.mSelected = selected;
+    }
+
+    public static final Parcelable.Creator<SmsCbConfigInfo> CREATOR = new Parcelable.Creator<SmsCbConfigInfo>() {
+        public SmsCbConfigInfo createFromParcel(Parcel source) {
+            int mFromServiceId = source.readInt();
+            int mToServiceId = source.readInt();
+            int mFromCodeScheme = source.readInt();
+            int mToCodeScheme = source.readInt();
+            boolean mSelected = source.readByte() != 0;
+
+            return new SmsCbConfigInfo(mFromServiceId, mToServiceId, mFromCodeScheme, mToCodeScheme, mSelected);
+        }
+
+        public SmsCbConfigInfo[] newArray(int size) {
+            return new SmsCbConfigInfo[size];
+        }
+    };
+
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mFromServiceId);
+        dest.writeInt(mToServiceId);
+        dest.writeInt(mFromCodeScheme);
+        dest.writeInt(mToCodeScheme);
+        dest.writeByte((byte) (mSelected ? 1 : 0));
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+}
diff --git a/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl b/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl
new file mode 100644
index 0000000..ab6ead1
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallCallback.aidl
@@ -0,0 +1,54 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.mediatek.internal.telephony.gsm;
+
+import android.telecom.VideoProfile;
+
+/**
+ * Internal remote interface for GSM's video call provider.
+ *
+ * At least initially, this aidl mirrors telecom's {@link VideoCallCallback}. We created a
+ * separate aidl interface for invoking callbacks in Telephony from the GSM Service to without
+ * accessing internal interfaces. See {@link IGsmVideoCallProvider} for additional detail.
+ *
+ * @see android.telecom.internal.IVideoCallCallback
+ * @see android.telecom.VideoCallImpl
+ *
+ * {@hide}
+ */
+oneway interface IGsmVideoCallCallback {
+    void receiveSessionModifyRequest(in VideoProfile videoProfile);
+
+    void receiveSessionModifyResponse(int status, in VideoProfile requestedProfile,
+        in VideoProfile responseProfile);
+
+    void handleCallSessionEvent(int event);
+
+    void changePeerDimensions(int width, int height);
+
+    /* M: ViLTE part start */
+    /* Different from AOSP, additional parameter "rotation" is added. */
+    void changePeerDimensionsWithAngle(int width, int height, int rotation);
+    /* M: ViLTE part end */
+
+    void changeCallDataUsage(long dataUsage);
+
+    void changeCameraCapabilities(in VideoProfile.CameraCapabilities cameraCapabilities);
+
+    void changeVideoQuality(int videoQuality);
+}
+
diff --git a/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl b/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl
new file mode 100644
index 0000000..987a3dd
--- /dev/null
+++ b/telephony/java/com/mediatek/internal/telephony/gsm/IGsmVideoCallProvider.aidl
@@ -0,0 +1,69 @@
+/*
+* Copyright (C) 2011-2014 MediaTek Inc.
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.mediatek.internal.telephony.gsm;
+
+import android.net.Uri;
+import android.view.Surface;
+import android.telecom.VideoProfile;
+
+import com.mediatek.internal.telephony.gsm.IGsmVideoCallCallback;
+
+/**
+ * Internal remote interface for GSM's video call provider.
+ *
+ * At least initially, this aidl mirrors telecom's {@link IVideoCallProvider}. We created a
+ * separate aidl interface even though the methods and parameters are same because the
+ * {@link IVideoCallProvider} was specifically created as a binder for inter-process communication
+ * between Telecomm and Telephony.
+ *
+ * We don't want to use the same aidl in other places for communication, namely communication
+ * between Telephony and the GSM Service, even if that communication may be for similar methods.
+ * This decouples the communication among these processes. Similarly, third parties implementing a
+ * video call provider will not have the benefit of accessing the internal
+ * {@link IVideoCallProvider} aidl for interprocess communication.
+ *
+ * @see android.telecom.internal.IVideoCallProvider
+ * @see android.telecom.VideoCallProvider
+ * @hide
+ */
+oneway interface IGsmVideoCallProvider {
+    void setCallback(IGsmVideoCallCallback callback);
+
+    void setCamera(String cameraId);
+
+    void setPreviewSurface(in Surface surface);
+
+    void setDisplaySurface(in Surface surface);
+
+    void setDeviceOrientation(int rotation);
+
+    void setZoom(float value);
+
+    void sendSessionModifyRequest(in VideoProfile fromProfile, in VideoProfile toProfile);
+
+    void sendSessionModifyResponse(in VideoProfile responseProfile);
+
+    void requestCameraCapabilities();
+
+    void requestCallDataUsage();
+
+    void setPauseImage(in Uri uri);
+
+    /* M: ViLTE part start */
+    void setUIMode(int mode);
+    /* M: ViLTE part end */
+}
